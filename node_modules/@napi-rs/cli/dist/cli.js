#!/usr/bin/env node
import { createRequire } from "node:module";
import { Cli, Command, Option } from "clipanion";
import path, { join, parse, resolve } from "node:path";
import * as colors from "colorette";
import { underline, yellow } from "colorette";
import rawDebug from "debug";
import fs, { copyFile, existsSync, mkdir, mkdirSync, promises, readFile, readdir, rmSync, stat, statSync, unlink, writeFile } from "node:fs";
import { promisify } from "node:util";
import { exec, execSync, spawn, spawnSync } from "node:child_process";
import { isNil, merge, omit, omitBy, pick, sortBy } from "lodash-es";
import { createHash } from "node:crypto";
import { homedir } from "node:os";
import { parse as parse$1 } from "semver";
import { checkbox, confirm, input, select } from "@inquirer/prompts";
import { dump, load } from "js-yaml";
import * as typanion from "typanion";
import { rename } from "node:fs/promises";
import { findUp } from "find-up";
import { Octokit } from "@octokit/rest";

//#region src/def/artifacts.ts
var BaseArtifactsCommand = class extends Command {
	static paths = [["artifacts"]];
	static usage = Command.Usage({ description: "Copy artifacts from Github Actions into npm packages and ready to publish" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o,-d", "./artifacts", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	buildOutputDir = Option.String("--build-output-dir", { description: "Path to the build output dir, only needed when targets contains `wasm32-wasi-*`" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir,
			npmDir: this.npmDir,
			buildOutputDir: this.buildOutputDir
		};
	}
};
function applyDefaultArtifactsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./artifacts",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/utils/log.ts
rawDebug.formatters.i = (v) => {
	return colors.green(v);
};
const debugFactory = (namespace) => {
	const debug$10 = rawDebug(`napi:${namespace}`);
	debug$10.info = (...args) => console.error(colors.black(colors.bgGreen(" INFO ")), ...args);
	debug$10.warn = (...args) => console.error(colors.black(colors.bgYellow(" WARNING ")), ...args);
	debug$10.error = (...args) => console.error(colors.white(colors.bgRed(" ERROR ")), ...args.map((arg) => arg instanceof Error ? arg.stack ?? arg.message : arg));
	return debug$10;
};
const debug$9 = debugFactory("utils");

//#endregion
//#region package.json
var name = "@napi-rs/cli";
var version$1 = "3.0.4";
var description = "Cli tools for napi-rs";
var author = "LongYinan <lynweklm@gmail.com>";
var homepage = "https://github.com/napi-rs/napi-rs";
var license = "MIT";
var type = "module";
var engines = { "node": ">= 16" };
var bin = {
	"napi": "./dist/cli.js",
	"napi-raw": "./cli.mjs"
};
var main = "./dist/index.cjs";
var module = "./dist/index.js";
var exports = {
	".": {
		"import": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.js"
		},
		"require": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.cjs"
		}
	},
	"./package.json": {
		"import": "./package.json",
		"require": "./package.json"
	}
};
var files = ["dist", "src"];
var keywords = [
	"cli",
	"rust",
	"napi",
	"n-api",
	"node-api",
	"node-addon",
	"neon"
];
var maintainers = [{
	"name": "LongYinan",
	"email": "lynweklm@gmail.com",
	"homepage": "https://github.com/Brooooooklyn"
}, {
	"name": "forehalo",
	"homepage": "https://github.com/forehalo"
}];
var repository = {
	"type": "git",
	"url": "git+https://github.com/napi-rs/napi-rs.git"
};
var publishConfig = {
	"registry": "https://registry.npmjs.org/",
	"access": "public"
};
var bugs = { "url": "https://github.com/napi-rs/napi-rs/issues" };
var dependencies = {
	"@inquirer/prompts": "^7.4.0",
	"@napi-rs/cross-toolchain": "^1.0.0",
	"@napi-rs/wasm-tools": "^1.0.0",
	"@octokit/rest": "^22.0.0",
	"clipanion": "^4.0.0-rc.4",
	"colorette": "^2.0.20",
	"debug": "^4.4.0",
	"emnapi": "^1.4.0",
	"find-up": "^7.0.0",
	"js-yaml": "^4.1.0",
	"lodash-es": "^4.17.21",
	"semver": "^7.7.1",
	"typanion": "^3.14.0"
};
var devDependencies = {
	"@emnapi/core": "^1.4.0",
	"@emnapi/runtime": "^1.4.0",
	"@oxc-node/core": "^0.0.30",
	"@std/toml": "npm:@jsr/std__toml@^1.0.8",
	"@types/debug": "^4.1.12",
	"@types/inquirer": "^9.0.7",
	"@types/js-yaml": "^4.0.9",
	"@types/lodash-es": "^4.17.12",
	"@types/node": "^22.13.16",
	"@types/semver": "^7.7.0",
	"ava": "^6.2.0",
	"env-paths": "^3.0.0",
	"prettier": "^3.5.3",
	"rolldown": "latest",
	"tslib": "^2.8.1",
	"typescript": "^5.8.2"
};
var peerDependencies = {
	"@emnapi/runtime": "^1.1.0",
	"emnapi": "^1.1.0"
};
var peerDependenciesMeta = {
	"@emnapi/runtime": { "optional": true },
	"emnapi": { "optional": true }
};
var funding = {
	"type": "github",
	"url": "https://github.com/sponsors/Brooooooklyn"
};
var scripts = {
	"clean": "node --import @oxc-node/core/register ./clean.ts",
	"codegen": "node --import @oxc-node/core/register ./codegen/index.ts",
	"build": "tsc && yarn clean && rolldown -c rolldown.config.js",
	"test": "node --import @oxc-node/core/register ../node_modules/ava/entrypoints/cli.mjs"
};
var ava = {
	"extensions": { "ts": "module" },
	"timeout": "1m",
	"files": ["**/__tests__/**/*.spec.ts", "e2e/**/*.spec.ts"]
};
var gitHead = "521b5774aa89f1a7c807a6ddba509ce43973f624";
var package_default = {
	name,
	version: version$1,
	description,
	author,
	homepage,
	license,
	type,
	engines,
	bin,
	main,
	module,
	exports,
	files,
	keywords,
	maintainers,
	repository,
	publishConfig,
	bugs,
	dependencies,
	devDependencies,
	peerDependencies,
	peerDependenciesMeta,
	funding,
	scripts,
	ava,
	gitHead
};

//#endregion
//#region src/utils/misc.ts
const readFileAsync = promisify(readFile);
const writeFileAsync = promisify(writeFile);
const unlinkAsync = promisify(unlink);
const copyFileAsync = promisify(copyFile);
const mkdirAsync = promisify(mkdir);
const statAsync = promisify(stat);
const readdirAsync = promisify(readdir);
async function fileExists(path$1) {
	const exists = await statAsync(path$1).then(() => true).catch(() => false);
	return exists;
}
async function dirExistsAsync(path$1) {
	try {
		const stats = await statAsync(path$1);
		return stats.isDirectory();
	} catch {
		return false;
	}
}
function pick$1(o, ...keys) {
	return keys.reduce((acc, key) => {
		acc[key] = o[key];
		return acc;
	}, {});
}
async function updatePackageJson(path$1, partial) {
	const exists = await fileExists(path$1);
	if (!exists) {
		debug$9(`File not exists ${path$1}`);
		return;
	}
	const old = JSON.parse(await readFileAsync(path$1, "utf8"));
	await writeFileAsync(path$1, JSON.stringify({
		...old,
		...partial
	}, null, 2));
}
const CLI_VERSION = package_default.version;

//#endregion
//#region src/utils/target.ts
const AVAILABLE_TARGETS = [
	"aarch64-apple-darwin",
	"aarch64-linux-android",
	"aarch64-unknown-linux-gnu",
	"aarch64-unknown-linux-musl",
	"aarch64-unknown-linux-ohos",
	"aarch64-pc-windows-msvc",
	"x86_64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu",
	"x86_64-unknown-linux-musl",
	"x86_64-unknown-linux-ohos",
	"x86_64-unknown-freebsd",
	"i686-pc-windows-msvc",
	"armv7-unknown-linux-gnueabihf",
	"armv7-unknown-linux-musleabihf",
	"armv7-linux-androideabi",
	"universal-apple-darwin",
	"riscv64gc-unknown-linux-gnu",
	"powerpc64le-unknown-linux-gnu",
	"s390x-unknown-linux-gnu",
	"wasm32-wasi-preview1-threads",
	"wasm32-wasip1-threads"
];
const DEFAULT_TARGETS = [
	"x86_64-apple-darwin",
	"aarch64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu"
];
const TARGET_LINKER = {
	"aarch64-unknown-linux-musl": "aarch64-linux-musl-gcc",
	"riscv64gc-unknown-linux-gnu": "riscv64-linux-gnu-gcc",
	"powerpc64le-unknown-linux-gnu": "powerpc64le-linux-gnu-gcc",
	"s390x-unknown-linux-gnu": "s390x-linux-gnu-gcc"
};
const CpuToNodeArch = {
	x86_64: "x64",
	aarch64: "arm64",
	i686: "ia32",
	armv7: "arm",
	riscv64gc: "riscv64",
	powerpc64le: "ppc64"
};
const SysToNodePlatform = {
	linux: "linux",
	freebsd: "freebsd",
	darwin: "darwin",
	windows: "win32",
	ohos: "openharmony"
};
const UniArchsByPlatform = { darwin: ["x64", "arm64"] };
/**
* A triple is a specific format for specifying a target architecture.
* Triples may be referred to as a target triple which is the architecture for the artifact produced, and the host triple which is the architecture that the compiler is running on.
* The general format of the triple is `<arch><sub>-<vendor>-<sys>-<abi>` where:
*   - `arch` = The base CPU architecture, for example `x86_64`, `i686`, `arm`, `thumb`, `mips`, etc.
*   - `sub` = The CPU sub-architecture, for example `arm` has `v7`, `v7s`, `v5te`, etc.
*   - `vendor` = The vendor, for example `unknown`, `apple`, `pc`, `nvidia`, etc.
*   - `sys` = The system name, for example `linux`, `windows`, `darwin`, etc. none is typically used for bare-metal without an OS.
*   - `abi` = The ABI, for example `gnu`, `android`, `eabi`, etc.
*/
function parseTriple(rawTriple) {
	if (rawTriple === "wasm32-wasi" || rawTriple === "wasm32-wasi-preview1-threads" || rawTriple.startsWith("wasm32-wasip")) return {
		triple: rawTriple,
		platformArchABI: "wasm32-wasi",
		platform: "wasi",
		arch: "wasm32",
		abi: "wasi"
	};
	const triple = rawTriple.endsWith("eabi") ? `${rawTriple.slice(0, -4)}-eabi` : rawTriple;
	const triples = triple.split("-");
	let cpu;
	let sys;
	let abi = null;
	if (triples.length === 2) [cpu, sys] = triples;
	else [cpu, , sys, abi = null] = triples;
	const platform = SysToNodePlatform[sys] ?? sys;
	const arch = CpuToNodeArch[cpu] ?? cpu;
	if (rawTriple.includes("ohos")) return {
		triple: rawTriple,
		platformArchABI: `linux-${arch}-ohos`,
		platform: "openharmony",
		arch,
		abi: null
	};
	return {
		triple: rawTriple,
		platformArchABI: abi ? `${platform}-${arch}-${abi}` : `${platform}-${arch}`,
		platform,
		arch,
		abi
	};
}
function getSystemDefaultTarget() {
	const host = execSync(`rustc -vV`, { env: process.env }).toString("utf8").split("\n").find((line) => line.startsWith("host: "));
	const triple = host?.slice(6);
	if (!triple) throw new TypeError(`Can not parse target triple from host`);
	return parseTriple(triple);
}
function getTargetLinker(target) {
	return TARGET_LINKER[target];
}
function targetToEnvVar(target) {
	return target.replace(/-/g, "_").toUpperCase();
}

//#endregion
//#region src/utils/version.ts
let NapiVersion = /* @__PURE__ */ function(NapiVersion$1) {
	NapiVersion$1[NapiVersion$1["Napi1"] = 1] = "Napi1";
	NapiVersion$1[NapiVersion$1["Napi2"] = 2] = "Napi2";
	NapiVersion$1[NapiVersion$1["Napi3"] = 3] = "Napi3";
	NapiVersion$1[NapiVersion$1["Napi4"] = 4] = "Napi4";
	NapiVersion$1[NapiVersion$1["Napi5"] = 5] = "Napi5";
	NapiVersion$1[NapiVersion$1["Napi6"] = 6] = "Napi6";
	NapiVersion$1[NapiVersion$1["Napi7"] = 7] = "Napi7";
	NapiVersion$1[NapiVersion$1["Napi8"] = 8] = "Napi8";
	NapiVersion$1[NapiVersion$1["Napi9"] = 9] = "Napi9";
	return NapiVersion$1;
}({});
const NAPI_VERSION_MATRIX = new Map([
	[NapiVersion.Napi1, "8.6.0 | 9.0.0 | 10.0.0"],
	[NapiVersion.Napi2, "8.10.0 | 9.3.0 | 10.0.0"],
	[NapiVersion.Napi3, "6.14.2 | 8.11.2 | 9.11.0 | 10.0.0"],
	[NapiVersion.Napi4, "10.16.0 | 11.8.0 | 12.0.0"],
	[NapiVersion.Napi5, "10.17.0 | 12.11.0 | 13.0.0"],
	[NapiVersion.Napi6, "10.20.0 | 12.17.0 | 14.0.0"],
	[NapiVersion.Napi7, "10.23.0 | 12.19.0 | 14.12.0 | 15.0.0"],
	[NapiVersion.Napi8, "12.22.0 | 14.17.0 | 15.12.0 | 16.0.0"],
	[NapiVersion.Napi9, "18.17.0 | 20.3.0 | 21.1.0"]
]);
function parseNodeVersion(v) {
	const matches = v.match(/v?([0-9]+)\.([0-9]+)\.([0-9]+)/i);
	if (!matches) throw new Error("Unknown node version number: " + v);
	const [, major, minor, patch] = matches;
	return {
		major: parseInt(major),
		minor: parseInt(minor),
		patch: parseInt(patch)
	};
}
function requiredNodeVersions(napiVersion) {
	const requirement = NAPI_VERSION_MATRIX.get(napiVersion);
	if (!requirement) return [parseNodeVersion("10.0.0")];
	return requirement.split("|").map(parseNodeVersion);
}
function toEngineRequirement(versions) {
	const requirements = [];
	versions.forEach((v, i) => {
		let req = "";
		if (i !== 0) {
			const lastVersion = versions[i - 1];
			req += `< ${lastVersion.major + 1}`;
		}
		req += `${i === 0 ? "" : " || "}>= ${v.major}.${v.minor}.${v.patch}`;
		requirements.push(req);
	});
	return requirements.join(" ");
}
function napiEngineRequirement(napiVersion) {
	return toEngineRequirement(requiredNodeVersions(napiVersion));
}

//#endregion
//#region src/utils/metadata.ts
async function parseMetadata(manifestPath) {
	if (!fs.existsSync(manifestPath)) throw new Error(`No crate found in manifest: ${manifestPath}`);
	const childProcess = spawn("cargo", [
		"metadata",
		"--manifest-path",
		manifestPath,
		"--format-version",
		"1"
	], { stdio: "pipe" });
	let stdout = "";
	let stderr = "";
	let status = 0;
	let error = null;
	childProcess.stdout.on("data", (data) => {
		stdout += data;
	});
	childProcess.stderr.on("data", (data) => {
		stderr += data;
	});
	await new Promise((resolve$1) => {
		childProcess.on("close", (code) => {
			status = code ?? 0;
			resolve$1();
		});
	});
	if (error) throw new Error("cargo metadata failed to run", { cause: error });
	if (status !== 0) {
		const simpleMessage = `cargo metadata exited with code ${status}`;
		throw new Error(`${simpleMessage} and error message:\n\n${stderr}`, { cause: new Error(simpleMessage) });
	}
	try {
		return JSON.parse(stdout);
	} catch (e) {
		throw new Error("Failed to parse cargo metadata JSON", { cause: e });
	}
}

//#endregion
//#region src/utils/config.ts
async function readNapiConfig(path$1, configPath) {
	if (configPath && !await fileExists(configPath)) throw new Error(`NAPI-RS config not found at ${configPath}`);
	if (!await fileExists(path$1)) throw new Error(`package.json not found at ${path$1}`);
	const content = await readFileAsync(path$1, "utf8");
	let pkgJson;
	try {
		pkgJson = JSON.parse(content);
	} catch (e) {
		throw new Error(`Failed to parse package.json at ${path$1}`, { cause: e });
	}
	let separatedConfig;
	if (configPath) {
		const configContent = await readFileAsync(configPath, "utf8");
		try {
			separatedConfig = JSON.parse(configContent);
		} catch (e) {
			throw new Error(`Failed to parse NAPI-RS config at ${configPath}`, { cause: e });
		}
	}
	const userNapiConfig = pkgJson.napi ?? {};
	if (pkgJson.napi && separatedConfig) {
		const pkgJsonPath = underline(path$1);
		const configPathUnderline = underline(configPath);
		console.warn(yellow(`Both napi field in ${pkgJsonPath} and [NAPI-RS config](${configPathUnderline}) file are found, the NAPI-RS config file will be used.`));
		Object.assign(userNapiConfig, separatedConfig);
	}
	const napiConfig = merge({
		binaryName: "index",
		packageName: pkgJson.name,
		targets: [],
		packageJson: pkgJson,
		npmClient: "npm"
	}, omit(userNapiConfig, "targets"));
	let targets = userNapiConfig.targets ?? [];
	if (userNapiConfig?.name) {
		console.warn(yellow(`[DEPRECATED] napi.name is deprecated, use napi.binaryName instead.`));
		napiConfig.binaryName = userNapiConfig.name;
	}
	if (!targets.length) {
		let deprecatedWarned = false;
		const warning = yellow(`[DEPRECATED] napi.triples is deprecated, use napi.targets instead.`);
		if (userNapiConfig.triples?.defaults) {
			deprecatedWarned = true;
			console.warn(warning);
			targets = targets.concat(DEFAULT_TARGETS);
		}
		if (userNapiConfig.triples?.additional?.length) {
			targets = targets.concat(userNapiConfig.triples.additional);
			if (!deprecatedWarned) console.warn(warning);
		}
	}
	const uniqueTargets = new Set(targets);
	if (uniqueTargets.size !== targets.length) {
		const duplicateTarget = targets.find((target, index) => targets.indexOf(target) !== index);
		throw new Error(`Duplicate targets are not allowed: ${duplicateTarget}`);
	}
	napiConfig.targets = targets.map(parseTriple);
	return napiConfig;
}

//#endregion
//#region src/utils/cargo.ts
function tryInstallCargoBinary(name$1, bin$1) {
	if (detectCargoBinary(bin$1)) {
		debug$9("Cargo binary already installed: %s", name$1);
		return;
	}
	try {
		debug$9("Installing cargo binary: %s", name$1);
		execSync(`cargo install ${name$1}`, { stdio: "inherit" });
	} catch (e) {
		throw new Error(`Failed to install cargo binary: ${name$1}`, { cause: e });
	}
}
function detectCargoBinary(bin$1) {
	debug$9("Detecting cargo binary: %s", bin$1);
	try {
		execSync(`cargo help ${bin$1}`, { stdio: "ignore" });
		debug$9("Cargo binary detected: %s", bin$1);
		return true;
	} catch {
		debug$9("Cargo binary not detected: %s", bin$1);
		return false;
	}
}

//#endregion
//#region src/utils/typegen.ts
const TOP_LEVEL_NAMESPACE = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER = `/* auto-generated by NAPI-RS */
/* eslint-disable */
`;
var TypeDefKind = /* @__PURE__ */ function(TypeDefKind$1) {
	TypeDefKind$1["Const"] = "const";
	TypeDefKind$1["Enum"] = "enum";
	TypeDefKind$1["StringEnum"] = "string_enum";
	TypeDefKind$1["Interface"] = "interface";
	TypeDefKind$1["Type"] = "type";
	TypeDefKind$1["Fn"] = "fn";
	TypeDefKind$1["Struct"] = "struct";
	TypeDefKind$1["Impl"] = "impl";
	return TypeDefKind$1;
}(TypeDefKind || {});
function prettyPrint(line, constEnum, ident, ambient = false) {
	let s = line.js_doc ?? "";
	switch (line.kind) {
		case TypeDefKind.Interface:
			s += `export interface ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.Type:
			s += `export type ${line.name} = \n${line.def}`;
			break;
		case TypeDefKind.Enum:
			const enumName = constEnum ? "const enum" : "enum";
			s += `${exportDeclare(ambient)} ${enumName} ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.StringEnum:
			if (constEnum) s += `${exportDeclare(ambient)} const enum ${line.name} {\n${line.def}\n}`;
			else s += `export type ${line.name} = ${line.def.replaceAll(/.*=/g, "").replaceAll(",", "|")};`;
			break;
		case TypeDefKind.Struct:
			s += `${exportDeclare(ambient)} class ${line.name} {\n${line.def}\n}`;
			if (line.original_name && line.original_name !== line.name) s += `\nexport type ${line.original_name} = ${line.name}`;
			break;
		case TypeDefKind.Fn:
			s += `${exportDeclare(ambient)} ${line.def}`;
			break;
		default: s += line.def;
	}
	return correctStringIdent(s, ident);
}
function exportDeclare(ambient) {
	if (ambient) return "export";
	return "export declare";
}
async function processTypeDef(intermediateTypeFile, constEnum) {
	const exports$1 = [];
	const defs = await readIntermediateTypeFile(intermediateTypeFile);
	const groupedDefs = preprocessTypeDef(defs);
	const dts = sortBy(Array.from(groupedDefs), ([namespace]) => namespace).map(([namespace, defs$1]) => {
		if (namespace === TOP_LEVEL_NAMESPACE) return defs$1.map((def) => {
			switch (def.kind) {
				case TypeDefKind.Const:
				case TypeDefKind.Enum:
				case TypeDefKind.StringEnum:
				case TypeDefKind.Fn:
				case TypeDefKind.Struct: {
					exports$1.push(def.name);
					if (def.original_name && def.original_name !== def.name) exports$1.push(def.original_name);
					break;
				}
				default: break;
			}
			return prettyPrint(def, constEnum, 0);
		}).join("\n\n");
		else {
			exports$1.push(namespace);
			let declaration = "";
			declaration += `export declare namespace ${namespace} {\n`;
			for (const def of defs$1) declaration += prettyPrint(def, constEnum, 2, true) + "\n";
			declaration += "}";
			return declaration;
		}
	}).join("\n\n") + "\n";
	return {
		dts,
		exports: exports$1
	};
}
async function readIntermediateTypeFile(file) {
	const content = await readFileAsync(file, "utf8");
	const defs = content.split("\n").filter(Boolean).map((line) => {
		line = line.trim();
		const parsed = JSON.parse(line);
		if (parsed.js_doc) parsed.js_doc = parsed.js_doc.replace(/\\n/g, "\n");
		if (parsed.def) parsed.def = parsed.def.replace(/\\n/g, "\n");
		return parsed;
	});
	return defs.sort((a, b) => {
		if (a.kind === TypeDefKind.Struct) {
			if (b.kind === TypeDefKind.Struct) return a.name.localeCompare(b.name);
			return -1;
		} else if (b.kind === TypeDefKind.Struct) return 1;
		else return a.name.localeCompare(b.name);
	});
}
function preprocessTypeDef(defs) {
	const namespaceGrouped = /* @__PURE__ */ new Map();
	const classDefs = /* @__PURE__ */ new Map();
	for (const def of defs) {
		const namespace = def.js_mod ?? TOP_LEVEL_NAMESPACE;
		if (!namespaceGrouped.has(namespace)) namespaceGrouped.set(namespace, []);
		const group = namespaceGrouped.get(namespace);
		if (def.kind === TypeDefKind.Struct) {
			group.push(def);
			classDefs.set(def.name, def);
		} else if (def.kind === TypeDefKind.Impl) {
			const classDef = classDefs.get(def.name);
			if (classDef) {
				if (classDef.def) classDef.def += "\n";
				classDef.def += def.def;
				if (classDef.def) classDef.def = classDef.def.replace(/\\n/g, "\n");
			}
		} else group.push(def);
	}
	return namespaceGrouped;
}
function correctStringIdent(src, ident) {
	let bracketDepth = 0;
	const result = src.split("\n").map((line) => {
		line = line.trim();
		if (line === "") return "";
		const isInMultilineComment = line.startsWith("*");
		const isClosingBracket = line.endsWith("}");
		const isOpeningBracket = line.endsWith("{");
		const isTypeDeclaration = line.endsWith("=");
		const isTypeVariant = line.startsWith("|");
		let rightIndent = ident;
		if ((isOpeningBracket || isTypeDeclaration) && !isInMultilineComment) {
			bracketDepth += 1;
			rightIndent += (bracketDepth - 1) * 2;
		} else {
			if (isClosingBracket && bracketDepth > 0 && !isInMultilineComment && !isTypeVariant) bracketDepth -= 1;
			rightIndent += bracketDepth * 2;
		}
		if (isInMultilineComment) rightIndent += 1;
		const s = `${" ".repeat(rightIndent)}${line}`;
		return s;
	}).join("\n");
	return result;
}

//#endregion
//#region src/utils/read-config.ts
async function readConfig(options) {
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	return config;
}

//#endregion
//#region src/api/artifacts.ts
const debug$8 = debugFactory("artifacts");
async function collectArtifacts(userOptions) {
	const options = applyDefaultArtifactsOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const { targets, binaryName, packageName } = await readNapiConfig(packageJsonPath);
	const distDirs = targets.map((platform) => join(options.cwd, options.npmDir, platform.platformArchABI));
	const universalSourceBins = new Set(targets.filter((platform) => platform.arch === "universal").flatMap((p) => UniArchsByPlatform[p.platform]?.map((a) => `${p.platform}-${a}`)).filter(Boolean));
	await collectNodeBinaries(join(options.cwd, options.outputDir)).then((output) => Promise.all(output.map(async (filePath) => {
		debug$8.info(`Read [${colors.yellowBright(filePath)}]`);
		const sourceContent = await readFileAsync(filePath);
		const parsedName = parse(filePath);
		const terms = parsedName.name.split(".");
		const platformArchABI = terms.pop();
		const _binaryName = terms.join(".");
		if (_binaryName !== binaryName) {
			debug$8.warn(`[${_binaryName}] is not matched with [${binaryName}], skip`);
			return;
		}
		const dir = distDirs.find((dir$1) => dir$1.includes(platformArchABI));
		if (!dir && universalSourceBins.has(platformArchABI)) {
			debug$8.warn(`[${platformArchABI}] has no dist dir but it is source bin for universal arch, skip`);
			return;
		}
		if (!dir) throw new Error(`No dist dir found for ${filePath}`);
		const distFilePath = join(dir, parsedName.base);
		debug$8.info(`Write file content to [${colors.yellowBright(distFilePath)}]`);
		await writeFileAsync(distFilePath, sourceContent);
		const distFilePathLocal = join(parse(packageJsonPath).dir, parsedName.base);
		debug$8.info(`Write file content to [${colors.yellowBright(distFilePathLocal)}]`);
		await writeFileAsync(distFilePathLocal, sourceContent);
	})));
	const wasiTarget = targets.find((t) => t.platform === "wasi");
	if (wasiTarget) {
		const wasiDir = join(options.cwd, options.npmDir, wasiTarget.platformArchABI);
		const cjsFile = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi.cjs`);
		const workerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker.mjs`);
		const browserEntry = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi-browser.js`);
		const browserWorkerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker-browser.mjs`);
		debug$8.info(`Move wasi binding file [${colors.yellowBright(cjsFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi.cjs`), await readFileAsync(cjsFile));
		debug$8.info(`Move wasi worker file [${colors.yellowBright(workerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker.mjs`), await readFileAsync(workerFile));
		debug$8.info(`Move wasi browser entry file [${colors.yellowBright(browserEntry)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi-browser.js`), (await readFileAsync(browserEntry, "utf8")).replace(`new URL('./wasi-worker-browser.mjs', import.meta.url)`, `new URL('${packageName}-wasm32-wasi/wasi-worker-browser.mjs', import.meta.url)`));
		debug$8.info(`Move wasi browser worker file [${colors.yellowBright(browserWorkerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker-browser.mjs`), await readFileAsync(browserWorkerFile));
	}
}
async function collectNodeBinaries(root) {
	const files$1 = await readdirAsync(root, { withFileTypes: true });
	const nodeBinaries = files$1.filter((file) => file.isFile() && (file.name.endsWith(".node") || file.name.endsWith(".wasm"))).map((file) => join(root, file.name));
	const dirs = files$1.filter((file) => file.isDirectory());
	for (const dir of dirs) if (dir.name !== "node_modules") nodeBinaries.push(...await collectNodeBinaries(join(root, dir.name)));
	return nodeBinaries;
}

//#endregion
//#region src/commands/artifacts.ts
var ArtifactsCommand = class extends BaseArtifactsCommand {
	static usage = Command.Usage({
		description: "Copy artifacts from Github Actions into specified dir",
		examples: [["$0 artifacts --output-dir ./artifacts --dist ./npm", `Copy [binaryName].[platform].node under current dir(.) into packages under npm dir.
e.g: index.linux-x64-gnu.node --> ./npm/linux-x64-gnu/index.linux-x64-gnu.node`]]
	});
	static paths = [["artifacts"]];
	async execute() {
		await collectArtifacts(this.getOptions());
	}
};

//#endregion
//#region src/api/templates/js-binding.ts
function createCjsBinding(localName, pkgName, idents) {
	return `${bindingHeader}
const { createRequire } = require('node:module')
require = createRequire(__filename)

${createCommonBinding(localName, pkgName)}
module.exports = nativeBinding
${idents.map((ident) => `module.exports.${ident} = nativeBinding.${ident}`).join("\n")}
`;
}
function createEsmBinding(localName, pkgName, idents) {
	return `${bindingHeader}
import { createRequire } from 'node:module'
const require = createRequire(import.meta.url)
const __dirname = new URL('.', import.meta.url).pathname

${createCommonBinding(localName, pkgName)}
const { ${idents.join(", ")} } = nativeBinding
${idents.map((ident) => `export { ${ident} }`).join("\n")}
`;
}
const bindingHeader = `// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */
`;
function createCommonBinding(localName, pkgName) {
	function requireTuple(tuple, identSize = 8) {
		const identLow = " ".repeat(identSize - 2);
		const ident = " ".repeat(identSize);
		return `try {
${ident}return require('./${localName}.${tuple}.node')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}
${identLow}try {
${ident}return require('${pkgName}-${tuple}')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}`;
	}
	return `const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      nativeBinding = require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      ${requireTuple("android-arm64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("android-arm-eabi")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Android \${process.arch}\`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      ${requireTuple("win32-x64-msvc")}
    } else if (process.arch === 'ia32') {
      ${requireTuple("win32-ia32-msvc")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("win32-arm64-msvc")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Windows: \${process.arch}\`))
    }
  } else if (process.platform === 'darwin') {
    ${requireTuple("darwin-universal", 6)}
    if (process.arch === 'x64') {
      ${requireTuple("darwin-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("darwin-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on macOS: \${process.arch}\`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      ${requireTuple("freebsd-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("freebsd-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on FreeBSD: \${process.arch}\`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        ${requireTuple("linux-x64-musl", 10)}
      } else {
        ${requireTuple("linux-x64-gnu", 10)}
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        ${requireTuple("linux-arm64-musl", 10)}
      } else {
        ${requireTuple("linux-arm64-gnu", 10)}
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        ${requireTuple("linux-arm-musleabihf", 10)}
      } else {
        ${requireTuple("linux-arm-gnueabihf", 10)}
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        ${requireTuple("linux-riscv64-musl", 10)}
      } else {
        ${requireTuple("linux-riscv64-gnu", 10)}
      }
    } else if (process.arch === 'ppc64') {
      ${requireTuple("linux-ppc64-gnu")}
    } else if (process.arch === 's390x') {
      ${requireTuple("linux-s390x-gnu")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Linux: \${process.arch}\`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      ${requireTuple("linux-arm64-ohos")}
    } else if (process.arch === 'x64') {
      ${requireTuple("linux-x64-ohos")}
    } else if (process.arch === 'arm') {
      ${requireTuple("linux-arm-ohos")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on OpenHarmony: \${process.arch}\`))
    }
  } else {
    loadErrors.push(new Error(\`Unsupported OS: \${process.platform}, architecture: \${process.arch}\`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  try {
    nativeBinding = require('./${localName}.wasi.cjs')
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      loadErrors.push(err)
    }
  }
  if (!nativeBinding) {
    try {
      nativeBinding = require('${pkgName}-wasm32-wasi')
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        loadErrors.push(err)
      }
    }
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      \`Cannot find native binding. \` +
        \`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). \` +
        'Please try \`npm i\` again after removing both package-lock.json and node_modules directory.',
      { cause: loadErrors }
    )
  }
  throw new Error(\`Failed to load native binding\`)
}
`;
}

//#endregion
//#region src/api/templates/load-wasi-template.ts
const createWasiBrowserBinding = (wasiFilename, initialMemory = 4e3, maximumMemory = 65536, fs$1 = false, asyncInit = false, buffer = false) => {
	const fsImport = fs$1 ? buffer ? `import { memfs, Buffer } from '@napi-rs/wasm-runtime/fs'` : `import { memfs } from '@napi-rs/wasm-runtime/fs'` : "";
	const bufferImport = buffer && !fs$1 ? `import { Buffer } from 'buffer'` : "";
	const wasiCreation = fs$1 ? `
export const { fs: __fs, vol: __volume } = memfs()

const __wasi = new __WASI({
  version: 'preview1',
  fs: __fs,
  preopens: {
    '/': '/',
  },
})` : `
const __wasi = new __WASI({
  version: 'preview1',
})`;
	const workerFsHandler = fs$1 ? `    worker.addEventListener('message', __wasmCreateOnMessageForFsProxy(__fs))\n` : "";
	const emnapiInjectBuffer = buffer ? "__emnapiContext.feature.Buffer = Buffer" : "";
	const emnapiInstantiateImport = asyncInit ? `instantiateNapiModule as __emnapiInstantiateNapiModule` : `instantiateNapiModuleSync as __emnapiInstantiateNapiModuleSync`;
	const emnapiInstantiateCall = asyncInit ? `await __emnapiInstantiateNapiModule` : `__emnapiInstantiateNapiModuleSync`;
	return `import {
  createOnMessage as __wasmCreateOnMessageForFsProxy,
  getDefaultContext as __emnapiGetDefaultContext,
  ${emnapiInstantiateImport},
  WASI as __WASI,
} from '@napi-rs/wasm-runtime'
${fsImport}
${bufferImport}
${wasiCreation}

const __wasmUrl = new URL('./${wasiFilename}.wasm', import.meta.url).href
const __emnapiContext = __emnapiGetDefaultContext()
${emnapiInjectBuffer}

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

const __wasmFile = await fetch(__wasmUrl).then((res) => res.arrayBuffer())

const {
  instance: __napiInstance,
  module: __wasiModule,
  napiModule: __napiModule,
} = ${emnapiInstantiateCall}(__wasmFile, {
  context: __emnapiContext,
  asyncWorkPoolSize: 4,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(new URL('./wasi-worker-browser.mjs', import.meta.url), {
      type: 'module',
    })
${workerFsHandler}
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;
};
const createWasiBinding = (wasmFileName, packageName, initialMemory = 4e3, maximumMemory = 65536) => `/* eslint-disable */
/* prettier-ignore */

/* auto-generated by NAPI-RS */

const __nodeFs = require('node:fs')
const __nodePath = require('node:path')
const { WASI: __nodeWASI } = require('node:wasi')
const { Worker } = require('node:worker_threads')

const {
  createOnMessage: __wasmCreateOnMessageForFsProxy,
  getDefaultContext: __emnapiGetDefaultContext,
  instantiateNapiModuleSync: __emnapiInstantiateNapiModuleSync,
} = require('@napi-rs/wasm-runtime')

const __rootDir = __nodePath.parse(process.cwd()).root

const __wasi = new __nodeWASI({
  version: 'preview1',
  env: process.env,
  preopens: {
    [__rootDir]: __rootDir,
  }
})

const __emnapiContext = __emnapiGetDefaultContext()

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

let __wasmFilePath = __nodePath.join(__dirname, '${wasmFileName}.wasm')
const __wasmDebugFilePath = __nodePath.join(__dirname, '${wasmFileName}.debug.wasm')

if (__nodeFs.existsSync(__wasmDebugFilePath)) {
  __wasmFilePath = __wasmDebugFilePath
} else if (!__nodeFs.existsSync(__wasmFilePath)) {
  try {
    __wasmFilePath = __nodePath.resolve('${packageName}-wasm32-wasi')
  } catch {
    throw new Error('Cannot find ${wasmFileName}.wasm file, and ${packageName}-wasm32-wasi package is not installed.')
  }
}

const { instance: __napiInstance, module: __wasiModule, napiModule: __napiModule } = __emnapiInstantiateNapiModuleSync(__nodeFs.readFileSync(__wasmFilePath), {
  context: __emnapiContext,
  asyncWorkPoolSize: (function() {
    const threadsSizeFromEnv = Number(process.env.NAPI_RS_ASYNC_WORK_POOL_SIZE ?? process.env.UV_THREADPOOL_SIZE)
    // NaN > 0 is false
    if (threadsSizeFromEnv > 0) {
      return threadsSizeFromEnv
    } else {
      return 4
    }
  })(),
  reuseWorker: true,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(__nodePath.join(__dirname, 'wasi-worker.mjs'), {
      env: process.env,
    })
    worker.onmessage = ({ data }) => {
      __wasmCreateOnMessageForFsProxy(__nodeFs)(data)
    }

    // The main thread of Node.js waits for all the active handles before exiting.
    // But Rust threads are never waited without \`thread::join\`.
    // So here we hack the code of Node.js to prevent the workers from being referenced (active).
    // According to https://github.com/nodejs/node/blob/19e0d472728c79d418b74bddff588bea70a403d0/lib/internal/worker.js#L415,
    // a worker is consist of two handles: kPublicPort and kHandle.
    {
      const kPublicPort = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kPublicPort")
      );
      if (kPublicPort) {
        worker[kPublicPort].ref = () => {};
      }

      const kHandle = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kHandle")
      );
      if (kHandle) {
        worker[kHandle].ref = () => {};
      }

      worker.unref();
    }
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;

//#endregion
//#region src/api/templates/wasi-worker-template.ts
const WASI_WORKER_TEMPLATE = `import fs from "node:fs";
import { createRequire } from "node:module";
import { parse } from "node:path";
import { WASI } from "node:wasi";
import { parentPort, Worker } from "node:worker_threads";

const require = createRequire(import.meta.url);

const { instantiateNapiModuleSync, MessageHandler, getDefaultContext } = require("@napi-rs/wasm-runtime");

if (parentPort) {
  parentPort.on("message", (data) => {
    globalThis.onmessage({ data });
  });
}

Object.assign(globalThis, {
  self: globalThis,
  require,
  Worker,
  importScripts: function (f) {
    ;(0, eval)(fs.readFileSync(f, "utf8") + "//# sourceURL=" + f);
  },
  postMessage: function (msg) {
    if (parentPort) {
      parentPort.postMessage(msg);
    }
  },
});

const emnapiContext = getDefaultContext();

const __rootDir = parse(process.cwd()).root;

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    const wasi = new WASI({
      version: 'preview1',
      env: process.env,
      preopens: {
        [__rootDir]: __rootDir,
      },
    });

    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      context: emnapiContext,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory
        };
      },
    });
  },
});

globalThis.onmessage = function (e) {
  handler.handle(e);
};
`;
const createWasiBrowserWorkerBinding = (fs$1) => {
	const fsImport = fs$1 ? `import { instantiateNapiModuleSync, MessageHandler, WASI, createFsProxy } from '@napi-rs/wasm-runtime'
import { memfsExported as __memfsExported } from '@napi-rs/wasm-runtime/fs'

const fs = createFsProxy(__memfsExported)` : `import { instantiateNapiModuleSync, MessageHandler, WASI } from '@napi-rs/wasm-runtime'`;
	const wasiCreation = fs$1 ? `const wasi = new WASI({
      fs,
      preopens: {
        '/': '/',
      },
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })` : `const wasi = new WASI({
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })`;
	return `${fsImport}

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    ${wasiCreation}
    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory,
        }
      },
    })
  },
})

globalThis.onmessage = function (e) {
  handler.handle(e)
}
`;
};

//#endregion
//#region src/api/build.ts
const debug$7 = debugFactory("build");
const require = createRequire(import.meta.url);
async function buildProject(rawOptions) {
	debug$7("napi build command receive options: %O", rawOptions);
	const options = {
		dtsCache: true,
		...rawOptions,
		cwd: rawOptions.cwd ?? process.cwd()
	};
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const manifestPath = resolvePath(options.manifestPath ?? "Cargo.toml");
	const metadata = await parseMetadata(manifestPath);
	const crate = metadata.packages.find((p) => {
		if (options.package) return p.name === options.package;
		else return p.manifest_path === manifestPath;
	});
	if (!crate) throw new Error("Unable to find crate to build. It seems you are trying to build a crate in a workspace, try using `--package` option to specify the package to build.");
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	const builder = new Builder(metadata, crate, config, options);
	return builder.build();
}
var Builder = class {
	args = [];
	envs = {};
	outputs = [];
	target;
	crateDir;
	outputDir;
	targetDir;
	enableTypeDef = false;
	constructor(metadata, crate, config, options) {
		this.metadata = metadata;
		this.crate = crate;
		this.config = config;
		this.options = options;
		this.target = options.target ? parseTriple(options.target) : process.env.CARGO_BUILD_TARGET ? parseTriple(process.env.CARGO_BUILD_TARGET) : getSystemDefaultTarget();
		this.crateDir = parse(crate.manifest_path).dir;
		this.outputDir = resolve(this.options.cwd, options.outputDir ?? this.crateDir);
		this.targetDir = options.targetDir ?? process.env.CARGO_BUILD_TARGET_DIR ?? metadata.target_directory;
		this.enableTypeDef = this.crate.dependencies.some((dep) => dep.name === "napi-derive" && (dep.uses_default_features || dep.features.includes("type-def")));
		if (!this.enableTypeDef) {
			const requirementWarning = "`napi-derive` crate is not used or `type-def` feature is not enabled for `napi-derive` crate";
			debug$7.warn(`${requirementWarning}. Will skip binding generation for \`.node\`, \`.wasi\` and \`.d.ts\` files.`);
			if (this.options.dts || this.options.dtsHeader || this.config.dtsHeader || this.config.dtsHeaderFile) debug$7.warn(`${requirementWarning}. \`dts\` related options are enabled but will be ignored.`);
		}
	}
	get cdyLibName() {
		return this.crate.targets.find((t) => t.crate_types.includes("cdylib"))?.name;
	}
	get binName() {
		return this.options.bin ?? (this.cdyLibName ? null : this.crate.targets.find((t) => t.crate_types.includes("bin"))?.name);
	}
	build() {
		if (!this.cdyLibName) {
			const warning = "Missing `crate-type = [\"cdylib\"]` in [lib] config. The build result will not be available as node addon.";
			if (this.binName) debug$7.warn(warning);
			else throw new Error(warning);
		}
		return this.pickBinary().setPackage().setFeatures().setTarget().pickCrossToolchain().setEnvs().setBypassArgs().exec();
	}
	pickCrossToolchain() {
		if (!this.options.useNapiCross) return this;
		if (this.options.useCross) debug$7.warn("You are trying to use both `--cross` and `--use-napi-cross` options, `--use-cross` will be ignored.");
		if (this.options.crossCompile) debug$7.warn("You are trying to use both `--cross-compile` and `--use-napi-cross` options, `--cross-compile` will be ignored.");
		try {
			const { version: version$2, download } = require("@napi-rs/cross-toolchain");
			const alias = { "s390x-unknown-linux-gnu": "s390x-ibm-linux-gnu" };
			const toolchainPath = join(homedir(), ".napi-rs", "cross-toolchain", version$2, this.target.triple);
			mkdirSync(toolchainPath, { recursive: true });
			if (existsSync(join(toolchainPath, "package.json"))) debug$7(`Toolchain ${toolchainPath} exists, skip extracting`);
			else {
				const tarArchive = download(process.arch, this.target.triple);
				tarArchive.unpack(toolchainPath);
			}
			const upperCaseTarget = targetToEnvVar(this.target.triple);
			const crossTargetName = alias[this.target.triple] ?? this.target.triple;
			const linkerEnv = `CARGO_TARGET_${upperCaseTarget}_LINKER`;
			this.envs[linkerEnv] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_SYSROOT) this.envs[`TARGET_SYSROOT`] = join(toolchainPath, crossTargetName, "sysroot");
			if (!process.env.TARGET_AR) this.envs[`TARGET_AR`] = join(toolchainPath, "bin", `${crossTargetName}-ar`);
			if (!process.env.TARGET_RANLIB) this.envs[`TARGET_RANLIB`] = join(toolchainPath, "bin", `${crossTargetName}-ranlib`);
			if (!process.env.TARGET_READELF) this.envs[`TARGET_READELF`] = join(toolchainPath, "bin", `${crossTargetName}-readelf`);
			if (!process.env.TARGET_C_INCLUDE_PATH) this.envs[`TARGET_C_INCLUDE_PATH`] = join(toolchainPath, crossTargetName, "sysroot", "usr", "include/");
			if (!process.env.TARGET_CC) this.envs[`TARGET_CC`] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_CXX) this.envs[`TARGET_CXX`] = join(toolchainPath, "bin", `${crossTargetName}-g++`);
			if (process.env.TARGET_CC?.startsWith("clang") || process.env.CC?.startsWith("clang") && !process.env.TARGET_CC) {
				const TARGET_CFLAGS = process.env.TARGET_CFLAGS ?? "";
				this.envs.TARGET_CFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CFLAGS}`;
			}
			if (process.env.CXX?.startsWith("clang++") && !process.env.TARGET_CXX || process.env.TARGET_CXX?.startsWith("clang++")) {
				const TARGET_CXXFLAGS = process.env.TARGET_CXXFLAGS ?? "";
				this.envs.TARGET_CXXFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CXXFLAGS}`;
			}
			this.envs.PATH = this.envs.PATH ? `${toolchainPath}/bin:${this.envs.PATH}:${process.env.PATH}` : `${toolchainPath}/bin:${process.env.PATH}`;
		} catch (e) {
			debug$7.warn("Pick cross toolchain failed", e);
		}
		return this;
	}
	exec() {
		debug$7(`Start building crate: ${this.crate.name}`);
		debug$7("  %i", `cargo ${this.args.join(" ")}`);
		const controller = new AbortController();
		const watch = this.options.watch;
		const buildTask = new Promise((resolve$1, reject) => {
			if (this.options.useCross && this.options.crossCompile) throw new Error("`--use-cross` and `--cross-compile` can not be used together");
			const command = process.env.CARGO ?? (this.options.useCross ? "cross" : "cargo");
			const buildProcess = spawn(command, this.args, {
				env: {
					...process.env,
					...this.envs
				},
				stdio: watch ? [
					"inherit",
					"inherit",
					"pipe"
				] : "inherit",
				cwd: this.options.cwd,
				signal: controller.signal
			});
			buildProcess.once("exit", (code) => {
				if (code === 0) {
					debug$7("%i", `Build crate ${this.crate.name} successfully!`);
					resolve$1();
				} else reject(/* @__PURE__ */ new Error(`Build failed with exit code ${code}`));
			});
			buildProcess.once("error", (e) => {
				reject(new Error(`Build failed with error: ${e.message}`, { cause: e }));
			});
			buildProcess.stderr?.on("data", (data) => {
				const output = data.toString();
				console.error(output);
				if (/Finished\s(`dev`|`release`)/.test(output)) this.postBuild().catch(() => {});
			});
		});
		return {
			task: buildTask.then(() => this.postBuild()),
			abort: () => controller.abort()
		};
	}
	pickBinary() {
		let set = false;
		if (this.options.watch) if (process.env.CI) debug$7.warn("Watch mode is not supported in CI environment");
		else {
			debug$7("Use %i", "cargo-watch");
			tryInstallCargoBinary("cargo-watch", "watch");
			this.args.push("watch", "--why", "-i", "*.{js,ts,node}", "-w", this.crateDir, "--", "cargo", "build");
			set = true;
		}
		if (this.options.crossCompile) if (this.target.platform === "win32") if (process.platform === "win32") debug$7.warn("You are trying to cross compile to win32 platform on win32 platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-xwin");
			tryInstallCargoBinary("cargo-xwin", "xwin");
			this.args.push("xwin", "build");
			if (this.target.arch === "ia32") this.envs.XWIN_ARCH = "x86";
			set = true;
		}
		else if (this.target.platform === "linux" && process.platform === "linux" && this.target.arch === process.arch && function(abi) {
			const glibcVersionRuntime = process.report?.getReport()?.header?.glibcVersionRuntime;
			const libc = glibcVersionRuntime ? "gnu" : "musl";
			return abi === libc;
		}(this.target.abi)) debug$7.warn("You are trying to cross compile to linux target on linux platform which is unnecessary.");
		else if (this.target.platform === "darwin" && process.platform === "darwin") debug$7.warn("You are trying to cross compile to darwin target on darwin platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-zigbuild");
			tryInstallCargoBinary("cargo-zigbuild", "zigbuild");
			this.args.push("zigbuild");
			set = true;
		}
		if (!set) this.args.push("build");
		return this;
	}
	setPackage() {
		const args = [];
		if (this.options.package) args.push("--package", this.options.package);
		if (this.binName) args.push("--bin", this.binName);
		if (args.length) {
			debug$7("Set package flags: ");
			debug$7("  %O", args);
			this.args.push(...args);
		}
		return this;
	}
	setTarget() {
		debug$7("Set compiling target to: ");
		debug$7("  %i", this.target.triple);
		this.args.push("--target", this.target.triple);
		return this;
	}
	setEnvs() {
		if (this.enableTypeDef) {
			this.envs.NAPI_TYPE_DEF_TMP_FOLDER = this.generateIntermediateTypeDefFolder();
			this.setForceBuildEnvs(this.envs.NAPI_TYPE_DEF_TMP_FOLDER);
		}
		let rustflags = process.env.RUSTFLAGS ?? process.env.CARGO_BUILD_RUSTFLAGS ?? "";
		if (this.target.abi?.includes("musl") && !rustflags.includes("target-feature=-crt-static")) rustflags += " -C target-feature=-crt-static";
		if (this.options.strip && !rustflags.includes("link-arg=-s")) rustflags += " -C link-arg=-s";
		if (rustflags.length) this.envs.RUSTFLAGS = rustflags;
		const linker = this.options.crossCompile ? void 0 : getTargetLinker(this.target.triple);
		const linkerEnv = `CARGO_TARGET_${targetToEnvVar(this.target.triple)}_LINKER`;
		if (linker && !process.env[linkerEnv] && !this.envs[linkerEnv]) this.envs[linkerEnv] = linker;
		if (this.target.platform === "android") this.setAndroidEnv();
		if (this.target.platform === "wasi") this.setWasiEnv();
		if (this.target.platform === "openharmony") this.setOpenHarmonyEnv();
		debug$7("Set envs: ");
		Object.entries(this.envs).forEach(([k, v]) => {
			debug$7("  %i", `${k}=${v}`);
		});
		return this;
	}
	setForceBuildEnvs(typeDefTmpFolder) {
		this.metadata.packages.forEach((crate) => {
			if (crate.dependencies.some((d) => d.name === "napi-derive") && !existsSync(join(typeDefTmpFolder, crate.name))) this.envs[`NAPI_FORCE_BUILD_${crate.name.replace(/-/g, "_").toUpperCase()}`] = Date.now().toString();
		});
	}
	setAndroidEnv() {
		const { ANDROID_NDK_LATEST_HOME } = process.env;
		if (!ANDROID_NDK_LATEST_HOME) debug$7.warn(`${colors.red("ANDROID_NDK_LATEST_HOME")} environment variable is missing`);
		if (process.platform === "android") return;
		const targetArch = this.target.arch === "arm" ? "armv7a" : "aarch64";
		const targetPlatform = this.target.arch === "arm" ? "androideabi24" : "android24";
		const hostPlatform = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "windows" : "linux";
		Object.assign(this.envs, {
			CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-android24-clang`,
			CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-androideabi24-clang`,
			TARGET_CC: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang`,
			TARGET_CXX: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang++`,
			TARGET_AR: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ar`,
			TARGET_RANLIB: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ranlib`,
			ANDROID_NDK: ANDROID_NDK_LATEST_HOME,
			PATH: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`
		});
	}
	setWasiEnv() {
		const emnapi = join(require.resolve("emnapi"), "..", "lib", "wasm32-wasi-threads");
		this.envs.EMNAPI_LINK_DIR = emnapi;
		const { WASI_SDK_PATH } = process.env;
		if (WASI_SDK_PATH && existsSync(WASI_SDK_PATH)) {
			this.envs.CARGO_TARGET_WASM32_WASI_PREVIEW1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP2_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.setEnvIfNotExists("TARGET_CC", join(WASI_SDK_PATH, "bin", "clang"));
			this.setEnvIfNotExists("TARGET_CXX", join(WASI_SDK_PATH, "bin", "clang++"));
			this.setEnvIfNotExists("TARGET_AR", join(WASI_SDK_PATH, "bin", "ar"));
			this.setEnvIfNotExists("TARGET_RANLIB", join(WASI_SDK_PATH, "bin", "ranlib"));
			this.setEnvIfNotExists("TARGET_CFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists("TARGET_CXXFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists(`TARGET_LDFLAGS`, `-fuse-ld=${WASI_SDK_PATH}/bin/wasm-ld --target=wasm32-wasi-threads`);
		}
	}
	setOpenHarmonyEnv() {
		const { OHOS_SDK_PATH, OHOS_SDK_NATIVE } = process.env;
		const ndkPath = OHOS_SDK_PATH ? `${OHOS_SDK_NATIVE}/native` : OHOS_SDK_NATIVE;
		if (!ndkPath && process.platform !== "openharmony") {
			debug$7.warn(`${colors.red("OHOS_SDK_PATH")} or ${colors.red("OHOS_SDK_NATIVE")} environment variable is missing`);
			return;
		}
		const linkerName = `CARGO_TARGET_${this.target.triple.toUpperCase().replace(/-/g, "_")}_LINKER`;
		const ranPath = `${ndkPath}/llvm/bin/llvm-ranlib`;
		const arPath = `${ndkPath}/llvm/bin/llvm-ar`;
		const ccPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang`;
		const cxxPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang++`;
		const asPath = `${ndkPath}/llvm/bin/llvm-as`;
		const ldPath = `${ndkPath}/llvm/bin/ld.lld`;
		const stripPath = `${ndkPath}/llvm/bin/llvm-strip`;
		const objDumpPath = `${ndkPath}/llvm/bin/llvm-objdump`;
		const objCopyPath = `${ndkPath}/llvm/bin/llvm-objcopy`;
		const nmPath = `${ndkPath}/llvm/bin/llvm-nm`;
		const binPath = `${ndkPath}/llvm/bin`;
		const libPath = `${ndkPath}/llvm/lib`;
		this.setEnvIfNotExists("LIBCLANG_PATH", libPath);
		this.setEnvIfNotExists("DEP_ATOMIC", "clang_rt.builtins");
		this.setEnvIfNotExists(linkerName, ccPath);
		this.setEnvIfNotExists("TARGET_CC", ccPath);
		this.setEnvIfNotExists("TARGET_CXX", cxxPath);
		this.setEnvIfNotExists("TARGET_AR", arPath);
		this.setEnvIfNotExists("TARGET_RANLIB", ranPath);
		this.setEnvIfNotExists("TARGET_AS", asPath);
		this.setEnvIfNotExists("TARGET_LD", ldPath);
		this.setEnvIfNotExists("TARGET_STRIP", stripPath);
		this.setEnvIfNotExists("TARGET_OBJDUMP", objDumpPath);
		this.setEnvIfNotExists("TARGET_OBJCOPY", objCopyPath);
		this.setEnvIfNotExists("TARGET_NM", nmPath);
		this.envs.PATH = `${binPath}${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`;
	}
	setFeatures() {
		const args = [];
		if (this.options.allFeatures && this.options.noDefaultFeatures) throw new Error("Cannot specify --all-features and --no-default-features together");
		if (this.options.allFeatures) args.push("--all-features");
		else if (this.options.noDefaultFeatures) args.push("--no-default-features");
		if (this.options.features) args.push("--features", ...this.options.features);
		debug$7("Set features flags: ");
		debug$7("  %O", args);
		this.args.push(...args);
		return this;
	}
	setBypassArgs() {
		if (this.options.release) this.args.push("--release");
		if (this.options.verbose) this.args.push("--verbose");
		if (this.options.targetDir) this.args.push("--target-dir", this.options.targetDir);
		if (this.options.profile) this.args.push("--profile", this.options.profile);
		if (this.options.manifestPath) this.args.push("--manifest-path", this.options.manifestPath);
		if (this.options.cargoOptions?.length) this.args.push(...this.options.cargoOptions);
		return this;
	}
	generateIntermediateTypeDefFolder() {
		let folder = join(this.targetDir, "napi-rs", `${this.crate.name}-${createHash("sha256").update(this.crate.manifest_path).update(CLI_VERSION).digest("hex").substring(0, 8)}`);
		if (!this.options.dtsCache) {
			rmSync(folder, {
				recursive: true,
				force: true
			});
			folder += `_${Date.now()}`;
		}
		mkdirAsync(folder, { recursive: true });
		return folder;
	}
	async postBuild() {
		try {
			debug$7(`Try to create output directory:`);
			debug$7("  %i", this.outputDir);
			await mkdirAsync(this.outputDir, { recursive: true });
			debug$7(`Output directory created`);
		} catch (e) {
			throw new Error(`Failed to create output directory ${this.outputDir}`, { cause: e });
		}
		const wasmBinaryName = await this.copyArtifact();
		if (this.cdyLibName) {
			const idents = await this.generateTypeDef();
			const jsOutput = await this.writeJsBinding(idents);
			const wasmBindingsOutput = await this.writeWasiBinding(wasmBinaryName, idents);
			if (jsOutput) this.outputs.push(jsOutput);
			if (wasmBindingsOutput) this.outputs.push(...wasmBindingsOutput);
		}
		return this.outputs;
	}
	async copyArtifact() {
		const [srcName, destName, wasmBinaryName] = this.getArtifactNames();
		if (!srcName || !destName) return;
		const profile = this.options.profile ?? (this.options.release ? "release" : "debug");
		const src = join(this.targetDir, this.target.triple, profile, srcName);
		debug$7(`Copy artifact from: [${src}]`);
		const dest = join(this.outputDir, destName);
		const isWasm = dest.endsWith(".wasm");
		try {
			if (await fileExists(dest)) {
				debug$7("Old artifact found, remove it first");
				await unlinkAsync(dest);
			}
			debug$7("Copy artifact to:");
			debug$7("  %i", dest);
			if (isWasm) {
				const { ModuleConfig } = await import("@napi-rs/wasm-tools");
				debug$7("Generate debug wasm module");
				try {
					const debugWasmModule = new ModuleConfig().generateDwarf(true).generateNameSection(true).generateProducersSection(true).preserveCodeTransform(true).strictValidate(false).parse(await readFileAsync(src));
					const debugWasmBinary = debugWasmModule.emitWasm(true);
					await writeFileAsync(dest.replace(/\.wasm$/, ".debug.wasm"), debugWasmBinary);
					debug$7("Generate release wasm module");
					const releaseWasmModule = new ModuleConfig().generateDwarf(false).generateNameSection(false).generateProducersSection(false).preserveCodeTransform(false).strictValidate(false).onlyStableFeatures(false).parse(debugWasmBinary);
					const releaseWasmBinary = releaseWasmModule.emitWasm(false);
					await writeFileAsync(dest, releaseWasmBinary);
				} catch (e) {
					debug$7.warn(`Failed to generate debug wasm module: ${e.message ?? e}`);
					await copyFileAsync(src, dest);
				}
			} else await copyFileAsync(src, dest);
			this.outputs.push({
				kind: dest.endsWith(".node") ? "node" : isWasm ? "wasm" : "exe",
				path: dest
			});
			return wasmBinaryName ? join(this.outputDir, wasmBinaryName) : null;
		} catch (e) {
			throw new Error("Failed to copy artifact", { cause: e });
		}
	}
	getArtifactNames() {
		if (this.cdyLibName) {
			const cdyLib = this.cdyLibName.replace(/-/g, "_");
			const wasiTarget = this.config.targets.find((t) => t.platform === "wasi");
			const srcName = this.target.platform === "darwin" ? `lib${cdyLib}.dylib` : this.target.platform === "win32" ? `${cdyLib}.dll` : this.target.platform === "wasi" || this.target.platform === "wasm" ? `${cdyLib}.wasm` : `lib${cdyLib}.so`;
			let destName = this.config.binaryName;
			if (this.options.platform) destName += `.${this.target.platformArchABI}`;
			if (srcName.endsWith(".wasm")) destName += ".wasm";
			else destName += ".node";
			return [
				srcName,
				destName,
				wasiTarget ? `${this.config.binaryName}.${wasiTarget.platformArchABI}.wasm` : null
			];
		} else if (this.binName) {
			const srcName = this.target.platform === "win32" ? `${this.binName}.exe` : this.binName;
			return [srcName, srcName];
		}
		return [];
	}
	async generateTypeDef() {
		const typeDefDir = this.envs.NAPI_TYPE_DEF_TMP_FOLDER;
		if (!this.enableTypeDef || !await dirExistsAsync(typeDefDir)) return [];
		const dest = join(this.outputDir, this.options.dts ?? "index.d.ts");
		let header = "";
		let dts = "";
		let exports$1 = [];
		if (!this.options.noDtsHeader) {
			const dtsHeader = this.options.dtsHeader ?? this.config.dtsHeader;
			if (this.config.dtsHeaderFile) try {
				header = await readFileAsync(join(this.options.cwd, this.config.dtsHeaderFile), "utf-8");
			} catch (e) {
				debug$7.warn(`Failed to read dts header file ${this.config.dtsHeaderFile}`, e);
			}
			else if (dtsHeader) header = dtsHeader;
			else header = DEFAULT_TYPE_DEF_HEADER;
		}
		const files$1 = await readdirAsync(typeDefDir, { withFileTypes: true });
		if (!files$1.length) {
			debug$7("No type def files found. Skip generating dts file.");
			return [];
		}
		for (const file of files$1) {
			if (!file.isFile()) continue;
			const { dts: fileDts, exports: fileExports } = await processTypeDef(join(typeDefDir, file.name), this.options.constEnum ?? this.config.constEnum ?? true);
			dts += fileDts;
			exports$1.push(...fileExports);
		}
		if (dts.indexOf("ExternalObject<") > -1) header += `
export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`;
		if (dts.indexOf("TypedArray") > -1) header += `
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array
`;
		dts = header + dts;
		try {
			debug$7("Writing type def to:");
			debug$7("  %i", dest);
			await writeFileAsync(dest, dts, "utf-8");
			this.outputs.push({
				kind: "dts",
				path: dest
			});
		} catch (e) {
			debug$7.error("Failed to write type def file");
			debug$7.error(e);
		}
		return exports$1;
	}
	async writeJsBinding(idents) {
		if (!this.options.platform || this.options.noJsBinding || idents.length === 0) return;
		const name$1 = this.options.jsBinding ?? "index.js";
		const createBinding = this.options.esm ? createEsmBinding : createCjsBinding;
		const binding = createBinding(this.config.binaryName, this.config.packageName, idents);
		try {
			const dest = join(this.outputDir, name$1);
			debug$7("Writing js binding to:");
			debug$7("  %i", dest);
			await writeFileAsync(dest, binding, "utf-8");
			return {
				kind: "js",
				path: dest
			};
		} catch (e) {
			throw new Error("Failed to write js binding file", { cause: e });
		}
	}
	async writeWasiBinding(distFileName, idents) {
		if (distFileName) {
			const { name: name$1, dir } = parse(distFileName);
			const bindingPath = join(dir, `${this.config.binaryName}.wasi.cjs`);
			const browserBindingPath = join(dir, `${this.config.binaryName}.wasi-browser.js`);
			const workerPath = join(dir, "wasi-worker.mjs");
			const browserWorkerPath = join(dir, "wasi-worker-browser.mjs");
			const browserEntryPath = join(dir, "browser.js");
			const exportsCode = `module.exports = __napiModule.exports\n` + idents.map((ident) => `module.exports.${ident} = __napiModule.exports.${ident}`).join("\n");
			await writeFileAsync(bindingPath, createWasiBinding(name$1, this.config.packageName, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory) + exportsCode + "\n", "utf8");
			await writeFileAsync(browserBindingPath, createWasiBrowserBinding(name$1, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory, this.config.wasm?.browser?.fs, this.config.wasm?.browser?.asyncInit, this.config.wasm?.browser?.buffer) + `export default __napiModule.exports\n` + idents.map((ident) => `export const ${ident} = __napiModule.exports.${ident}`).join("\n") + "\n", "utf8");
			await writeFileAsync(workerPath, WASI_WORKER_TEMPLATE, "utf8");
			await writeFileAsync(browserWorkerPath, createWasiBrowserWorkerBinding(this.config.wasm?.browser?.fs ?? false), "utf8");
			await writeFileAsync(browserEntryPath, `export * from '${this.config.packageName}-wasm32-wasi'\n`);
			return [
				{
					kind: "js",
					path: bindingPath
				},
				{
					kind: "js",
					path: browserBindingPath
				},
				{
					kind: "js",
					path: workerPath
				},
				{
					kind: "js",
					path: browserWorkerPath
				},
				{
					kind: "js",
					path: browserEntryPath
				}
			];
		}
		return [];
	}
	setEnvIfNotExists(env, value$1) {
		if (!process.env[env]) this.envs[env] = value$1;
	}
};

//#endregion
//#region src/def/build.ts
var BaseBuildCommand = class extends Command {
	static paths = [["build"]];
	static usage = Command.Usage({ description: "Build the NAPI-RS project" });
	target = Option.String("--target,-t", { description: "Build for the target triple, bypassed to `cargo build --target`" });
	cwd = Option.String("--cwd", { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	manifestPath = Option.String("--manifest-path", { description: "Path to `Cargo.toml`" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", { description: "Path to `package.json`" });
	targetDir = Option.String("--target-dir", { description: "Directory for all crate generated artifacts, see `cargo build --target-dir`" });
	outputDir = Option.String("--output-dir,-o", { description: "Path to where all the built files would be put. Default to the crate folder" });
	platform = Option.Boolean("--platform", { description: "Add platform triple to the generated nodejs binding file, eg: `[name].linux-x64-gnu.node`" });
	jsPackageName = Option.String("--js-package-name", { description: "Package name in generated js binding file. Only works with `--platform` flag" });
	constEnum = Option.Boolean("--const-enum", { description: "Whether generate const enum for typescript bindings" });
	jsBinding = Option.String("--js", { description: "Path and filename of generated JS binding file. Only works with `--platform` flag. Relative to `--output-dir`." });
	noJsBinding = Option.Boolean("--no-js", { description: "Whether to disable the generation JS binding file. Only works with `--platform` flag." });
	dts = Option.String("--dts", { description: "Path and filename of generated type def file. Relative to `--output-dir`" });
	dtsHeader = Option.String("--dts-header", { description: "Custom file header for generated type def file. Only works when `typedef` feature enabled." });
	noDtsHeader = Option.Boolean("--no-dts-header", { description: "Whether to disable the default file header for generated type def file. Only works when `typedef` feature enabled." });
	dtsCache = Option.Boolean("--dts-cache", true, { description: "Whether to enable the dts cache, default to true" });
	esm = Option.Boolean("--esm", { description: "Whether to emit an ESM JS binding file instead of CJS format. Only works with `--platform` flag." });
	strip = Option.Boolean("--strip,-s", { description: "Whether strip the library to achieve the minimum file size" });
	release = Option.Boolean("--release,-r", { description: "Build in release mode" });
	verbose = Option.Boolean("--verbose,-v", { description: "Verbosely log build command trace" });
	bin = Option.String("--bin", { description: "Build only the specified binary" });
	package = Option.String("--package,-p", { description: "Build the specified library or the one at cwd" });
	profile = Option.String("--profile", { description: "Build artifacts with the specified profile" });
	crossCompile = Option.Boolean("--cross-compile,-x", { description: "[experimental] cross-compile for the specified target with `cargo-xwin` on windows and `cargo-zigbuild` on other platform" });
	useCross = Option.Boolean("--use-cross", { description: "[experimental] use [cross](https://github.com/cross-rs/cross) instead of `cargo`" });
	useNapiCross = Option.Boolean("--use-napi-cross", { description: "[experimental] use @napi-rs/cross-toolchain to cross-compile Linux arm/arm64/x64 gnu targets." });
	watch = Option.Boolean("--watch,-w", { description: "watch the crate changes and build continuously with `cargo-watch` crates" });
	features = Option.Array("--features,-F", { description: "Space-separated list of features to activate" });
	allFeatures = Option.Boolean("--all-features", { description: "Activate all available features" });
	noDefaultFeatures = Option.Boolean("--no-default-features", { description: "Do not activate the `default` feature" });
	getOptions() {
		return {
			target: this.target,
			cwd: this.cwd,
			manifestPath: this.manifestPath,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			targetDir: this.targetDir,
			outputDir: this.outputDir,
			platform: this.platform,
			jsPackageName: this.jsPackageName,
			constEnum: this.constEnum,
			jsBinding: this.jsBinding,
			noJsBinding: this.noJsBinding,
			dts: this.dts,
			dtsHeader: this.dtsHeader,
			noDtsHeader: this.noDtsHeader,
			dtsCache: this.dtsCache,
			esm: this.esm,
			strip: this.strip,
			release: this.release,
			verbose: this.verbose,
			bin: this.bin,
			package: this.package,
			profile: this.profile,
			crossCompile: this.crossCompile,
			useCross: this.useCross,
			useNapiCross: this.useNapiCross,
			watch: this.watch,
			features: this.features,
			allFeatures: this.allFeatures,
			noDefaultFeatures: this.noDefaultFeatures
		};
	}
};

//#endregion
//#region src/commands/build.ts
const debug$6 = debugFactory("build");
var BuildCommand = class extends BaseBuildCommand {
	pipe = Option.String("--pipe", { description: "Pipe all outputs file to given command. e.g. `napi build --pipe \"npx prettier --write\"`" });
	cargoOptions = Option.Rest();
	async execute() {
		const { task } = await buildProject({
			...this.getOptions(),
			cargoOptions: this.cargoOptions
		});
		const outputs = await task;
		if (this.pipe) for (const output of outputs) {
			debug$6("Piping output file to command: %s", this.pipe);
			try {
				execSync(`${this.pipe} ${output.path}`, {
					stdio: "inherit",
					cwd: this.cwd
				});
			} catch (e) {
				debug$6.error(`Failed to pipe output file ${output.path} to command`);
				debug$6.error(e);
			}
		}
	}
};

//#endregion
//#region src/def/create-npm-dirs.ts
var BaseCreateNpmDirsCommand = class extends Command {
	static paths = [["create-npm-dirs"]];
	static usage = Command.Usage({ description: "Create npm package dirs for different platforms" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultCreateNpmDirsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/api/create-npm-dirs.ts
const debug$5 = debugFactory("create-npm-dirs");
async function createNpmDirs(userOptions) {
	const options = applyDefaultCreateNpmDirsOptions(userOptions);
	async function mkdirAsync$1(dir) {
		debug$5("Try to create dir: %i", dir);
		if (options.dryRun) return;
		await mkdirAsync(dir, { recursive: true });
	}
	async function writeFileAsync$1(file, content) {
		debug$5("Writing file %i", file);
		if (options.dryRun) {
			debug$5(content);
			return;
		}
		await writeFileAsync(file, content);
	}
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const npmPath = resolve(options.cwd, options.npmDir);
	debug$5(`Read content from [${options.configPath ?? packageJsonPath}]`);
	const { targets, binaryName, packageName, packageJson } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of targets) {
		const targetDir = join(npmPath, `${target.platformArchABI}`);
		await mkdirAsync$1(targetDir);
		const binaryFileName = target.arch === "wasm32" ? `${binaryName}.${target.platformArchABI}.wasm` : `${binaryName}.${target.platformArchABI}.node`;
		const scopedPackageJson = {
			name: `${packageName}-${target.platformArchABI}`,
			version: packageJson.version,
			cpu: target.arch !== "universal" ? [target.arch] : void 0,
			main: binaryFileName,
			files: [binaryFileName],
			...pick$1(packageJson, "description", "keywords", "author", "authors", "homepage", "license", "engines", "repository", "bugs")
		};
		if (packageJson.publishConfig) scopedPackageJson.publishConfig = pick$1(packageJson.publishConfig, "registry", "access");
		if (target.arch !== "wasm32") scopedPackageJson.os = [target.platform];
		else {
			const entry = `${binaryName}.wasi.cjs`;
			scopedPackageJson.main = entry;
			scopedPackageJson.browser = `${binaryName}.wasi-browser.js`;
			scopedPackageJson.files?.push(entry, scopedPackageJson.browser, `wasi-worker.mjs`, `wasi-worker-browser.mjs`);
			let needRestrictNodeVersion = true;
			if (scopedPackageJson.engines?.node) try {
				const { major } = parse$1(scopedPackageJson.engines.node) ?? { major: 0 };
				if (major >= 14) needRestrictNodeVersion = false;
			} catch {}
			if (needRestrictNodeVersion) scopedPackageJson.engines = { node: ">=14.0.0" };
			const wasmRuntime = await fetch(`https://registry.npmjs.org/@napi-rs/wasm-runtime`).then((res) => res.json());
			scopedPackageJson.dependencies = { "@napi-rs/wasm-runtime": `^${wasmRuntime["dist-tags"].latest}` };
		}
		if (target.abi === "gnu") scopedPackageJson.libc = ["glibc"];
		else if (target.abi === "musl") scopedPackageJson.libc = ["musl"];
		const targetPackageJson = join(targetDir, "package.json");
		await writeFileAsync$1(targetPackageJson, JSON.stringify(scopedPackageJson, null, 2) + "\n");
		const targetReadme = join(targetDir, "README.md");
		await writeFileAsync$1(targetReadme, readme(packageName, target));
		debug$5.info(`${packageName} -${target.platformArchABI} created`);
	}
}
function readme(packageName, target) {
	return `# \`${packageName}-${target.platformArchABI}\`

This is the **${target.triple}** binary for \`${packageName}\`
`;
}

//#endregion
//#region src/commands/create-npm-dirs.ts
var CreateNpmDirsCommand = class extends BaseCreateNpmDirsCommand {
	async execute() {
		await createNpmDirs(this.getOptions());
	}
};

//#endregion
//#region src/commands/help.ts
/**
* A command that prints the usage of all commands.
*
* Paths: `-h`, `--help`
*/
var HelpCommand = class extends Command {
	static paths = [[`-h`], [`--help`]];
	async execute() {
		await this.context.stdout.write(this.cli.usage());
	}
};

//#endregion
//#region src/def/new.ts
var BaseNewCommand = class extends Command {
	static paths = [["new"]];
	static usage = Command.Usage({ description: "Create a new project with pre-configured boilerplate" });
	$$path = Option.String({ required: false });
	$$name = Option.String("--name,-n", { description: "The name of the project, default to the name of the directory if not provided" });
	minNodeApiVersion = Option.String("--min-node-api,-v", "4", {
		validator: typanion.isNumber(),
		description: "The minimum Node-API version to support"
	});
	packageManager = Option.String("--package-manager", "yarn", { description: "The package manager to use. Only support yarn 4.x for now." });
	license = Option.String("--license,-l", "MIT", { description: "License for open-sourced project" });
	targets = Option.Array("--targets,-t", [], { description: "All targets the crate will be compiled for." });
	enableDefaultTargets = Option.Boolean("--enable-default-targets", true, { description: "Whether enable default targets" });
	enableAllTargets = Option.Boolean("--enable-all-targets", false, { description: "Whether enable all targets" });
	enableTypeDef = Option.Boolean("--enable-type-def", true, { description: "Whether enable the `type-def` feature for typescript definitions auto-generation" });
	enableGithubActions = Option.Boolean("--enable-github-actions", true, { description: "Whether generate preconfigured GitHub Actions workflow" });
	testFramework = Option.String("--test-framework", "ava", { description: "The JavaScript test framework to use, only support `ava` for now" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Whether to run the command in dry-run mode" });
	getOptions() {
		return {
			path: this.$$path,
			name: this.$$name,
			minNodeApiVersion: this.minNodeApiVersion,
			packageManager: this.packageManager,
			license: this.license,
			targets: this.targets,
			enableDefaultTargets: this.enableDefaultTargets,
			enableAllTargets: this.enableAllTargets,
			enableTypeDef: this.enableTypeDef,
			enableGithubActions: this.enableGithubActions,
			testFramework: this.testFramework,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultNewOptions(options) {
	return {
		minNodeApiVersion: 4,
		packageManager: "yarn",
		license: "MIT",
		targets: [],
		enableDefaultTargets: true,
		enableAllTargets: false,
		enableTypeDef: true,
		enableGithubActions: true,
		testFramework: "ava",
		dryRun: false,
		...options
	};
}

//#endregion
//#region ../node_modules/@std/toml/stringify.js
function joinKeys(keys) {
	return keys.map((str) => {
		return str.length === 0 || str.match(/[^A-Za-z0-9_-]/) ? JSON.stringify(str) : str;
	}).join(".");
}
var Dumper = class {
	maxPad = 0;
	srcObject;
	output = [];
	#arrayTypeCache = /* @__PURE__ */ new Map();
	constructor(srcObjc) {
		this.srcObject = srcObjc;
	}
	dump(fmtOptions = {}) {
		this.output = this.#printObject(this.srcObject);
		this.output = this.#format(fmtOptions);
		return this.output;
	}
	#printObject(obj, keys = []) {
		const out = [];
		const props = Object.keys(obj);
		const inlineProps = [];
		const multilineProps = [];
		for (const prop of props) if (this.#isSimplySerializable(obj[prop])) inlineProps.push(prop);
		else multilineProps.push(prop);
		const sortedProps = inlineProps.concat(multilineProps);
		for (const prop of sortedProps) {
			const value$1 = obj[prop];
			if (value$1 instanceof Date) out.push(this.#dateDeclaration([prop], value$1));
			else if (typeof value$1 === "string" || value$1 instanceof RegExp) out.push(this.#strDeclaration([prop], value$1.toString()));
			else if (typeof value$1 === "number") out.push(this.#numberDeclaration([prop], value$1));
			else if (typeof value$1 === "boolean") out.push(this.#boolDeclaration([prop], value$1));
			else if (value$1 instanceof Array) {
				const arrayType = this.#getTypeOfArray(value$1);
				if (arrayType === "ONLY_PRIMITIVE") out.push(this.#arrayDeclaration([prop], value$1));
				else if (arrayType === "ONLY_OBJECT_EXCLUDING_ARRAY") for (let i = 0; i < value$1.length; i++) {
					out.push("");
					out.push(this.#headerGroup([...keys, prop]));
					out.push(...this.#printObject(value$1[i], [...keys, prop]));
				}
				else {
					const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
					out.push(`${this.#declaration([prop])}[${str}]`);
				}
			} else if (typeof value$1 === "object") {
				out.push("");
				out.push(this.#header([...keys, prop]));
				if (value$1) {
					const toParse = value$1;
					out.push(...this.#printObject(toParse, [...keys, prop]));
				}
			}
		}
		out.push("");
		return out;
	}
	#isPrimitive(value$1) {
		return value$1 instanceof Date || value$1 instanceof RegExp || [
			"string",
			"number",
			"boolean"
		].includes(typeof value$1);
	}
	#getTypeOfArray(arr) {
		if (this.#arrayTypeCache.has(arr)) return this.#arrayTypeCache.get(arr);
		const type$1 = this.#doGetTypeOfArray(arr);
		this.#arrayTypeCache.set(arr, type$1);
		return type$1;
	}
	#doGetTypeOfArray(arr) {
		if (!arr.length) return "ONLY_PRIMITIVE";
		const onlyPrimitive = this.#isPrimitive(arr[0]);
		if (arr[0] instanceof Array) return "MIXED";
		for (let i = 1; i < arr.length; i++) if (onlyPrimitive !== this.#isPrimitive(arr[i]) || arr[i] instanceof Array) return "MIXED";
		return onlyPrimitive ? "ONLY_PRIMITIVE" : "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#printAsInlineValue(value$1) {
		if (value$1 instanceof Date) return `"${this.#printDate(value$1)}"`;
		else if (typeof value$1 === "string" || value$1 instanceof RegExp) return JSON.stringify(value$1.toString());
		else if (typeof value$1 === "number") return value$1;
		else if (typeof value$1 === "boolean") return value$1.toString();
		else if (value$1 instanceof Array) {
			const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
			return `[${str}]`;
		} else if (typeof value$1 === "object") {
			if (!value$1) throw new Error("Should never reach");
			const str = Object.keys(value$1).map((key) => {
				return `${joinKeys([key])} = ${this.#printAsInlineValue(value$1[key])}`;
			}).join(",");
			return `{${str}}`;
		}
		throw new Error("Should never reach");
	}
	#isSimplySerializable(value$1) {
		return typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || value$1 instanceof RegExp || value$1 instanceof Date || value$1 instanceof Array && this.#getTypeOfArray(value$1) !== "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#header(keys) {
		return `[${joinKeys(keys)}]`;
	}
	#headerGroup(keys) {
		return `[[${joinKeys(keys)}]]`;
	}
	#declaration(keys) {
		const title = joinKeys(keys);
		if (title.length > this.maxPad) this.maxPad = title.length;
		return `${title} = `;
	}
	#arrayDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#strDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#numberDeclaration(keys, value$1) {
		if (Number.isNaN(value$1)) return `${this.#declaration(keys)}nan`;
		switch (value$1) {
			case Infinity: return `${this.#declaration(keys)}inf`;
			case -Infinity: return `${this.#declaration(keys)}-inf`;
			default: return `${this.#declaration(keys)}${value$1}`;
		}
	}
	#boolDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${value$1}`;
	}
	#printDate(value$1) {
		function dtPad(v, lPad = 2) {
			return v.padStart(lPad, "0");
		}
		const m = dtPad((value$1.getUTCMonth() + 1).toString());
		const d = dtPad(value$1.getUTCDate().toString());
		const h = dtPad(value$1.getUTCHours().toString());
		const min = dtPad(value$1.getUTCMinutes().toString());
		const s = dtPad(value$1.getUTCSeconds().toString());
		const ms = dtPad(value$1.getUTCMilliseconds().toString(), 3);
		const fData = `${value$1.getUTCFullYear()}-${m}-${d}T${h}:${min}:${s}.${ms}`;
		return fData;
	}
	#dateDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${this.#printDate(value$1)}`;
	}
	#format(options = {}) {
		const { keyAlignment = false } = options;
		const rDeclaration = /^(\".*\"|[^=]*)\s=/;
		const out = [];
		for (let i = 0; i < this.output.length; i++) {
			const l = this.output[i];
			if (l[0] === "[" && l[1] !== "[") {
				if (this.output[i + 1] === "" && this.output[i + 2]?.slice(0, l.length) === l.slice(0, -1) + ".") {
					i += 1;
					continue;
				}
				out.push(l);
			} else if (keyAlignment) {
				const m = rDeclaration.exec(l);
				if (m && m[1]) out.push(l.replace(m[1], m[1].padEnd(this.maxPad)));
				else out.push(l);
			} else out.push(l);
		}
		const cleanedOutput = [];
		for (let i = 0; i < out.length; i++) {
			const l = out[i];
			if (!(l === "" && out[i + 1] === "")) cleanedOutput.push(l);
		}
		return cleanedOutput;
	}
};
/**
* Converts an object to a {@link https://toml.io | TOML} string.
*
* @example Usage
* ```ts
* import { stringify } from "@std/toml/stringify";
* import { assertEquals } from "@std/assert";
*
* const obj = {
*   title: "TOML Example",
*   owner: {
*     name: "Bob",
*     bio: "Bob is a cool guy",
*  }
* };
* const tomlString = stringify(obj);
* assertEquals(tomlString, `title = "TOML Example"\n\n[owner]\nname = "Bob"\nbio = "Bob is a cool guy"\n`);
* ```
* @param obj Source object
* @param options Options for stringifying.
* @returns TOML string
*/ function stringify(obj, options) {
	return new Dumper(obj).dump(options).join("\n");
}

//#endregion
//#region ../node_modules/@jsr/std__collections/_utils.js
/**
* Filters the given array, removing all elements that do not match the given predicate
* **in place. This means `array` will be modified!**.
*/ function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}

//#endregion
//#region ../node_modules/@jsr/std__collections/deep_merge.js
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, /* @__PURE__ */ new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys) {
		if (key === "__proto__") continue;
		const a = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a;
			continue;
		}
		const b = other[key];
		if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
			seen.add(a);
			seen.add(b);
			result[key] = mergeObjects(a, b, seen, options);
			continue;
		}
		result[key] = b;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
/**
* Test whether a value is mergeable or not
* Builtins that look like objects, null and user defined classes
* are not considered mergeable (it means that reference will be copied)
*/ function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}

//#endregion
//#region ../node_modules/@std/toml/_parser.js
/**
* Copy of `import { isLeap } from "@std/datetime";` because it cannot be impoted as long as it is unstable.
*/ function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
var Scanner = class {
	#whitespace = /[ \t]/;
	#position = 0;
	#source;
	constructor(source) {
		this.#source = source;
	}
	get position() {
		return this.#position;
	}
	get source() {
		return this.#source;
	}
	/**
	* Get current character
	* @param index - relative index from current position
	*/ char(index = 0) {
		return this.#source[this.#position + index] ?? "";
	}
	/**
	* Get sliced string
	* @param start - start position relative from current position
	* @param end - end position relative from current position
	*/ slice(start, end) {
		return this.#source.slice(this.#position + start, this.#position + end);
	}
	/**
	* Move position to next
	*/ next(count = 1) {
		this.#position += count;
	}
	skipWhitespaces() {
		while (this.#whitespace.test(this.char()) && !this.eof()) this.next();
		if (!this.isCurrentCharEOL() && /\s/.test(this.char())) {
			const escaped = "\\u" + this.char().charCodeAt(0).toString(16);
			const position = this.#position;
			throw new SyntaxError(`Cannot parse the TOML: It contains invalid whitespace at position '${position}': \`${escaped}\``);
		}
	}
	nextUntilChar(options = { skipComments: true }) {
		while (!this.eof()) {
			const char = this.char();
			if (this.#whitespace.test(char) || this.isCurrentCharEOL()) this.next();
			else if (options.skipComments && this.char() === "#") while (!this.isCurrentCharEOL() && !this.eof()) this.next();
			else break;
		}
	}
	/**
	* Position reached EOF or not
	*/ eof() {
		return this.#position >= this.#source.length;
	}
	isCurrentCharEOL() {
		return this.char() === "\n" || this.startsWith("\r\n");
	}
	startsWith(searchString) {
		return this.#source.startsWith(searchString, this.#position);
	}
	match(regExp) {
		if (!regExp.sticky) throw new Error(`RegExp ${regExp} does not have a sticky 'y' flag`);
		regExp.lastIndex = this.#position;
		return this.#source.match(regExp);
	}
};
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
/**
* Creates a nested object from the keys and values.
*
* e.g. `unflat(["a", "b", "c"], 1)` returns `{ a: { b: { c: 1 } } }`
*/ function unflat(keys, values = {}) {
	return keys.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function isObject(value$1) {
	return typeof value$1 === "object" && value$1 !== null;
}
function getTargetValue(target, keys) {
	const key = keys[0];
	if (!key) throw new Error("Cannot parse the TOML: key length is not a positive number");
	return target[key];
}
function deepAssignTable(target, table$1) {
	const { keys, type: type$1, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, value$1));
	if (Array.isArray(currentValue)) {
		const last = currentValue.at(-1);
		deepAssign(last, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssignTableArray(target, table$1) {
	const { type: type$1, keys, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, [value$1]));
	if (Array.isArray(currentValue)) {
		currentValue.push(value$1);
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssign(target, body) {
	switch (body.type) {
		case "Block": return deepMerge(target, body.value);
		case "Table": return deepAssignTable(target, body);
		case "TableArray": return deepAssignTableArray(target, body);
	}
}
function or(parsers) {
	return (scanner) => {
		for (const parse$3 of parsers) {
			const result = parse$3(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
/** Join the parse results of the given parser into an array.
*
* If the parser fails at the first attempt, it will return an empty array.
*/ function join$1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
/** Join the parse results of the given parser into an array.
*
* This requires the parser to succeed at least once.
*/ function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		const sep = Separator(scanner);
		if (!sep.ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function merge$1(parser) {
	return (scanner) => {
		const result = parser(scanner);
		if (!result.ok) return failure();
		let body = {};
		for (const record of result.body) if (typeof record === "object" && record !== null) body = deepMerge(body, record);
		return success(body);
	};
}
function repeat(parser) {
	return (scanner) => {
		const body = [];
		while (!scanner.eof()) {
			const result = parser(scanner);
			if (!result.ok) break;
			body.push(result.body);
			scanner.nextUntilChar();
		}
		if (body.length === 0) return failure();
		return success(body);
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str)) return failure();
		scanner.next(str.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	scanner.skipWhitespaces();
	const key = scanner.match(BARE_KEY_REGEXP)?.[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = string === "true";
	return success(value$1);
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = INFINITY_MAP.get(string);
	return success(value$1);
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = NaN;
	return success(value$1);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BINARY_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 2);
	return isNaN(number) ? failure() : success(number);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(OCTAL_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 8);
	return isNaN(number) ? failure() : success(number);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(HEX_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 16);
	return isNaN(number) ? failure() : success(number);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INTEGER_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const int = parseInt(value$1, 10);
	return success(int);
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(FLOAT_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$1 = parseFloat(value$1);
	if (isNaN(float$1)) return failure();
	return success(float$1);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(LOCAL_TIME_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({});
	}
	const pairs = surround("{", join$1(pair, ","), "}")(scanner);
	if (!pairs.ok) return failure();
	let table$1 = {};
	for (const pair$1 of pairs.body) table$1 = deepMerge(table$1, pair$1);
	return success(table$1);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary,
	octal,
	hex,
	float,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
function block(scanner) {
	scanner.nextUntilChar();
	const result = merge$1(repeat(pair))(scanner);
	if (result.ok) return success({
		type: "Block",
		value: result.body
	});
	return failure();
}
const tableHeader = surround("[", dottedKey, "]");
function table(scanner) {
	scanner.nextUntilChar();
	const header = tableHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "Table",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
const tableArrayHeader = surround("[[", dottedKey, "]]");
function tableArray(scanner) {
	scanner.nextUntilChar();
	const header = tableArrayHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "TableArray",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
function toml(scanner) {
	const blocks = repeat(or([
		block,
		tableArray,
		table
	]))(scanner);
	if (!blocks.ok) return success({});
	const body = blocks.body.reduce(deepAssign, {});
	return success(body);
}
function createParseErrorMessage(scanner, message) {
	const string = scanner.source.slice(0, scanner.position);
	const lines = string.split("\n");
	const row = lines.length;
	const column = lines.at(-1)?.length ?? 0;
	return `Parse error on line ${row}, column ${column}: ${message}`;
}
function parserFactory(parser) {
	return (tomlString) => {
		const scanner = new Scanner(tomlString);
		try {
			const result = parser(scanner);
			if (result.ok && scanner.eof()) return result.body;
			const message = `Unexpected character: "${scanner.char()}"`;
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		} catch (error) {
			if (error instanceof Error) throw new SyntaxError(createParseErrorMessage(scanner, error.message));
			const message = "Invalid error type caught";
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		}
	};
}

//#endregion
//#region ../node_modules/@std/toml/parse.js
/**
* Parses a {@link https://toml.io | TOML} string into an object.
*
* @example Usage
* ```ts
* import { parse } from "@std/toml/parse";
* import { assertEquals } from "@std/assert";
*
* const tomlString = `title = "TOML Example"
* [owner]
* name = "Alice"
* bio = "Alice is a programmer."`;
*
* const obj = parse(tomlString);
* assertEquals(obj, { title: "TOML Example", owner: { name: "Alice", bio: "Alice is a programmer." } });
* ```
* @param tomlString TOML string to be parsed.
* @returns The parsed JS object.
*/ function parse$2(tomlString) {
	return parserFactory(toml)(tomlString);
}

//#endregion
//#region src/def/rename.ts
var BaseRenameCommand = class extends Command {
	static paths = [["rename"]];
	static usage = Command.Usage({ description: "Rename the NAPI-RS project" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	$$name = Option.String("--name,-n", { description: "The new name of the project" });
	binaryName = Option.String("--binary-name,-b", { description: "The new binary name *.node files" });
	packageName = Option.String("--package-name", { description: "The new package name of the project" });
	manifestPath = Option.String("--manifest-path", "Cargo.toml", { description: "Path to `Cargo.toml`" });
	repository = Option.String("--repository", { description: "The new repository of the project" });
	description = Option.String("--description", { description: "The new description of the project" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			name: this.$$name,
			binaryName: this.binaryName,
			packageName: this.packageName,
			manifestPath: this.manifestPath,
			repository: this.repository,
			description: this.description
		};
	}
};
function applyDefaultRenameOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		manifestPath: "Cargo.toml",
		...options
	};
}

//#endregion
//#region src/api/rename.ts
async function renameProject(userOptions) {
	const options = applyDefaultRenameOptions(userOptions);
	const napiConfig = await readConfig(options);
	const oldName = napiConfig.binaryName;
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const cargoTomlPath = resolve(options.cwd, options.manifestPath);
	const packageJsonContent = await readFileAsync(packageJsonPath, "utf8");
	const packageJsonData = JSON.parse(packageJsonContent);
	merge(packageJsonData, omitBy(pick(options, [
		"name",
		"description",
		"author",
		"license"
	]), isNil), { napi: omitBy({
		binaryName: options.binaryName,
		packageName: options.packageName
	}, isNil) });
	if (options.configPath) {
		const configPath = resolve(options.cwd, options.configPath);
		const configContent = await readFileAsync(configPath, "utf8");
		const configData = JSON.parse(configContent);
		configData.binaryName = options.binaryName;
		configData.packageName = options.packageName;
		await writeFileAsync(configPath, JSON.stringify(configData, null, 2));
	}
	await writeFileAsync(packageJsonPath, JSON.stringify(packageJsonData, null, 2));
	const tomlContent = await readFileAsync(cargoTomlPath, "utf8");
	const cargoToml = parse$2(tomlContent);
	if (cargoToml.package && options.binaryName) {
		const sanitizedName = options.binaryName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
		cargoToml.package.name = sanitizedName;
	}
	const updatedTomlContent = stringify(cargoToml);
	await writeFileAsync(cargoTomlPath, updatedTomlContent);
	if (oldName !== options.binaryName) {
		const githubActionsPath = await findUp(".github", {
			cwd: options.cwd,
			type: "directory"
		});
		if (githubActionsPath) {
			const githubActionsCIYmlPath = join(githubActionsPath, "workflows", "CI.yml");
			if (existsSync(githubActionsCIYmlPath)) {
				const githubActionsContent = await readFileAsync(githubActionsCIYmlPath, "utf8");
				const githubActionsData = load(githubActionsContent);
				if (githubActionsData.env?.APP_NAME) {
					githubActionsData.env.APP_NAME = options.binaryName;
					await writeFileAsync(githubActionsCIYmlPath, dump(githubActionsData, {
						lineWidth: -1,
						noRefs: true,
						sortKeys: false
					}));
				}
			}
		}
		const oldWasiBrowserBindingPath = join(options.cwd, `${oldName}.wasi-browser.js`);
		if (existsSync(oldWasiBrowserBindingPath)) await rename(oldWasiBrowserBindingPath, join(options.cwd, `${options.binaryName}.wasi-browser.js`));
		const oldWasiBindingPath = join(options.cwd, `${oldName}.wasi.cjs`);
		if (existsSync(oldWasiBindingPath)) await rename(oldWasiBindingPath, join(options.cwd, `${options.binaryName}.wasi.cjs`));
		const gitAttributesPath = join(options.cwd, ".gitattributes");
		if (existsSync(gitAttributesPath)) {
			const gitAttributesContent = await readFileAsync(gitAttributesPath, "utf8");
			const gitAttributesData = gitAttributesContent.split("\n").map((line) => {
				return line.replace(`${oldName}.wasi-browser.js`, `${options.binaryName}.wasi-browser.js`).replace(`${oldName}.wasi.cjs`, `${options.binaryName}.wasi.cjs`);
			}).join("\n");
			await writeFileAsync(gitAttributesPath, gitAttributesData);
		}
	}
}

//#endregion
//#region src/api/new.ts
const debug$4 = debugFactory("new");
const TEMPLATE_REPOS = {
	yarn: "https://github.com/napi-rs/package-template",
	pnpm: "https://github.com/napi-rs/package-template-pnpm"
};
async function checkGitCommand() {
	try {
		await new Promise((resolve$1) => {
			const cp = exec("git --version");
			cp.on("error", () => {
				resolve$1(false);
			});
			cp.on("exit", (code) => {
				if (code === 0) resolve$1(true);
				else resolve$1(false);
			});
		});
		return true;
	} catch {
		return false;
	}
}
async function ensureCacheDir(packageManager) {
	const cacheDir = path.join(homedir(), ".napi-rs", "template", packageManager);
	await mkdirAsync(cacheDir, { recursive: true });
	return cacheDir;
}
async function downloadTemplate(packageManager, cacheDir) {
	const repoUrl = TEMPLATE_REPOS[packageManager];
	const templatePath = path.join(cacheDir, "repo");
	if (existsSync(templatePath)) {
		debug$4(`Template cache found at ${templatePath}, updating...`);
		try {
			await new Promise((resolve$1, reject) => {
				const cp = exec("git fetch origin", { cwd: templatePath });
				cp.on("error", reject);
				cp.on("exit", (code) => {
					if (code === 0) resolve$1();
					else reject(/* @__PURE__ */ new Error(`Failed to fetch latest changes, git process exited with code ${code}`));
				});
			});
			execSync("git reset --hard origin/main", {
				cwd: templatePath,
				stdio: "ignore"
			});
			debug$4("Template updated successfully");
		} catch (error) {
			debug$4(`Failed to update template: ${error}`);
			throw new Error(`Failed to update template from ${repoUrl}: ${error}`);
		}
	} else {
		debug$4(`Cloning template from ${repoUrl}...`);
		try {
			execSync(`git clone ${repoUrl} repo`, {
				cwd: cacheDir,
				stdio: "inherit"
			});
			debug$4("Template cloned successfully");
		} catch (error) {
			throw new Error(`Failed to clone template from ${repoUrl}: ${error}`);
		}
	}
}
async function copyDirectory(src, dest, includeWasiBindings) {
	await mkdirAsync(dest, { recursive: true });
	const entries = await promises.readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);
		if (entry.name === ".git") continue;
		if (entry.isDirectory()) await copyDirectory(srcPath, destPath, includeWasiBindings);
		else {
			if (!includeWasiBindings && (entry.name.endsWith(".wasi-browser.js") || entry.name.endsWith(".wasi.cjs") || entry.name.endsWith("wasi-worker.browser.mjs ") || entry.name.endsWith("wasi-worker.mjs") || entry.name.endsWith("browser.js"))) continue;
			await promises.copyFile(srcPath, destPath);
		}
	}
}
async function filterTargetsInPackageJson(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const packageJson = JSON.parse(content);
	if (packageJson.napi?.targets) packageJson.napi.targets = packageJson.napi.targets.filter((target) => enabledTargets.includes(target));
	await promises.writeFile(filePath, JSON.stringify(packageJson, null, 2) + "\n");
}
async function filterTargetsInGithubActions(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const yaml = load(content);
	const macOSAndWindowsTargets = new Set([
		"x86_64-pc-windows-msvc",
		"aarch64-pc-windows-msvc",
		"x86_64-apple-darwin"
	]);
	const linuxTargets = new Set([
		"x86_64-unknown-linux-gnu",
		"x86_64-unknown-linux-musl",
		"aarch64-unknown-linux-gnu",
		"aarch64-unknown-linux-musl",
		"armv7-unknown-linux-gnueabihf",
		"armv7-unknown-linux-musleabihf",
		"riscv64gc-unknown-linux-gnu",
		"powerpc64le-unknown-linux-gnu",
		"s390x-unknown-linux-gnu",
		"aarch64-linux-android",
		"armv7-linux-androideabi"
	]);
	const hasLinuxTargets = enabledTargets.some((target) => linuxTargets.has(target));
	if (yaml?.jobs?.build?.strategy?.matrix?.settings) yaml.jobs.build.strategy.matrix.settings = yaml.jobs.build.strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	const jobsToRemove = [];
	if (enabledTargets.every((target) => !macOSAndWindowsTargets.has(target))) jobsToRemove.push("test-macOS-windows-binding");
	else if (yaml?.jobs?.["test-macOS-windows-binding"]?.strategy?.matrix?.settings) yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings = yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	if (!hasLinuxTargets) {
		if (yaml?.jobs?.["test-linux-binding"]) jobsToRemove.push("test-linux-binding");
	} else if (yaml?.jobs?.["test-linux-binding"]?.strategy?.matrix?.target) yaml.jobs["test-linux-binding"].strategy.matrix.target = yaml.jobs["test-linux-binding"].strategy.matrix.target.filter((target) => {
		if (target) return enabledTargets.includes(target);
		return true;
	});
	if (!enabledTargets.includes("wasm32-wasip1-threads")) jobsToRemove.push("test-wasi");
	if (!enabledTargets.includes("x86_64-unknown-freebsd")) jobsToRemove.push("build-freebsd");
	for (const [jobName, jobConfig] of Object.entries(yaml.jobs || {})) if (jobName.startsWith("test-") && jobName !== "test-macOS-windows-binding" && jobName !== "test-linux-x64-gnu-binding") {
		const job = jobConfig;
		if (job.strategy?.matrix?.settings?.[0]?.target) {
			const target = job.strategy.matrix.settings[0].target;
			if (!enabledTargets.includes(target)) jobsToRemove.push(jobName);
		}
	}
	for (const jobName of jobsToRemove) delete yaml.jobs[jobName];
	if (Array.isArray(yaml.jobs?.publish?.needs)) yaml.jobs.publish.needs = yaml.jobs.publish.needs.filter((need) => !jobsToRemove.includes(need));
	const updatedYaml = dump(yaml, {
		lineWidth: -1,
		noRefs: true,
		sortKeys: false
	});
	await promises.writeFile(filePath, updatedYaml);
}
function processOptions(options) {
	debug$4("Processing options...");
	if (!options.path) throw new Error("Please provide the path as the argument");
	options.path = path.resolve(process.cwd(), options.path);
	debug$4(`Resolved target path to: ${options.path}`);
	if (!options.name) {
		options.name = path.parse(options.path).base;
		debug$4(`No project name provided, fix it to dir name: ${options.name}`);
	}
	if (!options.targets?.length) if (options.enableAllTargets) {
		options.targets = AVAILABLE_TARGETS.concat();
		debug$4("Enable all targets");
	} else if (options.enableDefaultTargets) {
		options.targets = DEFAULT_TARGETS.concat();
		debug$4("Enable default targets");
	} else throw new Error("At least one target must be enabled");
	if (options.targets.some((target) => target === "wasm32-wasi-preview1-threads")) {
		const out = execSync(`rustup target list`, { encoding: "utf8" });
		if (out.includes("wasm32-wasip1-threads")) options.targets = options.targets.map((target) => target === "wasm32-wasi-preview1-threads" ? "wasm32-wasip1-threads" : target);
	}
	return applyDefaultNewOptions(options);
}
async function newProject(userOptions) {
	debug$4("Will create napi-rs project with given options:");
	debug$4(userOptions);
	const options = processOptions(userOptions);
	debug$4("Targets to be enabled:");
	debug$4(options.targets);
	if (!await checkGitCommand()) throw new Error("Git is not installed or not available in PATH. Please install Git to continue.");
	const packageManager = options.packageManager;
	await ensurePath(options.path, options.dryRun);
	if (!options.dryRun) try {
		const cacheDir = await ensureCacheDir(packageManager);
		await downloadTemplate(packageManager, cacheDir);
		const templatePath = path.join(cacheDir, "repo");
		await copyDirectory(templatePath, options.path, options.targets.includes("wasm32-wasip1-threads"));
		await renameProject({
			cwd: options.path,
			name: options.name,
			binaryName: getBinaryName(options.name)
		});
		const packageJsonPath = path.join(options.path, "package.json");
		if (existsSync(packageJsonPath)) await filterTargetsInPackageJson(packageJsonPath, options.targets);
		const ciPath = path.join(options.path, ".github", "workflows", "CI.yml");
		if (existsSync(ciPath) && options.enableGithubActions) await filterTargetsInGithubActions(ciPath, options.targets);
		else if (!options.enableGithubActions && existsSync(path.join(options.path, ".github"))) await promises.rm(path.join(options.path, ".github"), {
			recursive: true,
			force: true
		});
		const pkgJsonContent = await promises.readFile(packageJsonPath, "utf-8");
		const pkgJson = JSON.parse(pkgJsonContent);
		if (!pkgJson.engines) pkgJson.engines = {};
		pkgJson.engines.node = napiEngineRequirement(options.minNodeApiVersion);
		if (options.license && pkgJson.license !== options.license) pkgJson.license = options.license;
		if (options.testFramework !== "ava") debug$4(`Test framework ${options.testFramework} requested but not yet implemented`);
		await promises.writeFile(packageJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
	} catch (error) {
		throw new Error(`Failed to create project: ${error}`);
	}
	debug$4(`Project created at: ${options.path}`);
}
async function ensurePath(path$1, dryRun = false) {
	const stat$1 = await statAsync(path$1, {}).catch(() => void 0);
	if (stat$1) {
		if (stat$1.isFile()) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not a directory.`);
		else if (stat$1.isDirectory()) {
			const files$1 = await readdirAsync(path$1);
			if (files$1.length) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not empty.`);
		}
	}
	if (!dryRun) try {
		debug$4(`Try to create target directory: ${path$1}`);
		if (!dryRun) await mkdirAsync(path$1, { recursive: true });
	} catch (e) {
		throw new Error(`Failed to create target directory: ${path$1}`, { cause: e });
	}
}
function getBinaryName(name$1) {
	return name$1.split("/").pop();
}

//#endregion
//#region src/commands/new.ts
const debug$3 = debugFactory("new");
var NewCommand = class extends BaseNewCommand {
	interactive = Option.Boolean("--interactive,-i", true, { description: "Ask project basic information interactively without just using the default." });
	async execute() {
		try {
			const options = await this.fetchOptions();
			await newProject(options);
			return 0;
		} catch (e) {
			debug$3("Failed to create new project");
			debug$3.error(e);
			return 1;
		}
	}
	async fetchOptions() {
		const cmdOptions = super.getOptions();
		if (this.interactive) {
			const targetPath = cmdOptions.path ? cmdOptions.path : await inquirerProjectPath();
			cmdOptions.path = targetPath;
			return {
				...cmdOptions,
				name: await this.fetchName(path.parse(targetPath).base),
				minNodeApiVersion: await this.fetchNapiVersion(),
				targets: await this.fetchTargets(),
				license: await this.fetchLicense(),
				enableTypeDef: await this.fetchTypeDef(),
				enableGithubActions: await this.fetchGithubActions()
			};
		}
		return cmdOptions;
	}
	async fetchName(defaultName) {
		return this.$$name ?? input({
			message: "Package name (the name field in your package.json file)",
			default: defaultName
		});
	}
	async fetchLicense() {
		return input({
			message: "License for open-sourced project",
			default: this.license
		});
	}
	async fetchNapiVersion() {
		return select({
			message: "Minimum node-api version (with node version requirement)",
			loop: false,
			choices: Array.from({ length: 8 }, (_, i) => ({
				name: `napi${i + 1} (${napiEngineRequirement(i + 1)})`,
				value: i + 1
			})),
			default: this.minNodeApiVersion - 1
		});
	}
	async fetchTargets() {
		if (this.enableAllTargets) return AVAILABLE_TARGETS.concat();
		const targets = await checkbox({
			loop: false,
			message: "Choose target(s) your crate will be compiled to",
			choices: AVAILABLE_TARGETS.map((target) => ({
				name: target,
				value: target,
				checked: DEFAULT_TARGETS.includes(target)
			}))
		});
		return targets;
	}
	async fetchTypeDef() {
		const enableTypeDef = await confirm({
			message: "Enable type definition auto-generation",
			default: this.enableTypeDef
		});
		return enableTypeDef;
	}
	async fetchGithubActions() {
		const enableGithubActions = await confirm({
			message: "Enable Github Actions CI",
			default: this.enableGithubActions
		});
		return enableGithubActions;
	}
};
async function inquirerProjectPath() {
	return input({ message: "Target path to create the project, relative to cwd." }).then((path$1) => {
		if (!path$1) return inquirerProjectPath();
		return path$1;
	});
}

//#endregion
//#region src/def/pre-publish.ts
var BasePrePublishCommand = class extends Command {
	static paths = [["pre-publish"], ["prepublish"]];
	static usage = Command.Usage({ description: "Update package.json and copy addons into per platform packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir,-p", "npm", { description: "Path to the folder where the npm packages put" });
	tagStyle = Option.String("--tag-style,--tagstyle,-t", "lerna", { description: "git tag style, `npm` or `lerna`" });
	ghRelease = Option.Boolean("--gh-release", true, { description: "Whether create GitHub release" });
	ghReleaseName = Option.String("--gh-release-name", { description: "GitHub release name" });
	ghReleaseId = Option.String("--gh-release-id", { description: "Existing GitHub release id" });
	skipOptionalPublish = Option.Boolean("--skip-optional-publish", false, { description: "Whether skip optionalDependencies packages publish" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			tagStyle: this.tagStyle,
			ghRelease: this.ghRelease,
			ghReleaseName: this.ghReleaseName,
			ghReleaseId: this.ghReleaseId,
			skipOptionalPublish: this.skipOptionalPublish,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultPrePublishOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		tagStyle: "lerna",
		ghRelease: true,
		skipOptionalPublish: false,
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/def/version.ts
var BaseVersionCommand = class extends Command {
	static paths = [["version"]];
	static usage = Command.Usage({ description: "Update version in created npm packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir
		};
	}
};
function applyDefaultVersionOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/api/version.ts
const debug$2 = debugFactory("version");
async function version(userOptions) {
	const options = applyDefaultVersionOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of config.targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, target.platformArchABI);
		debug$2(`Update version to %i in [%i]`, config.packageJson.version, pkgDir);
		await updatePackageJson(join(pkgDir, "package.json"), { version: config.packageJson.version });
	}
}

//#endregion
//#region src/api/pre-publish.ts
const debug$1 = debugFactory("pre-publish");
async function prePublish(userOptions) {
	debug$1("Receive pre-publish options:");
	debug$1("  %O", userOptions);
	const options = applyDefaultPrePublishOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const { packageJson, targets, packageName, binaryName, npmClient } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	async function createGhRelease(packageName$1, version$2) {
		if (!options.ghRelease) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		const { repo: repo$1, owner: owner$1, pkgInfo: pkgInfo$1, octokit: octokit$1 } = getRepoInfo(packageName$1, version$2);
		if (!repo$1 || !owner$1) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		if (!options.dryRun) try {
			await octokit$1.repos.createRelease({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag,
				name: options.ghReleaseName,
				prerelease: version$2.includes("alpha") || version$2.includes("beta") || version$2.includes("rc")
			});
		} catch (e) {
			debug$1(`Params: ${JSON.stringify({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag
			}, null, 2)}`);
			console.error(e);
		}
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	function getRepoInfo(packageName$1, version$2) {
		const headCommit = execSync("git log -1 --pretty=%B", { encoding: "utf-8" }).trim();
		const { GITHUB_REPOSITORY } = process.env;
		if (!GITHUB_REPOSITORY) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		debug$1(`Github repository: ${GITHUB_REPOSITORY}`);
		const [owner$1, repo$1] = GITHUB_REPOSITORY.split("/");
		const octokit$1 = new Octokit({ auth: process.env.GITHUB_TOKEN });
		let pkgInfo$1;
		if (options.tagStyle === "lerna") {
			const packagesToPublish = headCommit.split("\n").map((line) => line.trim()).filter((line, index) => line.length && index).map((line) => line.substring(2)).map(parseTag);
			pkgInfo$1 = packagesToPublish.find((pkgInfo$2) => pkgInfo$2.name === packageName$1);
			if (!pkgInfo$1) throw new TypeError(`No release commit found with ${packageName$1}, original commit info: ${headCommit}`);
		} else pkgInfo$1 = {
			tag: `v${version$2}`,
			version: version$2,
			name: packageName$1
		};
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	if (!options.dryRun) {
		await version(userOptions);
		await updatePackageJson(packageJsonPath, { optionalDependencies: targets.reduce((deps, target) => {
			deps[`${packageName}-${target.platformArchABI}`] = packageJson.version;
			return deps;
		}, {}) });
	}
	const { owner, repo, pkgInfo, octokit } = options.ghReleaseId ? getRepoInfo(packageName, packageJson.version) : await createGhRelease(packageName, packageJson.version);
	for (const target of targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, `${target.platformArchABI}`);
		const ext = target.platform === "wasi" || target.platform === "wasm" ? "wasm" : "node";
		const filename = `${binaryName}.${target.platformArchABI}.${ext}`;
		const dstPath = join(pkgDir, filename);
		if (!options.dryRun) {
			if (!existsSync(dstPath)) {
				debug$1.warn(`%s doesn't exist`, dstPath);
				continue;
			}
			if (!options.skipOptionalPublish) execSync(`${npmClient} publish`, {
				cwd: pkgDir,
				env: process.env
			});
			if (options.ghRelease && repo && owner) {
				debug$1.info(`Creating GitHub release ${pkgInfo.tag}`);
				try {
					const releaseId = options.ghReleaseId ? Number(options.ghReleaseId) : (await octokit.repos.getReleaseByTag({
						repo,
						owner,
						tag: pkgInfo.tag
					})).data.id;
					const dstFileStats = statSync(dstPath);
					const assetInfo = await octokit.repos.uploadReleaseAsset({
						owner,
						repo,
						name: filename,
						release_id: releaseId,
						mediaType: { format: "raw" },
						headers: {
							"content-length": dstFileStats.size,
							"content-type": "application/octet-stream"
						},
						data: await readFileAsync(dstPath)
					});
					debug$1.info(`GitHub release created`);
					debug$1.info(`Download URL: %s`, assetInfo.data.browser_download_url);
				} catch (e) {
					debug$1.error(`Param: ${JSON.stringify({
						owner,
						repo,
						tag: pkgInfo.tag,
						filename: dstPath
					}, null, 2)}`);
					debug$1.error(e);
				}
			}
		}
	}
}
function parseTag(tag) {
	const segments = tag.split("@");
	const version$2 = segments.pop();
	const name$1 = segments.join("@");
	return {
		name: name$1,
		version: version$2,
		tag
	};
}

//#endregion
//#region src/commands/pre-publish.ts
var PrePublishCommand = class extends BasePrePublishCommand {
	async execute() {
		await prePublish(this.getOptions());
	}
};

//#endregion
//#region src/commands/rename.ts
var RenameCommand = class extends BaseRenameCommand {
	async execute() {
		const options = this.getOptions();
		if (!options.name) {
			const name$1 = await input({
				message: `Enter the new package name in the package.json`,
				required: true
			});
			options.name = name$1;
		}
		if (!options.binaryName) {
			const binaryName = await input({
				message: `Enter the new binary name`,
				required: true
			});
			options.binaryName = binaryName;
		}
		await renameProject(options);
	}
};

//#endregion
//#region src/def/universalize.ts
var BaseUniversalizeCommand = class extends Command {
	static paths = [["universalize"]];
	static usage = Command.Usage({ description: "Combile built binaries into one universal binary" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o", "./", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir
		};
	}
};
function applyDefaultUniversalizeOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./",
		...options
	};
}

//#endregion
//#region src/api/universalize.ts
const debug = debugFactory("universalize");
const universalizers = { darwin: (inputs, output) => {
	spawnSync("lipo", [
		"-create",
		"-output",
		output,
		...inputs
	], { stdio: "inherit" });
} };
async function universalizeBinaries(userOptions) {
	const options = applyDefaultUniversalizeOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	const target = config.targets.find((t) => t.platform === process.platform && t.arch === "universal");
	if (!target) throw new Error(`'universal' arch for platform '${process.platform}' not found in config!`);
	const srcFiles = UniArchsByPlatform[process.platform]?.map((arch) => resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-${arch}.node`));
	if (!srcFiles || !universalizers[process.platform]) throw new Error(`'universal' arch for platform '${process.platform}' not supported.`);
	debug(`Looking up source binaries to combine: `);
	debug("  %O", srcFiles);
	const srcFileLookup = await Promise.all(srcFiles.map((f) => fileExists(f)));
	const notFoundFiles = srcFiles.filter((_, i) => !srcFileLookup[i]);
	if (notFoundFiles.length) throw new Error(`Some binary files were not found: ${JSON.stringify(notFoundFiles)}`);
	const output = resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-universal.node`);
	universalizers[process.platform]?.(srcFiles, output);
	debug(`Produced universal binary: ${output}`);
}

//#endregion
//#region src/commands/universalize.ts
var UniversalizeCommand = class extends BaseUniversalizeCommand {
	async execute() {
		await universalizeBinaries(this.getOptions());
	}
};

//#endregion
//#region src/commands/version.ts
var VersionCommand = class extends BaseVersionCommand {
	async execute() {
		await version(this.getOptions());
	}
};

//#endregion
//#region src/cli.ts
const cli = new Cli({
	binaryName: "napi",
	binaryVersion: CLI_VERSION
});
cli.register(NewCommand);
cli.register(BuildCommand);
cli.register(CreateNpmDirsCommand);
cli.register(ArtifactsCommand);
cli.register(UniversalizeCommand);
cli.register(RenameCommand);
cli.register(PrePublishCommand);
cli.register(VersionCommand);
cli.register(HelpCommand);
cli.runExit(process.argv.slice(2));

//#endregion
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwibmFtZXMiOlsib3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucyIsIm5hbWVzcGFjZTogc3RyaW5nIiwiZGVidWciLCJwYXRoOiBzdHJpbmciLCJwYXRoIiwicGljayIsIm86IE8iLCJwYXJ0aWFsOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IiwiZGVidWciLCJwa2dKc29uIiwiVEFSR0VUX0xJTktFUjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiIsIkNwdVRvTm9kZUFyY2g6IFJlY29yZDxzdHJpbmcsIE5vZGVKU0FyY2g+IiwiU3lzVG9Ob2RlUGxhdGZvcm06IFJlY29yZDxzdHJpbmcsIFBsYXRmb3JtPiIsIlVuaUFyY2hzQnlQbGF0Zm9ybTogUGFydGlhbDxSZWNvcmQ8UGxhdGZvcm0sIE5vZGVKU0FyY2hbXT4+IiwicmF3VHJpcGxlOiBzdHJpbmciLCJjcHU6IHN0cmluZyIsInN5czogc3RyaW5nIiwiYWJpOiBzdHJpbmcgfCBudWxsIiwidGFyZ2V0OiBzdHJpbmciLCJ2OiBzdHJpbmciLCJuYXBpVmVyc2lvbjogTmFwaVZlcnNpb24iLCJ2ZXJzaW9uczogTm9kZVZlcnNpb25bXSIsInJlcXVpcmVtZW50czogc3RyaW5nW10iLCJtYW5pZmVzdFBhdGg6IHN0cmluZyIsInJlc29sdmUiLCJwYXRoOiBzdHJpbmciLCJjb25maWdQYXRoPzogc3RyaW5nIiwicGF0aCIsInNlcGFyYXRlZENvbmZpZzogVXNlck5hcGlDb25maWcgfCB1bmRlZmluZWQiLCJuYXBpQ29uZmlnOiBOYXBpQ29uZmlnIiwidGFyZ2V0czogc3RyaW5nW10iLCJuYW1lOiBzdHJpbmciLCJiaW46IHN0cmluZyIsImJpbiIsImRlYnVnIiwibmFtZSIsImxpbmU6IFR5cGVEZWZMaW5lIiwiY29uc3RFbnVtOiBib29sZWFuIiwiaWRlbnQ6IG51bWJlciIsImFtYmllbnQ6IGJvb2xlYW4iLCJpbnRlcm1lZGlhdGVUeXBlRmlsZTogc3RyaW5nIiwiZXhwb3J0czogc3RyaW5nW10iLCJkZWZzIiwiZXhwb3J0cyIsImZpbGU6IHN0cmluZyIsImRlZnM6IFR5cGVEZWZMaW5lW10iLCJzcmM6IHN0cmluZyIsIm9wdGlvbnM6IE1pbmltYWxOYXBpT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMiLCJkaXIiLCJyb290OiBzdHJpbmciLCJmaWxlcyIsImxvY2FsTmFtZTogc3RyaW5nIiwicGtnTmFtZTogc3RyaW5nIiwiaWRlbnRzOiBzdHJpbmdbXSIsInR1cGxlOiBzdHJpbmciLCJ3YXNpRmlsZW5hbWU6IHN0cmluZyIsImZzIiwid2FzbUZpbGVOYW1lOiBzdHJpbmciLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwiZnM6IGJvb2xlYW4iLCJmcyIsImRlYnVnIiwicmF3T3B0aW9uczogQnVpbGRPcHRpb25zIiwib3B0aW9uczogUGFyc2VkQnVpbGRPcHRpb25zIiwibWV0YWRhdGE6IENhcmdvV29ya3NwYWNlTWV0YWRhdGEiLCJjcmF0ZTogQ3JhdGUiLCJjb25maWc6IE5hcGlDb25maWciLCJhbGlhczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiIsInZlcnNpb24iLCJyZXNvbHZlIiwiYWJpOiBzdHJpbmcgfCBudWxsIiwidHlwZURlZlRtcEZvbGRlcjogc3RyaW5nIiwiZXhwb3J0czogc3RyaW5nW10iLCJmaWxlcyIsImV4cG9ydHMiLCJpZGVudHM6IHN0cmluZ1tdIiwibmFtZSIsImRpc3RGaWxlTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCIsImVudjogc3RyaW5nIiwidmFsdWU6IHN0cmluZyIsInZhbHVlIiwiZGVidWciLCJvcHRpb25zOiBDcmVhdGVOcG1EaXJzT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zIiwibWtkaXJBc3luYyIsImRpcjogc3RyaW5nIiwicmF3TWtkaXJBc3luYyIsIndyaXRlRmlsZUFzeW5jIiwiZmlsZTogc3RyaW5nIiwiY29udGVudDogc3RyaW5nIiwicmF3V3JpdGVGaWxlQXN5bmMiLCJzY29wZWRQYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHMiLCJwaWNrIiwicGFyc2UiLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwidGFyZ2V0OiBUYXJnZXQiLCJvcHRpb25zOiBOZXdPcHRpb25zIiwiI3ByaW50T2JqZWN0IiwiI2Zvcm1hdCIsIiNpc1NpbXBseVNlcmlhbGl6YWJsZSIsInZhbHVlIiwiI2RhdGVEZWNsYXJhdGlvbiIsIiNzdHJEZWNsYXJhdGlvbiIsIiNudW1iZXJEZWNsYXJhdGlvbiIsIiNib29sRGVjbGFyYXRpb24iLCIjZ2V0VHlwZU9mQXJyYXkiLCIjYXJyYXlEZWNsYXJhdGlvbiIsIiNoZWFkZXJHcm91cCIsIiNwcmludEFzSW5saW5lVmFsdWUiLCIjZGVjbGFyYXRpb24iLCIjaGVhZGVyIiwiI2FycmF5VHlwZUNhY2hlIiwidHlwZSIsIiNkb0dldFR5cGVPZkFycmF5IiwiI2lzUHJpbWl0aXZlIiwiI3ByaW50RGF0ZSIsInZhbHVlIiwiI3NvdXJjZSIsIiNwb3NpdGlvbiIsIiN3aGl0ZXNwYWNlIiwidmFsdWUiLCJ0YWJsZSIsInBhcnNlIiwiam9pbiIsIm1lcmdlIiwiZmxvYXQiLCJwYWlyIiwicGFyc2UiLCJvcHRpb25zOiBSZW5hbWVPcHRpb25zIiwidXNlck9wdGlvbnM6IFJlbmFtZU9wdGlvbnMiLCJwYXJzZVRvbWwiLCJzdHJpbmdpZnlUb21sIiwieWFtbFBhcnNlIiwieWFtbFN0cmluZ2lmeSIsImRlYnVnIiwicmVzb2x2ZSIsInBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlciIsImNhY2hlRGlyOiBzdHJpbmciLCJzcmM6IHN0cmluZyIsImRlc3Q6IHN0cmluZyIsImluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4iLCJmcyIsImZpbGVQYXRoOiBzdHJpbmciLCJlbmFibGVkVGFyZ2V0czogc3RyaW5nW10iLCJ0YXJnZXQ6IHN0cmluZyIsInlhbWxMb2FkIiwic2V0dGluZzogYW55Iiwiam9ic1RvUmVtb3ZlOiBzdHJpbmdbXSIsIm5lZWQ6IHN0cmluZyIsInlhbWxEdW1wIiwib3B0aW9uczogUmF3TmV3T3B0aW9ucyIsInVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zIiwicGF0aDogc3RyaW5nIiwic3RhdCIsInBhdGgiLCJmaWxlcyIsIm5hbWU6IHN0cmluZyIsIm5hbWUiLCJkZWJ1ZyIsInRhcmdldFBhdGg6IHN0cmluZyIsImRlZmF1bHROYW1lOiBzdHJpbmciLCJwYXRoIiwib3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMiLCJvcHRpb25zOiBWZXJzaW9uT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IFZlcnNpb25PcHRpb25zIiwiZGVidWciLCJ1c2VyT3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMiLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwidmVyc2lvbjogc3RyaW5nIiwicGFja2FnZU5hbWUiLCJ2ZXJzaW9uIiwicmVwbyIsIm93bmVyIiwib2N0b2tpdCIsInBrZ0luZm8iLCJwa2dJbmZvOiBQYWNrYWdlSW5mbyB8IHVuZGVmaW5lZCIsInRhZzogc3RyaW5nIiwibmFtZSIsIm5hbWUiLCJvcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zIiwidW5pdmVyc2FsaXplcnM6IFBhcnRpYWw8XG4gIFJlY29yZDxOb2RlSlMuUGxhdGZvcm0sIChpbnB1dHM6IHN0cmluZ1tdLCBvdXRwdXQ6IHN0cmluZykgPT4gdm9pZD5cbj4iLCJ1c2VyT3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucyJdLCJzb3VyY2VzIjpbIi4uL3NyYy9kZWYvYXJ0aWZhY3RzLnRzIiwiLi4vc3JjL3V0aWxzL2xvZy50cyIsIi4uL3BhY2thZ2UuanNvbiIsIi4uL3NyYy91dGlscy9taXNjLnRzIiwiLi4vc3JjL3V0aWxzL3RhcmdldC50cyIsIi4uL3NyYy91dGlscy92ZXJzaW9uLnRzIiwiLi4vc3JjL3V0aWxzL21ldGFkYXRhLnRzIiwiLi4vc3JjL3V0aWxzL2NvbmZpZy50cyIsIi4uL3NyYy91dGlscy9jYXJnby50cyIsIi4uL3NyYy91dGlscy90eXBlZ2VuLnRzIiwiLi4vc3JjL3V0aWxzL3JlYWQtY29uZmlnLnRzIiwiLi4vc3JjL2FwaS9hcnRpZmFjdHMudHMiLCIuLi9zcmMvY29tbWFuZHMvYXJ0aWZhY3RzLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvanMtYmluZGluZy50cyIsIi4uL3NyYy9hcGkvdGVtcGxhdGVzL2xvYWQtd2FzaS10ZW1wbGF0ZS50cyIsIi4uL3NyYy9hcGkvdGVtcGxhdGVzL3dhc2ktd29ya2VyLXRlbXBsYXRlLnRzIiwiLi4vc3JjL2FwaS9idWlsZC50cyIsIi4uL3NyYy9kZWYvYnVpbGQudHMiLCIuLi9zcmMvY29tbWFuZHMvYnVpbGQudHMiLCIuLi9zcmMvZGVmL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9hcGkvY3JlYXRlLW5wbS1kaXJzLnRzIiwiLi4vc3JjL2NvbW1hbmRzL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9jb21tYW5kcy9oZWxwLnRzIiwiLi4vc3JjL2RlZi9uZXcudHMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQHN0ZC90b21sL3N0cmluZ2lmeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AanNyL3N0ZF9fY29sbGVjdGlvbnMvX3V0aWxzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bqc3Ivc3RkX19jb2xsZWN0aW9ucy9kZWVwX21lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9fcGFyc2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9wYXJzZS5qcyIsIi4uL3NyYy9kZWYvcmVuYW1lLnRzIiwiLi4vc3JjL2FwaS9yZW5hbWUudHMiLCIuLi9zcmMvYXBpL25ldy50cyIsIi4uL3NyYy9jb21tYW5kcy9uZXcudHMiLCIuLi9zcmMvZGVmL3ByZS1wdWJsaXNoLnRzIiwiLi4vc3JjL2RlZi92ZXJzaW9uLnRzIiwiLi4vc3JjL2FwaS92ZXJzaW9uLnRzIiwiLi4vc3JjL2FwaS9wcmUtcHVibGlzaC50cyIsIi4uL3NyYy9jb21tYW5kcy9wcmUtcHVibGlzaC50cyIsIi4uL3NyYy9jb21tYW5kcy9yZW5hbWUudHMiLCIuLi9zcmMvZGVmL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9hcGkvdW5pdmVyc2FsaXplLnRzIiwiLi4vc3JjL2NvbW1hbmRzL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9jb21tYW5kcy92ZXJzaW9uLnRzIiwiLi4vc3JjL2NsaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUFydGlmYWN0c0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1snYXJ0aWZhY3RzJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIG5wbSBwYWNrYWdlcyBhbmQgcmVhZHkgdG8gcHVibGlzaCcsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgb3V0cHV0RGlyID0gT3B0aW9uLlN0cmluZygnLS1vdXRwdXQtZGlyLC1vLC1kJywgJy4vYXJ0aWZhY3RzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgYnVpbGRPdXRwdXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWJ1aWxkLW91dHB1dC1kaXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgYnVpbGQgb3V0cHV0IGRpciwgb25seSBuZWVkZWQgd2hlbiB0YXJnZXRzIGNvbnRhaW5zIGB3YXNtMzItd2FzaS0qYCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBvdXRwdXREaXI6IHRoaXMub3V0cHV0RGlyLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIGJ1aWxkT3V0cHV0RGlyOiB0aGlzLmJ1aWxkT3V0cHV0RGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYXJ0aWZhY3RzIGZyb20gR2l0aHViIEFjdGlvbnMgaW50byBucG0gcGFja2FnZXMgYW5kIHJlYWR5IHRvIHB1Ymxpc2hcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdHNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kXG4gICAqXG4gICAqIEBkZWZhdWx0ICcuL2FydGlmYWN0cydcbiAgICovXG4gIG91dHB1dERpcj86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGJ1aWxkIG91dHB1dCBkaXIsIG9ubHkgbmVlZGVkIHdoZW4gdGFyZ2V0cyBjb250YWlucyBgd2FzbTMyLXdhc2ktKmBcbiAgICovXG4gIGJ1aWxkT3V0cHV0RGlyPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zKG9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBvdXRwdXREaXI6ICcuL2FydGlmYWN0cycsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuaW1wb3J0IHJhd0RlYnVnIGZyb20gJ2RlYnVnJ1xuXG4vLyBkZWJ1ZygnJWknLCAnVGhpcyBpcyBhbiBpbmZvJylcbnJhd0RlYnVnLmZvcm1hdHRlcnMuaSA9ICh2KSA9PiB7XG4gIHJldHVybiBjb2xvcnMuZ3JlZW4odilcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ2RlYnVnJyB7XG4gIGludGVyZmFjZSBEZWJ1Z2dlciB7XG4gICAgaW5mbzogdHlwZW9mIGNvbnNvbGUuZXJyb3JcbiAgICB3YXJuOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICAgIGVycm9yOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWJ1Z0ZhY3RvcnkgPSAobmFtZXNwYWNlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgZGVidWcgPSByYXdEZWJ1ZyhgbmFwaToke25hbWVzcGFjZX1gKVxuXG4gIGRlYnVnLmluZm8gPSAoLi4uYXJnczogYW55W10pID0+XG4gICAgY29uc29sZS5lcnJvcihjb2xvcnMuYmxhY2soY29sb3JzLmJnR3JlZW4oJyBJTkZPICcpKSwgLi4uYXJncylcbiAgZGVidWcud2FybiA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKGNvbG9ycy5ibGFjayhjb2xvcnMuYmdZZWxsb3coJyBXQVJOSU5HICcpKSwgLi4uYXJncylcbiAgZGVidWcuZXJyb3IgPSAoLi4uYXJnczogYW55W10pID0+XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGNvbG9ycy53aGl0ZShjb2xvcnMuYmdSZWQoJyBFUlJPUiAnKSksXG4gICAgICAuLi5hcmdzLm1hcCgoYXJnKSA9PlxuICAgICAgICBhcmcgaW5zdGFuY2VvZiBFcnJvciA/IChhcmcuc3RhY2sgPz8gYXJnLm1lc3NhZ2UpIDogYXJnLFxuICAgICAgKSxcbiAgICApXG5cbiAgcmV0dXJuIGRlYnVnXG59XG5leHBvcnQgY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3V0aWxzJylcbiIsIntcbiAgXCJuYW1lXCI6IFwiQG5hcGktcnMvY2xpXCIsXG4gIFwidmVyc2lvblwiOiBcIjMuMC40XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDbGkgdG9vbHMgZm9yIG5hcGktcnNcIixcbiAgXCJhdXRob3JcIjogXCJMb25nWWluYW4gPGx5bndla2xtQGdtYWlsLmNvbT5cIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL25hcGktcnNcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwidHlwZVwiOiBcIm1vZHVsZVwiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49IDE2XCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwibmFwaVwiOiBcIi4vZGlzdC9jbGkuanNcIixcbiAgICBcIm5hcGktcmF3XCI6IFwiLi9jbGkubWpzXCJcbiAgfSxcbiAgXCJtYWluXCI6IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICBcIm1vZHVsZVwiOiBcIi4vZGlzdC9pbmRleC5qc1wiLFxuICBcImV4cG9ydHNcIjoge1xuICAgIFwiLlwiOiB7XG4gICAgICBcImltcG9ydFwiOiB7XG4gICAgICAgIFwidHlwZXNcIjogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCIuL2Rpc3QvaW5kZXguanNcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZVwiOiB7XG4gICAgICAgIFwidHlwZXNcIjogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCIuL2Rpc3QvaW5kZXguY2pzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiLi9wYWNrYWdlLmpzb25cIjoge1xuICAgICAgXCJpbXBvcnRcIjogXCIuL3BhY2thZ2UuanNvblwiLFxuICAgICAgXCJyZXF1aXJlXCI6IFwiLi9wYWNrYWdlLmpzb25cIlxuICAgIH1cbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJkaXN0XCIsXG4gICAgXCJzcmNcIlxuICBdLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImNsaVwiLFxuICAgIFwicnVzdFwiLFxuICAgIFwibmFwaVwiLFxuICAgIFwibi1hcGlcIixcbiAgICBcIm5vZGUtYXBpXCIsXG4gICAgXCJub2RlLWFkZG9uXCIsXG4gICAgXCJuZW9uXCJcbiAgXSxcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiTG9uZ1lpbmFuXCIsXG4gICAgICBcImVtYWlsXCI6IFwibHlud2VrbG1AZ21haWwuY29tXCIsXG4gICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0Jyb29vb29va2x5blwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJmb3JlaGFsb1wiLFxuICAgICAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9mb3JlaGFsb1wiXG4gICAgfVxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL25hcGktcnMuZ2l0XCJcbiAgfSxcbiAgXCJwdWJsaXNoQ29uZmlnXCI6IHtcbiAgICBcInJlZ2lzdHJ5XCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXCIsXG4gICAgXCJhY2Nlc3NcIjogXCJwdWJsaWNcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1ycy9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAaW5xdWlyZXIvcHJvbXB0c1wiOiBcIl43LjQuMFwiLFxuICAgIFwiQG5hcGktcnMvY3Jvc3MtdG9vbGNoYWluXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJAbmFwaS1ycy93YXNtLXRvb2xzXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJAb2N0b2tpdC9yZXN0XCI6IFwiXjIyLjAuMFwiLFxuICAgIFwiY2xpcGFuaW9uXCI6IFwiXjQuMC4wLXJjLjRcIixcbiAgICBcImNvbG9yZXR0ZVwiOiBcIl4yLjAuMjBcIixcbiAgICBcImRlYnVnXCI6IFwiXjQuNC4wXCIsXG4gICAgXCJlbW5hcGlcIjogXCJeMS40LjBcIixcbiAgICBcImZpbmQtdXBcIjogXCJeNy4wLjBcIixcbiAgICBcImpzLXlhbWxcIjogXCJeNC4xLjBcIixcbiAgICBcImxvZGFzaC1lc1wiOiBcIl40LjE3LjIxXCIsXG4gICAgXCJzZW12ZXJcIjogXCJeNy43LjFcIixcbiAgICBcInR5cGFuaW9uXCI6IFwiXjMuMTQuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBlbW5hcGkvY29yZVwiOiBcIl4xLjQuMFwiLFxuICAgIFwiQGVtbmFwaS9ydW50aW1lXCI6IFwiXjEuNC4wXCIsXG4gICAgXCJAb3hjLW5vZGUvY29yZVwiOiBcIl4wLjAuMzBcIixcbiAgICBcIkBzdGQvdG9tbFwiOiBcIm5wbTpAanNyL3N0ZF9fdG9tbEBeMS4wLjhcIixcbiAgICBcIkB0eXBlcy9kZWJ1Z1wiOiBcIl40LjEuMTJcIixcbiAgICBcIkB0eXBlcy9pbnF1aXJlclwiOiBcIl45LjAuN1wiLFxuICAgIFwiQHR5cGVzL2pzLXlhbWxcIjogXCJeNC4wLjlcIixcbiAgICBcIkB0eXBlcy9sb2Rhc2gtZXNcIjogXCJeNC4xNy4xMlwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMjIuMTMuMTZcIixcbiAgICBcIkB0eXBlcy9zZW12ZXJcIjogXCJeNy43LjBcIixcbiAgICBcImF2YVwiOiBcIl42LjIuMFwiLFxuICAgIFwiZW52LXBhdGhzXCI6IFwiXjMuMC4wXCIsXG4gICAgXCJwcmV0dGllclwiOiBcIl4zLjUuM1wiLFxuICAgIFwicm9sbGRvd25cIjogXCJsYXRlc3RcIixcbiAgICBcInRzbGliXCI6IFwiXjIuOC4xXCIsXG4gICAgXCJ0eXBlc2NyaXB0XCI6IFwiXjUuOC4yXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBlbW5hcGkvcnVudGltZVwiOiBcIl4xLjEuMFwiLFxuICAgIFwiZW1uYXBpXCI6IFwiXjEuMS4wXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzTWV0YVwiOiB7XG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcImVtbmFwaVwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9XG4gIH0sXG4gIFwiZnVuZGluZ1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0aHViXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc3BvbnNvcnMvQnJvb29vb29rbHluXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImNsZWFuXCI6IFwibm9kZSAtLWltcG9ydCBAb3hjLW5vZGUvY29yZS9yZWdpc3RlciAuL2NsZWFuLnRzXCIsXG4gICAgXCJjb2RlZ2VuXCI6IFwibm9kZSAtLWltcG9ydCBAb3hjLW5vZGUvY29yZS9yZWdpc3RlciAuL2NvZGVnZW4vaW5kZXgudHNcIixcbiAgICBcImJ1aWxkXCI6IFwidHNjICYmIHlhcm4gY2xlYW4gJiYgcm9sbGRvd24gLWMgcm9sbGRvd24uY29uZmlnLmpzXCIsXG4gICAgXCJ0ZXN0XCI6IFwibm9kZSAtLWltcG9ydCBAb3hjLW5vZGUvY29yZS9yZWdpc3RlciAuLi9ub2RlX21vZHVsZXMvYXZhL2VudHJ5cG9pbnRzL2NsaS5tanNcIlxuICB9LFxuICBcImF2YVwiOiB7XG4gICAgXCJleHRlbnNpb25zXCI6IHtcbiAgICAgIFwidHNcIjogXCJtb2R1bGVcIlxuICAgIH0sXG4gICAgXCJ0aW1lb3V0XCI6IFwiMW1cIixcbiAgICBcImZpbGVzXCI6IFtcbiAgICAgIFwiKiovX190ZXN0c19fLyoqLyouc3BlYy50c1wiLFxuICAgICAgXCJlMmUvKiovKi5zcGVjLnRzXCJcbiAgICBdXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjUyMWI1Nzc0YWE4OWYxYTdjODA3YTZkZGJhNTA5Y2U0Mzk3M2Y2MjRcIlxufVxuIiwiaW1wb3J0IHtcbiAgcmVhZEZpbGUsXG4gIHdyaXRlRmlsZSxcbiAgY29weUZpbGUsXG4gIG1rZGlyLFxuICB1bmxpbmssXG4gIHN0YXQsXG4gIHJlYWRkaXIsXG59IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICdub2RlOnV0aWwnXG5cbmltcG9ydCBwa2dKc29uIGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbicgd2l0aCB7IHR5cGU6ICdqc29uJyB9XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vbG9nLmpzJ1xuXG5leHBvcnQgY29uc3QgcmVhZEZpbGVBc3luYyA9IHByb21pc2lmeShyZWFkRmlsZSlcbmV4cG9ydCBjb25zdCB3cml0ZUZpbGVBc3luYyA9IHByb21pc2lmeSh3cml0ZUZpbGUpXG5leHBvcnQgY29uc3QgdW5saW5rQXN5bmMgPSBwcm9taXNpZnkodW5saW5rKVxuZXhwb3J0IGNvbnN0IGNvcHlGaWxlQXN5bmMgPSBwcm9taXNpZnkoY29weUZpbGUpXG5leHBvcnQgY29uc3QgbWtkaXJBc3luYyA9IHByb21pc2lmeShta2RpcilcbmV4cG9ydCBjb25zdCBzdGF0QXN5bmMgPSBwcm9taXNpZnkoc3RhdClcbmV4cG9ydCBjb25zdCByZWFkZGlyQXN5bmMgPSBwcm9taXNpZnkocmVhZGRpcilcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbGVFeGlzdHMocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IGV4aXN0cyA9IGF3YWl0IHN0YXRBc3luYyhwYXRoKVxuICAgIC50aGVuKCgpID0+IHRydWUpXG4gICAgLmNhdGNoKCgpID0+IGZhbHNlKVxuICByZXR1cm4gZXhpc3RzXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXJFeGlzdHNBc3luYyhwYXRoOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHN0YXRBc3luYyhwYXRoKVxuICAgIHJldHVybiBzdGF0cy5pc0RpcmVjdG9yeSgpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrPE8sIEsgZXh0ZW5kcyBrZXlvZiBPPihvOiBPLCAuLi5rZXlzOiBLW10pOiBQaWNrPE8sIEs+IHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gb1trZXldXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSBhcyBPKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUGFja2FnZUpzb24oXG4gIHBhdGg6IHN0cmluZyxcbiAgcGFydGlhbDogUmVjb3JkPHN0cmluZywgYW55Pixcbikge1xuICBjb25zdCBleGlzdHMgPSBhd2FpdCBmaWxlRXhpc3RzKHBhdGgpXG4gIGlmICghZXhpc3RzKSB7XG4gICAgZGVidWcoYEZpbGUgbm90IGV4aXN0cyAke3BhdGh9YClcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvbGQgPSBKU09OLnBhcnNlKGF3YWl0IHJlYWRGaWxlQXN5bmMocGF0aCwgJ3V0ZjgnKSlcbiAgYXdhaXQgd3JpdGVGaWxlQXN5bmMocGF0aCwgSlNPTi5zdHJpbmdpZnkoeyAuLi5vbGQsIC4uLnBhcnRpYWwgfSwgbnVsbCwgMikpXG59XG5cbmV4cG9ydCBjb25zdCBDTElfVkVSU0lPTiA9IHBrZ0pzb24udmVyc2lvblxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5cbmV4cG9ydCB0eXBlIFBsYXRmb3JtID0gTm9kZUpTLlBsYXRmb3JtIHwgJ3dhc20nIHwgJ3dhc2knIHwgJ29wZW5oYXJtb255J1xuXG5leHBvcnQgY29uc3QgVU5JVkVSU0FMX1RBUkdFVFMgPSB7XG4gICd1bml2ZXJzYWwtYXBwbGUtZGFyd2luJzogWydhYXJjaDY0LWFwcGxlLWRhcndpbicsICd4ODZfNjQtYXBwbGUtZGFyd2luJ10sXG59IGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBBVkFJTEFCTEVfVEFSR0VUUyA9IFtcbiAgJ2FhcmNoNjQtYXBwbGUtZGFyd2luJyxcbiAgJ2FhcmNoNjQtbGludXgtYW5kcm9pZCcsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtZ251JyxcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1vaG9zJyxcbiAgJ2FhcmNoNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nLFxuICAneDg2XzY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1vaG9zJyxcbiAgJ3g4Nl82NC11bmtub3duLWZyZWVic2QnLFxuICAnaTY4Ni1wYy13aW5kb3dzLW1zdmMnLFxuICAnYXJtdjctdW5rbm93bi1saW51eC1nbnVlYWJpaGYnLFxuICAnYXJtdjctdW5rbm93bi1saW51eC1tdXNsZWFiaWhmJyxcbiAgJ2FybXY3LWxpbnV4LWFuZHJvaWRlYWJpJyxcbiAgJ3VuaXZlcnNhbC1hcHBsZS1kYXJ3aW4nLFxuICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JyxcbiAgJ3Bvd2VycGM2NGxlLXVua25vd24tbGludXgtZ251JyxcbiAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JyxcbiAgJ3dhc20zMi13YXNpLXByZXZpZXcxLXRocmVhZHMnLFxuICAnd2FzbTMyLXdhc2lwMS10aHJlYWRzJyxcbl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgVGFyZ2V0VHJpcGxlID0gKHR5cGVvZiBBVkFJTEFCTEVfVEFSR0VUUylbbnVtYmVyXVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UQVJHRVRTID0gW1xuICAneDg2XzY0LWFwcGxlLWRhcndpbicsXG4gICdhYXJjaDY0LWFwcGxlLWRhcndpbicsXG4gICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LWdudScsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBUQVJHRVRfTElOS0VSOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2wnOiAnYWFyY2g2NC1saW51eC1tdXNsLWdjYycsXG4gICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnOiAncmlzY3Y2NC1saW51eC1nbnUtZ2NjJyxcbiAgJ3Bvd2VycGM2NGxlLXVua25vd24tbGludXgtZ251JzogJ3Bvd2VycGM2NGxlLWxpbnV4LWdudS1nY2MnLFxuICAnczM5MHgtdW5rbm93bi1saW51eC1nbnUnOiAnczM5MHgtbGludXgtZ251LWdjYycsXG59XG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19hcmNoXG50eXBlIE5vZGVKU0FyY2ggPVxuICB8ICdhcm0nXG4gIHwgJ2FybTY0J1xuICB8ICdpYTMyJ1xuICB8ICdtaXBzJ1xuICB8ICdtaXBzZWwnXG4gIHwgJ3BwYydcbiAgfCAncHBjNjQnXG4gIHwgJ3Jpc2N2NjQnXG4gIHwgJ3MzOTAnXG4gIHwgJ3MzOTB4J1xuICB8ICd4MzInXG4gIHwgJ3g2NCdcbiAgfCAndW5pdmVyc2FsJ1xuICB8ICd3YXNtMzInXG5cbmNvbnN0IENwdVRvTm9kZUFyY2g6IFJlY29yZDxzdHJpbmcsIE5vZGVKU0FyY2g+ID0ge1xuICB4ODZfNjQ6ICd4NjQnLFxuICBhYXJjaDY0OiAnYXJtNjQnLFxuICBpNjg2OiAnaWEzMicsXG4gIGFybXY3OiAnYXJtJyxcbiAgcmlzY3Y2NGdjOiAncmlzY3Y2NCcsXG4gIHBvd2VycGM2NGxlOiAncHBjNjQnLFxufVxuXG5leHBvcnQgY29uc3QgTm9kZUFyY2hUb0NwdTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgeDY0OiAneDg2XzY0JyxcbiAgYXJtNjQ6ICdhYXJjaDY0JyxcbiAgaWEzMjogJ2k2ODYnLFxuICBhcm06ICdhcm12NycsXG4gIHJpc2N2NjQ6ICdyaXNjdjY0Z2MnLFxuICBwcGM2NDogJ3Bvd2VycGM2NGxlJyxcbn1cblxuY29uc3QgU3lzVG9Ob2RlUGxhdGZvcm06IFJlY29yZDxzdHJpbmcsIFBsYXRmb3JtPiA9IHtcbiAgbGludXg6ICdsaW51eCcsXG4gIGZyZWVic2Q6ICdmcmVlYnNkJyxcbiAgZGFyd2luOiAnZGFyd2luJyxcbiAgd2luZG93czogJ3dpbjMyJyxcbiAgb2hvczogJ29wZW5oYXJtb255Jyxcbn1cblxuZXhwb3J0IGNvbnN0IFVuaUFyY2hzQnlQbGF0Zm9ybTogUGFydGlhbDxSZWNvcmQ8UGxhdGZvcm0sIE5vZGVKU0FyY2hbXT4+ID0ge1xuICBkYXJ3aW46IFsneDY0JywgJ2FybTY0J10sXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFyZ2V0IHtcbiAgdHJpcGxlOiBzdHJpbmdcbiAgcGxhdGZvcm1BcmNoQUJJOiBzdHJpbmdcbiAgcGxhdGZvcm06IFBsYXRmb3JtXG4gIGFyY2g6IE5vZGVKU0FyY2hcbiAgYWJpOiBzdHJpbmcgfCBudWxsXG59XG5cbi8qKlxuICogQSB0cmlwbGUgaXMgYSBzcGVjaWZpYyBmb3JtYXQgZm9yIHNwZWNpZnlpbmcgYSB0YXJnZXQgYXJjaGl0ZWN0dXJlLlxuICogVHJpcGxlcyBtYXkgYmUgcmVmZXJyZWQgdG8gYXMgYSB0YXJnZXQgdHJpcGxlIHdoaWNoIGlzIHRoZSBhcmNoaXRlY3R1cmUgZm9yIHRoZSBhcnRpZmFjdCBwcm9kdWNlZCwgYW5kIHRoZSBob3N0IHRyaXBsZSB3aGljaCBpcyB0aGUgYXJjaGl0ZWN0dXJlIHRoYXQgdGhlIGNvbXBpbGVyIGlzIHJ1bm5pbmcgb24uXG4gKiBUaGUgZ2VuZXJhbCBmb3JtYXQgb2YgdGhlIHRyaXBsZSBpcyBgPGFyY2g+PHN1Yj4tPHZlbmRvcj4tPHN5cz4tPGFiaT5gIHdoZXJlOlxuICogICAtIGBhcmNoYCA9IFRoZSBiYXNlIENQVSBhcmNoaXRlY3R1cmUsIGZvciBleGFtcGxlIGB4ODZfNjRgLCBgaTY4NmAsIGBhcm1gLCBgdGh1bWJgLCBgbWlwc2AsIGV0Yy5cbiAqICAgLSBgc3ViYCA9IFRoZSBDUFUgc3ViLWFyY2hpdGVjdHVyZSwgZm9yIGV4YW1wbGUgYGFybWAgaGFzIGB2N2AsIGB2N3NgLCBgdjV0ZWAsIGV0Yy5cbiAqICAgLSBgdmVuZG9yYCA9IFRoZSB2ZW5kb3IsIGZvciBleGFtcGxlIGB1bmtub3duYCwgYGFwcGxlYCwgYHBjYCwgYG52aWRpYWAsIGV0Yy5cbiAqICAgLSBgc3lzYCA9IFRoZSBzeXN0ZW0gbmFtZSwgZm9yIGV4YW1wbGUgYGxpbnV4YCwgYHdpbmRvd3NgLCBgZGFyd2luYCwgZXRjLiBub25lIGlzIHR5cGljYWxseSB1c2VkIGZvciBiYXJlLW1ldGFsIHdpdGhvdXQgYW4gT1MuXG4gKiAgIC0gYGFiaWAgPSBUaGUgQUJJLCBmb3IgZXhhbXBsZSBgZ251YCwgYGFuZHJvaWRgLCBgZWFiaWAsIGV0Yy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVHJpcGxlKHJhd1RyaXBsZTogc3RyaW5nKTogVGFyZ2V0IHtcbiAgaWYgKFxuICAgIHJhd1RyaXBsZSA9PT0gJ3dhc20zMi13YXNpJyB8fFxuICAgIHJhd1RyaXBsZSA9PT0gJ3dhc20zMi13YXNpLXByZXZpZXcxLXRocmVhZHMnIHx8XG4gICAgcmF3VHJpcGxlLnN0YXJ0c1dpdGgoJ3dhc20zMi13YXNpcCcpXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmlwbGU6IHJhd1RyaXBsZSxcbiAgICAgIHBsYXRmb3JtQXJjaEFCSTogJ3dhc20zMi13YXNpJyxcbiAgICAgIHBsYXRmb3JtOiAnd2FzaScsXG4gICAgICBhcmNoOiAnd2FzbTMyJyxcbiAgICAgIGFiaTogJ3dhc2knLFxuICAgIH1cbiAgfVxuICBjb25zdCB0cmlwbGUgPSByYXdUcmlwbGUuZW5kc1dpdGgoJ2VhYmknKVxuICAgID8gYCR7cmF3VHJpcGxlLnNsaWNlKDAsIC00KX0tZWFiaWBcbiAgICA6IHJhd1RyaXBsZVxuICBjb25zdCB0cmlwbGVzID0gdHJpcGxlLnNwbGl0KCctJylcbiAgbGV0IGNwdTogc3RyaW5nXG4gIGxldCBzeXM6IHN0cmluZ1xuICBsZXQgYWJpOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBpZiAodHJpcGxlcy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyBhYXJjaDY0LWZ1Y2hzaWFcbiAgICAvLyBeIGNwdSAgIF4gc3lzXG4gICAgO1tjcHUsIHN5c10gPSB0cmlwbGVzXG4gIH0gZWxzZSB7XG4gICAgLy8gYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2xcbiAgICAvLyBeIGNwdSAgICAgICAgICAgXiBzeXMgXiBhYmlcbiAgICAvLyBhYXJjaDY0LWFwcGxlLWRhcndpblxuICAgIC8vIF4gY3B1ICAgICAgICAgXiBzeXMgIChhYmkgaXMgTm9uZSlcbiAgICA7W2NwdSwgLCBzeXMsIGFiaSA9IG51bGxdID0gdHJpcGxlc1xuICB9XG5cbiAgY29uc3QgcGxhdGZvcm0gPSBTeXNUb05vZGVQbGF0Zm9ybVtzeXNdID8/IChzeXMgYXMgUGxhdGZvcm0pXG4gIGNvbnN0IGFyY2ggPSBDcHVUb05vZGVBcmNoW2NwdV0gPz8gKGNwdSBhcyBOb2RlSlNBcmNoKVxuXG4gIGlmIChyYXdUcmlwbGUuaW5jbHVkZXMoJ29ob3MnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmlwbGU6IHJhd1RyaXBsZSxcbiAgICAgIHBsYXRmb3JtQXJjaEFCSTogYGxpbnV4LSR7YXJjaH0tb2hvc2AsXG4gICAgICBwbGF0Zm9ybTogJ29wZW5oYXJtb255JyxcbiAgICAgIGFyY2gsXG4gICAgICBhYmk6IG51bGwsXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgcGxhdGZvcm1BcmNoQUJJOiBhYmkgPyBgJHtwbGF0Zm9ybX0tJHthcmNofS0ke2FiaX1gIDogYCR7cGxhdGZvcm19LSR7YXJjaH1gLFxuICAgIHBsYXRmb3JtLFxuICAgIGFyY2gsXG4gICAgYWJpLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTeXN0ZW1EZWZhdWx0VGFyZ2V0KCk6IFRhcmdldCB7XG4gIGNvbnN0IGhvc3QgPSBleGVjU3luYyhgcnVzdGMgLXZWYCwge1xuICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gIH0pXG4gICAgLnRvU3RyaW5nKCd1dGY4JylcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLmZpbmQoKGxpbmUpID0+IGxpbmUuc3RhcnRzV2l0aCgnaG9zdDogJykpXG4gIGNvbnN0IHRyaXBsZSA9IGhvc3Q/LnNsaWNlKCdob3N0OiAnLmxlbmd0aClcbiAgaWYgKCF0cmlwbGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IHBhcnNlIHRhcmdldCB0cmlwbGUgZnJvbSBob3N0YClcbiAgfVxuICByZXR1cm4gcGFyc2VUcmlwbGUodHJpcGxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFyZ2V0TGlua2VyKHRhcmdldDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIFRBUkdFVF9MSU5LRVJbdGFyZ2V0XVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG9FbnZWYXIodGFyZ2V0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdGFyZ2V0LnJlcGxhY2UoLy0vZywgJ18nKS50b1VwcGVyQ2FzZSgpXG59XG4iLCJleHBvcnQgZW51bSBOYXBpVmVyc2lvbiB7XG4gIE5hcGkxID0gMSxcbiAgTmFwaTIsXG4gIE5hcGkzLFxuICBOYXBpNCxcbiAgTmFwaTUsXG4gIE5hcGk2LFxuICBOYXBpNyxcbiAgTmFwaTgsXG4gIE5hcGk5LFxufVxuXG4vLy8gYmVjYXVzZSBub2RlIHN1cHBvcnQgbmV3IG5hcGkgdmVyc2lvbiBpbiBzb21lIG1pbm9yIHZlcnNpb24gdXBkYXRlcywgc28gd2UgbWlnaHQgbWVldCBzdWNoIHNpdHVhdGlvbjpcbi8vLyBgbm9kZSB2MTAuMjAuMGAgc3VwcG9ydHMgYG5hcGk1YCBhbmQgYG5hcGk2YCwgYnV0IGBub2RlIHYxMi4wLjBgIG9ubHkgc3VwcG9ydCBgbmFwaTRgLFxuLy8vIGJ5IHdoaWNoLCB3ZSBjYW4gbm90IHRlbGwgZGlyZWN0bHkgbmFwaSB2ZXJzaW9uIHN1cHBvcnRsZXNzIGZyb20gbm9kZSB2ZXJzaW9uIGRpcmVjdGx5LlxuY29uc3QgTkFQSV9WRVJTSU9OX01BVFJJWCA9IG5ldyBNYXA8TmFwaVZlcnNpb24sIHN0cmluZz4oW1xuICBbTmFwaVZlcnNpb24uTmFwaTEsICc4LjYuMCB8IDkuMC4wIHwgMTAuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpMiwgJzguMTAuMCB8IDkuMy4wIHwgMTAuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpMywgJzYuMTQuMiB8IDguMTEuMiB8IDkuMTEuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTQsICcxMC4xNi4wIHwgMTEuOC4wIHwgMTIuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNSwgJzEwLjE3LjAgfCAxMi4xMS4wIHwgMTMuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNiwgJzEwLjIwLjAgfCAxMi4xNy4wIHwgMTQuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNywgJzEwLjIzLjAgfCAxMi4xOS4wIHwgMTQuMTIuMCB8IDE1LjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTgsICcxMi4yMi4wIHwgMTQuMTcuMCB8IDE1LjEyLjAgfCAxNi4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk5LCAnMTguMTcuMCB8IDIwLjMuMCB8IDIxLjEuMCddLFxuXSlcblxuaW50ZXJmYWNlIE5vZGVWZXJzaW9uIHtcbiAgbWFqb3I6IG51bWJlclxuICBtaW5vcjogbnVtYmVyXG4gIHBhdGNoOiBudW1iZXJcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlVmVyc2lvbih2OiBzdHJpbmcpOiBOb2RlVmVyc2lvbiB7XG4gIGNvbnN0IG1hdGNoZXMgPSB2Lm1hdGNoKC92PyhbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKS9pKVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHZlcnNpb24gbnVtYmVyOiAnICsgdilcbiAgfVxuXG4gIGNvbnN0IFssIG1ham9yLCBtaW5vciwgcGF0Y2hdID0gbWF0Y2hlc1xuXG4gIHJldHVybiB7XG4gICAgbWFqb3I6IHBhcnNlSW50KG1ham9yKSxcbiAgICBtaW5vcjogcGFyc2VJbnQobWlub3IpLFxuICAgIHBhdGNoOiBwYXJzZUludChwYXRjaCksXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWlyZWROb2RlVmVyc2lvbnMobmFwaVZlcnNpb246IE5hcGlWZXJzaW9uKTogTm9kZVZlcnNpb25bXSB7XG4gIGNvbnN0IHJlcXVpcmVtZW50ID0gTkFQSV9WRVJTSU9OX01BVFJJWC5nZXQobmFwaVZlcnNpb24pXG5cbiAgaWYgKCFyZXF1aXJlbWVudCkge1xuICAgIHJldHVybiBbcGFyc2VOb2RlVmVyc2lvbignMTAuMC4wJyldXG4gIH1cblxuICByZXR1cm4gcmVxdWlyZW1lbnQuc3BsaXQoJ3wnKS5tYXAocGFyc2VOb2RlVmVyc2lvbilcbn1cblxuZnVuY3Rpb24gdG9FbmdpbmVSZXF1aXJlbWVudCh2ZXJzaW9uczogTm9kZVZlcnNpb25bXSk6IHN0cmluZyB7XG4gIGNvbnN0IHJlcXVpcmVtZW50czogc3RyaW5nW10gPSBbXVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgbGV0IHJlcSA9ICcnXG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIGNvbnN0IGxhc3RWZXJzaW9uID0gdmVyc2lvbnNbaSAtIDFdXG4gICAgICByZXEgKz0gYDwgJHtsYXN0VmVyc2lvbi5tYWpvciArIDF9YFxuICAgIH1cblxuICAgIHJlcSArPSBgJHtpID09PSAwID8gJycgOiAnIHx8ICd9Pj0gJHt2Lm1ham9yfS4ke3YubWlub3J9LiR7di5wYXRjaH1gXG4gICAgcmVxdWlyZW1lbnRzLnB1c2gocmVxKVxuICB9KVxuXG4gIHJldHVybiByZXF1aXJlbWVudHMuam9pbignICcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXBpRW5naW5lUmVxdWlyZW1lbnQobmFwaVZlcnNpb246IE5hcGlWZXJzaW9uKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRvRW5naW5lUmVxdWlyZW1lbnQocmVxdWlyZWROb2RlVmVyc2lvbnMobmFwaVZlcnNpb24pKVxufVxuIiwiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcydcblxuZXhwb3J0IHR5cGUgQ3JhdGVUYXJnZXRLaW5kID1cbiAgfCAnYmluJ1xuICB8ICdleGFtcGxlJ1xuICB8ICd0ZXN0J1xuICB8ICdiZW5jaCdcbiAgfCAnbGliJ1xuICB8ICdybGliJ1xuICB8ICdjZHlsaWInXG4gIHwgJ2N1c3RvbS1idWlsZCdcblxuZXhwb3J0IGludGVyZmFjZSBDcmF0ZVRhcmdldCB7XG4gIG5hbWU6IHN0cmluZ1xuICBraW5kOiBDcmF0ZVRhcmdldEtpbmRbXVxuICBjcmF0ZV90eXBlczogQ3JhdGVUYXJnZXRLaW5kW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmF0ZSB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHNyY19wYXRoOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIGVkaXRpb246IHN0cmluZ1xuICB0YXJnZXRzOiBDcmF0ZVRhcmdldFtdXG4gIGZlYXR1cmVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT5cbiAgbWFuaWZlc3RfcGF0aDogc3RyaW5nXG4gIGRlcGVuZGVuY2llczogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHNvdXJjZTogc3RyaW5nXG4gICAgcmVxOiBzdHJpbmdcbiAgICBraW5kOiBzdHJpbmcgfCBudWxsXG4gICAgcmVuYW1lOiBzdHJpbmcgfCBudWxsXG4gICAgb3B0aW9uYWw6IGJvb2xlYW5cbiAgICB1c2VzX2RlZmF1bHRfZmVhdHVyZXM6IGJvb2xlYW5cbiAgICBmZWF0dXJlczogc3RyaW5nW11cbiAgICB0YXJnZXQ6IHN0cmluZyB8IG51bGxcbiAgICByZWdpc3RyeTogc3RyaW5nIHwgbnVsbFxuICB9PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhcmdvV29ya3NwYWNlTWV0YWRhdGEge1xuICB2ZXJzaW9uOiBudW1iZXJcbiAgcGFja2FnZXM6IENyYXRlW11cbiAgd29ya3NwYWNlX21lbWJlcnM6IHN0cmluZ1tdXG4gIHRhcmdldF9kaXJlY3Rvcnk6IHN0cmluZ1xuICB3b3Jrc3BhY2Vfcm9vdDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZU1ldGFkYXRhKG1hbmlmZXN0UGF0aDogc3RyaW5nKSB7XG4gIGlmICghZnMuZXhpc3RzU3luYyhtYW5pZmVzdFBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBjcmF0ZSBmb3VuZCBpbiBtYW5pZmVzdDogJHttYW5pZmVzdFBhdGh9YClcbiAgfVxuXG4gIGNvbnN0IGNoaWxkUHJvY2VzcyA9IHNwYXduKFxuICAgICdjYXJnbycsXG4gICAgWydtZXRhZGF0YScsICctLW1hbmlmZXN0LXBhdGgnLCBtYW5pZmVzdFBhdGgsICctLWZvcm1hdC12ZXJzaW9uJywgJzEnXSxcbiAgICB7IHN0ZGlvOiAncGlwZScgfSxcbiAgKVxuXG4gIGxldCBzdGRvdXQgPSAnJ1xuICBsZXQgc3RkZXJyID0gJydcbiAgbGV0IHN0YXR1cyA9IDBcbiAgbGV0IGVycm9yID0gbnVsbFxuXG4gIGNoaWxkUHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgIHN0ZG91dCArPSBkYXRhXG4gIH0pXG5cbiAgY2hpbGRQcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgc3RkZXJyICs9IGRhdGFcbiAgfSlcblxuICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIGNoaWxkUHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgc3RhdHVzID0gY29kZSA/PyAwXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FyZ28gbWV0YWRhdGEgZmFpbGVkIHRvIHJ1bicsIHsgY2F1c2U6IGVycm9yIH0pXG4gIH1cbiAgaWYgKHN0YXR1cyAhPT0gMCkge1xuICAgIGNvbnN0IHNpbXBsZU1lc3NhZ2UgPSBgY2FyZ28gbWV0YWRhdGEgZXhpdGVkIHdpdGggY29kZSAke3N0YXR1c31gXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpbXBsZU1lc3NhZ2V9IGFuZCBlcnJvciBtZXNzYWdlOlxcblxcbiR7c3RkZXJyfWAsIHtcbiAgICAgIGNhdXNlOiBuZXcgRXJyb3Ioc2ltcGxlTWVzc2FnZSksXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3Rkb3V0KSBhcyBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBjYXJnbyBtZXRhZGF0YSBKU09OJywgeyBjYXVzZTogZSB9KVxuICB9XG59XG4iLCJpbXBvcnQgeyB1bmRlcmxpbmUsIHllbGxvdyB9IGZyb20gJ2NvbG9yZXR0ZSdcbmltcG9ydCB7IG1lcmdlLCBvbWl0IH0gZnJvbSAnbG9kYXNoLWVzJ1xuXG5pbXBvcnQgeyBmaWxlRXhpc3RzLCByZWFkRmlsZUFzeW5jIH0gZnJvbSAnLi9taXNjLmpzJ1xuaW1wb3J0IHsgREVGQVVMVF9UQVJHRVRTLCBwYXJzZVRyaXBsZSwgVGFyZ2V0IH0gZnJvbSAnLi90YXJnZXQuanMnXG5cbmV4cG9ydCB0eXBlIFZhbHVlT2ZDb25zdEFycmF5PFQ+ID0gVFtFeGNsdWRlPGtleW9mIFQsIGtleW9mIEFycmF5PGFueT4+XVxuXG5leHBvcnQgY29uc3QgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJzID0gWyd5YXJuJywgJ3BucG0nXSBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IFN1cHBvcnRlZFRlc3RGcmFtZXdvcmtzID0gWydhdmEnXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlciA9IFZhbHVlT2ZDb25zdEFycmF5PFxuICB0eXBlb2YgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJzXG4+XG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUZXN0RnJhbWV3b3JrID0gVmFsdWVPZkNvbnN0QXJyYXk8XG4gIHR5cGVvZiBTdXBwb3J0ZWRUZXN0RnJhbWV3b3Jrc1xuPlxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJOYXBpQ29uZmlnIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGJpbmFyeSB0byBiZSBnZW5lcmF0ZWQsIGRlZmF1bHQgdG8gYGluZGV4YFxuICAgKi9cbiAgYmluYXJ5TmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgbnBtIHBhY2thZ2UsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2Ygcm9vdCBwYWNrYWdlLmpzb24gbmFtZVxuICAgKlxuICAgKiBBbHdheXMgZ2l2ZW4gYEBzY29wZS9wa2dgIGFuZCBhcmNoIHN1ZmZpeCB3aWxsIGJlIGFwcGVuZGVkIGxpa2UgYEBzY29wZS9wa2ctbGludXgtZ251LXg2NGBcbiAgICovXG4gIHBhY2thZ2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBbGwgdGFyZ2V0cyB0aGUgY3JhdGUgd2lsbCBiZSBjb21waWxlZCBmb3JcbiAgICovXG4gIHRhcmdldHM/OiBzdHJpbmdbXVxuXG4gIC8qKlxuICAgKiBUaGUgbnBtIGNsaWVudCBwcm9qZWN0IHVzZXMuXG4gICAqL1xuICBucG1DbGllbnQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogV2hldGhlciBnZW5lcmF0ZSBjb25zdCBlbnVtIGZvciB0eXBlc2NyaXB0IGJpbmRpbmdzXG4gICAqL1xuICBjb25zdEVudW0/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIGR0cyBoZWFkZXIgcHJlcGVuZCB0byB0aGUgZ2VuZXJhdGVkIGR0cyBmaWxlXG4gICAqL1xuICBkdHNIZWFkZXI/OiBzdHJpbmdcblxuICAvKipcbiAgICogZHRzIGhlYWRlciBmaWxlIHBhdGggdG8gYmUgcHJlcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgZHRzIGZpbGVcbiAgICogaWYgYm90aCBkdHNIZWFkZXIgYW5kIGR0c0hlYWRlckZpbGUgYXJlIHByb3ZpZGVkLCBkdHNIZWFkZXJGaWxlIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgZHRzSGVhZGVyRmlsZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiB3YXNtIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAgICovXG4gIHdhc20/OiB7XG4gICAgLyoqXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWJBc3NlbWJseS9KYXZhU2NyaXB0X2ludGVyZmFjZS9NZW1vcnlcbiAgICAgKiBAZGVmYXVsdCA0MDAwIHBhZ2VzICgyNTZNaUIpXG4gICAgICovXG4gICAgaW5pdGlhbE1lbW9yeT86IG51bWJlclxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDY1NTM2IHBhZ2VzICg0R2lCKVxuICAgICAqL1xuICAgIG1heGltdW1NZW1vcnk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIEJyb3dzZXIgd2FzbSBiaW5kaW5nIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBicm93c2VyOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gdXNlIGZzIG1vZHVsZSBpbiBicm93c2VyXG4gICAgICAgKi9cbiAgICAgIGZzPzogYm9vbGVhblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGluaXRpYWxpemUgd2FzbSBhc3luY2hyb25vdXNseVxuICAgICAgICovXG4gICAgICBhc3luY0luaXQ/OiBib29sZWFuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gaW5qZWN0IGBidWZmZXJgIHRvIGVtbmFwaSBjb250ZXh0XG4gICAgICAgKi9cbiAgICAgIGJ1ZmZlcj86IGJvb2xlYW5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYmluYXJ5TmFtZSBpbnN0ZWFkXG4gICAqL1xuICBuYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgcGFja2FnZU5hbWUgaW5zdGVhZFxuICAgKi9cbiAgcGFja2FnZT86IHtcbiAgICBuYW1lPzogc3RyaW5nXG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0YXJnZXRzIGluc3RlYWRcbiAgICovXG4gIHRyaXBsZXM/OiB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzXG4gICAgICovXG4gICAgZGVmYXVsdHM6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIHRhcmdldHMgdG8gYmUgY29tcGlsZWQgZm9yXG4gICAgICovXG4gICAgYWRkaXRpb25hbD86IHN0cmluZ1tdXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21tb25QYWNrYWdlSnNvbkZpZWxkcyB7XG4gIG5hbWU6IHN0cmluZ1xuICB2ZXJzaW9uOiBzdHJpbmdcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAga2V5d29yZHM/OiBzdHJpbmdbXVxuICBhdXRob3I/OiBzdHJpbmdcbiAgYXV0aG9ycz86IHN0cmluZ1tdXG4gIGxpY2Vuc2U/OiBzdHJpbmdcbiAgY3B1Pzogc3RyaW5nW11cbiAgb3M/OiBzdHJpbmdbXVxuICBsaWJjPzogc3RyaW5nW11cbiAgZmlsZXM/OiBzdHJpbmdbXVxuICByZXBvc2l0b3J5PzogYW55XG4gIGhvbWVwYWdlPzogYW55XG4gIGVuZ2luZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHB1Ymxpc2hDb25maWc/OiBhbnlcbiAgYnVncz86IGFueVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgbmFwaT86IFVzZXJOYXBpQ29uZmlnXG4gIHR5cGU/OiAnbW9kdWxlJyB8ICdjb21tb25qcydcbiAgc2NyaXB0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICAvLyBtb2R1bGVzXG4gIG1haW4/OiBzdHJpbmdcbiAgbW9kdWxlPzogc3RyaW5nXG4gIHR5cGVzPzogc3RyaW5nXG4gIGJyb3dzZXI/OiBzdHJpbmdcbiAgZXhwb3J0cz86IGFueVxuXG4gIGRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZGV2RGVwZW5kZW5jaWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXG4gIGF2YT86IHtcbiAgICB0aW1lb3V0Pzogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTmFwaUNvbmZpZyA9IFJlcXVpcmVkPFxuICBQaWNrPFVzZXJOYXBpQ29uZmlnLCAnYmluYXJ5TmFtZScgfCAncGFja2FnZU5hbWUnIHwgJ25wbUNsaWVudCc+XG4+ICZcbiAgUGljazxVc2VyTmFwaUNvbmZpZywgJ3dhc20nIHwgJ2R0c0hlYWRlcicgfCAnZHRzSGVhZGVyRmlsZScgfCAnY29uc3RFbnVtJz4gJiB7XG4gICAgdGFyZ2V0czogVGFyZ2V0W11cbiAgICBwYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHNcbiAgfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZE5hcGlDb25maWcoXG4gIHBhdGg6IHN0cmluZyxcbiAgY29uZmlnUGF0aD86IHN0cmluZyxcbik6IFByb21pc2U8TmFwaUNvbmZpZz4ge1xuICBpZiAoY29uZmlnUGF0aCAmJiAhKGF3YWl0IGZpbGVFeGlzdHMoY29uZmlnUGF0aCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOQVBJLVJTIGNvbmZpZyBub3QgZm91bmQgYXQgJHtjb25maWdQYXRofWApXG4gIH1cbiAgaWYgKCEoYXdhaXQgZmlsZUV4aXN0cyhwYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2thZ2UuanNvbiBub3QgZm91bmQgYXQgJHtwYXRofWApXG4gIH1cbiAgLy8gTWF5IHN1cHBvcnQgbXVsdGlwbGUgY29uZmlnIHNvdXJjZXMgbGF0ZXIgb24uXG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKHBhdGgsICd1dGY4JylcbiAgbGV0IHBrZ0pzb25cbiAgdHJ5IHtcbiAgICBwa2dKc29uID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyBDb21tb25QYWNrYWdlSnNvbkZpZWxkc1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgcGFja2FnZS5qc29uIGF0ICR7cGF0aH1gLCB7XG4gICAgICBjYXVzZTogZSxcbiAgICB9KVxuICB9XG5cbiAgbGV0IHNlcGFyYXRlZENvbmZpZzogVXNlck5hcGlDb25maWcgfCB1bmRlZmluZWRcbiAgaWYgKGNvbmZpZ1BhdGgpIHtcbiAgICBjb25zdCBjb25maWdDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjb25maWdQYXRoLCAndXRmOCcpXG4gICAgdHJ5IHtcbiAgICAgIHNlcGFyYXRlZENvbmZpZyA9IEpTT04ucGFyc2UoY29uZmlnQ29udGVudCkgYXMgVXNlck5hcGlDb25maWdcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBOQVBJLVJTIGNvbmZpZyBhdCAke2NvbmZpZ1BhdGh9YCwge1xuICAgICAgICBjYXVzZTogZSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXNlck5hcGlDb25maWcgPSBwa2dKc29uLm5hcGkgPz8ge31cbiAgaWYgKHBrZ0pzb24ubmFwaSAmJiBzZXBhcmF0ZWRDb25maWcpIHtcbiAgICBjb25zdCBwa2dKc29uUGF0aCA9IHVuZGVybGluZShwYXRoKVxuICAgIGNvbnN0IGNvbmZpZ1BhdGhVbmRlcmxpbmUgPSB1bmRlcmxpbmUoY29uZmlnUGF0aCEpXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgeWVsbG93KFxuICAgICAgICBgQm90aCBuYXBpIGZpZWxkIGluICR7cGtnSnNvblBhdGh9IGFuZCBbTkFQSS1SUyBjb25maWddKCR7Y29uZmlnUGF0aFVuZGVybGluZX0pIGZpbGUgYXJlIGZvdW5kLCB0aGUgTkFQSS1SUyBjb25maWcgZmlsZSB3aWxsIGJlIHVzZWQuYCxcbiAgICAgICksXG4gICAgKVxuICAgIE9iamVjdC5hc3NpZ24odXNlck5hcGlDb25maWcsIHNlcGFyYXRlZENvbmZpZylcbiAgfVxuICBjb25zdCBuYXBpQ29uZmlnOiBOYXBpQ29uZmlnID0gbWVyZ2UoXG4gICAge1xuICAgICAgYmluYXJ5TmFtZTogJ2luZGV4JyxcbiAgICAgIHBhY2thZ2VOYW1lOiBwa2dKc29uLm5hbWUsXG4gICAgICB0YXJnZXRzOiBbXSxcbiAgICAgIHBhY2thZ2VKc29uOiBwa2dKc29uLFxuICAgICAgbnBtQ2xpZW50OiAnbnBtJyxcbiAgICB9LFxuICAgIG9taXQodXNlck5hcGlDb25maWcsICd0YXJnZXRzJyksXG4gIClcblxuICBsZXQgdGFyZ2V0czogc3RyaW5nW10gPSB1c2VyTmFwaUNvbmZpZy50YXJnZXRzID8/IFtdXG5cbiAgLy8gY29tcGF0aWJsZSB3aXRoIG9sZCBjb25maWdcbiAgaWYgKHVzZXJOYXBpQ29uZmlnPy5uYW1lKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgeWVsbG93KFxuICAgICAgICBgW0RFUFJFQ0FURURdIG5hcGkubmFtZSBpcyBkZXByZWNhdGVkLCB1c2UgbmFwaS5iaW5hcnlOYW1lIGluc3RlYWQuYCxcbiAgICAgICksXG4gICAgKVxuICAgIG5hcGlDb25maWcuYmluYXJ5TmFtZSA9IHVzZXJOYXBpQ29uZmlnLm5hbWVcbiAgfVxuXG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICBsZXQgZGVwcmVjYXRlZFdhcm5lZCA9IGZhbHNlXG4gICAgY29uc3Qgd2FybmluZyA9IHllbGxvdyhcbiAgICAgIGBbREVQUkVDQVRFRF0gbmFwaS50cmlwbGVzIGlzIGRlcHJlY2F0ZWQsIHVzZSBuYXBpLnRhcmdldHMgaW5zdGVhZC5gLFxuICAgIClcbiAgICBpZiAodXNlck5hcGlDb25maWcudHJpcGxlcz8uZGVmYXVsdHMpIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuZWQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4od2FybmluZylcbiAgICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChERUZBVUxUX1RBUkdFVFMpXG4gICAgfVxuXG4gICAgaWYgKHVzZXJOYXBpQ29uZmlnLnRyaXBsZXM/LmFkZGl0aW9uYWw/Lmxlbmd0aCkge1xuICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KHVzZXJOYXBpQ29uZmlnLnRyaXBsZXMuYWRkaXRpb25hbClcbiAgICAgIGlmICghZGVwcmVjYXRlZFdhcm5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4od2FybmluZylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGR1cGxpY2F0ZSB0YXJnZXRzXG4gIGNvbnN0IHVuaXF1ZVRhcmdldHMgPSBuZXcgU2V0KHRhcmdldHMpXG4gIGlmICh1bmlxdWVUYXJnZXRzLnNpemUgIT09IHRhcmdldHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZHVwbGljYXRlVGFyZ2V0ID0gdGFyZ2V0cy5maW5kKFxuICAgICAgKHRhcmdldCwgaW5kZXgpID0+IHRhcmdldHMuaW5kZXhPZih0YXJnZXQpICE9PSBpbmRleCxcbiAgICApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdGFyZ2V0cyBhcmUgbm90IGFsbG93ZWQ6ICR7ZHVwbGljYXRlVGFyZ2V0fWApXG4gIH1cblxuICBuYXBpQ29uZmlnLnRhcmdldHMgPSB0YXJnZXRzLm1hcChwYXJzZVRyaXBsZSlcblxuICByZXR1cm4gbmFwaUNvbmZpZ1xufVxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5cbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9sb2cuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkobmFtZTogc3RyaW5nLCBiaW46IHN0cmluZykge1xuICBpZiAoZGV0ZWN0Q2FyZ29CaW5hcnkoYmluKSkge1xuICAgIGRlYnVnKCdDYXJnbyBiaW5hcnkgYWxyZWFkeSBpbnN0YWxsZWQ6ICVzJywgbmFtZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVidWcoJ0luc3RhbGxpbmcgY2FyZ28gYmluYXJ5OiAlcycsIG5hbWUpXG4gICAgZXhlY1N5bmMoYGNhcmdvIGluc3RhbGwgJHtuYW1lfWAsIHtcbiAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluc3RhbGwgY2FyZ28gYmluYXJ5OiAke25hbWV9YCwge1xuICAgICAgY2F1c2U6IGUsXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlY3RDYXJnb0JpbmFyeShiaW46IHN0cmluZykge1xuICBkZWJ1ZygnRGV0ZWN0aW5nIGNhcmdvIGJpbmFyeTogJXMnLCBiaW4pXG4gIHRyeSB7XG4gICAgZXhlY1N5bmMoYGNhcmdvIGhlbHAgJHtiaW59YCwge1xuICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgIH0pXG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBkZXRlY3RlZDogJXMnLCBiaW4pXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCB7XG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBub3QgZGV0ZWN0ZWQ6ICVzJywgYmluKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCJpbXBvcnQgeyBzb3J0QnkgfSBmcm9tICdsb2Rhc2gtZXMnXG5cbmltcG9ydCB7IHJlYWRGaWxlQXN5bmMgfSBmcm9tICcuL21pc2MuanMnXG5cbmNvbnN0IFRPUF9MRVZFTF9OQU1FU1BBQ0UgPSAnX19UT1BfTEVWRUxfTU9EVUxFX18nXG5leHBvcnQgY29uc3QgREVGQVVMVF9UWVBFX0RFRl9IRUFERVIgPSBgLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmBcblxuZW51bSBUeXBlRGVmS2luZCB7XG4gIENvbnN0ID0gJ2NvbnN0JyxcbiAgRW51bSA9ICdlbnVtJyxcbiAgU3RyaW5nRW51bSA9ICdzdHJpbmdfZW51bScsXG4gIEludGVyZmFjZSA9ICdpbnRlcmZhY2UnLFxuICBUeXBlID0gJ3R5cGUnLFxuICBGbiA9ICdmbicsXG4gIFN0cnVjdCA9ICdzdHJ1Y3QnLFxuICBJbXBsID0gJ2ltcGwnLFxufVxuXG5pbnRlcmZhY2UgVHlwZURlZkxpbmUge1xuICBraW5kOiBUeXBlRGVmS2luZFxuICBuYW1lOiBzdHJpbmdcbiAgb3JpZ2luYWxfbmFtZT86IHN0cmluZ1xuICBkZWY6IHN0cmluZ1xuICBqc19kb2M/OiBzdHJpbmdcbiAganNfbW9kPzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHByZXR0eVByaW50KFxuICBsaW5lOiBUeXBlRGVmTGluZSxcbiAgY29uc3RFbnVtOiBib29sZWFuLFxuICBpZGVudDogbnVtYmVyLFxuICBhbWJpZW50ID0gZmFsc2UsXG4pOiBzdHJpbmcge1xuICBsZXQgcyA9IGxpbmUuanNfZG9jID8/ICcnXG4gIHN3aXRjaCAobGluZS5raW5kKSB7XG4gICAgY2FzZSBUeXBlRGVmS2luZC5JbnRlcmZhY2U6XG4gICAgICBzICs9IGBleHBvcnQgaW50ZXJmYWNlICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuVHlwZTpcbiAgICAgIHMgKz0gYGV4cG9ydCB0eXBlICR7bGluZS5uYW1lfSA9IFxcbiR7bGluZS5kZWZ9YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuRW51bTpcbiAgICAgIGNvbnN0IGVudW1OYW1lID0gY29uc3RFbnVtID8gJ2NvbnN0IGVudW0nIDogJ2VudW0nXG4gICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9ICR7ZW51bU5hbWV9ICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuU3RyaW5nRW51bTpcbiAgICAgIGlmIChjb25zdEVudW0pIHtcbiAgICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSBjb25zdCBlbnVtICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyArPSBgZXhwb3J0IHR5cGUgJHtsaW5lLm5hbWV9ID0gJHtsaW5lLmRlZi5yZXBsYWNlQWxsKC8uKj0vZywgJycpLnJlcGxhY2VBbGwoJywnLCAnfCcpfTtgXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5TdHJ1Y3Q6XG4gICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9IGNsYXNzICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgaWYgKGxpbmUub3JpZ2luYWxfbmFtZSAmJiBsaW5lLm9yaWdpbmFsX25hbWUgIT09IGxpbmUubmFtZSkge1xuICAgICAgICBzICs9IGBcXG5leHBvcnQgdHlwZSAke2xpbmUub3JpZ2luYWxfbmFtZX0gPSAke2xpbmUubmFtZX1gXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5GbjpcbiAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gJHtsaW5lLmRlZn1gXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHMgKz0gbGluZS5kZWZcbiAgfVxuXG4gIHJldHVybiBjb3JyZWN0U3RyaW5nSWRlbnQocywgaWRlbnQpXG59XG5cbmZ1bmN0aW9uIGV4cG9ydERlY2xhcmUoYW1iaWVudDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChhbWJpZW50KSB7XG4gICAgcmV0dXJuICdleHBvcnQnXG4gIH1cblxuICByZXR1cm4gJ2V4cG9ydCBkZWNsYXJlJ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1R5cGVEZWYoXG4gIGludGVybWVkaWF0ZVR5cGVGaWxlOiBzdHJpbmcsXG4gIGNvbnN0RW51bTogYm9vbGVhbixcbikge1xuICBjb25zdCBleHBvcnRzOiBzdHJpbmdbXSA9IFtdXG4gIGNvbnN0IGRlZnMgPSBhd2FpdCByZWFkSW50ZXJtZWRpYXRlVHlwZUZpbGUoaW50ZXJtZWRpYXRlVHlwZUZpbGUpXG4gIGNvbnN0IGdyb3VwZWREZWZzID0gcHJlcHJvY2Vzc1R5cGVEZWYoZGVmcylcblxuICBjb25zdCBkdHMgPVxuICAgIHNvcnRCeShBcnJheS5mcm9tKGdyb3VwZWREZWZzKSwgKFtuYW1lc3BhY2VdKSA9PiBuYW1lc3BhY2UpXG4gICAgICAubWFwKChbbmFtZXNwYWNlLCBkZWZzXSkgPT4ge1xuICAgICAgICBpZiAobmFtZXNwYWNlID09PSBUT1BfTEVWRUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZnNcbiAgICAgICAgICAgIC5tYXAoKGRlZikgPT4ge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGRlZi5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5Db25zdDpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLkVudW06XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5TdHJpbmdFbnVtOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuRm46XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5TdHJ1Y3Q6IHtcbiAgICAgICAgICAgICAgICAgIGV4cG9ydHMucHVzaChkZWYubmFtZSlcbiAgICAgICAgICAgICAgICAgIGlmIChkZWYub3JpZ2luYWxfbmFtZSAmJiBkZWYub3JpZ2luYWxfbmFtZSAhPT0gZGVmLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5wdXNoKGRlZi5vcmlnaW5hbF9uYW1lKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHByZXR0eVByaW50KGRlZiwgY29uc3RFbnVtLCAwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG5cXG4nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydHMucHVzaChuYW1lc3BhY2UpXG4gICAgICAgICAgbGV0IGRlY2xhcmF0aW9uID0gJydcbiAgICAgICAgICBkZWNsYXJhdGlvbiArPSBgZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlICR7bmFtZXNwYWNlfSB7XFxuYFxuICAgICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uICs9IHByZXR0eVByaW50KGRlZiwgY29uc3RFbnVtLCAyLCB0cnVlKSArICdcXG4nXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlY2xhcmF0aW9uICs9ICd9J1xuICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvblxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJ1xcblxcbicpICsgJ1xcbidcblxuICByZXR1cm4ge1xuICAgIGR0cyxcbiAgICBleHBvcnRzLFxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRJbnRlcm1lZGlhdGVUeXBlRmlsZShmaWxlOiBzdHJpbmcpIHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoZmlsZSwgJ3V0ZjgnKVxuXG4gIGNvbnN0IGRlZnMgPSBjb250ZW50XG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICBsaW5lID0gbGluZS50cmltKClcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UobGluZSkgYXMgVHlwZURlZkxpbmVcbiAgICAgIC8vIENvbnZlcnQgZXNjYXBlZCBuZXdsaW5lcyBiYWNrIHRvIGFjdHVhbCBuZXdsaW5lcyBpbiBqc19kb2MgZmllbGRzXG4gICAgICBpZiAocGFyc2VkLmpzX2RvYykge1xuICAgICAgICBwYXJzZWQuanNfZG9jID0gcGFyc2VkLmpzX2RvYy5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIH1cbiAgICAgIC8vIENvbnZlcnQgZXNjYXBlZCBuZXdsaW5lcyB0byBhY3R1YWwgbmV3bGluZXMgaW4gZGVmIGZpZWxkcyBmb3Igc3RydWN0L2NsYXNzL2ludGVyZmFjZS90eXBlIHR5cGVzXG4gICAgICAvLyB3aGVyZSBcXG4gcmVwcmVzZW50cyBtZXRob2QvZmllbGQgc2VwYXJhdG9ycyB0aGF0IHNob3VsZCBiZSBhY3R1YWwgbmV3bGluZXNcbiAgICAgIGlmIChwYXJzZWQuZGVmKSB7XG4gICAgICAgIHBhcnNlZC5kZWYgPSBwYXJzZWQuZGVmLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZFxuICAgIH0pXG5cbiAgLy8gbW92ZSBhbGwgYHN0cnVjdGAgZGVmIHRvIHRoZSB2ZXJ5IHRvcFxuICAvLyBhbmQgb3JkZXIgdGhlIHJlc3QgYWxwaGFiZXRpY2FsbHkuXG4gIHJldHVybiBkZWZzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgIGlmIChiLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmIChiLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NUeXBlRGVmKGRlZnM6IFR5cGVEZWZMaW5lW10pOiBNYXA8c3RyaW5nLCBUeXBlRGVmTGluZVtdPiB7XG4gIGNvbnN0IG5hbWVzcGFjZUdyb3VwZWQgPSBuZXcgTWFwPHN0cmluZywgVHlwZURlZkxpbmVbXT4oKVxuICBjb25zdCBjbGFzc0RlZnMgPSBuZXcgTWFwPHN0cmluZywgVHlwZURlZkxpbmU+KClcblxuICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gZGVmLmpzX21vZCA/PyBUT1BfTEVWRUxfTkFNRVNQQUNFXG4gICAgaWYgKCFuYW1lc3BhY2VHcm91cGVkLmhhcyhuYW1lc3BhY2UpKSB7XG4gICAgICBuYW1lc3BhY2VHcm91cGVkLnNldChuYW1lc3BhY2UsIFtdKVxuICAgIH1cblxuICAgIGNvbnN0IGdyb3VwID0gbmFtZXNwYWNlR3JvdXBlZC5nZXQobmFtZXNwYWNlKSFcblxuICAgIGlmIChkZWYua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICBncm91cC5wdXNoKGRlZilcbiAgICAgIGNsYXNzRGVmcy5zZXQoZGVmLm5hbWUsIGRlZilcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBUeXBlRGVmS2luZC5JbXBsKSB7XG4gICAgICAvLyBtZXJnZSBgaW1wbGAgaW50byBjbGFzcyBkZWZpbml0aW9uXG4gICAgICBjb25zdCBjbGFzc0RlZiA9IGNsYXNzRGVmcy5nZXQoZGVmLm5hbWUpXG4gICAgICBpZiAoY2xhc3NEZWYpIHtcbiAgICAgICAgaWYgKGNsYXNzRGVmLmRlZikge1xuICAgICAgICAgIGNsYXNzRGVmLmRlZiArPSAnXFxuJ1xuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3NEZWYuZGVmICs9IGRlZi5kZWZcbiAgICAgICAgLy8gQ29udmVydCBhbnkgcmVtYWluaW5nIFxcbiBzZXF1ZW5jZXMgaW4gdGhlIG1lcmdlZCBkZWYgdG8gYWN0dWFsIG5ld2xpbmVzXG4gICAgICAgIGlmIChjbGFzc0RlZi5kZWYpIHtcbiAgICAgICAgICBjbGFzc0RlZi5kZWYgPSBjbGFzc0RlZi5kZWYucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAucHVzaChkZWYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWVzcGFjZUdyb3VwZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcnJlY3RTdHJpbmdJZGVudChzcmM6IHN0cmluZywgaWRlbnQ6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCBicmFja2V0RGVwdGggPSAwXG4gIGNvbnN0IHJlc3VsdCA9IHNyY1xuICAgIC5zcGxpdCgnXFxuJylcbiAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICBsaW5lID0gbGluZS50cmltKClcbiAgICAgIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNJbk11bHRpbGluZUNvbW1lbnQgPSBsaW5lLnN0YXJ0c1dpdGgoJyonKVxuICAgICAgY29uc3QgaXNDbG9zaW5nQnJhY2tldCA9IGxpbmUuZW5kc1dpdGgoJ30nKVxuICAgICAgY29uc3QgaXNPcGVuaW5nQnJhY2tldCA9IGxpbmUuZW5kc1dpdGgoJ3snKVxuICAgICAgY29uc3QgaXNUeXBlRGVjbGFyYXRpb24gPSBsaW5lLmVuZHNXaXRoKCc9JylcbiAgICAgIGNvbnN0IGlzVHlwZVZhcmlhbnQgPSBsaW5lLnN0YXJ0c1dpdGgoJ3wnKVxuXG4gICAgICBsZXQgcmlnaHRJbmRlbnQgPSBpZGVudFxuICAgICAgaWYgKChpc09wZW5pbmdCcmFja2V0IHx8IGlzVHlwZURlY2xhcmF0aW9uKSAmJiAhaXNJbk11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgICAgYnJhY2tldERlcHRoICs9IDFcbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gKGJyYWNrZXREZXB0aCAtIDEpICogMlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzQ2xvc2luZ0JyYWNrZXQgJiZcbiAgICAgICAgICBicmFja2V0RGVwdGggPiAwICYmXG4gICAgICAgICAgIWlzSW5NdWx0aWxpbmVDb21tZW50ICYmXG4gICAgICAgICAgIWlzVHlwZVZhcmlhbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgYnJhY2tldERlcHRoIC09IDFcbiAgICAgICAgfVxuICAgICAgICByaWdodEluZGVudCArPSBicmFja2V0RGVwdGggKiAyXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0luTXVsdGlsaW5lQ29tbWVudCkge1xuICAgICAgICByaWdodEluZGVudCArPSAxXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHMgPSBgJHsnICcucmVwZWF0KHJpZ2h0SW5kZW50KX0ke2xpbmV9YFxuXG4gICAgICByZXR1cm4gc1xuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiaW1wb3J0IHsgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcmVhZE5hcGlDb25maWcgfSBmcm9tICcuL2NvbmZpZy5qcydcblxuaW50ZXJmYWNlIE1pbmltYWxOYXBpT3B0aW9ucyB7XG4gIGN3ZDogc3RyaW5nXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQ29uZmlnKG9wdGlvbnM6IE1pbmltYWxOYXBpT3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlUGF0aCA9ICguLi5wYXRoczogc3RyaW5nW10pID0+IHJlc29sdmUob3B0aW9ucy5jd2QsIC4uLnBhdGhzKVxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICByZXNvbHZlUGF0aChcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/PyBvcHRpb25zLnBhY2thZ2VKc29uUGF0aCA/PyAncGFja2FnZS5qc29uJyxcbiAgICApLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmVQYXRoKG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcbiAgcmV0dXJuIGNvbmZpZ1xufVxuIiwiaW1wb3J0IHsgam9pbiwgcGFyc2UgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcmV0dGUnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnMsXG4gIEFydGlmYWN0c09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9hcnRpZmFjdHMuanMnXG5pbXBvcnQge1xuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICByZWFkRmlsZUFzeW5jLFxuICB3cml0ZUZpbGVBc3luYyxcbiAgVW5pQXJjaHNCeVBsYXRmb3JtLFxuICByZWFkZGlyQXN5bmMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnYXJ0aWZhY3RzJylcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RBcnRpZmFjdHModXNlck9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IHsgdGFyZ2V0cywgYmluYXJ5TmFtZSwgcGFja2FnZU5hbWUgfSA9XG4gICAgYXdhaXQgcmVhZE5hcGlDb25maWcocGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IGRpc3REaXJzID0gdGFyZ2V0cy5tYXAoKHBsYXRmb3JtKSA9PlxuICAgIGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMubnBtRGlyLCBwbGF0Zm9ybS5wbGF0Zm9ybUFyY2hBQkkpLFxuICApXG5cbiAgY29uc3QgdW5pdmVyc2FsU291cmNlQmlucyA9IG5ldyBTZXQoXG4gICAgdGFyZ2V0c1xuICAgICAgLmZpbHRlcigocGxhdGZvcm0pID0+IHBsYXRmb3JtLmFyY2ggPT09ICd1bml2ZXJzYWwnKVxuICAgICAgLmZsYXRNYXAoKHApID0+XG4gICAgICAgIFVuaUFyY2hzQnlQbGF0Zm9ybVtwLnBsYXRmb3JtXT8ubWFwKChhKSA9PiBgJHtwLnBsYXRmb3JtfS0ke2F9YCksXG4gICAgICApXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIHN0cmluZ1tdLFxuICApXG5cbiAgYXdhaXQgY29sbGVjdE5vZGVCaW5hcmllcyhqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLm91dHB1dERpcikpLnRoZW4oXG4gICAgKG91dHB1dCkgPT5cbiAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICBvdXRwdXQubWFwKGFzeW5jIChmaWxlUGF0aCkgPT4ge1xuICAgICAgICAgIGRlYnVnLmluZm8oYFJlYWQgWyR7Y29sb3JzLnllbGxvd0JyaWdodChmaWxlUGF0aCl9XWApXG4gICAgICAgICAgY29uc3Qgc291cmNlQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoZmlsZVBhdGgpXG4gICAgICAgICAgY29uc3QgcGFyc2VkTmFtZSA9IHBhcnNlKGZpbGVQYXRoKVxuICAgICAgICAgIGNvbnN0IHRlcm1zID0gcGFyc2VkTmFtZS5uYW1lLnNwbGl0KCcuJylcbiAgICAgICAgICBjb25zdCBwbGF0Zm9ybUFyY2hBQkkgPSB0ZXJtcy5wb3AoKSFcbiAgICAgICAgICBjb25zdCBfYmluYXJ5TmFtZSA9IHRlcm1zLmpvaW4oJy4nKVxuXG4gICAgICAgICAgaWYgKF9iaW5hcnlOYW1lICE9PSBiaW5hcnlOYW1lKSB7XG4gICAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgICBgWyR7X2JpbmFyeU5hbWV9XSBpcyBub3QgbWF0Y2hlZCB3aXRoIFske2JpbmFyeU5hbWV9XSwgc2tpcGAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGlyID0gZGlzdERpcnMuZmluZCgoZGlyKSA9PiBkaXIuaW5jbHVkZXMocGxhdGZvcm1BcmNoQUJJKSlcbiAgICAgICAgICBpZiAoIWRpciAmJiB1bml2ZXJzYWxTb3VyY2VCaW5zLmhhcyhwbGF0Zm9ybUFyY2hBQkkpKSB7XG4gICAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgICBgWyR7cGxhdGZvcm1BcmNoQUJJfV0gaGFzIG5vIGRpc3QgZGlyIGJ1dCBpdCBpcyBzb3VyY2UgYmluIGZvciB1bml2ZXJzYWwgYXJjaCwgc2tpcGAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGlzdCBkaXIgZm91bmQgZm9yICR7ZmlsZVBhdGh9YClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkaXN0RmlsZVBhdGggPSBqb2luKGRpciwgcGFyc2VkTmFtZS5iYXNlKVxuICAgICAgICAgIGRlYnVnLmluZm8oXG4gICAgICAgICAgICBgV3JpdGUgZmlsZSBjb250ZW50IHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoZGlzdEZpbGVQYXRoKX1dYCxcbiAgICAgICAgICApXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGlzdEZpbGVQYXRoLCBzb3VyY2VDb250ZW50KVxuICAgICAgICAgIGNvbnN0IGRpc3RGaWxlUGF0aExvY2FsID0gam9pbihcbiAgICAgICAgICAgIHBhcnNlKHBhY2thZ2VKc29uUGF0aCkuZGlyLFxuICAgICAgICAgICAgcGFyc2VkTmFtZS5iYXNlLFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1Zy5pbmZvKFxuICAgICAgICAgICAgYFdyaXRlIGZpbGUgY29udGVudCB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KGRpc3RGaWxlUGF0aExvY2FsKX1dYCxcbiAgICAgICAgICApXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGlzdEZpbGVQYXRoTG9jYWwsIHNvdXJjZUNvbnRlbnQpXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgKVxuXG4gIGNvbnN0IHdhc2lUYXJnZXQgPSB0YXJnZXRzLmZpbmQoKHQpID0+IHQucGxhdGZvcm0gPT09ICd3YXNpJylcbiAgaWYgKHdhc2lUYXJnZXQpIHtcbiAgICBjb25zdCB3YXNpRGlyID0gam9pbihcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5ucG1EaXIsXG4gICAgICB3YXNpVGFyZ2V0LnBsYXRmb3JtQXJjaEFCSSxcbiAgICApXG4gICAgY29uc3QgY2pzRmlsZSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYCR7YmluYXJ5TmFtZX0ud2FzaS5janNgLFxuICAgIClcbiAgICBjb25zdCB3b3JrZXJGaWxlID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgd2FzaS13b3JrZXIubWpzYCxcbiAgICApXG4gICAgY29uc3QgYnJvd3NlckVudHJ5ID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgJHtiaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgIClcbiAgICBjb25zdCBicm93c2VyV29ya2VyRmlsZSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgYmluZGluZyBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGNqc0ZpbGUsXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYCksXG4gICAgICBhd2FpdCByZWFkRmlsZUFzeW5jKGNqc0ZpbGUpLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSB3b3JrZXIgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICB3b3JrZXJGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgd2FzaS13b3JrZXIubWpzYCksXG4gICAgICBhd2FpdCByZWFkRmlsZUFzeW5jKHdvcmtlckZpbGUpLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSBicm93c2VyIGVudHJ5IGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgYnJvd3NlckVudHJ5LFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgJHtiaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgKSxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvODQyN1xuICAgICAgKGF3YWl0IHJlYWRGaWxlQXN5bmMoYnJvd3NlckVudHJ5LCAndXRmOCcpKS5yZXBsYWNlKFxuICAgICAgICBgbmV3IFVSTCgnLi93YXNpLXdvcmtlci1icm93c2VyLm1qcycsIGltcG9ydC5tZXRhLnVybClgLFxuICAgICAgICBgbmV3IFVSTCgnJHtwYWNrYWdlTmFtZX0td2FzbTMyLXdhc2kvd2FzaS13b3JrZXItYnJvd3Nlci5tanMnLCBpbXBvcnQubWV0YS51cmwpYCxcbiAgICAgICksXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIGJyb3dzZXIgd29ya2VyIGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgYnJvd3NlcldvcmtlckZpbGUsXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGB3YXNpLXdvcmtlci1icm93c2VyLm1qc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyhicm93c2VyV29ya2VyRmlsZSksXG4gICAgKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3ROb2RlQmluYXJpZXMocm9vdDogc3RyaW5nKSB7XG4gIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHJvb3QsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuICBjb25zdCBub2RlQmluYXJpZXMgPSBmaWxlc1xuICAgIC5maWx0ZXIoXG4gICAgICAoZmlsZSkgPT5cbiAgICAgICAgZmlsZS5pc0ZpbGUoKSAmJlxuICAgICAgICAoZmlsZS5uYW1lLmVuZHNXaXRoKCcubm9kZScpIHx8IGZpbGUubmFtZS5lbmRzV2l0aCgnLndhc20nKSksXG4gICAgKVxuICAgIC5tYXAoKGZpbGUpID0+IGpvaW4ocm9vdCwgZmlsZS5uYW1lKSlcblxuICBjb25zdCBkaXJzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiBmaWxlLmlzRGlyZWN0b3J5KCkpXG4gIGZvciAoY29uc3QgZGlyIG9mIGRpcnMpIHtcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdub2RlX21vZHVsZXMnKSB7XG4gICAgICBub2RlQmluYXJpZXMucHVzaCguLi4oYXdhaXQgY29sbGVjdE5vZGVCaW5hcmllcyhqb2luKHJvb3QsIGRpci5uYW1lKSkpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZUJpbmFyaWVzXG59XG4iLCJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5pbXBvcnQgeyBjb2xsZWN0QXJ0aWZhY3RzIH0gZnJvbSAnLi4vYXBpL2FydGlmYWN0cy5qcydcbmltcG9ydCB7IEJhc2VBcnRpZmFjdHNDb21tYW5kIH0gZnJvbSAnLi4vZGVmL2FydGlmYWN0cy5qcydcblxuZXhwb3J0IGNsYXNzIEFydGlmYWN0c0NvbW1hbmQgZXh0ZW5kcyBCYXNlQXJ0aWZhY3RzQ29tbWFuZCB7XG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIHNwZWNpZmllZCBkaXInLFxuICAgIGV4YW1wbGVzOiBbXG4gICAgICBbXG4gICAgICAgICckMCBhcnRpZmFjdHMgLS1vdXRwdXQtZGlyIC4vYXJ0aWZhY3RzIC0tZGlzdCAuL25wbScsXG4gICAgICAgIGBDb3B5IFtiaW5hcnlOYW1lXS5bcGxhdGZvcm1dLm5vZGUgdW5kZXIgY3VycmVudCBkaXIoLikgaW50byBwYWNrYWdlcyB1bmRlciBucG0gZGlyLlxuZS5nOiBpbmRleC5saW51eC14NjQtZ251Lm5vZGUgLS0+IC4vbnBtL2xpbnV4LXg2NC1nbnUvaW5kZXgubGludXgteDY0LWdudS5ub2RlYCxcbiAgICAgIF0sXG4gICAgXSxcbiAgfSlcblxuICBzdGF0aWMgcGF0aHMgPSBbWydhcnRpZmFjdHMnXV1cblxuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IGNvbGxlY3RBcnRpZmFjdHModGhpcy5nZXRPcHRpb25zKCkpXG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDanNCaW5kaW5nKFxuICBsb2NhbE5hbWU6IHN0cmluZyxcbiAgcGtnTmFtZTogc3RyaW5nLFxuICBpZGVudHM6IHN0cmluZ1tdLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2JpbmRpbmdIZWFkZXJ9XG5jb25zdCB7IGNyZWF0ZVJlcXVpcmUgfSA9IHJlcXVpcmUoJ25vZGU6bW9kdWxlJylcbnJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKF9fZmlsZW5hbWUpXG5cbiR7Y3JlYXRlQ29tbW9uQmluZGluZyhsb2NhbE5hbWUsIHBrZ05hbWUpfVxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVCaW5kaW5nXG4ke2lkZW50c1xuICAubWFwKChpZGVudCkgPT4gYG1vZHVsZS5leHBvcnRzLiR7aWRlbnR9ID0gbmF0aXZlQmluZGluZy4ke2lkZW50fWApXG4gIC5qb2luKCdcXG4nKX1cbmBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVzbUJpbmRpbmcoXG4gIGxvY2FsTmFtZTogc3RyaW5nLFxuICBwa2dOYW1lOiBzdHJpbmcsXG4gIGlkZW50czogc3RyaW5nW10sXG4pOiBzdHJpbmcge1xuICByZXR1cm4gYCR7YmluZGluZ0hlYWRlcn1cbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSdcbmNvbnN0IHJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybClcbmNvbnN0IF9fZGlybmFtZSA9IG5ldyBVUkwoJy4nLCBpbXBvcnQubWV0YS51cmwpLnBhdGhuYW1lXG5cbiR7Y3JlYXRlQ29tbW9uQmluZGluZyhsb2NhbE5hbWUsIHBrZ05hbWUpfVxuY29uc3QgeyAke2lkZW50cy5qb2luKCcsICcpfSB9ID0gbmF0aXZlQmluZGluZ1xuJHtpZGVudHMubWFwKChpZGVudCkgPT4gYGV4cG9ydCB7ICR7aWRlbnR9IH1gKS5qb2luKCdcXG4nKX1cbmBcbn1cblxuY29uc3QgYmluZGluZ0hlYWRlciA9IGAvLyBwcmV0dGllci1pZ25vcmVcbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuYFxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25CaW5kaW5nKGxvY2FsTmFtZTogc3RyaW5nLCBwa2dOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBmdW5jdGlvbiByZXF1aXJlVHVwbGUodHVwbGU6IHN0cmluZywgaWRlbnRTaXplID0gOCkge1xuICAgIGNvbnN0IGlkZW50TG93ID0gJyAnLnJlcGVhdChpZGVudFNpemUgLSAyKVxuICAgIGNvbnN0IGlkZW50ID0gJyAnLnJlcGVhdChpZGVudFNpemUpXG4gICAgcmV0dXJuIGB0cnkge1xuJHtpZGVudH1yZXR1cm4gcmVxdWlyZSgnLi8ke2xvY2FsTmFtZX0uJHt0dXBsZX0ubm9kZScpXG4ke2lkZW50TG93fX0gY2F0Y2ggKGUpIHtcbiR7aWRlbnR9bG9hZEVycm9ycy5wdXNoKGUpXG4ke2lkZW50TG93fX1cbiR7aWRlbnRMb3d9dHJ5IHtcbiR7aWRlbnR9cmV0dXJuIHJlcXVpcmUoJyR7cGtnTmFtZX0tJHt0dXBsZX0nKVxuJHtpZGVudExvd319IGNhdGNoIChlKSB7XG4ke2lkZW50fWxvYWRFcnJvcnMucHVzaChlKVxuJHtpZGVudExvd319YFxuICB9XG5cbiAgcmV0dXJuIGBjb25zdCB7IHJlYWRGaWxlU3luYyB9ID0gcmVxdWlyZSgnbm9kZTpmcycpXG5sZXQgbmF0aXZlQmluZGluZyA9IG51bGxcbmNvbnN0IGxvYWRFcnJvcnMgPSBbXVxuXG5jb25zdCBpc011c2wgPSAoKSA9PiB7XG4gIGxldCBtdXNsID0gZmFsc2VcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICBtdXNsID0gaXNNdXNsRnJvbUZpbGVzeXN0ZW0oKVxuICAgIGlmIChtdXNsID09PSBudWxsKSB7XG4gICAgICBtdXNsID0gaXNNdXNsRnJvbVJlcG9ydCgpXG4gICAgfVxuICAgIGlmIChtdXNsID09PSBudWxsKSB7XG4gICAgICBtdXNsID0gaXNNdXNsRnJvbUNoaWxkUHJvY2VzcygpXG4gICAgfVxuICB9XG4gIHJldHVybiBtdXNsXG59XG5cbmNvbnN0IGlzRmlsZU11c2wgPSAoZikgPT4gZi5pbmNsdWRlcygnbGliYy5tdXNsLScpIHx8IGYuaW5jbHVkZXMoJ2xkLW11c2wtJylcblxuY29uc3QgaXNNdXNsRnJvbUZpbGVzeXN0ZW0gPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlYWRGaWxlU3luYygnL3Vzci9iaW4vbGRkJywgJ3V0Zi04JykuaW5jbHVkZXMoJ211c2wnKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmNvbnN0IGlzTXVzbEZyb21SZXBvcnQgPSAoKSA9PiB7XG4gIGxldCByZXBvcnQgPSBudWxsXG4gIGlmICh0eXBlb2YgcHJvY2Vzcy5yZXBvcnQ/LmdldFJlcG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MucmVwb3J0LmV4Y2x1ZGVOZXR3b3JrID0gdHJ1ZVxuICAgIHJlcG9ydCA9IHByb2Nlc3MucmVwb3J0LmdldFJlcG9ydCgpXG4gIH1cbiAgaWYgKCFyZXBvcnQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChyZXBvcnQuaGVhZGVyICYmIHJlcG9ydC5oZWFkZXIuZ2xpYmNWZXJzaW9uUnVudGltZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHJlcG9ydC5zaGFyZWRPYmplY3RzKSkge1xuICAgIGlmIChyZXBvcnQuc2hhcmVkT2JqZWN0cy5zb21lKGlzRmlsZU11c2wpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgaXNNdXNsRnJvbUNoaWxkUHJvY2VzcyA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKCdsZGQgLS12ZXJzaW9uJywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLmluY2x1ZGVzKCdtdXNsJylcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElmIHdlIHJlYWNoIHRoaXMgY2FzZSwgd2UgZG9uJ3Qga25vdyBpZiB0aGUgc3lzdGVtIGlzIG11c2wgb3Igbm90LCBzbyBpcyBiZXR0ZXIgdG8ganVzdCBmYWxsYmFjayB0byBmYWxzZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVOYXRpdmUoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OQVBJX1JTX05BVElWRV9MSUJSQVJZX1BBVEgpIHtcbiAgICB0cnkge1xuICAgICAgbmF0aXZlQmluZGluZyA9IHJlcXVpcmUocHJvY2Vzcy5lbnYuTkFQSV9SU19OQVRJVkVfTElCUkFSWV9QQVRIKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChlcnIpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdhbmRyb2lkLWFybTY0Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnYW5kcm9pZC1hcm0tZWFiaScpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBBbmRyb2lkIFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzIteDY0LW1zdmMnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzItaWEzMi1tc3ZjJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi1hcm02NC1tc3ZjJyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIFdpbmRvd3M6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLXVuaXZlcnNhbCcsIDYpfVxuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLXg2NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLWFybTY0Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIG1hY09TOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdmcmVlYnNkJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZnJlZWJzZC14NjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2ZyZWVic2QtYXJtNjQnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gRnJlZUJTRDogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgteDY0LW11c2wnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgteDY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm02NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybTY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLW11c2xlYWJpaGYnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLWdudWVhYmloZicsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3Jpc2N2NjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXJpc2N2NjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1yaXNjdjY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3BwYzY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXBwYzY0LWdudScpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnczM5MHgnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtczM5MHgtZ251Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIExpbnV4OiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdvcGVuaGFybW9ueScpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtNjQtb2hvcycpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXg2NC1vaG9zJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLW9ob3MnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gT3Blbkhhcm1vbnk6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBPUzogXFwke3Byb2Nlc3MucGxhdGZvcm19LCBhcmNoaXRlY3R1cmU6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgfVxufVxuXG5uYXRpdmVCaW5kaW5nID0gcmVxdWlyZU5hdGl2ZSgpXG5cbmlmICghbmF0aXZlQmluZGluZyB8fCBwcm9jZXNzLmVudi5OQVBJX1JTX0ZPUkNFX1dBU0kpIHtcbiAgdHJ5IHtcbiAgICBuYXRpdmVCaW5kaW5nID0gcmVxdWlyZSgnLi8ke2xvY2FsTmFtZX0ud2FzaS5janMnKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19GT1JDRV9XQVNJKSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2goZXJyKVxuICAgIH1cbiAgfVxuICBpZiAoIW5hdGl2ZUJpbmRpbmcpIHtcbiAgICB0cnkge1xuICAgICAgbmF0aXZlQmluZGluZyA9IHJlcXVpcmUoJyR7cGtnTmFtZX0td2FzbTMyLXdhc2knKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICAgICAgICBsb2FkRXJyb3JzLnB1c2goZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAoIW5hdGl2ZUJpbmRpbmcpIHtcbiAgaWYgKGxvYWRFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFxcYENhbm5vdCBmaW5kIG5hdGl2ZSBiaW5kaW5nLiBcXGAgK1xuICAgICAgICBcXGBucG0gaGFzIGEgYnVnIHJlbGF0ZWQgdG8gb3B0aW9uYWwgZGVwZW5kZW5jaWVzIChodHRwczovL2dpdGh1Yi5jb20vbnBtL2NsaS9pc3N1ZXMvNDgyOCkuIFxcYCArXG4gICAgICAgICdQbGVhc2UgdHJ5IFxcYG5wbSBpXFxgIGFnYWluIGFmdGVyIHJlbW92aW5nIGJvdGggcGFja2FnZS1sb2NrLmpzb24gYW5kIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnkuJyxcbiAgICAgIHsgY2F1c2U6IGxvYWRFcnJvcnMgfVxuICAgIClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXFxgRmFpbGVkIHRvIGxvYWQgbmF0aXZlIGJpbmRpbmdcXGApXG59XG5gXG59XG4iLCJleHBvcnQgY29uc3QgY3JlYXRlV2FzaUJyb3dzZXJCaW5kaW5nID0gKFxuICB3YXNpRmlsZW5hbWU6IHN0cmluZyxcbiAgaW5pdGlhbE1lbW9yeSA9IDQwMDAsXG4gIG1heGltdW1NZW1vcnkgPSA2NTUzNixcbiAgZnMgPSBmYWxzZSxcbiAgYXN5bmNJbml0ID0gZmFsc2UsXG4gIGJ1ZmZlciA9IGZhbHNlLFxuKSA9PiB7XG4gIGNvbnN0IGZzSW1wb3J0ID0gZnNcbiAgICA/IGJ1ZmZlclxuICAgICAgPyBgaW1wb3J0IHsgbWVtZnMsIEJ1ZmZlciB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydgXG4gICAgICA6IGBpbXBvcnQgeyBtZW1mcyB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydgXG4gICAgOiAnJ1xuICBjb25zdCBidWZmZXJJbXBvcnQgPSBidWZmZXIgJiYgIWZzID8gYGltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcidgIDogJydcbiAgY29uc3Qgd2FzaUNyZWF0aW9uID0gZnNcbiAgICA/IGBcbmV4cG9ydCBjb25zdCB7IGZzOiBfX2ZzLCB2b2w6IF9fdm9sdW1lIH0gPSBtZW1mcygpXG5cbmNvbnN0IF9fd2FzaSA9IG5ldyBfX1dBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICBmczogX19mcyxcbiAgcHJlb3BlbnM6IHtcbiAgICAnLyc6ICcvJyxcbiAgfSxcbn0pYFxuICAgIDogYFxuY29uc3QgX193YXNpID0gbmV3IF9fV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG59KWBcblxuICBjb25zdCB3b3JrZXJGc0hhbmRsZXIgPSBmc1xuICAgID8gYCAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHkoX19mcykpXFxuYFxuICAgIDogJydcblxuICBjb25zdCBlbW5hcGlJbmplY3RCdWZmZXIgPSBidWZmZXJcbiAgICA/ICdfX2VtbmFwaUNvbnRleHQuZmVhdHVyZS5CdWZmZXIgPSBCdWZmZXInXG4gICAgOiAnJ1xuICBjb25zdCBlbW5hcGlJbnN0YW50aWF0ZUltcG9ydCA9IGFzeW5jSW5pdFxuICAgID8gYGluc3RhbnRpYXRlTmFwaU1vZHVsZSBhcyBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZWBcbiAgICA6IGBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jIGFzIF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luY2BcbiAgY29uc3QgZW1uYXBpSW5zdGFudGlhdGVDYWxsID0gYXN5bmNJbml0XG4gICAgPyBgYXdhaXQgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVgXG4gICAgOiBgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jYFxuXG4gIHJldHVybiBgaW1wb3J0IHtcbiAgY3JlYXRlT25NZXNzYWdlIGFzIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHksXG4gIGdldERlZmF1bHRDb250ZXh0IGFzIF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQsXG4gICR7ZW1uYXBpSW5zdGFudGlhdGVJbXBvcnR9LFxuICBXQVNJIGFzIF9fV0FTSSxcbn0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lJ1xuJHtmc0ltcG9ydH1cbiR7YnVmZmVySW1wb3J0fVxuJHt3YXNpQ3JlYXRpb259XG5cbmNvbnN0IF9fd2FzbVVybCA9IG5ldyBVUkwoJy4vJHt3YXNpRmlsZW5hbWV9Lndhc20nLCBpbXBvcnQubWV0YS51cmwpLmhyZWZcbmNvbnN0IF9fZW1uYXBpQ29udGV4dCA9IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQoKVxuJHtlbW5hcGlJbmplY3RCdWZmZXJ9XG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmNvbnN0IF9fd2FzbUZpbGUgPSBhd2FpdCBmZXRjaChfX3dhc21VcmwpLnRoZW4oKHJlcykgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG5cbmNvbnN0IHtcbiAgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLFxuICBtb2R1bGU6IF9fd2FzaU1vZHVsZSxcbiAgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlLFxufSA9ICR7ZW1uYXBpSW5zdGFudGlhdGVDYWxsfShfX3dhc21GaWxlLCB7XG4gIGNvbnRleHQ6IF9fZW1uYXBpQ29udGV4dCxcbiAgYXN5bmNXb3JrUG9vbFNpemU6IDQsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKCcuL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKSwge1xuICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgfSlcbiR7d29ya2VyRnNIYW5kbGVyfVxuICAgIHJldHVybiB3b3JrZXJcbiAgfSxcbiAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICBpbXBvcnRPYmplY3QuZW52ID0ge1xuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVtbmFwaSxcbiAgICAgIG1lbW9yeTogX19zaGFyZWRNZW1vcnksXG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRPYmplY3RcbiAgfSxcbiAgYmVmb3JlSW5pdCh7IGluc3RhbmNlIH0pIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaW5zdGFuY2UuZXhwb3J0cykpIHtcbiAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ19fbmFwaV9yZWdpc3Rlcl9fJykpIHtcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1tuYW1lXSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxufSlcbmBcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCaW5kaW5nID0gKFxuICB3YXNtRmlsZU5hbWU6IHN0cmluZyxcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgaW5pdGlhbE1lbW9yeSA9IDQwMDAsXG4gIG1heGltdW1NZW1vcnkgPSA2NTUzNixcbikgPT4gYC8qIGVzbGludC1kaXNhYmxlICovXG4vKiBwcmV0dGllci1pZ25vcmUgKi9cblxuLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuXG5jb25zdCBfX25vZGVGcyA9IHJlcXVpcmUoJ25vZGU6ZnMnKVxuY29uc3QgX19ub2RlUGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpXG5jb25zdCB7IFdBU0k6IF9fbm9kZVdBU0kgfSA9IHJlcXVpcmUoJ25vZGU6d2FzaScpXG5jb25zdCB7IFdvcmtlciB9ID0gcmVxdWlyZSgnbm9kZTp3b3JrZXJfdGhyZWFkcycpXG5cbmNvbnN0IHtcbiAgY3JlYXRlT25NZXNzYWdlOiBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5LFxuICBnZXREZWZhdWx0Q29udGV4dDogX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCxcbiAgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYzogX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLFxufSA9IHJlcXVpcmUoJ0BuYXBpLXJzL3dhc20tcnVudGltZScpXG5cbmNvbnN0IF9fcm9vdERpciA9IF9fbm9kZVBhdGgucGFyc2UocHJvY2Vzcy5jd2QoKSkucm9vdFxuXG5jb25zdCBfX3dhc2kgPSBuZXcgX19ub2RlV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG4gIGVudjogcHJvY2Vzcy5lbnYsXG4gIHByZW9wZW5zOiB7XG4gICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgfVxufSlcblxuY29uc3QgX19lbW5hcGlDb250ZXh0ID0gX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCgpXG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmxldCBfX3dhc21GaWxlUGF0aCA9IF9fbm9kZVBhdGguam9pbihfX2Rpcm5hbWUsICcke3dhc21GaWxlTmFtZX0ud2FzbScpXG5jb25zdCBfX3dhc21EZWJ1Z0ZpbGVQYXRoID0gX19ub2RlUGF0aC5qb2luKF9fZGlybmFtZSwgJyR7d2FzbUZpbGVOYW1lfS5kZWJ1Zy53YXNtJylcblxuaWYgKF9fbm9kZUZzLmV4aXN0c1N5bmMoX193YXNtRGVidWdGaWxlUGF0aCkpIHtcbiAgX193YXNtRmlsZVBhdGggPSBfX3dhc21EZWJ1Z0ZpbGVQYXRoXG59IGVsc2UgaWYgKCFfX25vZGVGcy5leGlzdHNTeW5jKF9fd2FzbUZpbGVQYXRoKSkge1xuICB0cnkge1xuICAgIF9fd2FzbUZpbGVQYXRoID0gX19ub2RlUGF0aC5yZXNvbHZlKCcke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaScpXG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgJHt3YXNtRmlsZU5hbWV9Lndhc20gZmlsZSwgYW5kICR7cGFja2FnZU5hbWV9LXdhc20zMi13YXNpIHBhY2thZ2UgaXMgbm90IGluc3RhbGxlZC4nKVxuICB9XG59XG5cbmNvbnN0IHsgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLCBtb2R1bGU6IF9fd2FzaU1vZHVsZSwgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlIH0gPSBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMoX19ub2RlRnMucmVhZEZpbGVTeW5jKF9fd2FzbUZpbGVQYXRoKSwge1xuICBjb250ZXh0OiBfX2VtbmFwaUNvbnRleHQsXG4gIGFzeW5jV29ya1Bvb2xTaXplOiAoZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdGhyZWFkc1NpemVGcm9tRW52ID0gTnVtYmVyKHByb2Nlc3MuZW52Lk5BUElfUlNfQVNZTkNfV09SS19QT09MX1NJWkUgPz8gcHJvY2Vzcy5lbnYuVVZfVEhSRUFEUE9PTF9TSVpFKVxuICAgIC8vIE5hTiA+IDAgaXMgZmFsc2VcbiAgICBpZiAodGhyZWFkc1NpemVGcm9tRW52ID4gMCkge1xuICAgICAgcmV0dXJuIHRocmVhZHNTaXplRnJvbUVudlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNFxuICAgIH1cbiAgfSkoKSxcbiAgcmV1c2VXb3JrZXI6IHRydWUsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihfX25vZGVQYXRoLmpvaW4oX19kaXJuYW1lLCAnd2FzaS13b3JrZXIubWpzJyksIHtcbiAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgfSlcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5KF9fbm9kZUZzKShkYXRhKVxuICAgIH1cblxuICAgIC8vIFRoZSBtYWluIHRocmVhZCBvZiBOb2RlLmpzIHdhaXRzIGZvciBhbGwgdGhlIGFjdGl2ZSBoYW5kbGVzIGJlZm9yZSBleGl0aW5nLlxuICAgIC8vIEJ1dCBSdXN0IHRocmVhZHMgYXJlIG5ldmVyIHdhaXRlZCB3aXRob3V0IFxcYHRocmVhZDo6am9pblxcYC5cbiAgICAvLyBTbyBoZXJlIHdlIGhhY2sgdGhlIGNvZGUgb2YgTm9kZS5qcyB0byBwcmV2ZW50IHRoZSB3b3JrZXJzIGZyb20gYmVpbmcgcmVmZXJlbmNlZCAoYWN0aXZlKS5cbiAgICAvLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvMTllMGQ0NzI3MjhjNzlkNDE4Yjc0YmRkZmY1ODhiZWE3MGE0MDNkMC9saWIvaW50ZXJuYWwvd29ya2VyLmpzI0w0MTUsXG4gICAgLy8gYSB3b3JrZXIgaXMgY29uc2lzdCBvZiB0d28gaGFuZGxlczoga1B1YmxpY1BvcnQgYW5kIGtIYW5kbGUuXG4gICAge1xuICAgICAgY29uc3Qga1B1YmxpY1BvcnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtQdWJsaWNQb3J0XCIpXG4gICAgICApO1xuICAgICAgaWYgKGtQdWJsaWNQb3J0KSB7XG4gICAgICAgIHdvcmtlcltrUHVibGljUG9ydF0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtIYW5kbGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtIYW5kbGVcIilcbiAgICAgICk7XG4gICAgICBpZiAoa0hhbmRsZSkge1xuICAgICAgICB3b3JrZXJba0hhbmRsZV0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIHdvcmtlci51bnJlZigpO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VyXG4gIH0sXG4gIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICBtZW1vcnk6IF9fc2hhcmVkTWVtb3J5LFxuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0T2JqZWN0XG4gIH0sXG4gIGJlZm9yZUluaXQoeyBpbnN0YW5jZSB9KSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfX25hcGlfcmVnaXN0ZXJfXycpKSB7XG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbbmFtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pXG5gXG4iLCJleHBvcnQgY29uc3QgV0FTSV9XT1JLRVJfVEVNUExBVEUgPSBgaW1wb3J0IGZzIGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSBcIm5vZGU6bW9kdWxlXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IFdBU0kgfSBmcm9tIFwibm9kZTp3YXNpXCI7XG5pbXBvcnQgeyBwYXJlbnRQb3J0LCBXb3JrZXIgfSBmcm9tIFwibm9kZTp3b3JrZXJfdGhyZWFkc1wiO1xuXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuXG5jb25zdCB7IGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMsIE1lc3NhZ2VIYW5kbGVyLCBnZXREZWZhdWx0Q29udGV4dCB9ID0gcmVxdWlyZShcIkBuYXBpLXJzL3dhc20tcnVudGltZVwiKTtcblxuaWYgKHBhcmVudFBvcnQpIHtcbiAgcGFyZW50UG9ydC5vbihcIm1lc3NhZ2VcIiwgKGRhdGEpID0+IHtcbiAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSh7IGRhdGEgfSk7XG4gIH0pO1xufVxuXG5PYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgc2VsZjogZ2xvYmFsVGhpcyxcbiAgcmVxdWlyZSxcbiAgV29ya2VyLFxuICBpbXBvcnRTY3JpcHRzOiBmdW5jdGlvbiAoZikge1xuICAgIDsoMCwgZXZhbCkoZnMucmVhZEZpbGVTeW5jKGYsIFwidXRmOFwiKSArIFwiLy8jIHNvdXJjZVVSTD1cIiArIGYpO1xuICB9LFxuICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChwYXJlbnRQb3J0KSB7XG4gICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9LFxufSk7XG5cbmNvbnN0IGVtbmFwaUNvbnRleHQgPSBnZXREZWZhdWx0Q29udGV4dCgpO1xuXG5jb25zdCBfX3Jvb3REaXIgPSBwYXJzZShwcm9jZXNzLmN3ZCgpKS5yb290O1xuXG5jb25zdCBoYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKHtcbiAgb25Mb2FkKHsgd2FzbU1vZHVsZSwgd2FzbU1lbW9yeSB9KSB7XG4gICAgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIHZlcnNpb246ICdwcmV2aWV3MScsXG4gICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyh3YXNtTW9kdWxlLCB7XG4gICAgICBjaGlsZFRocmVhZDogdHJ1ZSxcbiAgICAgIHdhc2ksXG4gICAgICBjb250ZXh0OiBlbW5hcGlDb250ZXh0LFxuICAgICAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICAgICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW52LFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICAgICAgbWVtb3J5OiB3YXNtTWVtb3J5XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufSk7XG5cbmdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgaGFuZGxlci5oYW5kbGUoZSk7XG59O1xuYFxuXG5leHBvcnQgY29uc3QgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nID0gKGZzOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGZzSW1wb3J0ID0gZnNcbiAgICA/IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSwgY3JlYXRlRnNQcm94eSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdcbmltcG9ydCB7IG1lbWZzRXhwb3J0ZWQgYXMgX19tZW1mc0V4cG9ydGVkIH0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lL2ZzJ1xuXG5jb25zdCBmcyA9IGNyZWF0ZUZzUHJveHkoX19tZW1mc0V4cG9ydGVkKWBcbiAgICA6IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdgXG4gIGNvbnN0IHdhc2lDcmVhdGlvbiA9IGZzXG4gICAgPyBgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIGZzLFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgJy8nOiAnLycsXG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICAgIHByaW50RXJyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgIH0pYFxuICAgIDogYGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgICAgcHJpbnRFcnI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIH0sXG4gICAgfSlgXG4gIHJldHVybiBgJHtmc0ltcG9ydH1cblxuY29uc3QgaGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcih7XG4gIG9uTG9hZCh7IHdhc21Nb2R1bGUsIHdhc21NZW1vcnkgfSkge1xuICAgICR7d2FzaUNyZWF0aW9ufVxuICAgIHJldHVybiBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jKHdhc21Nb2R1bGUsIHtcbiAgICAgIGNoaWxkVGhyZWFkOiB0cnVlLFxuICAgICAgd2FzaSxcbiAgICAgIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9LFxufSlcblxuZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICBoYW5kbGVyLmhhbmRsZShlKVxufVxuYFxufVxuIiwiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnbm9kZTpjcnlwdG8nXG5pbXBvcnQgeyBleGlzdHNTeW5jLCBta2RpclN5bmMsIHJtU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbm9kZTptb2R1bGUnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCB7IHBhcnNlLCBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuXG5pbXBvcnQgeyBCdWlsZE9wdGlvbnMgYXMgUmF3QnVpbGRPcHRpb25zIH0gZnJvbSAnLi4vZGVmL2J1aWxkLmpzJ1xuaW1wb3J0IHtcbiAgQ0xJX1ZFUlNJT04sXG4gIGNvcHlGaWxlQXN5bmMsXG4gIENyYXRlLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVFlQRV9ERUZfSEVBREVSLFxuICBmaWxlRXhpc3RzLFxuICBnZXRTeXN0ZW1EZWZhdWx0VGFyZ2V0LFxuICBnZXRUYXJnZXRMaW5rZXIsXG4gIG1rZGlyQXN5bmMsXG4gIE5hcGlDb25maWcsXG4gIHBhcnNlTWV0YWRhdGEsXG4gIHBhcnNlVHJpcGxlLFxuICBwcm9jZXNzVHlwZURlZixcbiAgcmVhZEZpbGVBc3luYyxcbiAgcmVhZE5hcGlDb25maWcsXG4gIFRhcmdldCxcbiAgdGFyZ2V0VG9FbnZWYXIsXG4gIHRyeUluc3RhbGxDYXJnb0JpbmFyeSxcbiAgdW5saW5rQXN5bmMsXG4gIHdyaXRlRmlsZUFzeW5jLFxuICBkaXJFeGlzdHNBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuaW1wb3J0IHsgY3JlYXRlQ2pzQmluZGluZywgY3JlYXRlRXNtQmluZGluZyB9IGZyb20gJy4vdGVtcGxhdGVzL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlV2FzaUJpbmRpbmcsXG4gIGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyxcbn0gZnJvbSAnLi90ZW1wbGF0ZXMvbG9hZC13YXNpLXRlbXBsYXRlLmpzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nLFxuICBXQVNJX1dPUktFUl9URU1QTEFURSxcbn0gZnJvbSAnLi90ZW1wbGF0ZXMvd2FzaS13b3JrZXItdGVtcGxhdGUuanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdidWlsZCcpXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpXG5cbnR5cGUgT3V0cHV0S2luZCA9ICdqcycgfCAnZHRzJyB8ICdub2RlJyB8ICdleGUnIHwgJ3dhc20nXG50eXBlIE91dHB1dCA9IHsga2luZDogT3V0cHV0S2luZDsgcGF0aDogc3RyaW5nIH1cblxudHlwZSBCdWlsZE9wdGlvbnMgPSBSYXdCdWlsZE9wdGlvbnMgJiB7IGNhcmdvT3B0aW9ucz86IHN0cmluZ1tdIH1cbnR5cGUgUGFyc2VkQnVpbGRPcHRpb25zID0gT21pdDxCdWlsZE9wdGlvbnMsICdjd2QnPiAmIHsgY3dkOiBzdHJpbmcgfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRQcm9qZWN0KHJhd09wdGlvbnM6IEJ1aWxkT3B0aW9ucykge1xuICBkZWJ1ZygnbmFwaSBidWlsZCBjb21tYW5kIHJlY2VpdmUgb3B0aW9uczogJU8nLCByYXdPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnM6IFBhcnNlZEJ1aWxkT3B0aW9ucyA9IHtcbiAgICBkdHNDYWNoZTogdHJ1ZSxcbiAgICAuLi5yYXdPcHRpb25zLFxuICAgIGN3ZDogcmF3T3B0aW9ucy5jd2QgPz8gcHJvY2Vzcy5jd2QoKSxcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVQYXRoID0gKC4uLnBhdGhzOiBzdHJpbmdbXSkgPT4gcmVzb2x2ZShvcHRpb25zLmN3ZCwgLi4ucGF0aHMpXG5cbiAgY29uc3QgbWFuaWZlc3RQYXRoID0gcmVzb2x2ZVBhdGgob3B0aW9ucy5tYW5pZmVzdFBhdGggPz8gJ0NhcmdvLnRvbWwnKVxuICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHBhcnNlTWV0YWRhdGEobWFuaWZlc3RQYXRoKVxuXG4gIGNvbnN0IGNyYXRlID0gbWV0YWRhdGEucGFja2FnZXMuZmluZCgocCkgPT4ge1xuICAgIC8vIHBhY2thZ2Ugd2l0aCBnaXZlbiBuYW1lXG4gICAgaWYgKG9wdGlvbnMucGFja2FnZSkge1xuICAgICAgcmV0dXJuIHAubmFtZSA9PT0gb3B0aW9ucy5wYWNrYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwLm1hbmlmZXN0X3BhdGggPT09IG1hbmlmZXN0UGF0aFxuICAgIH1cbiAgfSlcblxuICBpZiAoIWNyYXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1VuYWJsZSB0byBmaW5kIGNyYXRlIHRvIGJ1aWxkLiBJdCBzZWVtcyB5b3UgYXJlIHRyeWluZyB0byBidWlsZCBhIGNyYXRlIGluIGEgd29ya3NwYWNlLCB0cnkgdXNpbmcgYC0tcGFja2FnZWAgb3B0aW9uIHRvIHNwZWNpZnkgdGhlIHBhY2thZ2UgdG8gYnVpbGQuJyxcbiAgICApXG4gIH1cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcmVzb2x2ZVBhdGgoXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPz8gb3B0aW9ucy5wYWNrYWdlSnNvblBhdGggPz8gJ3BhY2thZ2UuanNvbicsXG4gICAgKSxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgY29uc3QgYnVpbGRlciA9IG5ldyBCdWlsZGVyKG1ldGFkYXRhLCBjcmF0ZSwgY29uZmlnLCBvcHRpb25zKVxuXG4gIHJldHVybiBidWlsZGVyLmJ1aWxkKClcbn1cblxuY2xhc3MgQnVpbGRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXJnczogc3RyaW5nW10gPSBbXVxuICBwcml2YXRlIHJlYWRvbmx5IGVudnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dHM6IE91dHB1dFtdID0gW11cblxuICBwcml2YXRlIHJlYWRvbmx5IHRhcmdldDogVGFyZ2V0XG4gIHByaXZhdGUgcmVhZG9ubHkgY3JhdGVEaXI6IHN0cmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dERpcjogc3RyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0RGlyOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBlbmFibGVUeXBlRGVmOiBib29sZWFuID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldGFkYXRhOiBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY3JhdGU6IENyYXRlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBOYXBpQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogUGFyc2VkQnVpbGRPcHRpb25zLFxuICApIHtcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0XG4gICAgICA/IHBhcnNlVHJpcGxlKG9wdGlvbnMudGFyZ2V0KVxuICAgICAgOiBwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVRcbiAgICAgICAgPyBwYXJzZVRyaXBsZShwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVQpXG4gICAgICAgIDogZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCgpXG4gICAgdGhpcy5jcmF0ZURpciA9IHBhcnNlKGNyYXRlLm1hbmlmZXN0X3BhdGgpLmRpclxuICAgIHRoaXMub3V0cHV0RGlyID0gcmVzb2x2ZShcbiAgICAgIHRoaXMub3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm91dHB1dERpciA/PyB0aGlzLmNyYXRlRGlyLFxuICAgIClcbiAgICB0aGlzLnRhcmdldERpciA9XG4gICAgICBvcHRpb25zLnRhcmdldERpciA/P1xuICAgICAgcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUX0RJUiA/P1xuICAgICAgbWV0YWRhdGEudGFyZ2V0X2RpcmVjdG9yeVxuICAgIHRoaXMuZW5hYmxlVHlwZURlZiA9IHRoaXMuY3JhdGUuZGVwZW5kZW5jaWVzLnNvbWUoXG4gICAgICAoZGVwKSA9PlxuICAgICAgICBkZXAubmFtZSA9PT0gJ25hcGktZGVyaXZlJyAmJlxuICAgICAgICAoZGVwLnVzZXNfZGVmYXVsdF9mZWF0dXJlcyB8fCBkZXAuZmVhdHVyZXMuaW5jbHVkZXMoJ3R5cGUtZGVmJykpLFxuICAgIClcblxuICAgIGlmICghdGhpcy5lbmFibGVUeXBlRGVmKSB7XG4gICAgICBjb25zdCByZXF1aXJlbWVudFdhcm5pbmcgPVxuICAgICAgICAnYG5hcGktZGVyaXZlYCBjcmF0ZSBpcyBub3QgdXNlZCBvciBgdHlwZS1kZWZgIGZlYXR1cmUgaXMgbm90IGVuYWJsZWQgZm9yIGBuYXBpLWRlcml2ZWAgY3JhdGUnXG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBXaWxsIHNraXAgYmluZGluZyBnZW5lcmF0aW9uIGZvciBcXGAubm9kZVxcYCwgXFxgLndhc2lcXGAgYW5kIFxcYC5kLnRzXFxgIGZpbGVzLmAsXG4gICAgICApXG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmR0cyB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZHRzSGVhZGVyIHx8XG4gICAgICAgIHRoaXMuY29uZmlnLmR0c0hlYWRlciB8fFxuICAgICAgICB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlXG4gICAgICApIHtcbiAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBcXGBkdHNcXGAgcmVsYXRlZCBvcHRpb25zIGFyZSBlbmFibGVkIGJ1dCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBjZHlMaWJOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnY2R5bGliJykpXG4gICAgICA/Lm5hbWVcbiAgfVxuXG4gIGdldCBiaW5OYW1lKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm9wdGlvbnMuYmluID8/XG4gICAgICAvLyBvbmx5IGF2YWlsYWJsZSBpZiBub3QgY2R5bGliIG9yIGJpbiBuYW1lIHNwZWNpZmllZFxuICAgICAgKHRoaXMuY2R5TGliTmFtZVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnYmluJykpPy5uYW1lKVxuICAgIClcbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCB3YXJuaW5nID1cbiAgICAgICAgJ01pc3NpbmcgYGNyYXRlLXR5cGUgPSBbXCJjZHlsaWJcIl1gIGluIFtsaWJdIGNvbmZpZy4gVGhlIGJ1aWxkIHJlc3VsdCB3aWxsIG5vdCBiZSBhdmFpbGFibGUgYXMgbm9kZSBhZGRvbi4nXG5cbiAgICAgIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgICAgZGVidWcud2Fybih3YXJuaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdhcm5pbmcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGlja0JpbmFyeSgpXG4gICAgICAuc2V0UGFja2FnZSgpXG4gICAgICAuc2V0RmVhdHVyZXMoKVxuICAgICAgLnNldFRhcmdldCgpXG4gICAgICAucGlja0Nyb3NzVG9vbGNoYWluKClcbiAgICAgIC5zZXRFbnZzKClcbiAgICAgIC5zZXRCeXBhc3NBcmdzKClcbiAgICAgIC5leGVjKClcbiAgfVxuXG4gIHByaXZhdGUgcGlja0Nyb3NzVG9vbGNoYWluKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU5hcGlDcm9zcykge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51c2VDcm9zcykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIHVzZSBib3RoIGAtLWNyb3NzYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLXVzZS1jcm9zc2Agd2lsbCBiZSBpZ25vcmVkLicsXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYm90aCBgLS1jcm9zcy1jb21waWxlYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLWNyb3NzLWNvbXBpbGVgIHdpbGwgYmUgaWdub3JlZC4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZlcnNpb24sIGRvd25sb2FkIH0gPSByZXF1aXJlKCdAbmFwaS1ycy9jcm9zcy10b29sY2hhaW4nKVxuXG4gICAgICBjb25zdCBhbGlhczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JzogJ3MzOTB4LWlibS1saW51eC1nbnUnLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b29sY2hhaW5QYXRoID0gam9pbihcbiAgICAgICAgaG9tZWRpcigpLFxuICAgICAgICAnLm5hcGktcnMnLFxuICAgICAgICAnY3Jvc3MtdG9vbGNoYWluJyxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgdGhpcy50YXJnZXQudHJpcGxlLFxuICAgICAgKVxuICAgICAgbWtkaXJTeW5jKHRvb2xjaGFpblBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICBpZiAoZXhpc3RzU3luYyhqb2luKHRvb2xjaGFpblBhdGgsICdwYWNrYWdlLmpzb24nKSkpIHtcbiAgICAgICAgZGVidWcoYFRvb2xjaGFpbiAke3Rvb2xjaGFpblBhdGh9IGV4aXN0cywgc2tpcCBleHRyYWN0aW5nYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhckFyY2hpdmUgPSBkb3dubG9hZChwcm9jZXNzLmFyY2gsIHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgICAgdGFyQXJjaGl2ZS51bnBhY2sodG9vbGNoYWluUGF0aClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVwcGVyQ2FzZVRhcmdldCA9IHRhcmdldFRvRW52VmFyKHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgIGNvbnN0IGNyb3NzVGFyZ2V0TmFtZSA9IGFsaWFzW3RoaXMudGFyZ2V0LnRyaXBsZV0gPz8gdGhpcy50YXJnZXQudHJpcGxlXG4gICAgICBjb25zdCBsaW5rZXJFbnYgPSBgQ0FSR09fVEFSR0VUXyR7dXBwZXJDYXNlVGFyZ2V0fV9MSU5LRVJgXG4gICAgICB0aGlzLmVudnNbbGlua2VyRW52XSA9IGpvaW4oXG4gICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWdjY2AsXG4gICAgICApXG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9TWVNST09UKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1NZU1JPT1RgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICBjcm9zc1RhcmdldE5hbWUsXG4gICAgICAgICAgJ3N5c3Jvb3QnLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9BUikge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9BUmBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgICdiaW4nLFxuICAgICAgICAgIGAke2Nyb3NzVGFyZ2V0TmFtZX0tYXJgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9SQU5MSUIpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfUkFOTElCYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1yYW5saWJgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9SRUFERUxGKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1JFQURFTEZgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LXJlYWRlbGZgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9DX0lOQ0xVREVfUEFUSCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9DX0lOQ0xVREVfUEFUSGBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgIGNyb3NzVGFyZ2V0TmFtZSxcbiAgICAgICAgICAnc3lzcm9vdCcsXG4gICAgICAgICAgJ3VzcicsXG4gICAgICAgICAgJ2luY2x1ZGUvJyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfQ0MpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQ0NgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWdjY2AsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9DWFhgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWcrK2AsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEFSR0VUX0NDPy5zdGFydHNXaXRoKCdjbGFuZycpIHx8XG4gICAgICAgIChwcm9jZXNzLmVudi5DQz8uc3RhcnRzV2l0aCgnY2xhbmcnKSAmJiAhcHJvY2Vzcy5lbnYuVEFSR0VUX0NDKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IFRBUkdFVF9DRkxBR1MgPSBwcm9jZXNzLmVudi5UQVJHRVRfQ0ZMQUdTID8/ICcnXG4gICAgICAgIHRoaXMuZW52cy5UQVJHRVRfQ0ZMQUdTID0gYC0tc3lzcm9vdD0ke3RoaXMuZW52cy5UQVJHRVRfU1lTUk9PVH0gLS1nY2MtdG9vbGNoYWluPSR7dG9vbGNoYWluUGF0aH0gJHtUQVJHRVRfQ0ZMQUdTfWBcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKHByb2Nlc3MuZW52LkNYWD8uc3RhcnRzV2l0aCgnY2xhbmcrKycpICYmICFwcm9jZXNzLmVudi5UQVJHRVRfQ1hYKSB8fFxuICAgICAgICBwcm9jZXNzLmVudi5UQVJHRVRfQ1hYPy5zdGFydHNXaXRoKCdjbGFuZysrJylcbiAgICAgICkge1xuICAgICAgICBjb25zdCBUQVJHRVRfQ1hYRkxBR1MgPSBwcm9jZXNzLmVudi5UQVJHRVRfQ1hYRkxBR1MgPz8gJydcbiAgICAgICAgdGhpcy5lbnZzLlRBUkdFVF9DWFhGTEFHUyA9IGAtLXN5c3Jvb3Q9JHt0aGlzLmVudnMuVEFSR0VUX1NZU1JPT1R9IC0tZ2NjLXRvb2xjaGFpbj0ke3Rvb2xjaGFpblBhdGh9ICR7VEFSR0VUX0NYWEZMQUdTfWBcbiAgICAgIH1cbiAgICAgIHRoaXMuZW52cy5QQVRIID0gdGhpcy5lbnZzLlBBVEhcbiAgICAgICAgPyBgJHt0b29sY2hhaW5QYXRofS9iaW46JHt0aGlzLmVudnMuUEFUSH06JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgICAgICAgOiBgJHt0b29sY2hhaW5QYXRofS9iaW46JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1Zy53YXJuKCdQaWNrIGNyb3NzIHRvb2xjaGFpbiBmYWlsZWQnLCBlIGFzIEVycm9yKVxuICAgICAgLy8gaWdub3JlLCBkbyBub3RoaW5nXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGV4ZWMoKSB7XG4gICAgZGVidWcoYFN0YXJ0IGJ1aWxkaW5nIGNyYXRlOiAke3RoaXMuY3JhdGUubmFtZX1gKVxuICAgIGRlYnVnKCcgICVpJywgYGNhcmdvICR7dGhpcy5hcmdzLmpvaW4oJyAnKX1gKVxuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gICAgY29uc3Qgd2F0Y2ggPSB0aGlzLm9wdGlvbnMud2F0Y2hcbiAgICBjb25zdCBidWlsZFRhc2sgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUNyb3NzICYmIHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdgLS11c2UtY3Jvc3NgIGFuZCBgLS1jcm9zcy1jb21waWxlYCBjYW4gbm90IGJlIHVzZWQgdG9nZXRoZXInLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYW5kID1cbiAgICAgICAgcHJvY2Vzcy5lbnYuQ0FSR08gPz8gKHRoaXMub3B0aW9ucy51c2VDcm9zcyA/ICdjcm9zcycgOiAnY2FyZ28nKVxuICAgICAgY29uc3QgYnVpbGRQcm9jZXNzID0gc3Bhd24oY29tbWFuZCwgdGhpcy5hcmdzLCB7XG4gICAgICAgIGVudjogeyAuLi5wcm9jZXNzLmVudiwgLi4udGhpcy5lbnZzIH0sXG4gICAgICAgIHN0ZGlvOiB3YXRjaCA/IFsnaW5oZXJpdCcsICdpbmhlcml0JywgJ3BpcGUnXSA6ICdpbmhlcml0JyxcbiAgICAgICAgY3dkOiB0aGlzLm9wdGlvbnMuY3dkLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSlcblxuICAgICAgYnVpbGRQcm9jZXNzLm9uY2UoJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgIGRlYnVnKCclaScsIGBCdWlsZCBjcmF0ZSAke3RoaXMuY3JhdGUubmFtZX0gc3VjY2Vzc2Z1bGx5IWApXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQnVpbGQgZmFpbGVkIHdpdGggZXhpdCBjb2RlICR7Y29kZX1gKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgYnVpbGRQcm9jZXNzLm9uY2UoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQnVpbGQgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZS5tZXNzYWdlfWAsIHsgY2F1c2U6IGUgfSkpXG4gICAgICB9KVxuXG4gICAgICAvLyB3YXRjaCBtb2RlIG9ubHksIHRoZXkgYXJlIHBpcGVkIHRocm91Z2ggc3RkZXJyXG4gICAgICBidWlsZFByb2Nlc3Muc3RkZXJyPy5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICBjb25zb2xlLmVycm9yKG91dHB1dClcbiAgICAgICAgaWYgKC9GaW5pc2hlZFxccyhgZGV2YHxgcmVsZWFzZWApLy50ZXN0KG91dHB1dCkpIHtcbiAgICAgICAgICB0aGlzLnBvc3RCdWlsZCgpLmNhdGNoKCgpID0+IHt9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgdGFzazogYnVpbGRUYXNrLnRoZW4oKCkgPT4gdGhpcy5wb3N0QnVpbGQoKSksXG4gICAgICBhYm9ydDogKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGlja0JpbmFyeSgpIHtcbiAgICBsZXQgc2V0ID0gZmFsc2VcbiAgICBpZiAodGhpcy5vcHRpb25zLndhdGNoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuQ0kpIHtcbiAgICAgICAgZGVidWcud2FybignV2F0Y2ggbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIENJIGVudmlyb25tZW50JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdVc2UgJWknLCAnY2FyZ28td2F0Y2gnKVxuICAgICAgICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkoJ2NhcmdvLXdhdGNoJywgJ3dhdGNoJylcbiAgICAgICAgLy8geWFybiBuYXBpIHdhdGNoIC0tdGFyZ2V0IHg4Nl82NC11bmtub3duLWxpbnV4LWdudSBbLS1jcm9zcy1jb21waWxlXVxuICAgICAgICAvLyA9PT0+XG4gICAgICAgIC8vIGNhcmdvIHdhdGNoIFsuLi5dIC0tIGJ1aWxkIC0tdGFyZ2V0IHg4Nl82NC11bmtub3duLWxpbnV4LWdudVxuICAgICAgICAvLyBjYXJnbyB3YXRjaCBbLi4uXSAtLSB6aWdidWlsZCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnVcbiAgICAgICAgdGhpcy5hcmdzLnB1c2goXG4gICAgICAgICAgJ3dhdGNoJyxcbiAgICAgICAgICAnLS13aHknLFxuICAgICAgICAgICctaScsXG4gICAgICAgICAgJyoue2pzLHRzLG5vZGV9JyxcbiAgICAgICAgICAnLXcnLFxuICAgICAgICAgIHRoaXMuY3JhdGVEaXIsXG4gICAgICAgICAgJy0tJyxcbiAgICAgICAgICAnY2FyZ28nLFxuICAgICAgICAgICdidWlsZCcsXG4gICAgICAgIClcbiAgICAgICAgc2V0ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gd2luMzIgcGxhdGZvcm0gb24gd2luMzIgcGxhdGZvcm0gd2hpY2ggaXMgdW5uZWNlc3NhcnkuJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGNhcmdvLXh3aW4gdG8gY3Jvc3MgY29tcGlsZSB0byB3aW4zMiBwbGF0Zm9ybVxuICAgICAgICAgIGRlYnVnKCdVc2UgJWknLCAnY2FyZ28teHdpbicpXG4gICAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby14d2luJywgJ3h3aW4nKVxuICAgICAgICAgIHRoaXMuYXJncy5wdXNoKCd4d2luJywgJ2J1aWxkJylcbiAgICAgICAgICBpZiAodGhpcy50YXJnZXQuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgICAgICAgICB0aGlzLmVudnMuWFdJTl9BUkNIID0gJ3g4NidcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdsaW51eCcgJiZcbiAgICAgICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnICYmXG4gICAgICAgICAgdGhpcy50YXJnZXQuYXJjaCA9PT0gcHJvY2Vzcy5hcmNoICYmXG4gICAgICAgICAgKGZ1bmN0aW9uIChhYmk6IHN0cmluZyB8IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsaWJjVmVyc2lvblJ1bnRpbWUgPVxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIHByb2Nlc3MucmVwb3J0Py5nZXRSZXBvcnQoKT8uaGVhZGVyPy5nbGliY1ZlcnNpb25SdW50aW1lXG4gICAgICAgICAgICBjb25zdCBsaWJjID0gZ2xpYmNWZXJzaW9uUnVudGltZSA/ICdnbnUnIDogJ211c2wnXG4gICAgICAgICAgICByZXR1cm4gYWJpID09PSBsaWJjXG4gICAgICAgICAgfSkodGhpcy50YXJnZXQuYWJpKVxuICAgICAgICApIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gbGludXggdGFyZ2V0IG9uIGxpbnV4IHBsYXRmb3JtIHdoaWNoIGlzIHVubmVjZXNzYXJ5LicsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnZGFyd2luJyAmJlxuICAgICAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgICkge1xuICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gY3Jvc3MgY29tcGlsZSB0byBkYXJ3aW4gdGFyZ2V0IG9uIGRhcndpbiBwbGF0Zm9ybSB3aGljaCBpcyB1bm5lY2Vzc2FyeS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2UgY2FyZ28temlnYnVpbGQgdG8gY3Jvc3MgY29tcGlsZSB0byBvdGhlciBwbGF0Zm9ybXNcbiAgICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXppZ2J1aWxkJylcbiAgICAgICAgICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkoJ2NhcmdvLXppZ2J1aWxkJywgJ3ppZ2J1aWxkJylcbiAgICAgICAgICB0aGlzLmFyZ3MucHVzaCgnemlnYnVpbGQnKVxuICAgICAgICAgIHNldCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2V0KSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnYnVpbGQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRQYWNrYWdlKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYWNrYWdlKSB7XG4gICAgICBhcmdzLnB1c2goJy0tcGFja2FnZScsIHRoaXMub3B0aW9ucy5wYWNrYWdlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1iaW4nLCB0aGlzLmJpbk5hbWUpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnU2V0IHBhY2thZ2UgZmxhZ3M6ICcpXG4gICAgICBkZWJ1ZygnICAlTycsIGFyZ3MpXG4gICAgICB0aGlzLmFyZ3MucHVzaCguLi5hcmdzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldFRhcmdldCgpIHtcbiAgICBkZWJ1ZygnU2V0IGNvbXBpbGluZyB0YXJnZXQgdG86ICcpXG4gICAgZGVidWcoJyAgJWknLCB0aGlzLnRhcmdldC50cmlwbGUpXG5cbiAgICB0aGlzLmFyZ3MucHVzaCgnLS10YXJnZXQnLCB0aGlzLnRhcmdldC50cmlwbGUpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRFbnZzKCkge1xuICAgIC8vIFRZUEUgREVGXG4gICAgaWYgKHRoaXMuZW5hYmxlVHlwZURlZikge1xuICAgICAgdGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUiA9XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJbnRlcm1lZGlhdGVUeXBlRGVmRm9sZGVyKClcbiAgICAgIHRoaXMuc2V0Rm9yY2VCdWlsZEVudnModGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUilcbiAgICB9XG5cbiAgICAvLyBSVVNURkxBR1NcbiAgICBsZXQgcnVzdGZsYWdzID1cbiAgICAgIHByb2Nlc3MuZW52LlJVU1RGTEFHUyA/PyBwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9SVVNURkxBR1MgPz8gJydcblxuICAgIGlmIChcbiAgICAgIHRoaXMudGFyZ2V0LmFiaT8uaW5jbHVkZXMoJ211c2wnKSAmJlxuICAgICAgIXJ1c3RmbGFncy5pbmNsdWRlcygndGFyZ2V0LWZlYXR1cmU9LWNydC1zdGF0aWMnKVxuICAgICkge1xuICAgICAgcnVzdGZsYWdzICs9ICcgLUMgdGFyZ2V0LWZlYXR1cmU9LWNydC1zdGF0aWMnXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpcCAmJiAhcnVzdGZsYWdzLmluY2x1ZGVzKCdsaW5rLWFyZz0tcycpKSB7XG4gICAgICBydXN0ZmxhZ3MgKz0gJyAtQyBsaW5rLWFyZz0tcydcbiAgICB9XG5cbiAgICBpZiAocnVzdGZsYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5lbnZzLlJVU1RGTEFHUyA9IHJ1c3RmbGFnc1xuICAgIH1cbiAgICAvLyBFTkQgUlVTVEZMQUdTXG5cbiAgICAvLyBMSU5LRVJcbiAgICBjb25zdCBsaW5rZXIgPSB0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlXG4gICAgICA/IHZvaWQgMFxuICAgICAgOiBnZXRUYXJnZXRMaW5rZXIodGhpcy50YXJnZXQudHJpcGxlKVxuICAgIC8vIFRPRE86XG4gICAgLy8gICBkaXJlY3RseSBzZXQgQ0FSR09fVEFSR0VUXzx0YXJnZXQ+X0xJTktFUiB3aWxsIGNvdmVyIC5jYXJnby9jb25maWcudG9tbFxuICAgIC8vICAgd2lsbCBkZXRlY3QgYnkgY2FyZ28gY29uZmlnIHdoZW4gaXQgYmVjb21lcyBzdGFibGVcbiAgICAvLyAgIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9jYXJnby9pc3N1ZXMvOTMwMVxuICAgIGNvbnN0IGxpbmtlckVudiA9IGBDQVJHT19UQVJHRVRfJHt0YXJnZXRUb0VudlZhcihcbiAgICAgIHRoaXMudGFyZ2V0LnRyaXBsZSxcbiAgICApfV9MSU5LRVJgXG4gICAgaWYgKGxpbmtlciAmJiAhcHJvY2Vzcy5lbnZbbGlua2VyRW52XSAmJiAhdGhpcy5lbnZzW2xpbmtlckVudl0pIHtcbiAgICAgIHRoaXMuZW52c1tsaW5rZXJFbnZdID0gbGlua2VyXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICAgIHRoaXMuc2V0QW5kcm9pZEVudigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScpIHtcbiAgICAgIHRoaXMuc2V0V2FzaUVudigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnb3Blbmhhcm1vbnknKSB7XG4gICAgICB0aGlzLnNldE9wZW5IYXJtb255RW52KClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2V0IGVudnM6ICcpXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnZzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgIGRlYnVnKCcgICVpJywgYCR7a309JHt2fWApXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldEZvcmNlQnVpbGRFbnZzKHR5cGVEZWZUbXBGb2xkZXI6IHN0cmluZykge1xuICAgIC8vIGR5bmFtaWNhbGx5IGNoZWNrIGFsbCBuYXBpLXJzIGRlcHMgYW5kIHNldCBgTkFQSV9GT1JDRV9CVUlMRF97dXBwZXJjYXNlKHNuYWtlX2Nhc2UobmFtZSkpfSA9IHRpbWVzdGFtcGBcbiAgICB0aGlzLm1ldGFkYXRhLnBhY2thZ2VzLmZvckVhY2goKGNyYXRlKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGNyYXRlLmRlcGVuZGVuY2llcy5zb21lKChkKSA9PiBkLm5hbWUgPT09ICduYXBpLWRlcml2ZScpICYmXG4gICAgICAgICFleGlzdHNTeW5jKGpvaW4odHlwZURlZlRtcEZvbGRlciwgY3JhdGUubmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5lbnZzW1xuICAgICAgICAgIGBOQVBJX0ZPUkNFX0JVSUxEXyR7Y3JhdGUubmFtZS5yZXBsYWNlKC8tL2csICdfJykudG9VcHBlckNhc2UoKX1gXG4gICAgICAgIF0gPSBEYXRlLm5vdygpLnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRBbmRyb2lkRW52KCkge1xuICAgIGNvbnN0IHsgQU5EUk9JRF9OREtfTEFURVNUX0hPTUUgfSA9IHByb2Nlc3MuZW52XG4gICAgaWYgKCFBTkRST0lEX05ES19MQVRFU1RfSE9NRSkge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7Y29sb3JzLnJlZChcbiAgICAgICAgICAnQU5EUk9JRF9OREtfTEFURVNUX0hPTUUnLFxuICAgICAgICApfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBza2lwIGNyb3NzIGNvbXBpbGUgc2V0dXAgaWYgaG9zdCBpcyBhbmRyb2lkXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0QXJjaCA9IHRoaXMudGFyZ2V0LmFyY2ggPT09ICdhcm0nID8gJ2FybXY3YScgOiAnYWFyY2g2NCdcbiAgICBjb25zdCB0YXJnZXRQbGF0Zm9ybSA9XG4gICAgICB0aGlzLnRhcmdldC5hcmNoID09PSAnYXJtJyA/ICdhbmRyb2lkZWFiaTI0JyA6ICdhbmRyb2lkMjQnXG4gICAgY29uc3QgaG9zdFBsYXRmb3JtID1cbiAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgID8gJ2RhcndpbidcbiAgICAgICAgOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICAgICAgPyAnd2luZG93cydcbiAgICAgICAgICA6ICdsaW51eCdcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZW52cywge1xuICAgICAgQ0FSR09fVEFSR0VUX0FBUkNINjRfTElOVVhfQU5EUk9JRF9MSU5LRVI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC1hbmRyb2lkMjQtY2xhbmdgLFxuICAgICAgQ0FSR09fVEFSR0VUX0FSTVY3X0xJTlVYX0FORFJPSURFQUJJX0xJTktFUjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LWFuZHJvaWRlYWJpMjQtY2xhbmdgLFxuICAgICAgVEFSR0VUX0NDOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtJHt0YXJnZXRQbGF0Zm9ybX0tY2xhbmdgLFxuICAgICAgVEFSR0VUX0NYWDogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LSR7dGFyZ2V0UGxhdGZvcm19LWNsYW5nKytgLFxuICAgICAgVEFSR0VUX0FSOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluL2xsdm0tYXJgLFxuICAgICAgVEFSR0VUX1JBTkxJQjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi9sbHZtLXJhbmxpYmAsXG4gICAgICBBTkRST0lEX05ESzogQU5EUk9JRF9OREtfTEFURVNUX0hPTUUsXG4gICAgICBQQVRIOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluJHtwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJzsnIDogJzonfSR7cHJvY2Vzcy5lbnYuUEFUSH1gLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIHNldFdhc2lFbnYoKSB7XG4gICAgY29uc3QgZW1uYXBpID0gam9pbihcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnZW1uYXBpJyksXG4gICAgICAnLi4nLFxuICAgICAgJ2xpYicsXG4gICAgICAnd2FzbTMyLXdhc2ktdGhyZWFkcycsXG4gICAgKVxuICAgIHRoaXMuZW52cy5FTU5BUElfTElOS19ESVIgPSBlbW5hcGlcbiAgICBjb25zdCB7IFdBU0lfU0RLX1BBVEggfSA9IHByb2Nlc3MuZW52XG5cbiAgICBpZiAoV0FTSV9TREtfUEFUSCAmJiBleGlzdHNTeW5jKFdBU0lfU0RLX1BBVEgpKSB7XG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJX1BSRVZJRVcxX1RIUkVBRFNfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lQMV9MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSVAxX1RIUkVBRFNfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lQMl9MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NDJywgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ2NsYW5nJykpXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NYWCcsXG4gICAgICAgIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdjbGFuZysrJyksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQVInLCBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAnYXInKSlcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfUkFOTElCJyxcbiAgICAgICAgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ3JhbmxpYicpLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DRkxBR1MnLFxuICAgICAgICBgLS10YXJnZXQ9d2FzbTMyLXdhc2ktdGhyZWFkcyAtLXN5c3Jvb3Q9JHtXQVNJX1NES19QQVRIfS9zaGFyZS93YXNpLXN5c3Jvb3QgLXB0aHJlYWQgLW1sbHZtIC13YXNtLWVuYWJsZS1zamxqYCxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ1hYRkxBR1MnLFxuICAgICAgICBgLS10YXJnZXQ9d2FzbTMyLXdhc2ktdGhyZWFkcyAtLXN5c3Jvb3Q9JHtXQVNJX1NES19QQVRIfS9zaGFyZS93YXNpLXN5c3Jvb3QgLXB0aHJlYWQgLW1sbHZtIC13YXNtLWVuYWJsZS1zamxqYCxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgIGBUQVJHRVRfTERGTEFHU2AsXG4gICAgICAgIGAtZnVzZS1sZD0ke1dBU0lfU0RLX1BBVEh9L2Jpbi93YXNtLWxkIC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHNgLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0T3Blbkhhcm1vbnlFbnYoKSB7XG4gICAgY29uc3QgeyBPSE9TX1NES19QQVRILCBPSE9TX1NES19OQVRJVkUgfSA9IHByb2Nlc3MuZW52XG4gICAgY29uc3QgbmRrUGF0aCA9IE9IT1NfU0RLX1BBVEhcbiAgICAgID8gYCR7T0hPU19TREtfTkFUSVZFfS9uYXRpdmVgXG4gICAgICA6IE9IT1NfU0RLX05BVElWRVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoIW5ka1BhdGggJiYgcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ29wZW5oYXJtb255Jykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7Y29sb3JzLnJlZCgnT0hPU19TREtfUEFUSCcpfSBvciAke2NvbG9ycy5yZWQoJ09IT1NfU0RLX05BVElWRScpfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nYCxcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBsaW5rZXJOYW1lID0gYENBUkdPX1RBUkdFVF8ke3RoaXMudGFyZ2V0LnRyaXBsZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKX1fTElOS0VSYFxuICAgIGNvbnN0IHJhblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLXJhbmxpYmBcbiAgICBjb25zdCBhclBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLWFyYFxuICAgIGNvbnN0IGNjUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluLyR7dGhpcy50YXJnZXQudHJpcGxlfS1jbGFuZ2BcbiAgICBjb25zdCBjeHhQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vJHt0aGlzLnRhcmdldC50cmlwbGV9LWNsYW5nKytgXG4gICAgY29uc3QgYXNQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1hc2BcbiAgICBjb25zdCBsZFBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sZC5sbGRgXG4gICAgY29uc3Qgc3RyaXBQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1zdHJpcGBcbiAgICBjb25zdCBvYmpEdW1wUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqZHVtcGBcbiAgICBjb25zdCBvYmpDb3B5UGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqY29weWBcbiAgICBjb25zdCBubVBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW5tYFxuICAgIGNvbnN0IGJpblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2JpbmBcbiAgICBjb25zdCBsaWJQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9saWJgXG5cbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdMSUJDTEFOR19QQVRIJywgbGliUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdERVBfQVRPTUlDJywgJ2NsYW5nX3J0LmJ1aWx0aW5zJylcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKGxpbmtlck5hbWUsIGNjUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQ0MnLCBjY1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NYWCcsIGN4eFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0FSJywgYXJQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9SQU5MSUInLCByYW5QYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUycsIGFzUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTEQnLCBsZFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX1NUUklQJywgc3RyaXBQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9PQkpEVU1QJywgb2JqRHVtcFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX09CSkNPUFknLCBvYmpDb3B5UGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTk0nLCBubVBhdGgpXG4gICAgdGhpcy5lbnZzLlBBVEggPSBgJHtiaW5QYXRofSR7cHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6J30ke3Byb2Nlc3MuZW52LlBBVEh9YFxuICB9XG5cbiAgcHJpdmF0ZSBzZXRGZWF0dXJlcygpIHtcbiAgICBjb25zdCBhcmdzID0gW11cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbEZlYXR1cmVzICYmIHRoaXMub3B0aW9ucy5ub0RlZmF1bHRGZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHNwZWNpZnkgLS1hbGwtZmVhdHVyZXMgYW5kIC0tbm8tZGVmYXVsdC1mZWF0dXJlcyB0b2dldGhlcicsXG4gICAgICApXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsRmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1hbGwtZmVhdHVyZXMnKVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm5vRGVmYXVsdEZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tbm8tZGVmYXVsdC1mZWF0dXJlcycpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1mZWF0dXJlcycsIC4uLnRoaXMub3B0aW9ucy5mZWF0dXJlcylcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2V0IGZlYXR1cmVzIGZsYWdzOiAnKVxuICAgIGRlYnVnKCcgICVPJywgYXJncylcbiAgICB0aGlzLmFyZ3MucHVzaCguLi5hcmdzKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0QnlwYXNzQXJncygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbGVhc2UpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXJlbGVhc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tdmVyYm9zZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXREaXIpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXRhcmdldC1kaXInLCB0aGlzLm9wdGlvbnMudGFyZ2V0RGlyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvZmlsZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tcHJvZmlsZScsIHRoaXMub3B0aW9ucy5wcm9maWxlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubWFuaWZlc3RQYXRoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS1tYW5pZmVzdC1wYXRoJywgdGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNhcmdvT3B0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCguLi50aGlzLm9wdGlvbnMuY2FyZ29PcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlSW50ZXJtZWRpYXRlVHlwZURlZkZvbGRlcigpIHtcbiAgICBsZXQgZm9sZGVyID0gam9pbihcbiAgICAgIHRoaXMudGFyZ2V0RGlyLFxuICAgICAgJ25hcGktcnMnLFxuICAgICAgYCR7dGhpcy5jcmF0ZS5uYW1lfS0ke2NyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUodGhpcy5jcmF0ZS5tYW5pZmVzdF9wYXRoKVxuICAgICAgICAudXBkYXRlKENMSV9WRVJTSU9OKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKVxuICAgICAgICAuc3Vic3RyaW5nKDAsIDgpfWAsXG4gICAgKVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZHRzQ2FjaGUpIHtcbiAgICAgIHJtU3luYyhmb2xkZXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KVxuICAgICAgZm9sZGVyICs9IGBfJHtEYXRlLm5vdygpfWBcbiAgICB9XG5cbiAgICBta2RpckFzeW5jKGZvbGRlciwgeyByZWN1cnNpdmU6IHRydWUgfSlcblxuICAgIHJldHVybiBmb2xkZXJcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcG9zdEJ1aWxkKCkge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5OmApXG4gICAgICBkZWJ1ZygnICAlaScsIHRoaXMub3V0cHV0RGlyKVxuICAgICAgYXdhaXQgbWtkaXJBc3luYyh0aGlzLm91dHB1dERpciwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIGRlYnVnKGBPdXRwdXQgZGlyZWN0b3J5IGNyZWF0ZWRgKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5ICR7dGhpcy5vdXRwdXREaXJ9YCwge1xuICAgICAgICBjYXVzZTogZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgd2FzbUJpbmFyeU5hbWUgPSBhd2FpdCB0aGlzLmNvcHlBcnRpZmFjdCgpXG5cbiAgICAvLyBvbmx5IGZvciBjZHlsaWJcbiAgICBpZiAodGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCBpZGVudHMgPSBhd2FpdCB0aGlzLmdlbmVyYXRlVHlwZURlZigpXG4gICAgICBjb25zdCBqc091dHB1dCA9IGF3YWl0IHRoaXMud3JpdGVKc0JpbmRpbmcoaWRlbnRzKVxuICAgICAgY29uc3Qgd2FzbUJpbmRpbmdzT3V0cHV0ID0gYXdhaXQgdGhpcy53cml0ZVdhc2lCaW5kaW5nKFxuICAgICAgICB3YXNtQmluYXJ5TmFtZSxcbiAgICAgICAgaWRlbnRzLFxuICAgICAgKVxuICAgICAgaWYgKGpzT3V0cHV0KSB7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGpzT3V0cHV0KVxuICAgICAgfVxuICAgICAgaWYgKHdhc21CaW5kaW5nc091dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaCguLi53YXNtQmluZGluZ3NPdXRwdXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb3B5QXJ0aWZhY3QoKSB7XG4gICAgY29uc3QgW3NyY05hbWUsIGRlc3ROYW1lLCB3YXNtQmluYXJ5TmFtZV0gPSB0aGlzLmdldEFydGlmYWN0TmFtZXMoKVxuICAgIGlmICghc3JjTmFtZSB8fCAhZGVzdE5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByb2ZpbGUgPVxuICAgICAgdGhpcy5vcHRpb25zLnByb2ZpbGUgPz8gKHRoaXMub3B0aW9ucy5yZWxlYXNlID8gJ3JlbGVhc2UnIDogJ2RlYnVnJylcbiAgICBjb25zdCBzcmMgPSBqb2luKHRoaXMudGFyZ2V0RGlyLCB0aGlzLnRhcmdldC50cmlwbGUsIHByb2ZpbGUsIHNyY05hbWUpXG4gICAgZGVidWcoYENvcHkgYXJ0aWZhY3QgZnJvbTogWyR7c3JjfV1gKVxuICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCBkZXN0TmFtZSlcbiAgICBjb25zdCBpc1dhc20gPSBkZXN0LmVuZHNXaXRoKCcud2FzbScpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoZGVzdCkpIHtcbiAgICAgICAgZGVidWcoJ09sZCBhcnRpZmFjdCBmb3VuZCwgcmVtb3ZlIGl0IGZpcnN0JylcbiAgICAgICAgYXdhaXQgdW5saW5rQXN5bmMoZGVzdClcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdDb3B5IGFydGlmYWN0IHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBpZiAoaXNXYXNtKSB7XG4gICAgICAgIGNvbnN0IHsgTW9kdWxlQ29uZmlnIH0gPSBhd2FpdCBpbXBvcnQoJ0BuYXBpLXJzL3dhc20tdG9vbHMnKVxuICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgZGVidWcgd2FzbSBtb2R1bGUnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbU1vZHVsZSA9IG5ldyBNb2R1bGVDb25maWcoKVxuICAgICAgICAgICAgLmdlbmVyYXRlRHdhcmYodHJ1ZSlcbiAgICAgICAgICAgIC5nZW5lcmF0ZU5hbWVTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAucHJlc2VydmVDb2RlVHJhbnNmb3JtKHRydWUpXG4gICAgICAgICAgICAuc3RyaWN0VmFsaWRhdGUoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoYXdhaXQgcmVhZEZpbGVBc3luYyhzcmMpKVxuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbUJpbmFyeSA9IGRlYnVnV2FzbU1vZHVsZS5lbWl0V2FzbSh0cnVlKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICAgICAgZGVzdC5yZXBsYWNlKC9cXC53YXNtJC8sICcuZGVidWcud2FzbScpLFxuICAgICAgICAgICAgZGVidWdXYXNtQmluYXJ5LFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgcmVsZWFzZSB3YXNtIG1vZHVsZScpXG4gICAgICAgICAgY29uc3QgcmVsZWFzZVdhc21Nb2R1bGUgPSBuZXcgTW9kdWxlQ29uZmlnKClcbiAgICAgICAgICAgIC5nZW5lcmF0ZUR3YXJmKGZhbHNlKVxuICAgICAgICAgICAgLmdlbmVyYXRlTmFtZVNlY3Rpb24oZmFsc2UpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKGZhbHNlKVxuICAgICAgICAgICAgLnByZXNlcnZlQ29kZVRyYW5zZm9ybShmYWxzZSlcbiAgICAgICAgICAgIC5zdHJpY3RWYWxpZGF0ZShmYWxzZSlcbiAgICAgICAgICAgIC5vbmx5U3RhYmxlRmVhdHVyZXMoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoZGVidWdXYXNtQmluYXJ5KVxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VXYXNtQmluYXJ5ID0gcmVsZWFzZVdhc21Nb2R1bGUuZW1pdFdhc20oZmFsc2UpXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGVzdCwgcmVsZWFzZVdhc21CaW5hcnkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSBkZWJ1ZyB3YXNtIG1vZHVsZTogJHsoZSBhcyBhbnkpLm1lc3NhZ2UgPz8gZX1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCBjb3B5RmlsZUFzeW5jKHNyYywgZGVzdClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgY29weUZpbGVBc3luYyhzcmMsIGRlc3QpXG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7XG4gICAgICAgIGtpbmQ6IGRlc3QuZW5kc1dpdGgoJy5ub2RlJykgPyAnbm9kZScgOiBpc1dhc20gPyAnd2FzbScgOiAnZXhlJyxcbiAgICAgICAgcGF0aDogZGVzdCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gd2FzbUJpbmFyeU5hbWUgPyBqb2luKHRoaXMub3V0cHV0RGlyLCB3YXNtQmluYXJ5TmFtZSkgOiBudWxsXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29weSBhcnRpZmFjdCcsIHsgY2F1c2U6IGUgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEFydGlmYWN0TmFtZXMoKSB7XG4gICAgaWYgKHRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3QgY2R5TGliID0gdGhpcy5jZHlMaWJOYW1lLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgICAgY29uc3Qgd2FzaVRhcmdldCA9IHRoaXMuY29uZmlnLnRhcmdldHMuZmluZCgodCkgPT4gdC5wbGF0Zm9ybSA9PT0gJ3dhc2knKVxuXG4gICAgICBjb25zdCBzcmNOYW1lID1cbiAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgICAgPyBgbGliJHtjZHlMaWJ9LmR5bGliYFxuICAgICAgICAgIDogdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICAgICAgICAgID8gYCR7Y2R5TGlifS5kbGxgXG4gICAgICAgICAgICA6IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScgfHwgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3YXNtJ1xuICAgICAgICAgICAgICA/IGAke2NkeUxpYn0ud2FzbWBcbiAgICAgICAgICAgICAgOiBgbGliJHtjZHlMaWJ9LnNvYFxuXG4gICAgICBsZXQgZGVzdE5hbWUgPSB0aGlzLmNvbmZpZy5iaW5hcnlOYW1lXG4gICAgICAvLyBhZGQgcGxhdGZvcm0gc3VmZml4IHRvIGJpbmFyeSBuYW1lXG4gICAgICAvLyBpbmRleFsubGludXgteDY0LWdudV0ubm9kZVxuICAgICAgLy8gICAgICAgXl5eXl5eXl5eXl5eXl5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGxhdGZvcm0pIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gYC4ke3RoaXMudGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gXG4gICAgICB9XG4gICAgICBpZiAoc3JjTmFtZS5lbmRzV2l0aCgnLndhc20nKSkge1xuICAgICAgICBkZXN0TmFtZSArPSAnLndhc20nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0TmFtZSArPSAnLm5vZGUnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNyY05hbWUsXG4gICAgICAgIGRlc3ROYW1lLFxuICAgICAgICB3YXNpVGFyZ2V0XG4gICAgICAgICAgPyBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS4ke3dhc2lUYXJnZXQucGxhdGZvcm1BcmNoQUJJfS53YXNtYFxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIF1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmluTmFtZSkge1xuICAgICAgY29uc3Qgc3JjTmFtZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInID8gYCR7dGhpcy5iaW5OYW1lfS5leGVgIDogdGhpcy5iaW5OYW1lXG5cbiAgICAgIHJldHVybiBbc3JjTmFtZSwgc3JjTmFtZV1cbiAgICB9XG5cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVUeXBlRGVmKCkge1xuICAgIGNvbnN0IHR5cGVEZWZEaXIgPSB0aGlzLmVudnMuTkFQSV9UWVBFX0RFRl9UTVBfRk9MREVSXG4gICAgaWYgKCF0aGlzLmVuYWJsZVR5cGVEZWYgfHwgIShhd2FpdCBkaXJFeGlzdHNBc3luYyh0eXBlRGVmRGlyKSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCB0aGlzLm9wdGlvbnMuZHRzID8/ICdpbmRleC5kLnRzJylcblxuICAgIGxldCBoZWFkZXIgPSAnJ1xuICAgIGxldCBkdHMgPSAnJ1xuICAgIGxldCBleHBvcnRzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ub0R0c0hlYWRlcikge1xuICAgICAgY29uc3QgZHRzSGVhZGVyID0gdGhpcy5vcHRpb25zLmR0c0hlYWRlciA/PyB0aGlzLmNvbmZpZy5kdHNIZWFkZXJcbiAgICAgIC8vIGBkdHNIZWFkZXJGaWxlYCBpbiBjb25maWcgPiBgZHRzSGVhZGVyYCBpbiBjbGkgZmxhZyA+IGBkdHNIZWFkZXJgIGluIGNvbmZpZ1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmR0c0hlYWRlckZpbGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoZWFkZXIgPSBhd2FpdCByZWFkRmlsZUFzeW5jKFxuICAgICAgICAgICAgam9pbih0aGlzLm9wdGlvbnMuY3dkLCB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlKSxcbiAgICAgICAgICAgICd1dGYtOCcsXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVhZCBkdHMgaGVhZGVyIGZpbGUgJHt0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlfWAsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkdHNIZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyID0gZHRzSGVhZGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIgPSBERUZBVUxUX1RZUEVfREVGX0hFQURFUlxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHR5cGVEZWZEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuXG4gICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdObyB0eXBlIGRlZiBmaWxlcyBmb3VuZC4gU2tpcCBnZW5lcmF0aW5nIGR0cyBmaWxlLicpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGlmICghZmlsZS5pc0ZpbGUoKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGR0czogZmlsZUR0cywgZXhwb3J0czogZmlsZUV4cG9ydHMgfSA9IGF3YWl0IHByb2Nlc3NUeXBlRGVmKFxuICAgICAgICBqb2luKHR5cGVEZWZEaXIsIGZpbGUubmFtZSksXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb25zdEVudW0gPz8gdGhpcy5jb25maWcuY29uc3RFbnVtID8/IHRydWUsXG4gICAgICApXG5cbiAgICAgIGR0cyArPSBmaWxlRHRzXG4gICAgICBleHBvcnRzLnB1c2goLi4uZmlsZUV4cG9ydHMpXG4gICAgfVxuXG4gICAgaWYgKGR0cy5pbmRleE9mKCdFeHRlcm5hbE9iamVjdDwnKSA+IC0xKSB7XG4gICAgICBoZWFkZXIgKz0gYFxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRXh0ZXJuYWxPYmplY3Q8VD4ge1xuICByZWFkb25seSAnJzoge1xuICAgIHJlYWRvbmx5ICcnOiB1bmlxdWUgc3ltYm9sXG4gICAgW0s6IHN5bWJvbF06IFRcbiAgfVxufVxuYFxuICAgIH1cblxuICAgIGlmIChkdHMuaW5kZXhPZignVHlwZWRBcnJheScpID4gLTEpIHtcbiAgICAgIGhlYWRlciArPSBgXG5leHBvcnQgdHlwZSBUeXBlZEFycmF5ID0gSW50OEFycmF5IHwgVWludDhBcnJheSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSB8IFVpbnQzMkFycmF5IHwgRmxvYXQzMkFycmF5IHwgRmxvYXQ2NEFycmF5IHwgQmlnSW50NjRBcnJheSB8IEJpZ1VpbnQ2NEFycmF5XG5gXG4gICAgfVxuXG4gICAgZHRzID0gaGVhZGVyICsgZHRzXG5cbiAgICB0cnkge1xuICAgICAgZGVidWcoJ1dyaXRpbmcgdHlwZSBkZWYgdG86JylcbiAgICAgIGRlYnVnKCcgICVpJywgZGVzdClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIGR0cywgJ3V0Zi04JylcbiAgICAgIHRoaXMub3V0cHV0cy5wdXNoKHsga2luZDogJ2R0cycsIHBhdGg6IGRlc3QgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1Zy5lcnJvcignRmFpbGVkIHRvIHdyaXRlIHR5cGUgZGVmIGZpbGUnKVxuICAgICAgZGVidWcuZXJyb3IoZSBhcyBFcnJvcilcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3cml0ZUpzQmluZGluZyhpZGVudHM6IHN0cmluZ1tdKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMub3B0aW9ucy5wbGF0Zm9ybSB8fFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICB0aGlzLm9wdGlvbnMubm9Kc0JpbmRpbmcgfHxcbiAgICAgIGlkZW50cy5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm9wdGlvbnMuanNCaW5kaW5nID8/ICdpbmRleC5qcydcblxuICAgIGNvbnN0IGNyZWF0ZUJpbmRpbmcgPSB0aGlzLm9wdGlvbnMuZXNtID8gY3JlYXRlRXNtQmluZGluZyA6IGNyZWF0ZUNqc0JpbmRpbmdcbiAgICBjb25zdCBiaW5kaW5nID0gY3JlYXRlQmluZGluZyhcbiAgICAgIHRoaXMuY29uZmlnLmJpbmFyeU5hbWUsXG4gICAgICB0aGlzLmNvbmZpZy5wYWNrYWdlTmFtZSxcbiAgICAgIGlkZW50cyxcbiAgICApXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVzdCA9IGpvaW4odGhpcy5vdXRwdXREaXIsIG5hbWUpXG4gICAgICBkZWJ1ZygnV3JpdGluZyBqcyBiaW5kaW5nIHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkZXN0LCBiaW5kaW5nLCAndXRmLTgnKVxuICAgICAgcmV0dXJuIHsga2luZDogJ2pzJywgcGF0aDogZGVzdCB9IHNhdGlzZmllcyBPdXRwdXRcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSBqcyBiaW5kaW5nIGZpbGUnLCB7IGNhdXNlOiBlIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3cml0ZVdhc2lCaW5kaW5nKFxuICAgIGRpc3RGaWxlTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBpZGVudHM6IHN0cmluZ1tdLFxuICApIHtcbiAgICBpZiAoZGlzdEZpbGVOYW1lKSB7XG4gICAgICBjb25zdCB7IG5hbWUsIGRpciB9ID0gcGFyc2UoZGlzdEZpbGVOYW1lKVxuICAgICAgY29uc3QgYmluZGluZ1BhdGggPSBqb2luKGRpciwgYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0ud2FzaS5janNgKVxuICAgICAgY29uc3QgYnJvd3NlckJpbmRpbmdQYXRoID0gam9pbihcbiAgICAgICAgZGlyLFxuICAgICAgICBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgKVxuICAgICAgY29uc3Qgd29ya2VyUGF0aCA9IGpvaW4oZGlyLCAnd2FzaS13b3JrZXIubWpzJylcbiAgICAgIGNvbnN0IGJyb3dzZXJXb3JrZXJQYXRoID0gam9pbihkaXIsICd3YXNpLXdvcmtlci1icm93c2VyLm1qcycpXG4gICAgICBjb25zdCBicm93c2VyRW50cnlQYXRoID0gam9pbihkaXIsICdicm93c2VyLmpzJylcbiAgICAgIGNvbnN0IGV4cG9ydHNDb2RlID1cbiAgICAgICAgYG1vZHVsZS5leHBvcnRzID0gX19uYXBpTW9kdWxlLmV4cG9ydHNcXG5gICtcbiAgICAgICAgaWRlbnRzXG4gICAgICAgICAgLm1hcChcbiAgICAgICAgICAgIChpZGVudCkgPT5cbiAgICAgICAgICAgICAgYG1vZHVsZS5leHBvcnRzLiR7aWRlbnR9ID0gX19uYXBpTW9kdWxlLmV4cG9ydHMuJHtpZGVudH1gLFxuICAgICAgICAgIClcbiAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBiaW5kaW5nUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJpbmRpbmcoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy5wYWNrYWdlTmFtZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5pbml0aWFsTWVtb3J5LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/Lm1heGltdW1NZW1vcnksXG4gICAgICAgICkgK1xuICAgICAgICAgIGV4cG9ydHNDb2RlICtcbiAgICAgICAgICAnXFxuJyxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJCaW5kaW5nUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJyb3dzZXJCaW5kaW5nKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uaW5pdGlhbE1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5tYXhpbXVtTWVtb3J5LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmZzLFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmFzeW5jSW5pdCxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5idWZmZXIsXG4gICAgICAgICkgK1xuICAgICAgICAgIGBleHBvcnQgZGVmYXVsdCBfX25hcGlNb2R1bGUuZXhwb3J0c1xcbmAgK1xuICAgICAgICAgIGlkZW50c1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgKGlkZW50KSA9PlxuICAgICAgICAgICAgICAgIGBleHBvcnQgY29uc3QgJHtpZGVudH0gPSBfX25hcGlNb2R1bGUuZXhwb3J0cy4ke2lkZW50fWAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAgICdcXG4nLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyh3b3JrZXJQYXRoLCBXQVNJX1dPUktFUl9URU1QTEFURSwgJ3V0ZjgnKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJXb3JrZXJQYXRoLFxuICAgICAgICBjcmVhdGVXYXNpQnJvd3NlcldvcmtlckJpbmRpbmcodGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uZnMgPz8gZmFsc2UpLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYnJvd3NlckVudHJ5UGF0aCxcbiAgICAgICAgYGV4cG9ydCAqIGZyb20gJyR7dGhpcy5jb25maWcucGFja2FnZU5hbWV9LXdhc20zMi13YXNpJ1xcbmAsXG4gICAgICApXG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJpbmRpbmdQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYnJvd3NlckJpbmRpbmdQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogd29ya2VyUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJXb3JrZXJQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYnJvd3NlckVudHJ5UGF0aCB9LFxuICAgICAgXSBzYXRpc2ZpZXMgT3V0cHV0W11cbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBwcml2YXRlIHNldEVudklmTm90RXhpc3RzKGVudjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudltlbnZdKSB7XG4gICAgICB0aGlzLmVudnNbZW52XSA9IHZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUJ1aWxkQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydidWlsZCddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgdGhlIE5BUEktUlMgcHJvamVjdCcsXG4gIH0pXG5cbiAgdGFyZ2V0Pzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS10YXJnZXQsLXQnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnQnVpbGQgZm9yIHRoZSB0YXJnZXQgdHJpcGxlLCBieXBhc3NlZCB0byBgY2FyZ28gYnVpbGQgLS10YXJnZXRgJyxcbiAgfSlcblxuICBjd2Q/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIG1hbmlmZXN0UGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbWFuaWZlc3QtcGF0aCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYENhcmdvLnRvbWxgJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICB0YXJnZXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXRhcmdldC1kaXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnRGlyZWN0b3J5IGZvciBhbGwgY3JhdGUgZ2VuZXJhdGVkIGFydGlmYWN0cywgc2VlIGBjYXJnbyBidWlsZCAtLXRhcmdldC1kaXJgJyxcbiAgfSlcblxuICBvdXRwdXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8nLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB3aGVyZSBhbGwgdGhlIGJ1aWx0IGZpbGVzIHdvdWxkIGJlIHB1dC4gRGVmYXVsdCB0byB0aGUgY3JhdGUgZm9sZGVyJyxcbiAgfSlcblxuICBwbGF0Zm9ybT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1wbGF0Zm9ybScsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdBZGQgcGxhdGZvcm0gdHJpcGxlIHRvIHRoZSBnZW5lcmF0ZWQgbm9kZWpzIGJpbmRpbmcgZmlsZSwgZWc6IGBbbmFtZV0ubGludXgteDY0LWdudS5ub2RlYCcsXG4gIH0pXG5cbiAganNQYWNrYWdlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tanMtcGFja2FnZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhY2thZ2UgbmFtZSBpbiBnZW5lcmF0ZWQganMgYmluZGluZyBmaWxlLiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcnLFxuICB9KVxuXG4gIGNvbnN0RW51bT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1jb25zdC1lbnVtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBnZW5lcmF0ZSBjb25zdCBlbnVtIGZvciB0eXBlc2NyaXB0IGJpbmRpbmdzJyxcbiAgfSlcblxuICBqc0JpbmRpbmc/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWpzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggYW5kIGZpbGVuYW1lIG9mIGdlbmVyYXRlZCBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAuJyxcbiAgfSlcblxuICBub0pzQmluZGluZz86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1uby1qcycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIHRvIGRpc2FibGUgdGhlIGdlbmVyYXRpb24gSlMgYmluZGluZyBmaWxlLiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcuJyxcbiAgfSlcblxuICBkdHM/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWR0cycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIGFuZCBmaWxlbmFtZSBvZiBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAnLFxuICB9KVxuXG4gIGR0c0hlYWRlcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZHRzLWhlYWRlcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdDdXN0b20gZmlsZSBoZWFkZXIgZm9yIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBPbmx5IHdvcmtzIHdoZW4gYHR5cGVkZWZgIGZlYXR1cmUgZW5hYmxlZC4nLFxuICB9KVxuXG4gIG5vRHRzSGVhZGVyPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLW5vLWR0cy1oZWFkZXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnV2hldGhlciB0byBkaXNhYmxlIHRoZSBkZWZhdWx0IGZpbGUgaGVhZGVyIGZvciBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gT25seSB3b3JrcyB3aGVuIGB0eXBlZGVmYCBmZWF0dXJlIGVuYWJsZWQuJyxcbiAgfSlcblxuICBkdHNDYWNoZSA9IE9wdGlvbi5Cb29sZWFuKCctLWR0cy1jYWNoZScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdG8gZW5hYmxlIHRoZSBkdHMgY2FjaGUsIGRlZmF1bHQgdG8gdHJ1ZScsXG4gIH0pXG5cbiAgZXNtPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLWVzbScsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIHRvIGVtaXQgYW4gRVNNIEpTIGJpbmRpbmcgZmlsZSBpbnN0ZWFkIG9mIENKUyBmb3JtYXQuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4nLFxuICB9KVxuXG4gIHN0cmlwPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXN0cmlwLC1zJywge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBzdHJpcCB0aGUgbGlicmFyeSB0byBhY2hpZXZlIHRoZSBtaW5pbXVtIGZpbGUgc2l6ZScsXG4gIH0pXG5cbiAgcmVsZWFzZT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1yZWxlYXNlLC1yJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgaW4gcmVsZWFzZSBtb2RlJyxcbiAgfSlcblxuICB2ZXJib3NlPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXZlcmJvc2UsLXYnLCB7XG4gICAgZGVzY3JpcHRpb246ICdWZXJib3NlbHkgbG9nIGJ1aWxkIGNvbW1hbmQgdHJhY2UnLFxuICB9KVxuXG4gIGJpbj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYmluJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgb25seSB0aGUgc3BlY2lmaWVkIGJpbmFyeScsXG4gIH0pXG5cbiAgcGFja2FnZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZSwtcCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWxkIHRoZSBzcGVjaWZpZWQgbGlicmFyeSBvciB0aGUgb25lIGF0IGN3ZCcsXG4gIH0pXG5cbiAgcHJvZmlsZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcHJvZmlsZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWxkIGFydGlmYWN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvZmlsZScsXG4gIH0pXG5cbiAgY3Jvc3NDb21waWxlPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLWNyb3NzLWNvbXBpbGUsLXgnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnW2V4cGVyaW1lbnRhbF0gY3Jvc3MtY29tcGlsZSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgd2l0aCBgY2FyZ28teHdpbmAgb24gd2luZG93cyBhbmQgYGNhcmdvLXppZ2J1aWxkYCBvbiBvdGhlciBwbGF0Zm9ybScsXG4gIH0pXG5cbiAgdXNlQ3Jvc3M/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tdXNlLWNyb3NzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1tleHBlcmltZW50YWxdIHVzZSBbY3Jvc3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zcy1ycy9jcm9zcykgaW5zdGVhZCBvZiBgY2FyZ29gJyxcbiAgfSlcblxuICB1c2VOYXBpQ3Jvc3M/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tdXNlLW5hcGktY3Jvc3MnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnW2V4cGVyaW1lbnRhbF0gdXNlIEBuYXBpLXJzL2Nyb3NzLXRvb2xjaGFpbiB0byBjcm9zcy1jb21waWxlIExpbnV4IGFybS9hcm02NC94NjQgZ251IHRhcmdldHMuJyxcbiAgfSlcblxuICB3YXRjaD86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS13YXRjaCwtdycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICd3YXRjaCB0aGUgY3JhdGUgY2hhbmdlcyBhbmQgYnVpbGQgY29udGludW91c2x5IHdpdGggYGNhcmdvLXdhdGNoYCBjcmF0ZXMnLFxuICB9KVxuXG4gIGZlYXR1cmVzPzogc3RyaW5nW10gPSBPcHRpb24uQXJyYXkoJy0tZmVhdHVyZXMsLUYnLCB7XG4gICAgZGVzY3JpcHRpb246ICdTcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBmZWF0dXJlcyB0byBhY3RpdmF0ZScsXG4gIH0pXG5cbiAgYWxsRmVhdHVyZXM/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tYWxsLWZlYXR1cmVzJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQWN0aXZhdGUgYWxsIGF2YWlsYWJsZSBmZWF0dXJlcycsXG4gIH0pXG5cbiAgbm9EZWZhdWx0RmVhdHVyZXM/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tbm8tZGVmYXVsdC1mZWF0dXJlcycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RvIG5vdCBhY3RpdmF0ZSB0aGUgYGRlZmF1bHRgIGZlYXR1cmUnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgbWFuaWZlc3RQYXRoOiB0aGlzLm1hbmlmZXN0UGF0aCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICB0YXJnZXREaXI6IHRoaXMudGFyZ2V0RGlyLFxuICAgICAgb3V0cHV0RGlyOiB0aGlzLm91dHB1dERpcixcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAganNQYWNrYWdlTmFtZTogdGhpcy5qc1BhY2thZ2VOYW1lLFxuICAgICAgY29uc3RFbnVtOiB0aGlzLmNvbnN0RW51bSxcbiAgICAgIGpzQmluZGluZzogdGhpcy5qc0JpbmRpbmcsXG4gICAgICBub0pzQmluZGluZzogdGhpcy5ub0pzQmluZGluZyxcbiAgICAgIGR0czogdGhpcy5kdHMsXG4gICAgICBkdHNIZWFkZXI6IHRoaXMuZHRzSGVhZGVyLFxuICAgICAgbm9EdHNIZWFkZXI6IHRoaXMubm9EdHNIZWFkZXIsXG4gICAgICBkdHNDYWNoZTogdGhpcy5kdHNDYWNoZSxcbiAgICAgIGVzbTogdGhpcy5lc20sXG4gICAgICBzdHJpcDogdGhpcy5zdHJpcCxcbiAgICAgIHJlbGVhc2U6IHRoaXMucmVsZWFzZSxcbiAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZSxcbiAgICAgIGJpbjogdGhpcy5iaW4sXG4gICAgICBwYWNrYWdlOiB0aGlzLnBhY2thZ2UsXG4gICAgICBwcm9maWxlOiB0aGlzLnByb2ZpbGUsXG4gICAgICBjcm9zc0NvbXBpbGU6IHRoaXMuY3Jvc3NDb21waWxlLFxuICAgICAgdXNlQ3Jvc3M6IHRoaXMudXNlQ3Jvc3MsXG4gICAgICB1c2VOYXBpQ3Jvc3M6IHRoaXMudXNlTmFwaUNyb3NzLFxuICAgICAgd2F0Y2g6IHRoaXMud2F0Y2gsXG4gICAgICBmZWF0dXJlczogdGhpcy5mZWF0dXJlcyxcbiAgICAgIGFsbEZlYXR1cmVzOiB0aGlzLmFsbEZlYXR1cmVzLFxuICAgICAgbm9EZWZhdWx0RmVhdHVyZXM6IHRoaXMubm9EZWZhdWx0RmVhdHVyZXMsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgdGhlIE5BUEktUlMgcHJvamVjdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBCdWlsZCBmb3IgdGhlIHRhcmdldCB0cmlwbGUsIGJ5cGFzc2VkIHRvIGBjYXJnbyBidWlsZCAtLXRhcmdldGBcbiAgICovXG4gIHRhcmdldD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYENhcmdvLnRvbWxgXG4gICAqL1xuICBtYW5pZmVzdFBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogRGlyZWN0b3J5IGZvciBhbGwgY3JhdGUgZ2VuZXJhdGVkIGFydGlmYWN0cywgc2VlIGBjYXJnbyBidWlsZCAtLXRhcmdldC1kaXJgXG4gICAqL1xuICB0YXJnZXREaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gd2hlcmUgYWxsIHRoZSBidWlsdCBmaWxlcyB3b3VsZCBiZSBwdXQuIERlZmF1bHQgdG8gdGhlIGNyYXRlIGZvbGRlclxuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBZGQgcGxhdGZvcm0gdHJpcGxlIHRvIHRoZSBnZW5lcmF0ZWQgbm9kZWpzIGJpbmRpbmcgZmlsZSwgZWc6IGBbbmFtZV0ubGludXgteDY0LWdudS5ub2RlYFxuICAgKi9cbiAgcGxhdGZvcm0/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQYWNrYWdlIG5hbWUgaW4gZ2VuZXJhdGVkIGpzIGJpbmRpbmcgZmlsZS4gT25seSB3b3JrcyB3aXRoIGAtLXBsYXRmb3JtYCBmbGFnXG4gICAqL1xuICBqc1BhY2thZ2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIGdlbmVyYXRlIGNvbnN0IGVudW0gZm9yIHR5cGVzY3JpcHQgYmluZGluZ3NcbiAgICovXG4gIGNvbnN0RW51bT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFBhdGggYW5kIGZpbGVuYW1lIG9mIGdlbmVyYXRlZCBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAuXG4gICAqL1xuICBqc0JpbmRpbmc/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGlzYWJsZSB0aGUgZ2VuZXJhdGlvbiBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy5cbiAgICovXG4gIG5vSnNCaW5kaW5nPzogYm9vbGVhblxuICAvKipcbiAgICogUGF0aCBhbmQgZmlsZW5hbWUgb2YgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIFJlbGF0aXZlIHRvIGAtLW91dHB1dC1kaXJgXG4gICAqL1xuICBkdHM/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEN1c3RvbSBmaWxlIGhlYWRlciBmb3IgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIE9ubHkgd29ya3Mgd2hlbiBgdHlwZWRlZmAgZmVhdHVyZSBlbmFibGVkLlxuICAgKi9cbiAgZHRzSGVhZGVyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRpc2FibGUgdGhlIGRlZmF1bHQgZmlsZSBoZWFkZXIgZm9yIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBPbmx5IHdvcmtzIHdoZW4gYHR5cGVkZWZgIGZlYXR1cmUgZW5hYmxlZC5cbiAgICovXG4gIG5vRHRzSGVhZGVyPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgdGhlIGR0cyBjYWNoZSwgZGVmYXVsdCB0byB0cnVlXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGR0c0NhY2hlPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciB0byBlbWl0IGFuIEVTTSBKUyBiaW5kaW5nIGZpbGUgaW5zdGVhZCBvZiBDSlMgZm9ybWF0LiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcuXG4gICAqL1xuICBlc20/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHN0cmlwIHRoZSBsaWJyYXJ5IHRvIGFjaGlldmUgdGhlIG1pbmltdW0gZmlsZSBzaXplXG4gICAqL1xuICBzdHJpcD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEJ1aWxkIGluIHJlbGVhc2UgbW9kZVxuICAgKi9cbiAgcmVsZWFzZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFZlcmJvc2VseSBsb2cgYnVpbGQgY29tbWFuZCB0cmFjZVxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEJ1aWxkIG9ubHkgdGhlIHNwZWNpZmllZCBiaW5hcnlcbiAgICovXG4gIGJpbj86IHN0cmluZ1xuICAvKipcbiAgICogQnVpbGQgdGhlIHNwZWNpZmllZCBsaWJyYXJ5IG9yIHRoZSBvbmUgYXQgY3dkXG4gICAqL1xuICBwYWNrYWdlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBCdWlsZCBhcnRpZmFjdHMgd2l0aCB0aGUgc3BlY2lmaWVkIHByb2ZpbGVcbiAgICovXG4gIHByb2ZpbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIGNyb3NzLWNvbXBpbGUgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IHdpdGggYGNhcmdvLXh3aW5gIG9uIHdpbmRvd3MgYW5kIGBjYXJnby16aWdidWlsZGAgb24gb3RoZXIgcGxhdGZvcm1cbiAgICovXG4gIGNyb3NzQ29tcGlsZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIHVzZSBbY3Jvc3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zcy1ycy9jcm9zcykgaW5zdGVhZCBvZiBgY2FyZ29gXG4gICAqL1xuICB1c2VDcm9zcz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIHVzZSBAbmFwaS1ycy9jcm9zcy10b29sY2hhaW4gdG8gY3Jvc3MtY29tcGlsZSBMaW51eCBhcm0vYXJtNjQveDY0IGdudSB0YXJnZXRzLlxuICAgKi9cbiAgdXNlTmFwaUNyb3NzPzogYm9vbGVhblxuICAvKipcbiAgICogd2F0Y2ggdGhlIGNyYXRlIGNoYW5nZXMgYW5kIGJ1aWxkIGNvbnRpbnVvdXNseSB3aXRoIGBjYXJnby13YXRjaGAgY3JhdGVzXG4gICAqL1xuICB3YXRjaD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGZlYXR1cmVzIHRvIGFjdGl2YXRlXG4gICAqL1xuICBmZWF0dXJlcz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSBhbGwgYXZhaWxhYmxlIGZlYXR1cmVzXG4gICAqL1xuICBhbGxGZWF0dXJlcz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIERvIG5vdCBhY3RpdmF0ZSB0aGUgYGRlZmF1bHRgIGZlYXR1cmVcbiAgICovXG4gIG5vRGVmYXVsdEZlYXR1cmVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0QnVpbGRPcHRpb25zKG9wdGlvbnM6IEJ1aWxkT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGR0c0NhY2hlOiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmltcG9ydCB7IGJ1aWxkUHJvamVjdCB9IGZyb20gJy4uL2FwaS9idWlsZC5qcydcbmltcG9ydCB7IEJhc2VCdWlsZENvbW1hbmQgfSBmcm9tICcuLi9kZWYvYnVpbGQuanMnXG5pbXBvcnQgeyBkZWJ1Z0ZhY3RvcnkgfSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ2J1aWxkJylcblxuZXhwb3J0IGNsYXNzIEJ1aWxkQ29tbWFuZCBleHRlbmRzIEJhc2VCdWlsZENvbW1hbmQge1xuICBwaXBlID0gT3B0aW9uLlN0cmluZygnLS1waXBlJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BpcGUgYWxsIG91dHB1dHMgZmlsZSB0byBnaXZlbiBjb21tYW5kLiBlLmcuIGBuYXBpIGJ1aWxkIC0tcGlwZSBcIm5weCBwcmV0dGllciAtLXdyaXRlXCJgJyxcbiAgfSlcblxuICBjYXJnb09wdGlvbnMgPSBPcHRpb24uUmVzdCgpXG5cbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBjb25zdCB7IHRhc2sgfSA9IGF3YWl0IGJ1aWxkUHJvamVjdCh7XG4gICAgICAuLi50aGlzLmdldE9wdGlvbnMoKSxcbiAgICAgIGNhcmdvT3B0aW9uczogdGhpcy5jYXJnb09wdGlvbnMsXG4gICAgfSlcblxuICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCB0YXNrXG5cbiAgICBpZiAodGhpcy5waXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICAgIGRlYnVnKCdQaXBpbmcgb3V0cHV0IGZpbGUgdG8gY29tbWFuZDogJXMnLCB0aGlzLnBpcGUpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYCR7dGhpcy5waXBlfSAke291dHB1dC5wYXRofWAsIHtcbiAgICAgICAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihgRmFpbGVkIHRvIHBpcGUgb3V0cHV0IGZpbGUgJHtvdXRwdXQucGF0aH0gdG8gY29tbWFuZGApXG4gICAgICAgICAgZGVidWcuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDcmVhdGVOcG1EaXJzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydjcmVhdGUtbnBtLWRpcnMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBucG0gcGFja2FnZSBkaXJzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgbnBtIHBhY2thZ2UgZGlycyBmb3IgZGlmZmVyZW50IHBsYXRmb3Jtc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU5wbURpcnNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIERyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0Q3JlYXRlTnBtRGlyc09wdGlvbnMoXG4gIG9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zLFxuKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnc2VtdmVyJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyxcbiAgQ3JlYXRlTnBtRGlyc09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQge1xuICBkZWJ1Z0ZhY3RvcnksXG4gIHJlYWROYXBpQ29uZmlnLFxuICBta2RpckFzeW5jIGFzIHJhd01rZGlyQXN5bmMsXG4gIHBpY2ssXG4gIHdyaXRlRmlsZUFzeW5jIGFzIHJhd1dyaXRlRmlsZUFzeW5jLFxuICBUYXJnZXQsXG4gIHR5cGUgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnY3JlYXRlLW5wbS1kaXJzJylcblxuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlTWV0YSB7XG4gICdkaXN0LXRhZ3MnOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5wbURpcnModXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBhc3luYyBmdW5jdGlvbiBta2RpckFzeW5jKGRpcjogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1RyeSB0byBjcmVhdGUgZGlyOiAlaScsIGRpcilcbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGF3YWl0IHJhd01rZGlyQXN5bmMoZGlyLCB7XG4gICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUFzeW5jKGZpbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1dyaXRpbmcgZmlsZSAlaScsIGZpbGUpXG5cbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIGRlYnVnKGNvbnRlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCByYXdXcml0ZUZpbGVBc3luYyhmaWxlLCBjb250ZW50KVxuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IG5wbVBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpcilcblxuICBkZWJ1ZyhgUmVhZCBjb250ZW50IGZyb20gWyR7b3B0aW9ucy5jb25maWdQYXRoID8/IHBhY2thZ2VKc29uUGF0aH1dYClcblxuICBjb25zdCB7IHRhcmdldHMsIGJpbmFyeU5hbWUsIHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbiB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gICAgKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBqb2luKG5wbVBhdGgsIGAke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YClcbiAgICBhd2FpdCBta2RpckFzeW5jKHRhcmdldERpcilcblxuICAgIGNvbnN0IGJpbmFyeUZpbGVOYW1lID1cbiAgICAgIHRhcmdldC5hcmNoID09PSAnd2FzbTMyJ1xuICAgICAgICA/IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgOiBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9Lm5vZGVgXG4gICAgY29uc3Qgc2NvcGVkUGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzID0ge1xuICAgICAgbmFtZTogYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgICAgdmVyc2lvbjogcGFja2FnZUpzb24udmVyc2lvbixcbiAgICAgIGNwdTogdGFyZ2V0LmFyY2ggIT09ICd1bml2ZXJzYWwnID8gW3RhcmdldC5hcmNoXSA6IHVuZGVmaW5lZCxcbiAgICAgIG1haW46IGJpbmFyeUZpbGVOYW1lLFxuICAgICAgZmlsZXM6IFtiaW5hcnlGaWxlTmFtZV0sXG4gICAgICAuLi5waWNrKFxuICAgICAgICBwYWNrYWdlSnNvbixcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ2tleXdvcmRzJyxcbiAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICdhdXRob3JzJyxcbiAgICAgICAgJ2hvbWVwYWdlJyxcbiAgICAgICAgJ2xpY2Vuc2UnLFxuICAgICAgICAnZW5naW5lcycsXG4gICAgICAgICdyZXBvc2l0b3J5JyxcbiAgICAgICAgJ2J1Z3MnLFxuICAgICAgKSxcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcgPSBwaWNrKFxuICAgICAgICBwYWNrYWdlSnNvbi5wdWJsaXNoQ29uZmlnLFxuICAgICAgICAncmVnaXN0cnknLFxuICAgICAgICAnYWNjZXNzJyxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHRhcmdldC5hcmNoICE9PSAnd2FzbTMyJykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ub3MgPSBbdGFyZ2V0LnBsYXRmb3JtXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24ubWFpbiA9IGVudHJ5XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyID0gYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24uZmlsZXM/LnB1c2goXG4gICAgICAgIGVudHJ5LFxuICAgICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyLFxuICAgICAgICBgd2FzaS13b3JrZXIubWpzYCxcbiAgICAgICAgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCxcbiAgICAgIClcbiAgICAgIGxldCBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IHRydWVcbiAgICAgIGlmIChzY29wZWRQYWNrYWdlSnNvbi5lbmdpbmVzPy5ub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBtYWpvciB9ID0gcGFyc2Uoc2NvcGVkUGFja2FnZUpzb24uZW5naW5lcy5ub2RlKSA/PyB7XG4gICAgICAgICAgICBtYWpvcjogMCxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ham9yID49IDE0KSB7XG4gICAgICAgICAgICBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRSZXN0cmljdE5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmVuZ2luZXMgPSB7XG4gICAgICAgICAgbm9kZTogJz49MTQuMC4wJyxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2FzbVJ1bnRpbWUgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL0BuYXBpLXJzL3dhc20tcnVudGltZWAsXG4gICAgICApLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSBhcyBQcm9taXNlPFBhY2thZ2VNZXRhPilcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgJ0BuYXBpLXJzL3dhc20tcnVudGltZSc6IGBeJHt3YXNtUnVudGltZVsnZGlzdC10YWdzJ10ubGF0ZXN0fWAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5hYmkgPT09ICdnbnUnKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5saWJjID0gWydnbGliYyddXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYWJpID09PSAnbXVzbCcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmxpYmMgPSBbJ211c2wnXVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFBhY2thZ2VKc29uID0gam9pbih0YXJnZXREaXIsICdwYWNrYWdlLmpzb24nKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgdGFyZ2V0UGFja2FnZUpzb24sXG4gICAgICBKU09OLnN0cmluZ2lmeShzY29wZWRQYWNrYWdlSnNvbiwgbnVsbCwgMikgKyAnXFxuJyxcbiAgICApXG4gICAgY29uc3QgdGFyZ2V0UmVhZG1lID0gam9pbih0YXJnZXREaXIsICdSRUFETUUubWQnKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHRhcmdldFJlYWRtZSwgcmVhZG1lKHBhY2thZ2VOYW1lLCB0YXJnZXQpKVxuXG4gICAgZGVidWcuaW5mbyhgJHtwYWNrYWdlTmFtZX0gLSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0gY3JlYXRlZGApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZG1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHRhcmdldDogVGFyZ2V0KSB7XG4gIHJldHVybiBgIyBcXGAke3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9XFxgXG5cblRoaXMgaXMgdGhlICoqJHt0YXJnZXQudHJpcGxlfSoqIGJpbmFyeSBmb3IgXFxgJHtwYWNrYWdlTmFtZX1cXGBcbmBcbn1cbiIsImltcG9ydCB7IGNyZWF0ZU5wbURpcnMgfSBmcm9tICcuLi9hcGkvY3JlYXRlLW5wbS1kaXJzLmpzJ1xuaW1wb3J0IHsgQmFzZUNyZWF0ZU5wbURpcnNDb21tYW5kIH0gZnJvbSAnLi4vZGVmL2NyZWF0ZS1ucG0tZGlycy5qcydcblxuZXhwb3J0IGNsYXNzIENyZWF0ZU5wbURpcnNDb21tYW5kIGV4dGVuZHMgQmFzZUNyZWF0ZU5wbURpcnNDb21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCBjcmVhdGVOcG1EaXJzKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG4vKipcbiAqIEEgY29tbWFuZCB0aGF0IHByaW50cyB0aGUgdXNhZ2Ugb2YgYWxsIGNvbW1hbmRzLlxuICpcbiAqIFBhdGhzOiBgLWhgLCBgLS1oZWxwYFxuICovXG5leHBvcnQgY2xhc3MgSGVscENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kPGFueT4ge1xuICBzdGF0aWMgcGF0aHMgPSBbW2AtaGBdLCBbYC0taGVscGBdXVxuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IHRoaXMuY29udGV4dC5zdGRvdXQud3JpdGUodGhpcy5jbGkudXNhZ2UoKSlcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcbmltcG9ydCAqIGFzIHR5cGFuaW9uIGZyb20gJ3R5cGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZU5ld0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1snbmV3J11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdDcmVhdGUgYSBuZXcgcHJvamVjdCB3aXRoIHByZS1jb25maWd1cmVkIGJvaWxlcnBsYXRlJyxcbiAgfSlcblxuICAkJHBhdGggPSBPcHRpb24uU3RyaW5nKHsgcmVxdWlyZWQ6IGZhbHNlIH0pXG5cbiAgJCRuYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1uYW1lLC1uJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaWYgbm90IHByb3ZpZGVkJyxcbiAgfSlcblxuICBtaW5Ob2RlQXBpVmVyc2lvbiA9IE9wdGlvbi5TdHJpbmcoJy0tbWluLW5vZGUtYXBpLC12JywgJzQnLCB7XG4gICAgdmFsaWRhdG9yOiB0eXBhbmlvbi5pc051bWJlcigpLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG1pbmltdW0gTm9kZS1BUEkgdmVyc2lvbiB0byBzdXBwb3J0JyxcbiAgfSlcblxuICBwYWNrYWdlTWFuYWdlciA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1tYW5hZ2VyJywgJ3lhcm4nLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgcGFja2FnZSBtYW5hZ2VyIHRvIHVzZS4gT25seSBzdXBwb3J0IHlhcm4gNC54IGZvciBub3cuJyxcbiAgfSlcblxuICBsaWNlbnNlID0gT3B0aW9uLlN0cmluZygnLS1saWNlbnNlLC1sJywgJ01JVCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0xpY2Vuc2UgZm9yIG9wZW4tc291cmNlZCBwcm9qZWN0JyxcbiAgfSlcblxuICB0YXJnZXRzID0gT3B0aW9uLkFycmF5KCctLXRhcmdldHMsLXQnLCBbXSwge1xuICAgIGRlc2NyaXB0aW9uOiAnQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yLicsXG4gIH0pXG5cbiAgZW5hYmxlRGVmYXVsdFRhcmdldHMgPSBPcHRpb24uQm9vbGVhbignLS1lbmFibGUtZGVmYXVsdC10YXJnZXRzJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzJyxcbiAgfSlcblxuICBlbmFibGVBbGxUYXJnZXRzID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWFsbC10YXJnZXRzJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZW5hYmxlIGFsbCB0YXJnZXRzJyxcbiAgfSlcblxuICBlbmFibGVUeXBlRGVmID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLXR5cGUtZGVmJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1doZXRoZXIgZW5hYmxlIHRoZSBgdHlwZS1kZWZgIGZlYXR1cmUgZm9yIHR5cGVzY3JpcHQgZGVmaW5pdGlvbnMgYXV0by1nZW5lcmF0aW9uJyxcbiAgfSlcblxuICBlbmFibGVHaXRodWJBY3Rpb25zID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWdpdGh1Yi1hY3Rpb25zJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBnZW5lcmF0ZSBwcmVjb25maWd1cmVkIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93JyxcbiAgfSlcblxuICB0ZXN0RnJhbWV3b3JrID0gT3B0aW9uLlN0cmluZygnLS10ZXN0LWZyYW1ld29yaycsICdhdmEnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIEphdmFTY3JpcHQgdGVzdCBmcmFtZXdvcmsgdG8gdXNlLCBvbmx5IHN1cHBvcnQgYGF2YWAgZm9yIG5vdycsXG4gIH0pXG5cbiAgZHJ5UnVuID0gT3B0aW9uLkJvb2xlYW4oJy0tZHJ5LXJ1bicsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIHRvIHJ1biB0aGUgY29tbWFuZCBpbiBkcnktcnVuIG1vZGUnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHRoaXMuJCRwYXRoLFxuICAgICAgbmFtZTogdGhpcy4kJG5hbWUsXG4gICAgICBtaW5Ob2RlQXBpVmVyc2lvbjogdGhpcy5taW5Ob2RlQXBpVmVyc2lvbixcbiAgICAgIHBhY2thZ2VNYW5hZ2VyOiB0aGlzLnBhY2thZ2VNYW5hZ2VyLFxuICAgICAgbGljZW5zZTogdGhpcy5saWNlbnNlLFxuICAgICAgdGFyZ2V0czogdGhpcy50YXJnZXRzLFxuICAgICAgZW5hYmxlRGVmYXVsdFRhcmdldHM6IHRoaXMuZW5hYmxlRGVmYXVsdFRhcmdldHMsXG4gICAgICBlbmFibGVBbGxUYXJnZXRzOiB0aGlzLmVuYWJsZUFsbFRhcmdldHMsXG4gICAgICBlbmFibGVUeXBlRGVmOiB0aGlzLmVuYWJsZVR5cGVEZWYsXG4gICAgICBlbmFibGVHaXRodWJBY3Rpb25zOiB0aGlzLmVuYWJsZUdpdGh1YkFjdGlvbnMsXG4gICAgICB0ZXN0RnJhbWV3b3JrOiB0aGlzLnRlc3RGcmFtZXdvcmssXG4gICAgICBkcnlSdW46IHRoaXMuZHJ5UnVuLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwcm9qZWN0IHdpdGggcHJlLWNvbmZpZ3VyZWQgYm9pbGVycGxhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXdPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHdoZXJlIHRoZSBOQVBJLVJTIHByb2plY3Qgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgcGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSBpZiBub3QgcHJvdmlkZWRcbiAgICovXG4gIG5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIE5vZGUtQVBJIHZlcnNpb24gdG8gc3VwcG9ydFxuICAgKlxuICAgKiBAZGVmYXVsdCA0XG4gICAqL1xuICBtaW5Ob2RlQXBpVmVyc2lvbj86IG51bWJlclxuICAvKipcbiAgICogVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UuIE9ubHkgc3VwcG9ydCB5YXJuIDQueCBmb3Igbm93LlxuICAgKlxuICAgKiBAZGVmYXVsdCAneWFybidcbiAgICovXG4gIHBhY2thZ2VNYW5hZ2VyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdFxuICAgKlxuICAgKiBAZGVmYXVsdCAnTUlUJ1xuICAgKi9cbiAgbGljZW5zZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgdGFyZ2V0cz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSBkZWZhdWx0IHRhcmdldHNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlRGVmYXVsdFRhcmdldHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSBhbGwgdGFyZ2V0c1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZW5hYmxlQWxsVGFyZ2V0cz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZW5hYmxlIHRoZSBgdHlwZS1kZWZgIGZlYXR1cmUgZm9yIHR5cGVzY3JpcHQgZGVmaW5pdGlvbnMgYXV0by1nZW5lcmF0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZVR5cGVEZWY/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGdlbmVyYXRlIHByZWNvbmZpZ3VyZWQgR2l0SHViIEFjdGlvbnMgd29ya2Zsb3dcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlR2l0aHViQWN0aW9ucz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBKYXZhU2NyaXB0IHRlc3QgZnJhbWV3b3JrIHRvIHVzZSwgb25seSBzdXBwb3J0IGBhdmFgIGZvciBub3dcbiAgICpcbiAgICogQGRlZmF1bHQgJ2F2YSdcbiAgICovXG4gIHRlc3RGcmFtZXdvcms/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcnVuIHRoZSBjb21tYW5kIGluIGRyeS1ydW4gbW9kZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0TmV3T3B0aW9ucyhvcHRpb25zOiBOZXdPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgbWluTm9kZUFwaVZlcnNpb246IDQsXG4gICAgcGFja2FnZU1hbmFnZXI6ICd5YXJuJyxcbiAgICBsaWNlbnNlOiAnTUlUJyxcbiAgICB0YXJnZXRzOiBbXSxcbiAgICBlbmFibGVEZWZhdWx0VGFyZ2V0czogdHJ1ZSxcbiAgICBlbmFibGVBbGxUYXJnZXRzOiBmYWxzZSxcbiAgICBlbmFibGVUeXBlRGVmOiB0cnVlLFxuICAgIGVuYWJsZUdpdGh1YkFjdGlvbnM6IHRydWUsXG4gICAgdGVzdEZyYW1ld29yazogJ2F2YScsXG4gICAgZHJ5UnVuOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuLy8gQmFyZSBrZXlzIG1heSBvbmx5IGNvbnRhaW4gQVNDSUkgbGV0dGVycyxcbi8vIEFTQ0lJIGRpZ2l0cywgdW5kZXJzY29yZXMsIGFuZCBkYXNoZXMgKEEtWmEtejAtOV8tKS5cbmZ1bmN0aW9uIGpvaW5LZXlzKGtleXMpIHtcbiAgLy8gRG90dGVkIGtleXMgYXJlIGEgc2VxdWVuY2Ugb2YgYmFyZSBvciBxdW90ZWQga2V5cyBqb2luZWQgd2l0aCBhIGRvdC5cbiAgLy8gVGhpcyBhbGxvd3MgZm9yIGdyb3VwaW5nIHNpbWlsYXIgcHJvcGVydGllcyB0b2dldGhlcjpcbiAgcmV0dXJuIGtleXMubWFwKChzdHIpPT57XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDAgfHwgc3RyLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID8gSlNPTi5zdHJpbmdpZnkoc3RyKSA6IHN0cjtcbiAgfSkuam9pbihcIi5cIik7XG59XG5jbGFzcyBEdW1wZXIge1xuICBtYXhQYWQgPSAwO1xuICBzcmNPYmplY3Q7XG4gIG91dHB1dCA9IFtdO1xuICAjYXJyYXlUeXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHNyY09iamMpe1xuICAgIHRoaXMuc3JjT2JqZWN0ID0gc3JjT2JqYztcbiAgfVxuICBkdW1wKGZtdE9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLiNwcmludE9iamVjdCh0aGlzLnNyY09iamVjdCk7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLiNmb3JtYXQoZm10T3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0O1xuICB9XG4gICNwcmludE9iamVjdChvYmosIGtleXMgPSBbXSkge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBpbmxpbmVQcm9wcyA9IFtdO1xuICAgIGNvbnN0IG11bHRpbGluZVByb3BzID0gW107XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKXtcbiAgICAgIGlmICh0aGlzLiNpc1NpbXBseVNlcmlhbGl6YWJsZShvYmpbcHJvcF0pKSB7XG4gICAgICAgIGlubGluZVByb3BzLnB1c2gocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aWxpbmVQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzb3J0ZWRQcm9wcyA9IGlubGluZVByb3BzLmNvbmNhdChtdWx0aWxpbmVQcm9wcyk7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHNvcnRlZFByb3BzKXtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNkYXRlRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI3N0ckRlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI251bWJlckRlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jYm9vbERlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXlUeXBlID0gdGhpcy4jZ2V0VHlwZU9mQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoYXJyYXlUeXBlID09PSBcIk9OTFlfUFJJTUlUSVZFXCIpIHtcbiAgICAgICAgICBvdXQucHVzaCh0aGlzLiNhcnJheURlY2xhcmF0aW9uKFtcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5VHlwZSA9PT0gXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIikge1xuICAgICAgICAgIC8vIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgb3V0LnB1c2goXCJcIik7XG4gICAgICAgICAgICBvdXQucHVzaCh0aGlzLiNoZWFkZXJHcm91cChbXG4gICAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIG91dC5wdXNoKC4uLnRoaXMuI3ByaW50T2JqZWN0KHZhbHVlW2ldLCBbXG4gICAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbXBsZXggYXJyYXksIHVzZSB0aGUgaW5saW5lIGZvcm1hdC5cbiAgICAgICAgICBjb25zdCBzdHIgPSB2YWx1ZS5tYXAoKHgpPT50aGlzLiNwcmludEFzSW5saW5lVmFsdWUoeCkpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIG91dC5wdXNoKGAke3RoaXMuI2RlY2xhcmF0aW9uKFtcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdKX1bJHtzdHJ9XWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvdXQucHVzaChcIlwiKTtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jaGVhZGVyKFtcbiAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgIHByb3BcbiAgICAgICAgXSkpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB0b1BhcnNlID0gdmFsdWU7XG4gICAgICAgICAgb3V0LnB1c2goLi4udGhpcy4jcHJpbnRPYmplY3QodG9QYXJzZSwgW1xuICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdKSk7XG4gICAgICAgIH1cbiAgICAgIC8vIG91dC5wdXNoKC4uLnRoaXMuX3BhcnNlKHZhbHVlLCBgJHtwYXRofSR7cHJvcH0uYCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQucHVzaChcIlwiKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gICNpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgW1xuICAgICAgXCJzdHJpbmdcIixcbiAgICAgIFwibnVtYmVyXCIsXG4gICAgICBcImJvb2xlYW5cIlxuICAgIF0uaW5jbHVkZXModHlwZW9mIHZhbHVlKTtcbiAgfVxuICAjZ2V0VHlwZU9mQXJyYXkoYXJyKSB7XG4gICAgaWYgKHRoaXMuI2FycmF5VHlwZUNhY2hlLmhhcyhhcnIpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXJyYXlUeXBlQ2FjaGUuZ2V0KGFycik7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLiNkb0dldFR5cGVPZkFycmF5KGFycik7XG4gICAgdGhpcy4jYXJyYXlUeXBlQ2FjaGUuc2V0KGFyciwgdHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgI2RvR2V0VHlwZU9mQXJyYXkoYXJyKSB7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAvLyBhbnkgdHlwZSBzaG91bGQgYmUgZmluZVxuICAgICAgcmV0dXJuIFwiT05MWV9QUklNSVRJVkVcIjtcbiAgICB9XG4gICAgY29uc3Qgb25seVByaW1pdGl2ZSA9IHRoaXMuI2lzUHJpbWl0aXZlKGFyclswXSk7XG4gICAgaWYgKGFyclswXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gXCJNSVhFRFwiO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChvbmx5UHJpbWl0aXZlICE9PSB0aGlzLiNpc1ByaW1pdGl2ZShhcnJbaV0pIHx8IGFycltpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcIk1JWEVEXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbmx5UHJpbWl0aXZlID8gXCJPTkxZX1BSSU1JVElWRVwiIDogXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIjtcbiAgfVxuICAjcHJpbnRBc0lubGluZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGBcIiR7dGhpcy4jcHJpbnREYXRlKHZhbHVlKX1cImA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjb25zdCBzdHIgPSB2YWx1ZS5tYXAoKHgpPT50aGlzLiNwcmludEFzSW5saW5lVmFsdWUoeCkpLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGBbJHtzdHJ9XWA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RyID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2V5KT0+e1xuICAgICAgICByZXR1cm4gYCR7am9pbktleXMoW1xuICAgICAgICAgIGtleVxuICAgICAgICBdKX0gPSAkey8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMuI3ByaW50QXNJbmxpbmVWYWx1ZSh2YWx1ZVtrZXldKX1gO1xuICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYHske3N0cn19YDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoXCIpO1xuICB9XG4gICNpc1NpbXBseVNlcmlhbGl6YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdGhpcy4jZ2V0VHlwZU9mQXJyYXkodmFsdWUpICE9PSBcIk9OTFlfT0JKRUNUX0VYQ0xVRElOR19BUlJBWVwiO1xuICB9XG4gICNoZWFkZXIoa2V5cykge1xuICAgIHJldHVybiBgWyR7am9pbktleXMoa2V5cyl9XWA7XG4gIH1cbiAgI2hlYWRlckdyb3VwKGtleXMpIHtcbiAgICByZXR1cm4gYFtbJHtqb2luS2V5cyhrZXlzKX1dXWA7XG4gIH1cbiAgI2RlY2xhcmF0aW9uKGtleXMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGpvaW5LZXlzKGtleXMpO1xuICAgIGlmICh0aXRsZS5sZW5ndGggPiB0aGlzLm1heFBhZCkge1xuICAgICAgdGhpcy5tYXhQYWQgPSB0aXRsZS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aXRsZX0gPSBgO1xuICB9XG4gICNhcnJheURlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gIH1cbiAgI3N0ckRlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gIH1cbiAgI251bWJlckRlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX1uYW5gO1xuICAgIH1cbiAgICBzd2l0Y2godmFsdWUpe1xuICAgICAgY2FzZSBJbmZpbml0eTpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfWluZmA7XG4gICAgICBjYXNlIC1JbmZpbml0eTpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfS1pbmZgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dmFsdWV9YDtcbiAgICB9XG4gIH1cbiAgI2Jvb2xEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke3ZhbHVlfWA7XG4gIH1cbiAgI3ByaW50RGF0ZSh2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIGR0UGFkKHYsIGxQYWQgPSAyKSB7XG4gICAgICByZXR1cm4gdi5wYWRTdGFydChsUGFkLCBcIjBcIik7XG4gICAgfVxuICAgIGNvbnN0IG0gPSBkdFBhZCgodmFsdWUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IGQgPSBkdFBhZCh2YWx1ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgaCA9IGR0UGFkKHZhbHVlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbWluID0gZHRQYWQodmFsdWUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IHMgPSBkdFBhZCh2YWx1ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbXMgPSBkdFBhZCh2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKS50b1N0cmluZygpLCAzKTtcbiAgICAvLyBmb3JtYXR0ZWQgZGF0ZVxuICAgIGNvbnN0IGZEYXRhID0gYCR7dmFsdWUuZ2V0VVRDRnVsbFllYXIoKX0tJHttfS0ke2R9VCR7aH06JHttaW59OiR7c30uJHttc31gO1xuICAgIHJldHVybiBmRGF0YTtcbiAgfVxuICAjZGF0ZURlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dGhpcy4jcHJpbnREYXRlKHZhbHVlKX1gO1xuICB9XG4gICNmb3JtYXQob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBrZXlBbGlnbm1lbnQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByRGVjbGFyYXRpb24gPSAvXihcXFwiLipcXFwifFtePV0qKVxccz0vO1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dC5sZW5ndGg7IGkrKyl7XG4gICAgICBjb25zdCBsID0gdGhpcy5vdXRwdXRbaV07XG4gICAgICAvLyB3ZSBrZWVwIGVtcHR5IGVudHJ5IGZvciBhcnJheSBvZiBvYmplY3RzXG4gICAgICBpZiAobFswXSA9PT0gXCJbXCIgJiYgbFsxXSAhPT0gXCJbXCIpIHtcbiAgICAgICAgLy8gbm9uLWVtcHR5IG9iamVjdCB3aXRoIG9ubHkgc3Vib2JqZWN0cyBhcyBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICh0aGlzLm91dHB1dFtpICsgMV0gPT09IFwiXCIgJiYgdGhpcy5vdXRwdXRbaSArIDJdPy5zbGljZSgwLCBsLmxlbmd0aCkgPT09IGwuc2xpY2UoMCwgLTEpICsgXCIuXCIpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5QWxpZ25tZW50KSB7XG4gICAgICAgICAgY29uc3QgbSA9IHJEZWNsYXJhdGlvbi5leGVjKGwpO1xuICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGwucmVwbGFjZShtWzFdLCBtWzFdLnBhZEVuZCh0aGlzLm1heFBhZCkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5wdXNoKGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFuaW5nIG11bHRpcGxlIHNwYWNlc1xuICAgIGNvbnN0IGNsZWFuZWRPdXRwdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IGwgPSBvdXRbaV07XG4gICAgICBpZiAoIShsID09PSBcIlwiICYmIG91dFtpICsgMV0gPT09IFwiXCIpKSB7XG4gICAgICAgIGNsZWFuZWRPdXRwdXQucHVzaChsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuZWRPdXRwdXQ7XG4gIH1cbn1cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IHRvIGEge0BsaW5rIGh0dHBzOi8vdG9tbC5pbyB8IFRPTUx9IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZSBVc2FnZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gXCJAc3RkL3RvbWwvc3RyaW5naWZ5XCI7XG4gKiBpbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tIFwiQHN0ZC9hc3NlcnRcIjtcbiAqXG4gKiBjb25zdCBvYmogPSB7XG4gKiAgIHRpdGxlOiBcIlRPTUwgRXhhbXBsZVwiLFxuICogICBvd25lcjoge1xuICogICAgIG5hbWU6IFwiQm9iXCIsXG4gKiAgICAgYmlvOiBcIkJvYiBpcyBhIGNvb2wgZ3V5XCIsXG4gKiAgfVxuICogfTtcbiAqIGNvbnN0IHRvbWxTdHJpbmcgPSBzdHJpbmdpZnkob2JqKTtcbiAqIGFzc2VydEVxdWFscyh0b21sU3RyaW5nLCBgdGl0bGUgPSBcIlRPTUwgRXhhbXBsZVwiXFxuXFxuW293bmVyXVxcbm5hbWUgPSBcIkJvYlwiXFxuYmlvID0gXCJCb2IgaXMgYSBjb29sIGd1eVwiXFxuYCk7XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogU291cmNlIG9iamVjdFxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3Igc3RyaW5naWZ5aW5nLlxuICogQHJldHVybnMgVE9NTCBzdHJpbmdcbiAqLyBleHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IER1bXBlcihvYmopLmR1bXAob3B0aW9ucykuam9pbihcIlxcblwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ2lmeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBnaXZlbiBhcnJheSwgcmVtb3ZpbmcgYWxsIGVsZW1lbnRzIHRoYXQgZG8gbm90IG1hdGNoIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAqICoqaW4gcGxhY2UuIFRoaXMgbWVhbnMgYGFycmF5YCB3aWxsIGJlIG1vZGlmaWVkISoqLlxuICovIGV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJJblBsYWNlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgbGV0IG91dHB1dEluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBjdXIgb2YgYXJyYXkpe1xuICAgIGlmICghcHJlZGljYXRlKGN1cikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhcnJheVtvdXRwdXRJbmRleF0gPSBjdXI7XG4gICAgb3V0cHV0SW5kZXggKz0gMTtcbiAgfVxuICBhcnJheS5zcGxpY2Uob3V0cHV0SW5kZXgpO1xuICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdXRpbHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IGZpbHRlckluUGxhY2UgfSBmcm9tIFwiLi9fdXRpbHMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2UocmVjb3JkLCBvdGhlciwgb3B0aW9ucykge1xuICByZXR1cm4gZGVlcE1lcmdlSW50ZXJuYWwocmVjb3JkLCBvdGhlciwgbmV3IFNldCgpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZUludGVybmFsKHJlY29yZCwgb3RoZXIsIHNlZW4sIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KFtcbiAgICAuLi5nZXRLZXlzKHJlY29yZCksXG4gICAgLi4uZ2V0S2V5cyhvdGhlcilcbiAgXSk7XG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGtleSBvZiBvdGhlciBvYmplY3QgYW5kIHVzZSBjb3JyZWN0IG1lcmdpbmcgc3RyYXRlZ3lcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyl7XG4gICAgLy8gU2tpcCB0byBwcmV2ZW50IE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fIGFjY2Vzc29yIHByb3BlcnR5IGNhbGxzIG9uIG5vbi1EZW5vIHBsYXRmb3Jtc1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBhID0gcmVjb3JkW2tleV07XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKG90aGVyLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYiA9IG90aGVyW2tleV07XG4gICAgaWYgKGlzTm9uTnVsbE9iamVjdChhKSAmJiBpc05vbk51bGxPYmplY3QoYikgJiYgIXNlZW4uaGFzKGEpICYmICFzZWVuLmhhcyhiKSkge1xuICAgICAgc2Vlbi5hZGQoYSk7XG4gICAgICBzZWVuLmFkZChiKTtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPYmplY3RzKGEsIGIsIHNlZW4sIG9wdGlvbnMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIHZhbHVlXG4gICAgcmVzdWx0W2tleV0gPSBiO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMobGVmdCwgcmlnaHQsIHNlZW4sIG9wdGlvbnMgPSB7XG4gIGFycmF5czogXCJtZXJnZVwiLFxuICBzZXRzOiBcIm1lcmdlXCIsXG4gIG1hcHM6IFwibWVyZ2VcIlxufSkge1xuICAvLyBSZWN1cnNpdmVseSBtZXJnZSBtZXJnZWFibGUgb2JqZWN0c1xuICBpZiAoaXNNZXJnZWFibGUobGVmdCkgJiYgaXNNZXJnZWFibGUocmlnaHQpKSB7XG4gICAgcmV0dXJuIGRlZXBNZXJnZUludGVybmFsKGxlZnQsIHJpZ2h0LCBzZWVuLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShsZWZ0KSAmJiBpc0l0ZXJhYmxlKHJpZ2h0KSkge1xuICAgIC8vIEhhbmRsZSBhcnJheXNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsZWZ0KSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0KSkge1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gICAgLy8gSGFuZGxlIG1hcHNcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIE1hcCAmJiByaWdodCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgaWYgKG9wdGlvbnMubWFwcyA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKFtcbiAgICAgICAgICAuLi5sZWZ0LFxuICAgICAgICAgIC4uLnJpZ2h0XG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgc2V0c1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgU2V0ICYmIHJpZ2h0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBpZiAob3B0aW9ucy5zZXRzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoW1xuICAgICAgICAgIC4uLmxlZnQsXG4gICAgICAgICAgLi4ucmlnaHRcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByaWdodDtcbn1cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgbWVyZ2VhYmxlIG9yIG5vdFxuICogQnVpbHRpbnMgdGhhdCBsb29rIGxpa2Ugb2JqZWN0cywgbnVsbCBhbmQgdXNlciBkZWZpbmVkIGNsYXNzZXNcbiAqIGFyZSBub3QgY29uc2lkZXJlZCBtZXJnZWFibGUgKGl0IG1lYW5zIHRoYXQgcmVmZXJlbmNlIHdpbGwgYmUgY29waWVkKVxuICovIGZ1bmN0aW9uIGlzTWVyZ2VhYmxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gaXNJdGVyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gZ2V0S2V5cyhyZWNvcmQpIHtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyZWNvcmQpO1xuICBmaWx0ZXJJblBsYWNlKHJlc3VsdCwgKGtleSk9Pk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChyZWNvcmQsIGtleSkpO1xuICByZXN1bHQucHVzaCguLi5PYmplY3Qua2V5cyhyZWNvcmQpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZXBfbWVyZ2UuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gXCJAanNyL3N0ZF9fY29sbGVjdGlvbnMvZGVlcC1tZXJnZVwiO1xuLyoqXG4gKiBDb3B5IG9mIGBpbXBvcnQgeyBpc0xlYXAgfSBmcm9tIFwiQHN0ZC9kYXRldGltZVwiO2AgYmVjYXVzZSBpdCBjYW5ub3QgYmUgaW1wb3RlZCBhcyBsb25nIGFzIGl0IGlzIHVuc3RhYmxlLlxuICovIGZ1bmN0aW9uIGlzTGVhcCh5ZWFyTnVtYmVyKSB7XG4gIHJldHVybiB5ZWFyTnVtYmVyICUgNCA9PT0gMCAmJiB5ZWFyTnVtYmVyICUgMTAwICE9PSAwIHx8IHllYXJOdW1iZXIgJSA0MDAgPT09IDA7XG59XG5leHBvcnQgY2xhc3MgU2Nhbm5lciB7XG4gICN3aGl0ZXNwYWNlID0gL1sgXFx0XS87XG4gICNwb3NpdGlvbiA9IDA7XG4gICNzb3VyY2U7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSl7XG4gICAgdGhpcy4jc291cmNlID0gc291cmNlO1xuICB9XG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb247XG4gIH1cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIGluZGV4IC0gcmVsYXRpdmUgaW5kZXggZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqLyBjaGFyKGluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2VbdGhpcy4jcG9zaXRpb24gKyBpbmRleF0gPz8gXCJcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHNsaWNlZCBzdHJpbmdcbiAgICogQHBhcmFtIHN0YXJ0IC0gc3RhcnQgcG9zaXRpb24gcmVsYXRpdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqIEBwYXJhbSBlbmQgLSBlbmQgcG9zaXRpb24gcmVsYXRpdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqLyBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5zbGljZSh0aGlzLiNwb3NpdGlvbiArIHN0YXJ0LCB0aGlzLiNwb3NpdGlvbiArIGVuZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgcG9zaXRpb24gdG8gbmV4dFxuICAgKi8gbmV4dChjb3VudCA9IDEpIHtcbiAgICB0aGlzLiNwb3NpdGlvbiArPSBjb3VudDtcbiAgfVxuICBza2lwV2hpdGVzcGFjZXMoKSB7XG4gICAgd2hpbGUodGhpcy4jd2hpdGVzcGFjZS50ZXN0KHRoaXMuY2hhcigpKSAmJiAhdGhpcy5lb2YoKSl7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgLy8gSW52YWxpZCBpZiBjdXJyZW50IGNoYXIgaXMgb3RoZXIga2luZHMgb2Ygd2hpdGVzcGFjZVxuICAgIGlmICghdGhpcy5pc0N1cnJlbnRDaGFyRU9MKCkgJiYgL1xccy8udGVzdCh0aGlzLmNoYXIoKSkpIHtcbiAgICAgIGNvbnN0IGVzY2FwZWQgPSBcIlxcXFx1XCIgKyB0aGlzLmNoYXIoKS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jcG9zaXRpb247XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENhbm5vdCBwYXJzZSB0aGUgVE9NTDogSXQgY29udGFpbnMgaW52YWxpZCB3aGl0ZXNwYWNlIGF0IHBvc2l0aW9uICcke3Bvc2l0aW9ufSc6IFxcYCR7ZXNjYXBlZH1cXGBgKTtcbiAgICB9XG4gIH1cbiAgbmV4dFVudGlsQ2hhcihvcHRpb25zID0ge1xuICAgIHNraXBDb21tZW50czogdHJ1ZVxuICB9KSB7XG4gICAgd2hpbGUoIXRoaXMuZW9mKCkpe1xuICAgICAgY29uc3QgY2hhciA9IHRoaXMuY2hhcigpO1xuICAgICAgaWYgKHRoaXMuI3doaXRlc3BhY2UudGVzdChjaGFyKSB8fCB0aGlzLmlzQ3VycmVudENoYXJFT0woKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5za2lwQ29tbWVudHMgJiYgdGhpcy5jaGFyKCkgPT09IFwiI1wiKSB7XG4gICAgICAgIC8vIGVudGVyaW5nIGNvbW1lbnRcbiAgICAgICAgd2hpbGUoIXRoaXMuaXNDdXJyZW50Q2hhckVPTCgpICYmICF0aGlzLmVvZigpKXtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQb3NpdGlvbiByZWFjaGVkIEVPRiBvciBub3RcbiAgICovIGVvZigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPj0gdGhpcy4jc291cmNlLmxlbmd0aDtcbiAgfVxuICBpc0N1cnJlbnRDaGFyRU9MKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXIoKSA9PT0gXCJcXG5cIiB8fCB0aGlzLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIik7XG4gIH1cbiAgc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nLCB0aGlzLiNwb3NpdGlvbik7XG4gIH1cbiAgbWF0Y2gocmVnRXhwKSB7XG4gICAgaWYgKCFyZWdFeHAuc3RpY2t5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZ0V4cCAke3JlZ0V4cH0gZG9lcyBub3QgaGF2ZSBhIHN0aWNreSAneScgZmxhZ2ApO1xuICAgIH1cbiAgICByZWdFeHAubGFzdEluZGV4ID0gdGhpcy4jcG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5tYXRjaChyZWdFeHApO1xuICB9XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVXRpbGl0aWVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3VjY2Vzcyhib2R5KSB7XG4gIHJldHVybiB7XG4gICAgb2s6IHRydWUsXG4gICAgYm9keVxuICB9O1xufVxuZnVuY3Rpb24gZmFpbHVyZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBvazogZmFsc2VcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGUga2V5cyBhbmQgdmFsdWVzLlxuICpcbiAqIGUuZy4gYHVuZmxhdChbXCJhXCIsIFwiYlwiLCBcImNcIl0sIDEpYCByZXR1cm5zIGB7IGE6IHsgYjogeyBjOiAxIH0gfSB9YFxuICovIGV4cG9ydCBmdW5jdGlvbiB1bmZsYXQoa2V5cywgdmFsdWVzID0ge30pIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlUmlnaHQoKGFjYywga2V5KT0+KHtcbiAgICAgIFtrZXldOiBhY2NcbiAgICB9KSwgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRWYWx1ZSh0YXJnZXQsIGtleXMpIHtcbiAgY29uc3Qga2V5ID0ga2V5c1swXTtcbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgdGhlIFRPTUw6IGtleSBsZW5ndGggaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIHJldHVybiB0YXJnZXRba2V5XTtcbn1cbmZ1bmN0aW9uIGRlZXBBc3NpZ25UYWJsZSh0YXJnZXQsIHRhYmxlKSB7XG4gIGNvbnN0IHsga2V5cywgdHlwZSwgdmFsdWUgfSA9IHRhYmxlO1xuICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRUYXJnZXRWYWx1ZSh0YXJnZXQsIGtleXMpO1xuICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHVuZmxhdChrZXlzLCB2YWx1ZSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBjb25zdCBsYXN0ID0gY3VycmVudFZhbHVlLmF0KC0xKTtcbiAgICBkZWVwQXNzaWduKGxhc3QsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc09iamVjdChjdXJyZW50VmFsdWUpKSB7XG4gICAgZGVlcEFzc2lnbihjdXJyZW50VmFsdWUsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYXNzaWduXCIpO1xufVxuZnVuY3Rpb24gZGVlcEFzc2lnblRhYmxlQXJyYXkodGFyZ2V0LCB0YWJsZSkge1xuICBjb25zdCB7IHR5cGUsIGtleXMsIHZhbHVlIH0gPSB0YWJsZTtcbiAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB1bmZsYXQoa2V5cywgW1xuICAgICAgdmFsdWVcbiAgICBdKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgIGN1cnJlbnRWYWx1ZS5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc09iamVjdChjdXJyZW50VmFsdWUpKSB7XG4gICAgZGVlcEFzc2lnbihjdXJyZW50VmFsdWUsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYXNzaWduXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0LCBib2R5KSB7XG4gIHN3aXRjaChib2R5LnR5cGUpe1xuICAgIGNhc2UgXCJCbG9ja1wiOlxuICAgICAgcmV0dXJuIGRlZXBNZXJnZSh0YXJnZXQsIGJvZHkudmFsdWUpO1xuICAgIGNhc2UgXCJUYWJsZVwiOlxuICAgICAgcmV0dXJuIGRlZXBBc3NpZ25UYWJsZSh0YXJnZXQsIGJvZHkpO1xuICAgIGNhc2UgXCJUYWJsZUFycmF5XCI6XG4gICAgICByZXR1cm4gZGVlcEFzc2lnblRhYmxlQXJyYXkodGFyZ2V0LCBib2R5KTtcbiAgfVxufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQYXJzZXIgY29tYmluYXRvcnMgYW5kIGdlbmVyYXRvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIG9yKHBhcnNlcnMpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGZvciAoY29uc3QgcGFyc2Ugb2YgcGFyc2Vycyl7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZShzY2FubmVyKTtcbiAgICAgIGlmIChyZXN1bHQub2spIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBmYWlsdXJlKCk7XG4gIH07XG59XG4vKiogSm9pbiB0aGUgcGFyc2UgcmVzdWx0cyBvZiB0aGUgZ2l2ZW4gcGFyc2VyIGludG8gYW4gYXJyYXkuXG4gKlxuICogSWYgdGhlIHBhcnNlciBmYWlscyBhdCB0aGUgZmlyc3QgYXR0ZW1wdCwgaXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gKi8gZnVuY3Rpb24gam9pbihwYXJzZXIsIHNlcGFyYXRvcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghZmlyc3Qub2spIHJldHVybiBzdWNjZXNzKG91dCk7XG4gICAgb3V0LnB1c2goZmlyc3QuYm9keSk7XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgaWYgKCFTZXBhcmF0b3Ioc2Nhbm5lcikub2spIGJyZWFrO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3Mob3V0KTtcbiAgfTtcbn1cbi8qKiBKb2luIHRoZSBwYXJzZSByZXN1bHRzIG9mIHRoZSBnaXZlbiBwYXJzZXIgaW50byBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIHJlcXVpcmVzIHRoZSBwYXJzZXIgdG8gc3VjY2VlZCBhdCBsZWFzdCBvbmNlLlxuICovIGZ1bmN0aW9uIGpvaW4xKHBhcnNlciwgc2VwYXJhdG9yKSB7XG4gIGNvbnN0IFNlcGFyYXRvciA9IGNoYXJhY3RlcihzZXBhcmF0b3IpO1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgZmlyc3QgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFmaXJzdC5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBjb25zdCBvdXQgPSBbXG4gICAgICBmaXJzdC5ib2R5XG4gICAgXTtcbiAgICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgICBpZiAoIVNlcGFyYXRvcihzY2FubmVyKS5vaykgYnJlYWs7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke3NlcGFyYXRvcn1cImApO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcyhvdXQpO1xuICB9O1xufVxuZnVuY3Rpb24ga3Yoa2V5UGFyc2VyLCBzZXBhcmF0b3IsIHZhbHVlUGFyc2VyKSB7XG4gIGNvbnN0IFNlcGFyYXRvciA9IGNoYXJhY3RlcihzZXBhcmF0b3IpO1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgcG9zaXRpb24gPSBzY2FubmVyLnBvc2l0aW9uO1xuICAgIGNvbnN0IGtleSA9IGtleVBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIWtleS5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBjb25zdCBzZXAgPSBTZXBhcmF0b3Ioc2Nhbm5lcik7XG4gICAgaWYgKCFzZXAub2spIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihga2V5L3ZhbHVlIHBhaXIgZG9lc24ndCBoYXZlIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXZhbHVlLm9rKSB7XG4gICAgICBjb25zdCBsaW5lRW5kSW5kZXggPSBzY2FubmVyLnNvdXJjZS5pbmRleE9mKFwiXFxuXCIsIHNjYW5uZXIucG9zaXRpb24pO1xuICAgICAgY29uc3QgZW5kUG9zaXRpb24gPSBsaW5lRW5kSW5kZXggPiAwID8gbGluZUVuZEluZGV4IDogc2Nhbm5lci5zb3VyY2UubGVuZ3RoO1xuICAgICAgY29uc3QgbGluZSA9IHNjYW5uZXIuc291cmNlLnNsaWNlKHBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENhbm5vdCBwYXJzZSB2YWx1ZSBvbiBsaW5lICcke2xpbmV9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2Vzcyh1bmZsYXQoa2V5LmJvZHksIHZhbHVlLmJvZHkpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlKHBhcnNlcikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIGxldCBib2R5ID0ge307XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVzdWx0LmJvZHkpe1xuICAgICAgaWYgKHR5cGVvZiByZWNvcmQgPT09IFwib2JqZWN0XCIgJiYgcmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBkZWVwTWVyZ2UoYm9keSwgcmVjb3JkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiByZXBlYXQocGFyc2VyKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgICAgYm9keS5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICAgIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICAgIH1cbiAgICBpZiAoYm9keS5sZW5ndGggPT09IDApIHJldHVybiBmYWlsdXJlKCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiBzdXJyb3VuZChsZWZ0LCBwYXJzZXIsIHJpZ2h0KSB7XG4gIGNvbnN0IExlZnQgPSBjaGFyYWN0ZXIobGVmdCk7XG4gIGNvbnN0IFJpZ2h0ID0gY2hhcmFjdGVyKHJpZ2h0KTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGlmICghTGVmdChzY2FubmVyKS5vaykge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFSaWdodChzY2FubmVyKS5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb3QgY2xvc2VkIGJ5IFwiJHtyaWdodH1cIiBhZnRlciBzdGFydGVkIHdpdGggXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MocmVzdWx0LmJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gY2hhcmFjdGVyKHN0cikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aChzdHIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIHNjYW5uZXIubmV4dChzdHIubGVuZ3RoKTtcbiAgICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICAgIHJldHVybiBzdWNjZXNzKHVuZGVmaW5lZCk7XG4gIH07XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2VyIGNvbXBvbmVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBCQVJFX0tFWV9SRUdFWFAgPSAvW0EtWmEtejAtOV8tXSsveTtcbmV4cG9ydCBmdW5jdGlvbiBiYXJlS2V5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3Qga2V5ID0gc2Nhbm5lci5tYXRjaChCQVJFX0tFWV9SRUdFWFApPy5bMF07XG4gIGlmICgha2V5KSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoa2V5Lmxlbmd0aCk7XG4gIHJldHVybiBzdWNjZXNzKGtleSk7XG59XG5mdW5jdGlvbiBlc2NhcGVTZXF1ZW5jZShzY2FubmVyKSB7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJcXFxcXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICAvLyBTZWUgaHR0cHM6Ly90b21sLmlvL2VuL3YxLjAuMC1yYy4zI3N0cmluZ1xuICBzd2l0Y2goc2Nhbm5lci5jaGFyKCkpe1xuICAgIGNhc2UgXCJiXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxiXCIpO1xuICAgIGNhc2UgXCJ0XCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFx0XCIpO1xuICAgIGNhc2UgXCJuXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxuXCIpO1xuICAgIGNhc2UgXCJmXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxmXCIpO1xuICAgIGNhc2UgXCJyXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxyXCIpO1xuICAgIGNhc2UgXCJ1XCI6XG4gICAgY2FzZSBcIlVcIjpcbiAgICAgIHtcbiAgICAgICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgY29kZVBvaW50TGVuID0gc2Nhbm5lci5jaGFyKCkgPT09IFwidVwiID8gNCA6IDY7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHBhcnNlSW50KFwiMHhcIiArIHNjYW5uZXIuc2xpY2UoMSwgMSArIGNvZGVQb2ludExlbiksIDE2KTtcbiAgICAgICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgc2Nhbm5lci5uZXh0KGNvZGVQb2ludExlbiArIDEpO1xuICAgICAgICByZXR1cm4gc3VjY2VzcyhzdHIpO1xuICAgICAgfVxuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoJ1wiJyk7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoXCJcXFxcXCIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlOiBcXFxcJHtzY2FubmVyLmNoYXIoKX1gKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJhc2ljU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSAnXCInKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSAnXCInICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBpZiAoc2Nhbm5lci5jaGFyKCkgPT09IFwiXFxuXCIpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlNpbmdsZS1saW5lIHN0cmluZyBjYW5ub3QgY29udGFpbiBFT0xcIik7XG4gICAgfVxuICAgIGNvbnN0IGVzY2FwZWRDaGFyID0gZXNjYXBlU2VxdWVuY2Uoc2Nhbm5lcik7XG4gICAgaWYgKGVzY2FwZWRDaGFyLm9rKSB7XG4gICAgICBhY2MucHVzaChlc2NhcGVkQ2hhci5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgfVxuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBTaW5nbGUtbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIHNjYW5uZXIubmV4dCgpOyAvLyBza2lwIGxhc3QgJ1wiXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWxTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiJ1wiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSBcIidcIiAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJTaW5nbGUtbGluZSBzdHJpbmcgY2Fubm90IGNvbnRhaW4gRU9MXCIpO1xuICAgIH1cbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFNpbmdsZS1saW5lIHN0cmluZyBpcyBub3QgY2xvc2VkOlxcbiR7YWNjLmpvaW4oXCJcIil9YCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0KCk7IC8vIHNraXAgbGFzdCBcIidcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lQmFzaWNTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aCgnXCJcIlwiJykpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgzKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKExGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxyXFxuXCIpKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKENSTEYpIGlzIHRyaW1tZWRcbiAgICBzY2FubmVyLm5leHQoMik7XG4gIH1cbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKCFzY2FubmVyLnN0YXJ0c1dpdGgoJ1wiXCJcIicpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICAvLyBsaW5lIGVuZGluZyBiYWNrc2xhc2hcbiAgICBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcclxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVNlcXVlbmNlKHNjYW5uZXIpO1xuICAgIGlmIChlc2NhcGVkQ2hhci5vaykge1xuICAgICAgYWNjLnB1c2goZXNjYXBlZENoYXIuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5wdXNoKHNjYW5uZXIuY2hhcigpKTtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoc2Nhbm5lci5lb2YoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTXVsdGktbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIC8vIGlmIGVuZHMgd2l0aCA0IGBcImAsIHB1c2ggdGhlIGZpc3QgYFwiYCB0byBzdHJpbmdcbiAgaWYgKHNjYW5uZXIuY2hhcigzKSA9PT0gJ1wiJykge1xuICAgIGFjYy5wdXNoKCdcIicpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIHNjYW5uZXIubmV4dCgzKTsgLy8gc2tpcCBsYXN0ICdcIlwiXCJcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lTGl0ZXJhbFN0cmluZyhzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmICghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoMyk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcclxcblwiKSkge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChDUkxGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICB9XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE11bHRpLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICAvLyBpZiBlbmRzIHdpdGggNCBgJ2AsIHB1c2ggdGhlIGZpc3QgYCdgIHRvIHN0cmluZ1xuICBpZiAoc2Nhbm5lci5jaGFyKDMpID09PSBcIidcIikge1xuICAgIGFjYy5wdXNoKFwiJ1wiKTtcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfVxuICBzY2FubmVyLm5leHQoMyk7IC8vIHNraXAgbGFzdCBcIicnJ1wiXG4gIHJldHVybiBzdWNjZXNzKGFjYy5qb2luKFwiXCIpKTtcbn1cbmNvbnN0IEJPT0xFQU5fUkVHRVhQID0gLyg/OnRydWV8ZmFsc2UpXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYm9vbGVhbihzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChCT09MRUFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gc3RyaW5nID09PSBcInRydWVcIjtcbiAgcmV0dXJuIHN1Y2Nlc3ModmFsdWUpO1xufVxuY29uc3QgSU5GSU5JVFlfTUFQID0gbmV3IE1hcChbXG4gIFtcbiAgICBcImluZlwiLFxuICAgIEluZmluaXR5XG4gIF0sXG4gIFtcbiAgICBcIitpbmZcIixcbiAgICBJbmZpbml0eVxuICBdLFxuICBbXG4gICAgXCItaW5mXCIsXG4gICAgLUluZmluaXR5XG4gIF1cbl0pO1xuY29uc3QgSU5GSU5JVFlfUkVHRVhQID0gL1srLV0/aW5mXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gaW5maW5pdHkoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goSU5GSU5JVFlfUkVHRVhQKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgY29uc3Qgc3RyaW5nID0gbWF0Y2hbMF07XG4gIHNjYW5uZXIubmV4dChzdHJpbmcubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBJTkZJTklUWV9NQVAuZ2V0KHN0cmluZyk7XG4gIHJldHVybiBzdWNjZXNzKHZhbHVlKTtcbn1cbmNvbnN0IE5BTl9SRUdFWFAgPSAvWystXT9uYW5cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBuYW4oc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTkFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gTmFOO1xuICByZXR1cm4gc3VjY2Vzcyh2YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgZG90dGVkS2V5ID0gam9pbjEob3IoW1xuICBiYXJlS2V5LFxuICBiYXNpY1N0cmluZyxcbiAgbGl0ZXJhbFN0cmluZ1xuXSksIFwiLlwiKTtcbmNvbnN0IEJJTkFSWV9SRUdFWFAgPSAvMGJbMDFdKyg/Ol9bMDFdKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEJJTkFSWV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMik7XG4gIHJldHVybiBpc05hTihudW1iZXIpID8gZmFpbHVyZSgpIDogc3VjY2VzcyhudW1iZXIpO1xufVxuY29uc3QgT0NUQUxfUkVHRVhQID0gLzBvWzAtN10rKD86X1swLTddKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gb2N0YWwoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goT0NUQUxfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDgpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IEhFWF9SRUdFWFAgPSAvMHhbMC05YS1mXSsoPzpfWzAtOWEtZl0rKSpcXGIveWk7XG5leHBvcnQgZnVuY3Rpb24gaGV4KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEhFWF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IElOVEVHRVJfUkVHRVhQID0gL1srLV0/KD86MHxbMS05XVswLTldKig/Ol9bMC05XSspKilcXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKElOVEVHRVJfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgaW50ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoaW50KTtcbn1cbmNvbnN0IEZMT0FUX1JFR0VYUCA9IC9bKy1dPyg/OjB8WzEtOV1bMC05XSooPzpfWzAtOV0rKSopKD86XFwuWzAtOV0rKD86X1swLTldKykqKT8oPzplWystXT9bMC05XSsoPzpfWzAtOV0rKSopP1xcYi95aTtcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdChzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChGTE9BVF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBmbG9hdCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICBpZiAoaXNOYU4oZmxvYXQpKSByZXR1cm4gZmFpbHVyZSgpO1xuICByZXR1cm4gc3VjY2VzcyhmbG9hdCk7XG59XG5jb25zdCBEQVRFX1RJTUVfUkVHRVhQID0gLyg/PHllYXI+XFxkezR9KS0oPzxtb250aD5cXGR7Mn0pLSg/PGRheT5cXGR7Mn0pKD86WyAwLTlUWi46Ky1dKyk/XFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gZGF0ZVRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goREFURV9USU1FX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgLy8gc3BlY2lhbCBjYXNlIGlmIG1vbnRoIGlzIEZlYnJ1YXJ5XG4gIGlmIChncm91cHMubW9udGggPT0gXCIwMlwiKSB7XG4gICAgY29uc3QgZGF5cyA9IHBhcnNlSW50KGdyb3Vwcy5kYXkpO1xuICAgIGlmIChkYXlzID4gMjkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KGdyb3Vwcy55ZWFyKTtcbiAgICBpZiAoZGF5cyA+IDI4ICYmICFpc0xlYXAoeWVhcikpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZy50cmltKCkpO1xuICAvLyBpbnZhbGlkIGRhdGVcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgfVxuICByZXR1cm4gc3VjY2VzcyhkYXRlKTtcbn1cbmNvbnN0IExPQ0FMX1RJTUVfUkVHRVhQID0gLyhcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pKD86XFwuWzAtOV0rKT9cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTE9DQUxfVElNRV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICByZXR1cm4gc3VjY2VzcyhtYXRjaCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlWYWx1ZShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJbXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoc2Nhbm5lcik7XG4gICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgIGFycmF5LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gICAgLy8gbWF5IGhhdmUgYSBuZXh0IGl0ZW0sIGJ1dCB0cmFpbGluZyBjb21tYSBpcyBhbGxvd2VkIGF0IGFycmF5XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSBcIixcIikgYnJlYWs7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJdXCIpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFycmF5IGlzIG5vdCBjbG9zZWRcIik7XG4gIHNjYW5uZXIubmV4dCgpO1xuICByZXR1cm4gc3VjY2VzcyhhcnJheSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5saW5lVGFibGUoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigxKSA9PT0gXCJ9XCIpIHtcbiAgICBzY2FubmVyLm5leHQoMik7XG4gICAgcmV0dXJuIHN1Y2Nlc3Moe30pO1xuICB9XG4gIGNvbnN0IHBhaXJzID0gc3Vycm91bmQoXCJ7XCIsIGpvaW4ocGFpciwgXCIsXCIpLCBcIn1cIikoc2Nhbm5lcik7XG4gIGlmICghcGFpcnMub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIGxldCB0YWJsZSA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMuYm9keSl7XG4gICAgdGFibGUgPSBkZWVwTWVyZ2UodGFibGUsIHBhaXIpO1xuICB9XG4gIHJldHVybiBzdWNjZXNzKHRhYmxlKTtcbn1cbmV4cG9ydCBjb25zdCB2YWx1ZSA9IG9yKFtcbiAgbXVsdGlsaW5lQmFzaWNTdHJpbmcsXG4gIG11bHRpbGluZUxpdGVyYWxTdHJpbmcsXG4gIGJhc2ljU3RyaW5nLFxuICBsaXRlcmFsU3RyaW5nLFxuICBib29sZWFuLFxuICBpbmZpbml0eSxcbiAgbmFuLFxuICBkYXRlVGltZSxcbiAgbG9jYWxUaW1lLFxuICBiaW5hcnksXG4gIG9jdGFsLFxuICBoZXgsXG4gIGZsb2F0LFxuICBpbnRlZ2VyLFxuICBhcnJheVZhbHVlLFxuICBpbmxpbmVUYWJsZVxuXSk7XG5leHBvcnQgY29uc3QgcGFpciA9IGt2KGRvdHRlZEtleSwgXCI9XCIsIHZhbHVlKTtcbmV4cG9ydCBmdW5jdGlvbiBibG9jayhzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCByZXN1bHQgPSBtZXJnZShyZXBlYXQocGFpcikpKHNjYW5uZXIpO1xuICBpZiAocmVzdWx0Lm9rKSByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJCbG9ja1wiLFxuICAgIHZhbHVlOiByZXN1bHQuYm9keVxuICB9KTtcbiAgcmV0dXJuIGZhaWx1cmUoKTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUhlYWRlciA9IHN1cnJvdW5kKFwiW1wiLCBkb3R0ZWRLZXksIFwiXVwiKTtcbmV4cG9ydCBmdW5jdGlvbiB0YWJsZShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUhlYWRlcihzY2FubmVyKTtcbiAgaWYgKCFoZWFkZXIub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBiID0gYmxvY2soc2Nhbm5lcik7XG4gIHJldHVybiBzdWNjZXNzKHtcbiAgICB0eXBlOiBcIlRhYmxlXCIsXG4gICAga2V5czogaGVhZGVyLmJvZHksXG4gICAgdmFsdWU6IGIub2sgPyBiLmJvZHkudmFsdWUgOiB7fVxuICB9KTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUFycmF5SGVhZGVyID0gc3Vycm91bmQoXCJbW1wiLCBkb3R0ZWRLZXksIFwiXV1cIik7XG5leHBvcnQgZnVuY3Rpb24gdGFibGVBcnJheShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUFycmF5SGVhZGVyKHNjYW5uZXIpO1xuICBpZiAoIWhlYWRlci5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGNvbnN0IGIgPSBibG9jayhzY2FubmVyKTtcbiAgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIHR5cGU6IFwiVGFibGVBcnJheVwiLFxuICAgIGtleXM6IGhlYWRlci5ib2R5LFxuICAgIHZhbHVlOiBiLm9rID8gYi5ib2R5LnZhbHVlIDoge31cbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9tbChzY2FubmVyKSB7XG4gIGNvbnN0IGJsb2NrcyA9IHJlcGVhdChvcihbXG4gICAgYmxvY2ssXG4gICAgdGFibGVBcnJheSxcbiAgICB0YWJsZVxuICBdKSkoc2Nhbm5lcik7XG4gIGlmICghYmxvY2tzLm9rKSByZXR1cm4gc3VjY2Vzcyh7fSk7XG4gIGNvbnN0IGJvZHkgPSBibG9ja3MuYm9keS5yZWR1Y2UoZGVlcEFzc2lnbiwge30pO1xuICByZXR1cm4gc3VjY2Vzcyhib2R5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlRXJyb3JNZXNzYWdlKHNjYW5uZXIsIG1lc3NhZ2UpIHtcbiAgY29uc3Qgc3RyaW5nID0gc2Nhbm5lci5zb3VyY2Uuc2xpY2UoMCwgc2Nhbm5lci5wb3NpdGlvbik7XG4gIGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICBjb25zdCByb3cgPSBsaW5lcy5sZW5ndGg7XG4gIGNvbnN0IGNvbHVtbiA9IGxpbmVzLmF0KC0xKT8ubGVuZ3RoID8/IDA7XG4gIHJldHVybiBgUGFyc2UgZXJyb3Igb24gbGluZSAke3Jvd30sIGNvbHVtbiAke2NvbHVtbn06ICR7bWVzc2FnZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZhY3RvcnkocGFyc2VyKSB7XG4gIHJldHVybiAodG9tbFN0cmluZyk9PntcbiAgICBjb25zdCBzY2FubmVyID0gbmV3IFNjYW5uZXIodG9tbFN0cmluZyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmIChyZXN1bHQub2sgJiYgc2Nhbm5lci5lb2YoKSkgcmV0dXJuIHJlc3VsdC5ib2R5O1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIke3NjYW5uZXIuY2hhcigpfVwiYDtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBtZXNzYWdlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIGVycm9yIHR5cGUgY2F1Z2h0XCI7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgbWVzc2FnZSkpO1xuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9wYXJzZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IHBhcnNlckZhY3RvcnksIHRvbWwgfSBmcm9tIFwiLi9fcGFyc2VyLmpzXCI7XG4vKipcbiAqIFBhcnNlcyBhIHtAbGluayBodHRwczovL3RvbWwuaW8gfCBUT01MfSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gKlxuICogQGV4YW1wbGUgVXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJAc3RkL3RvbWwvcGFyc2VcIjtcbiAqIGltcG9ydCB7IGFzc2VydEVxdWFscyB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IHRvbWxTdHJpbmcgPSBgdGl0bGUgPSBcIlRPTUwgRXhhbXBsZVwiXG4gKiBbb3duZXJdXG4gKiBuYW1lID0gXCJBbGljZVwiXG4gKiBiaW8gPSBcIkFsaWNlIGlzIGEgcHJvZ3JhbW1lci5cImA7XG4gKlxuICogY29uc3Qgb2JqID0gcGFyc2UodG9tbFN0cmluZyk7XG4gKiBhc3NlcnRFcXVhbHMob2JqLCB7IHRpdGxlOiBcIlRPTUwgRXhhbXBsZVwiLCBvd25lcjogeyBuYW1lOiBcIkFsaWNlXCIsIGJpbzogXCJBbGljZSBpcyBhIHByb2dyYW1tZXIuXCIgfSB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHRvbWxTdHJpbmcgVE9NTCBzdHJpbmcgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBKUyBvYmplY3QuXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRvbWxTdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlckZhY3RvcnkodG9tbCkodG9tbFN0cmluZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXAiLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVJlbmFtZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sncmVuYW1lJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdSZW5hbWUgdGhlIE5BUEktUlMgcHJvamVjdCcsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgJCRuYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1uYW1lLC1uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBiaW5hcnlOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1iaW5hcnktbmFtZSwtYicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgYmluYXJ5IG5hbWUgKi5ub2RlIGZpbGVzJyxcbiAgfSlcblxuICBwYWNrYWdlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBwYWNrYWdlIG5hbWUgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIG1hbmlmZXN0UGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tbWFuaWZlc3QtcGF0aCcsICdDYXJnby50b21sJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgQ2FyZ28udG9tbGAnLFxuICB9KVxuXG4gIHJlcG9zaXRvcnk/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXJlcG9zaXRvcnknLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IHJlcG9zaXRvcnkgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1kZXNjcmlwdGlvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIG5hbWU6IHRoaXMuJCRuYW1lLFxuICAgICAgYmluYXJ5TmFtZTogdGhpcy5iaW5hcnlOYW1lLFxuICAgICAgcGFja2FnZU5hbWU6IHRoaXMucGFja2FnZU5hbWUsXG4gICAgICBtYW5pZmVzdFBhdGg6IHRoaXMubWFuaWZlc3RQYXRoLFxuICAgICAgcmVwb3NpdG9yeTogdGhpcy5yZXBvc2l0b3J5LFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVuYW1lIHRoZSBOQVBJLVJTIHByb2plY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZW5hbWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBiaW5hcnkgbmFtZSAqLm5vZGUgZmlsZXNcbiAgICovXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcGFja2FnZSBuYW1lIG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICBwYWNrYWdlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgQ2FyZ28udG9tbGBcbiAgICpcbiAgICogQGRlZmF1bHQgJ0NhcmdvLnRvbWwnXG4gICAqL1xuICBtYW5pZmVzdFBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcmVwb3NpdG9yeSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgcmVwb3NpdG9yeT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFJlbmFtZU9wdGlvbnMob3B0aW9uczogUmVuYW1lT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgbWFuaWZlc3RQYXRoOiAnQ2FyZ28udG9tbCcsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyByZW5hbWUgfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJ1xuaW1wb3J0IHsgcmVzb2x2ZSwgam9pbiB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VUb21sLCBzdHJpbmdpZnkgYXMgc3RyaW5naWZ5VG9tbCB9IGZyb20gJ0BzdGQvdG9tbCdcbmltcG9ydCB7IGxvYWQgYXMgeWFtbFBhcnNlLCBkdW1wIGFzIHlhbWxTdHJpbmdpZnkgfSBmcm9tICdqcy15YW1sJ1xuaW1wb3J0IHsgaXNOaWwsIG1lcmdlLCBvbWl0QnksIHBpY2sgfSBmcm9tICdsb2Rhc2gtZXMnXG5pbXBvcnQgeyBmaW5kVXAgfSBmcm9tICdmaW5kLXVwJ1xuXG5pbXBvcnQgeyBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zLCBSZW5hbWVPcHRpb25zIH0gZnJvbSAnLi4vZGVmL3JlbmFtZS5qcydcbmltcG9ydCB7IHJlYWRDb25maWcsIHJlYWRGaWxlQXN5bmMsIHdyaXRlRmlsZUFzeW5jIH0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5hbWVQcm9qZWN0KHVzZXJPcHRpb25zOiBSZW5hbWVPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zKHVzZXJPcHRpb25zKVxuICBjb25zdCBuYXBpQ29uZmlnID0gYXdhaXQgcmVhZENvbmZpZyhvcHRpb25zKVxuICBjb25zdCBvbGROYW1lID0gbmFwaUNvbmZpZy5iaW5hcnlOYW1lXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IGNhcmdvVG9tbFBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm1hbmlmZXN0UGF0aClcblxuICBjb25zdCBwYWNrYWdlSnNvbkNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKHBhY2thZ2VKc29uUGF0aCwgJ3V0ZjgnKVxuICBjb25zdCBwYWNrYWdlSnNvbkRhdGEgPSBKU09OLnBhcnNlKHBhY2thZ2VKc29uQ29udGVudClcblxuICBtZXJnZShcbiAgICBwYWNrYWdlSnNvbkRhdGEsXG4gICAgb21pdEJ5KHBpY2sob3B0aW9ucywgWyduYW1lJywgJ2Rlc2NyaXB0aW9uJywgJ2F1dGhvcicsICdsaWNlbnNlJ10pLCBpc05pbCksXG4gICAge1xuICAgICAgbmFwaTogb21pdEJ5KFxuICAgICAgICB7XG4gICAgICAgICAgYmluYXJ5TmFtZTogb3B0aW9ucy5iaW5hcnlOYW1lLFxuICAgICAgICAgIHBhY2thZ2VOYW1lOiBvcHRpb25zLnBhY2thZ2VOYW1lLFxuICAgICAgICB9LFxuICAgICAgICBpc05pbCxcbiAgICAgICksXG4gICAgfSxcbiAgKVxuXG4gIGlmIChvcHRpb25zLmNvbmZpZ1BhdGgpIHtcbiAgICBjb25zdCBjb25maWdQYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKVxuICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGNvbmZpZ1BhdGgsICd1dGY4JylcbiAgICBjb25zdCBjb25maWdEYXRhID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgIGNvbmZpZ0RhdGEuYmluYXJ5TmFtZSA9IG9wdGlvbnMuYmluYXJ5TmFtZVxuICAgIGNvbmZpZ0RhdGEucGFja2FnZU5hbWUgPSBvcHRpb25zLnBhY2thZ2VOYW1lXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoY29uZmlnUGF0aCwgSlNPTi5zdHJpbmdpZnkoY29uZmlnRGF0YSwgbnVsbCwgMikpXG4gIH1cblxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb25EYXRhLCBudWxsLCAyKSxcbiAgKVxuXG4gIGNvbnN0IHRvbWxDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjYXJnb1RvbWxQYXRoLCAndXRmOCcpXG4gIGNvbnN0IGNhcmdvVG9tbCA9IHBhcnNlVG9tbCh0b21sQ29udGVudCkgYXMgYW55XG5cbiAgLy8gVXBkYXRlIHRoZSBwYWNrYWdlIG5hbWVcbiAgaWYgKGNhcmdvVG9tbC5wYWNrYWdlICYmIG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIC8vIFNhbml0aXplIHRoZSBiaW5hcnkgbmFtZSBmb3IgUnVzdCBwYWNrYWdlIG5hbWluZyBjb252ZW50aW9uc1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBvcHRpb25zLmJpbmFyeU5hbWVcbiAgICAgIC5yZXBsYWNlKCdAJywgJycpXG4gICAgICAucmVwbGFjZSgnLycsICdfJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgY2FyZ29Ub21sLnBhY2thZ2UubmFtZSA9IHNhbml0aXplZE5hbWVcbiAgfVxuXG4gIC8vIFN0cmluZ2lmeSB0aGUgdXBkYXRlZCBUT01MXG4gIGNvbnN0IHVwZGF0ZWRUb21sQ29udGVudCA9IHN0cmluZ2lmeVRvbWwoY2FyZ29Ub21sKVxuXG4gIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGNhcmdvVG9tbFBhdGgsIHVwZGF0ZWRUb21sQ29udGVudClcbiAgaWYgKG9sZE5hbWUgIT09IG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNQYXRoID0gYXdhaXQgZmluZFVwKCcuZ2l0aHViJywge1xuICAgICAgY3dkOiBvcHRpb25zLmN3ZCxcbiAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgIH0pXG4gICAgaWYgKGdpdGh1YkFjdGlvbnNQYXRoKSB7XG4gICAgICBjb25zdCBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoID0gam9pbihcbiAgICAgICAgZ2l0aHViQWN0aW9uc1BhdGgsXG4gICAgICAgICd3b3JrZmxvd3MnLFxuICAgICAgICAnQ0kueW1sJyxcbiAgICAgIClcbiAgICAgIGlmIChleGlzdHNTeW5jKGdpdGh1YkFjdGlvbnNDSVltbFBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICd1dGY4JyxcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBnaXRodWJBY3Rpb25zRGF0YSA9IHlhbWxQYXJzZShnaXRodWJBY3Rpb25zQ29udGVudCkgYXMgYW55XG4gICAgICAgIGlmIChnaXRodWJBY3Rpb25zRGF0YS5lbnY/LkFQUF9OQU1FKSB7XG4gICAgICAgICAgZ2l0aHViQWN0aW9uc0RhdGEuZW52LkFQUF9OQU1FID0gb3B0aW9ucy5iaW5hcnlOYW1lXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICAgeWFtbFN0cmluZ2lmeShnaXRodWJBY3Rpb25zRGF0YSwge1xuICAgICAgICAgICAgICBsaW5lV2lkdGg6IC0xLFxuICAgICAgICAgICAgICBub1JlZnM6IHRydWUsXG4gICAgICAgICAgICAgIHNvcnRLZXlzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvbGRXYXNpQnJvd3NlckJpbmRpbmdQYXRoID0gam9pbihcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgYCR7b2xkTmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICApXG4gICAgaWYgKGV4aXN0c1N5bmMob2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCxcbiAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgKSxcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3Qgb2xkV2FzaUJpbmRpbmdQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgYCR7b2xkTmFtZX0ud2FzaS5janNgKVxuICAgIGlmIChleGlzdHNTeW5jKG9sZFdhc2lCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJpbmRpbmdQYXRoLFxuICAgICAgICBqb2luKG9wdGlvbnMuY3dkLCBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2kuY2pzYCksXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgJy5naXRhdHRyaWJ1dGVzJylcbiAgICBpZiAoZXhpc3RzU3luYyhnaXRBdHRyaWJ1dGVzUGF0aCkpIHtcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgZ2l0QXR0cmlidXRlc1BhdGgsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNEYXRhID0gZ2l0QXR0cmlidXRlc0NvbnRlbnRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVcbiAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICBgJHtvbGROYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgICAgICAgICBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAucmVwbGFjZShgJHtvbGROYW1lfS53YXNpLmNqc2AsIGAke29wdGlvbnMuYmluYXJ5TmFtZX0ud2FzaS5janNgKVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGdpdEF0dHJpYnV0ZXNQYXRoLCBnaXRBdHRyaWJ1dGVzRGF0YSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWMsIGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnbm9kZTpmcydcblxuaW1wb3J0IHsgbG9hZCBhcyB5YW1sTG9hZCwgZHVtcCBhcyB5YW1sRHVtcCB9IGZyb20gJ2pzLXlhbWwnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMsXG4gIE5ld09wdGlvbnMgYXMgUmF3TmV3T3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL25ldy5qcydcbmltcG9ydCB7XG4gIEFWQUlMQUJMRV9UQVJHRVRTLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVEFSR0VUUyxcbiAgbWtkaXJBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICBzdGF0QXN5bmMsXG4gIFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcbmltcG9ydCB7IG5hcGlFbmdpbmVSZXF1aXJlbWVudCB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24uanMnXG5pbXBvcnQgeyByZW5hbWVQcm9qZWN0IH0gZnJvbSAnLi9yZW5hbWUuanMnXG5cbi8vIFRlbXBsYXRlIGltcG9ydHMgcmVtb3ZlZCBhcyB3ZSdyZSBub3cgdXNpbmcgZXh0ZXJuYWwgdGVtcGxhdGVzXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCduZXcnKVxuXG50eXBlIE5ld09wdGlvbnMgPSBSZXF1aXJlZDxSYXdOZXdPcHRpb25zPlxuXG5jb25zdCBURU1QTEFURV9SRVBPUyA9IHtcbiAgeWFybjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL3BhY2thZ2UtdGVtcGxhdGUnLFxuICBwbnBtOiAnaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvcGFja2FnZS10ZW1wbGF0ZS1wbnBtJyxcbn0gYXMgY29uc3RcblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tHaXRDb21tYW5kKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBjcCA9IGV4ZWMoJ2dpdCAtLXZlcnNpb24nKVxuICAgICAgY3Aub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGZhbHNlKVxuICAgICAgfSlcbiAgICAgIGNwLm9uKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUNhY2hlRGlyKFxuICBwYWNrYWdlTWFuYWdlcjogU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBjYWNoZURpciA9IHBhdGguam9pbihob21lZGlyKCksICcubmFwaS1ycycsICd0ZW1wbGF0ZScsIHBhY2thZ2VNYW5hZ2VyKVxuICBhd2FpdCBta2RpckFzeW5jKGNhY2hlRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICByZXR1cm4gY2FjaGVEaXJcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRUZW1wbGF0ZShcbiAgcGFja2FnZU1hbmFnZXI6IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxuICBjYWNoZURpcjogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcG9VcmwgPSBURU1QTEFURV9SRVBPU1twYWNrYWdlTWFuYWdlcl1cbiAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGNhY2hlRGlyLCAncmVwbycpXG5cbiAgaWYgKGV4aXN0c1N5bmModGVtcGxhdGVQYXRoKSkge1xuICAgIGRlYnVnKGBUZW1wbGF0ZSBjYWNoZSBmb3VuZCBhdCAke3RlbXBsYXRlUGF0aH0sIHVwZGF0aW5nLi4uYClcbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggbGF0ZXN0IGNoYW5nZXMgYW5kIHJlc2V0IHRvIHJlbW90ZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjcCA9IGV4ZWMoJ2dpdCBmZXRjaCBvcmlnaW4nLCB7IGN3ZDogdGVtcGxhdGVQYXRoIH0pXG4gICAgICAgIGNwLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgY3Aub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZhaWxlZCB0byBmZXRjaCBsYXRlc3QgY2hhbmdlcywgZ2l0IHByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgZXhlY1N5bmMoJ2dpdCByZXNldCAtLWhhcmQgb3JpZ2luL21haW4nLCB7XG4gICAgICAgIGN3ZDogdGVtcGxhdGVQYXRoLFxuICAgICAgICBzdGRpbzogJ2lnbm9yZScsXG4gICAgICB9KVxuICAgICAgZGVidWcoJ1RlbXBsYXRlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byB1cGRhdGUgdGVtcGxhdGU6ICR7ZXJyb3J9YClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSB0ZW1wbGF0ZSBmcm9tICR7cmVwb1VybH06ICR7ZXJyb3J9YClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoYENsb25pbmcgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9Li4uYClcbiAgICB0cnkge1xuICAgICAgZXhlY1N5bmMoYGdpdCBjbG9uZSAke3JlcG9Vcmx9IHJlcG9gLCB7IGN3ZDogY2FjaGVEaXIsIHN0ZGlvOiAnaW5oZXJpdCcgfSlcbiAgICAgIGRlYnVnKCdUZW1wbGF0ZSBjbG9uZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2xvbmUgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9OiAke2Vycm9yfWApXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlEaXJlY3RvcnkoXG4gIHNyYzogc3RyaW5nLFxuICBkZXN0OiBzdHJpbmcsXG4gIGluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgbWtkaXJBc3luYyhkZXN0LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZnMucmVhZGRpcihzcmMsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGNvbnN0IHNyY1BhdGggPSBwYXRoLmpvaW4oc3JjLCBlbnRyeS5uYW1lKVxuICAgIGNvbnN0IGRlc3RQYXRoID0gcGF0aC5qb2luKGRlc3QsIGVudHJ5Lm5hbWUpXG5cbiAgICAvLyBTa2lwIC5naXQgZGlyZWN0b3J5XG4gICAgaWYgKGVudHJ5Lm5hbWUgPT09ICcuZ2l0Jykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgYXdhaXQgY29weURpcmVjdG9yeShzcmNQYXRoLCBkZXN0UGF0aCwgaW5jbHVkZVdhc2lCaW5kaW5ncylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFxuICAgICAgICAhaW5jbHVkZVdhc2lCaW5kaW5ncyAmJlxuICAgICAgICAoZW50cnkubmFtZS5lbmRzV2l0aCgnLndhc2ktYnJvd3Nlci5qcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnLndhc2kuY2pzJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCd3YXNpLXdvcmtlci5icm93c2VyLm1qcyAnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJ3dhc2ktd29ya2VyLm1qcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnYnJvd3Nlci5qcycpKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBhd2FpdCBmcy5jb3B5RmlsZShzcmNQYXRoLCBkZXN0UGF0aClcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmlsdGVyVGFyZ2V0c0luUGFja2FnZUpzb24oXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIGVuYWJsZWRUYXJnZXRzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShjb250ZW50KVxuXG4gIC8vIEZpbHRlciBuYXBpLnRhcmdldHNcbiAgaWYgKHBhY2thZ2VKc29uLm5hcGk/LnRhcmdldHMpIHtcbiAgICBwYWNrYWdlSnNvbi5uYXBpLnRhcmdldHMgPSBwYWNrYWdlSnNvbi5uYXBpLnRhcmdldHMuZmlsdGVyKFxuICAgICAgKHRhcmdldDogc3RyaW5nKSA9PiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpLFxuICAgIClcbiAgfVxuXG4gIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb24sIG51bGwsIDIpICsgJ1xcbicpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbHRlclRhcmdldHNJbkdpdGh1YkFjdGlvbnMoXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIGVuYWJsZWRUYXJnZXRzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpXG4gIGNvbnN0IHlhbWwgPSB5YW1sTG9hZChjb250ZW50KSBhcyBhbnlcblxuICBjb25zdCBtYWNPU0FuZFdpbmRvd3NUYXJnZXRzID0gbmV3IFNldChbXG4gICAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAgICdhYXJjaDY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICAgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nLFxuICBdKVxuXG4gIGNvbnN0IGxpbnV4VGFyZ2V0cyA9IG5ldyBTZXQoW1xuICAgICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICd4ODZfNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgICAnYWFyY2g2NC11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgICAnYXJtdjctdW5rbm93bi1saW51eC1nbnVlYWJpaGYnLFxuICAgICdhcm12Ny11bmtub3duLWxpbnV4LW11c2xlYWJpaGYnLFxuICAgICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JyxcbiAgICAnYWFyY2g2NC1saW51eC1hbmRyb2lkJyxcbiAgICAnYXJtdjctbGludXgtYW5kcm9pZGVhYmknLFxuICBdKVxuXG4gIC8vIENoZWNrIGlmIGFueSBMaW51eCB0YXJnZXRzIGFyZSBlbmFibGVkXG4gIGNvbnN0IGhhc0xpbnV4VGFyZ2V0cyA9IGVuYWJsZWRUYXJnZXRzLnNvbWUoKHRhcmdldCkgPT5cbiAgICBsaW51eFRhcmdldHMuaGFzKHRhcmdldCksXG4gIClcblxuICAvLyBGaWx0ZXIgdGhlIG1hdHJpeCBjb25maWd1cmF0aW9ucyBpbiB0aGUgYnVpbGQgam9iXG4gIGlmICh5YW1sPy5qb2JzPy5idWlsZD8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3MpIHtcbiAgICB5YW1sLmpvYnMuYnVpbGQuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzID1cbiAgICAgIHlhbWwuam9icy5idWlsZC5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MuZmlsdGVyKChzZXR0aW5nOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHNldHRpbmcudGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICB9XG5cbiAgY29uc3Qgam9ic1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdXG5cbiAgaWYgKGVuYWJsZWRUYXJnZXRzLmV2ZXJ5KCh0YXJnZXQpID0+ICFtYWNPU0FuZFdpbmRvd3NUYXJnZXRzLmhhcyh0YXJnZXQpKSkge1xuICAgIGpvYnNUb1JlbW92ZS5wdXNoKCd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nIGpvYlxuICAgIGlmIChcbiAgICAgIHlhbWw/LmpvYnM/LlsndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXT8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3NcbiAgICApIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXS5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MgPVxuICAgICAgICB5YW1sLmpvYnNbJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzLmZpbHRlcihcbiAgICAgICAgICAoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gTGludXggdGFyZ2V0cyBhcmUgZW5hYmxlZCwgcmVtb3ZlIExpbnV4LXNwZWNpZmljIGpvYnNcbiAgaWYgKCFoYXNMaW51eFRhcmdldHMpIHtcbiAgICAvLyBSZW1vdmUgdGVzdC1saW51eC1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddKSB7XG4gICAgICBqb2JzVG9SZW1vdmUucHVzaCgndGVzdC1saW51eC1iaW5kaW5nJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbGludXgteDY0LWdudS1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddPy5zdHJhdGVneT8ubWF0cml4Py50YXJnZXQpIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1saW51eC1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnRhcmdldCA9IHlhbWwuam9ic1tcbiAgICAgICAgJ3Rlc3QtbGludXgtYmluZGluZydcbiAgICAgIF0uc3RyYXRlZ3kubWF0cml4LnRhcmdldC5maWx0ZXIoKHRhcmdldDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZW5hYmxlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghZW5hYmxlZFRhcmdldHMuaW5jbHVkZXMoJ3dhc20zMi13YXNpcDEtdGhyZWFkcycpKSB7XG4gICAgam9ic1RvUmVtb3ZlLnB1c2goJ3Rlc3Qtd2FzaScpXG4gIH1cblxuICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKCd4ODZfNjQtdW5rbm93bi1mcmVlYnNkJykpIHtcbiAgICBqb2JzVG9SZW1vdmUucHVzaCgnYnVpbGQtZnJlZWJzZCcpXG4gIH1cblxuICAvLyBGaWx0ZXIgb3RoZXIgdGVzdCBqb2JzIGJhc2VkIG9uIHRhcmdldFxuICBmb3IgKGNvbnN0IFtqb2JOYW1lLCBqb2JDb25maWddIG9mIE9iamVjdC5lbnRyaWVzKHlhbWwuam9icyB8fCB7fSkpIHtcbiAgICBpZiAoXG4gICAgICBqb2JOYW1lLnN0YXJ0c1dpdGgoJ3Rlc3QtJykgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LWxpbnV4LXg2NC1nbnUtYmluZGluZydcbiAgICApIHtcbiAgICAgIC8vIEV4dHJhY3QgdGFyZ2V0IGZyb20gam9iIG5hbWUgb3IgY29uZmlnXG4gICAgICBjb25zdCBqb2IgPSBqb2JDb25maWcgYXMgYW55XG4gICAgICBpZiAoam9iLnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzPy5bMF0/LnRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBqb2Iuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzWzBdLnRhcmdldFxuICAgICAgICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgICAgICBqb2JzVG9SZW1vdmUucHVzaChqb2JOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGpvYnMgZm9yIGRpc2FibGVkIHRhcmdldHNcbiAgZm9yIChjb25zdCBqb2JOYW1lIG9mIGpvYnNUb1JlbW92ZSkge1xuICAgIGRlbGV0ZSB5YW1sLmpvYnNbam9iTmFtZV1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHlhbWwuam9icz8ucHVibGlzaD8ubmVlZHMpKSB7XG4gICAgeWFtbC5qb2JzLnB1Ymxpc2gubmVlZHMgPSB5YW1sLmpvYnMucHVibGlzaC5uZWVkcy5maWx0ZXIoXG4gICAgICAobmVlZDogc3RyaW5nKSA9PiAham9ic1RvUmVtb3ZlLmluY2x1ZGVzKG5lZWQpLFxuICAgIClcbiAgfVxuXG4gIC8vIFdyaXRlIGJhY2sgdGhlIGZpbHRlcmVkIFlBTUxcbiAgY29uc3QgdXBkYXRlZFlhbWwgPSB5YW1sRHVtcCh5YW1sLCB7XG4gICAgbGluZVdpZHRoOiAtMSxcbiAgICBub1JlZnM6IHRydWUsXG4gICAgc29ydEtleXM6IGZhbHNlLFxuICB9KVxuICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIHVwZGF0ZWRZYW1sKVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdQcm9jZXNzaW5nIG9wdGlvbnMuLi4nKVxuICBpZiAoIW9wdGlvbnMucGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdGhlIHBhdGggYXMgdGhlIGFyZ3VtZW50JylcbiAgfVxuICBvcHRpb25zLnBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgb3B0aW9ucy5wYXRoKVxuICBkZWJ1ZyhgUmVzb2x2ZWQgdGFyZ2V0IHBhdGggdG86ICR7b3B0aW9ucy5wYXRofWApXG5cbiAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICBvcHRpb25zLm5hbWUgPSBwYXRoLnBhcnNlKG9wdGlvbnMucGF0aCkuYmFzZVxuICAgIGRlYnVnKGBObyBwcm9qZWN0IG5hbWUgcHJvdmlkZWQsIGZpeCBpdCB0byBkaXIgbmFtZTogJHtvcHRpb25zLm5hbWV9YClcbiAgfVxuXG4gIGlmICghb3B0aW9ucy50YXJnZXRzPy5sZW5ndGgpIHtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVBbGxUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBBVkFJTEFCTEVfVEFSR0VUUy5jb25jYXQoKVxuICAgICAgZGVidWcoJ0VuYWJsZSBhbGwgdGFyZ2V0cycpXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVuYWJsZURlZmF1bHRUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBERUZBVUxUX1RBUkdFVFMuY29uY2F0KClcbiAgICAgIGRlYnVnKCdFbmFibGUgZGVmYXVsdCB0YXJnZXRzJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdGFyZ2V0IG11c3QgYmUgZW5hYmxlZCcpXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICBvcHRpb25zLnRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJylcbiAgKSB7XG4gICAgY29uc3Qgb3V0ID0gZXhlY1N5bmMoYHJ1c3R1cCB0YXJnZXQgbGlzdGAsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgfSlcbiAgICBpZiAob3V0LmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSkge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gb3B0aW9ucy50YXJnZXRzLm1hcCgodGFyZ2V0KSA9PlxuICAgICAgICB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJ1xuICAgICAgICAgID8gJ3dhc20zMi13YXNpcDEtdGhyZWFkcydcbiAgICAgICAgICA6IHRhcmdldCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBwbHlEZWZhdWx0TmV3T3B0aW9ucyhvcHRpb25zKSBhcyBOZXdPcHRpb25zXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdQcm9qZWN0KHVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdXaWxsIGNyZWF0ZSBuYXBpLXJzIHByb2plY3Qgd2l0aCBnaXZlbiBvcHRpb25zOicpXG4gIGRlYnVnKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBkZWJ1ZygnVGFyZ2V0cyB0byBiZSBlbmFibGVkOicpXG4gIGRlYnVnKG9wdGlvbnMudGFyZ2V0cylcblxuICAvLyBDaGVjayBpZiBnaXQgaXMgYXZhaWxhYmxlXG4gIGlmICghKGF3YWl0IGNoZWNrR2l0Q29tbWFuZCgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdHaXQgaXMgbm90IGluc3RhbGxlZCBvciBub3QgYXZhaWxhYmxlIGluIFBBVEguIFBsZWFzZSBpbnN0YWxsIEdpdCB0byBjb250aW51ZS4nLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHBhY2thZ2VNYW5hZ2VyID0gb3B0aW9ucy5wYWNrYWdlTWFuYWdlciBhcyBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlclxuXG4gIC8vIEVuc3VyZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cyBhbmQgaXMgZW1wdHlcbiAgYXdhaXQgZW5zdXJlUGF0aChvcHRpb25zLnBhdGgsIG9wdGlvbnMuZHJ5UnVuKVxuXG4gIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICB0cnkge1xuICAgICAgLy8gRG93bmxvYWQgb3IgdXBkYXRlIHRlbXBsYXRlXG4gICAgICBjb25zdCBjYWNoZURpciA9IGF3YWl0IGVuc3VyZUNhY2hlRGlyKHBhY2thZ2VNYW5hZ2VyKVxuICAgICAgYXdhaXQgZG93bmxvYWRUZW1wbGF0ZShwYWNrYWdlTWFuYWdlciwgY2FjaGVEaXIpXG5cbiAgICAgIC8vIENvcHkgdGVtcGxhdGUgZmlsZXMgdG8gdGFyZ2V0IGRpcmVjdG9yeVxuICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGNhY2hlRGlyLCAncmVwbycpXG4gICAgICBhd2FpdCBjb3B5RGlyZWN0b3J5KFxuICAgICAgICB0ZW1wbGF0ZVBhdGgsXG4gICAgICAgIG9wdGlvbnMucGF0aCxcbiAgICAgICAgb3B0aW9ucy50YXJnZXRzLmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSxcbiAgICAgIClcblxuICAgICAgLy8gUmVuYW1lIHByb2plY3QgdXNpbmcgdGhlIHJlbmFtZSBBUElcbiAgICAgIGF3YWl0IHJlbmFtZVByb2plY3Qoe1xuICAgICAgICBjd2Q6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICBiaW5hcnlOYW1lOiBnZXRCaW5hcnlOYW1lKG9wdGlvbnMubmFtZSksXG4gICAgICB9KVxuXG4gICAgICAvLyBGaWx0ZXIgdGFyZ2V0cyBpbiBwYWNrYWdlLmpzb25cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICdwYWNrYWdlLmpzb24nKVxuICAgICAgaWYgKGV4aXN0c1N5bmMocGFja2FnZUpzb25QYXRoKSkge1xuICAgICAgICBhd2FpdCBmaWx0ZXJUYXJnZXRzSW5QYWNrYWdlSnNvbihwYWNrYWdlSnNvblBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIHRhcmdldHMgaW4gR2l0SHViIEFjdGlvbnMgQ0lcbiAgICAgIGNvbnN0IGNpUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICcuZ2l0aHViJywgJ3dvcmtmbG93cycsICdDSS55bWwnKVxuICAgICAgaWYgKGV4aXN0c1N5bmMoY2lQYXRoKSAmJiBvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgZmlsdGVyVGFyZ2V0c0luR2l0aHViQWN0aW9ucyhjaVBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICFvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMgJiZcbiAgICAgICAgZXhpc3RzU3luYyhwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFJlbW92ZSAuZ2l0aHViIGRpcmVjdG9yeSBpZiBHaXRIdWIgQWN0aW9ucyBpcyBub3QgZW5hYmxlZFxuICAgICAgICBhd2FpdCBmcy5ybShwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpLCB7XG4gICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcGFja2FnZS5qc29uIHdpdGggYWRkaXRpb25hbCBjb25maWd1cmF0aW9uc1xuICAgICAgY29uc3QgcGtnSnNvbkNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShwYWNrYWdlSnNvblBhdGgsICd1dGYtOCcpXG4gICAgICBjb25zdCBwa2dKc29uID0gSlNPTi5wYXJzZShwa2dKc29uQ29udGVudClcblxuICAgICAgLy8gVXBkYXRlIGVuZ2luZSByZXF1aXJlbWVudFxuICAgICAgaWYgKCFwa2dKc29uLmVuZ2luZXMpIHtcbiAgICAgICAgcGtnSnNvbi5lbmdpbmVzID0ge31cbiAgICAgIH1cbiAgICAgIHBrZ0pzb24uZW5naW5lcy5ub2RlID0gbmFwaUVuZ2luZVJlcXVpcmVtZW50KG9wdGlvbnMubWluTm9kZUFwaVZlcnNpb24pXG5cbiAgICAgIC8vIFVwZGF0ZSBsaWNlbnNlIGlmIGRpZmZlcmVudCBmcm9tIHRlbXBsYXRlXG4gICAgICBpZiAob3B0aW9ucy5saWNlbnNlICYmIHBrZ0pzb24ubGljZW5zZSAhPT0gb3B0aW9ucy5saWNlbnNlKSB7XG4gICAgICAgIHBrZ0pzb24ubGljZW5zZSA9IG9wdGlvbnMubGljZW5zZVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGVzdCBmcmFtZXdvcmsgaWYgbmVlZGVkXG4gICAgICBpZiAob3B0aW9ucy50ZXN0RnJhbWV3b3JrICE9PSAnYXZhJykge1xuICAgICAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgbW9yZSBjb21wbGV4IGxvZ2ljIHRvIHVwZGF0ZSB0ZXN0IHNjcmlwdHMgYW5kIGRlcGVuZGVuY2llc1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBgVGVzdCBmcmFtZXdvcmsgJHtvcHRpb25zLnRlc3RGcmFtZXdvcmt9IHJlcXVlc3RlZCBidXQgbm90IHlldCBpbXBsZW1lbnRlZGAsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHBrZ0pzb24sIG51bGwsIDIpICsgJ1xcbicsXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBwcm9qZWN0OiAke2Vycm9yfWApXG4gICAgfVxuICB9XG5cbiAgZGVidWcoYFByb2plY3QgY3JlYXRlZCBhdDogJHtvcHRpb25zLnBhdGh9YClcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlUGF0aChwYXRoOiBzdHJpbmcsIGRyeVJ1biA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0QXN5bmMocGF0aCwge30pLmNhdGNoKCgpID0+IHVuZGVmaW5lZClcblxuICAvLyBmaWxlIGRlc2NyaXB0b3IgZXhpc3RzXG4gIGlmIChzdGF0KSB7XG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBhdGggJHtwYXRofSBmb3IgY3JlYXRpbmcgbmV3IG5hcGktcnMgcHJvamVjdCBhbHJlYWR5IGV4aXN0cyBhbmQgaXQncyBub3QgYSBkaXJlY3RvcnkuYCxcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCByZWFkZGlyQXN5bmMocGF0aClcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQYXRoICR7cGF0aH0gZm9yIGNyZWF0aW5nIG5ldyBuYXBpLXJzIHByb2plY3QgYWxyZWFkeSBleGlzdHMgYW5kIGl0J3Mgbm90IGVtcHR5LmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWRyeVJ1bikge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSB0YXJnZXQgZGlyZWN0b3J5OiAke3BhdGh9YClcbiAgICAgIGlmICghZHJ5UnVuKSB7XG4gICAgICAgIGF3YWl0IG1rZGlyQXN5bmMocGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdGFyZ2V0IGRpcmVjdG9yeTogJHtwYXRofWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlOYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBuYW1lLnNwbGl0KCcvJykucG9wKCkhXG59XG5cbmV4cG9ydCB7IE5ld09wdGlvbnMgfVxuIiwiaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyBpbnB1dCwgc2VsZWN0LCBjaGVja2JveCwgY29uZmlybSB9IGZyb20gJ0BpbnF1aXJlci9wcm9tcHRzJ1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5pbXBvcnQgeyBuZXdQcm9qZWN0IH0gZnJvbSAnLi4vYXBpL25ldy5qcydcbmltcG9ydCB7IEJhc2VOZXdDb21tYW5kIH0gZnJvbSAnLi4vZGVmL25ldy5qcydcbmltcG9ydCB7XG4gIEFWQUlMQUJMRV9UQVJHRVRTLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVEFSR0VUUyxcbiAgVGFyZ2V0VHJpcGxlLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcbmltcG9ydCB7IG5hcGlFbmdpbmVSZXF1aXJlbWVudCB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24uanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCduZXcnKVxuXG5leHBvcnQgY2xhc3MgTmV3Q29tbWFuZCBleHRlbmRzIEJhc2VOZXdDb21tYW5kIHtcbiAgaW50ZXJhY3RpdmUgPSBPcHRpb24uQm9vbGVhbignLS1pbnRlcmFjdGl2ZSwtaScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdBc2sgcHJvamVjdCBiYXNpYyBpbmZvcm1hdGlvbiBpbnRlcmFjdGl2ZWx5IHdpdGhvdXQganVzdCB1c2luZyB0aGUgZGVmYXVsdC4nLFxuICB9KVxuXG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCB0aGlzLmZldGNoT3B0aW9ucygpXG4gICAgICBhd2FpdCBuZXdQcm9qZWN0KG9wdGlvbnMpXG4gICAgICByZXR1cm4gMFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdGYWlsZWQgdG8gY3JlYXRlIG5ldyBwcm9qZWN0JylcbiAgICAgIGRlYnVnLmVycm9yKGUpXG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hPcHRpb25zKCkge1xuICAgIGNvbnN0IGNtZE9wdGlvbnMgPSBzdXBlci5nZXRPcHRpb25zKClcblxuICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICBjb25zdCB0YXJnZXRQYXRoOiBzdHJpbmcgPSBjbWRPcHRpb25zLnBhdGhcbiAgICAgICAgPyBjbWRPcHRpb25zLnBhdGhcbiAgICAgICAgOiBhd2FpdCBpbnF1aXJlclByb2plY3RQYXRoKClcbiAgICAgIGNtZE9wdGlvbnMucGF0aCA9IHRhcmdldFBhdGhcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNtZE9wdGlvbnMsXG4gICAgICAgIG5hbWU6IGF3YWl0IHRoaXMuZmV0Y2hOYW1lKHBhdGgucGFyc2UodGFyZ2V0UGF0aCkuYmFzZSksXG4gICAgICAgIG1pbk5vZGVBcGlWZXJzaW9uOiBhd2FpdCB0aGlzLmZldGNoTmFwaVZlcnNpb24oKSxcbiAgICAgICAgdGFyZ2V0czogYXdhaXQgdGhpcy5mZXRjaFRhcmdldHMoKSxcbiAgICAgICAgbGljZW5zZTogYXdhaXQgdGhpcy5mZXRjaExpY2Vuc2UoKSxcbiAgICAgICAgZW5hYmxlVHlwZURlZjogYXdhaXQgdGhpcy5mZXRjaFR5cGVEZWYoKSxcbiAgICAgICAgZW5hYmxlR2l0aHViQWN0aW9uczogYXdhaXQgdGhpcy5mZXRjaEdpdGh1YkFjdGlvbnMoKSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21kT3B0aW9uc1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaE5hbWUoZGVmYXVsdE5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuJCRuYW1lID8/XG4gICAgICBpbnB1dCh7XG4gICAgICAgIG1lc3NhZ2U6ICdQYWNrYWdlIG5hbWUgKHRoZSBuYW1lIGZpZWxkIGluIHlvdXIgcGFja2FnZS5qc29uIGZpbGUpJyxcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdE5hbWUsXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hMaWNlbnNlKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIGlucHV0KHtcbiAgICAgIG1lc3NhZ2U6ICdMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdCcsXG4gICAgICBkZWZhdWx0OiB0aGlzLmxpY2Vuc2UsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hOYXBpVmVyc2lvbigpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBzZWxlY3Qoe1xuICAgICAgbWVzc2FnZTogJ01pbmltdW0gbm9kZS1hcGkgdmVyc2lvbiAod2l0aCBub2RlIHZlcnNpb24gcmVxdWlyZW1lbnQpJyxcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgY2hvaWNlczogQXJyYXkuZnJvbSh7IGxlbmd0aDogOCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgbmFtZTogYG5hcGkke2kgKyAxfSAoJHtuYXBpRW5naW5lUmVxdWlyZW1lbnQoaSArIDEpfSlgLFxuICAgICAgICB2YWx1ZTogaSArIDEsXG4gICAgICB9KSksXG4gICAgICAvLyBjaG9pY2UgaW5kZXhcbiAgICAgIGRlZmF1bHQ6IHRoaXMubWluTm9kZUFwaVZlcnNpb24gLSAxLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoVGFyZ2V0cygpOiBQcm9taXNlPFRhcmdldFRyaXBsZVtdPiB7XG4gICAgaWYgKHRoaXMuZW5hYmxlQWxsVGFyZ2V0cykge1xuICAgICAgcmV0dXJuIEFWQUlMQUJMRV9UQVJHRVRTLmNvbmNhdCgpXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0cyA9IGF3YWl0IGNoZWNrYm94KHtcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0Nob29zZSB0YXJnZXQocykgeW91ciBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIHRvJyxcbiAgICAgIGNob2ljZXM6IEFWQUlMQUJMRV9UQVJHRVRTLm1hcCgodGFyZ2V0KSA9PiAoe1xuICAgICAgICBuYW1lOiB0YXJnZXQsXG4gICAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY2hlY2tlZDogREVGQVVMVF9UQVJHRVRTLmluY2x1ZGVzKHRhcmdldCksXG4gICAgICB9KSksXG4gICAgfSlcblxuICAgIHJldHVybiB0YXJnZXRzXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoVHlwZURlZigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBlbmFibGVUeXBlRGVmID0gYXdhaXQgY29uZmlybSh7XG4gICAgICBtZXNzYWdlOiAnRW5hYmxlIHR5cGUgZGVmaW5pdGlvbiBhdXRvLWdlbmVyYXRpb24nLFxuICAgICAgZGVmYXVsdDogdGhpcy5lbmFibGVUeXBlRGVmLFxuICAgIH0pXG5cbiAgICByZXR1cm4gZW5hYmxlVHlwZURlZlxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaEdpdGh1YkFjdGlvbnMoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZW5hYmxlR2l0aHViQWN0aW9ucyA9IGF3YWl0IGNvbmZpcm0oe1xuICAgICAgbWVzc2FnZTogJ0VuYWJsZSBHaXRodWIgQWN0aW9ucyBDSScsXG4gICAgICBkZWZhdWx0OiB0aGlzLmVuYWJsZUdpdGh1YkFjdGlvbnMsXG4gICAgfSlcblxuICAgIHJldHVybiBlbmFibGVHaXRodWJBY3Rpb25zXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5xdWlyZXJQcm9qZWN0UGF0aCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gaW5wdXQoe1xuICAgIG1lc3NhZ2U6ICdUYXJnZXQgcGF0aCB0byBjcmVhdGUgdGhlIHByb2plY3QsIHJlbGF0aXZlIHRvIGN3ZC4nLFxuICB9KS50aGVuKChwYXRoKSA9PiB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gaW5xdWlyZXJQcm9qZWN0UGF0aCgpXG4gICAgfVxuICAgIHJldHVybiBwYXRoXG4gIH0pXG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVByZVB1Ymxpc2hDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3ByZS1wdWJsaXNoJ10sIFsncHJlcHVibGlzaCddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1VwZGF0ZSBwYWNrYWdlLmpzb24gYW5kIGNvcHkgYWRkb25zIGludG8gcGVyIHBsYXRmb3JtIHBhY2thZ2VzJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXIsLXAnLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICB0YWdTdHlsZSA9IE9wdGlvbi5TdHJpbmcoJy0tdGFnLXN0eWxlLC0tdGFnc3R5bGUsLXQnLCAnbGVybmEnLCB7XG4gICAgZGVzY3JpcHRpb246ICdnaXQgdGFnIHN0eWxlLCBgbnBtYCBvciBgbGVybmFgJyxcbiAgfSlcblxuICBnaFJlbGVhc2UgPSBPcHRpb24uQm9vbGVhbignLS1naC1yZWxlYXNlJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBjcmVhdGUgR2l0SHViIHJlbGVhc2UnLFxuICB9KVxuXG4gIGdoUmVsZWFzZU5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWdoLXJlbGVhc2UtbmFtZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0dpdEh1YiByZWxlYXNlIG5hbWUnLFxuICB9KVxuXG4gIGdoUmVsZWFzZUlkPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1naC1yZWxlYXNlLWlkJywge1xuICAgIGRlc2NyaXB0aW9uOiAnRXhpc3RpbmcgR2l0SHViIHJlbGVhc2UgaWQnLFxuICB9KVxuXG4gIHNraXBPcHRpb25hbFB1Ymxpc2ggPSBPcHRpb24uQm9vbGVhbignLS1za2lwLW9wdGlvbmFsLXB1Ymxpc2gnLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBza2lwIG9wdGlvbmFsRGVwZW5kZW5jaWVzIHBhY2thZ2VzIHB1Ymxpc2gnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICB0YWdTdHlsZTogdGhpcy50YWdTdHlsZSxcbiAgICAgIGdoUmVsZWFzZTogdGhpcy5naFJlbGVhc2UsXG4gICAgICBnaFJlbGVhc2VOYW1lOiB0aGlzLmdoUmVsZWFzZU5hbWUsXG4gICAgICBnaFJlbGVhc2VJZDogdGhpcy5naFJlbGVhc2VJZCxcbiAgICAgIHNraXBPcHRpb25hbFB1Ymxpc2g6IHRoaXMuc2tpcE9wdGlvbmFsUHVibGlzaCxcbiAgICAgIGRyeVJ1bjogdGhpcy5kcnlSdW4sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHBhY2thZ2UuanNvbiBhbmQgY29weSBhZGRvbnMgaW50byBwZXIgcGxhdGZvcm0gcGFja2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVQdWJsaXNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBnaXQgdGFnIHN0eWxlLCBgbnBtYCBvciBgbGVybmFgXG4gICAqXG4gICAqIEBkZWZhdWx0ICdsZXJuYSdcbiAgICovXG4gIHRhZ1N0eWxlPzogJ25wbScgfCAnbGVybmEnXG4gIC8qKlxuICAgKiBXaGV0aGVyIGNyZWF0ZSBHaXRIdWIgcmVsZWFzZVxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBnaFJlbGVhc2U/OiBib29sZWFuXG4gIC8qKlxuICAgKiBHaXRIdWIgcmVsZWFzZSBuYW1lXG4gICAqL1xuICBnaFJlbGVhc2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBFeGlzdGluZyBHaXRIdWIgcmVsZWFzZSBpZFxuICAgKi9cbiAgZ2hSZWxlYXNlSWQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgc2tpcCBvcHRpb25hbERlcGVuZGVuY2llcyBwYWNrYWdlcyBwdWJsaXNoXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBza2lwT3B0aW9uYWxQdWJsaXNoPzogYm9vbGVhblxuICAvKipcbiAgICogRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcnlSdW4/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyhvcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgdGFnU3R5bGU6ICdsZXJuYScsXG4gICAgZ2hSZWxlYXNlOiB0cnVlLFxuICAgIHNraXBPcHRpb25hbFB1Ymxpc2g6IGZhbHNlLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VWZXJzaW9uQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWyd2ZXJzaW9uJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdVcGRhdGUgdmVyc2lvbiBpbiBjcmVhdGVkIG5wbSBwYWNrYWdlcycsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSB2ZXJzaW9uIGluIGNyZWF0ZWQgbnBtIHBhY2thZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VmVyc2lvbk9wdGlvbnMob3B0aW9uczogVmVyc2lvbk9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IGFwcGx5RGVmYXVsdFZlcnNpb25PcHRpb25zLCBWZXJzaW9uT3B0aW9ucyB9IGZyb20gJy4uL2RlZi92ZXJzaW9uLmpzJ1xuaW1wb3J0IHtcbiAgcmVhZE5hcGlDb25maWcsXG4gIGRlYnVnRmFjdG9yeSxcbiAgdXBkYXRlUGFja2FnZUpzb24sXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndmVyc2lvbicpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJzaW9uKHVzZXJPcHRpb25zOiBWZXJzaW9uT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0VmVyc2lvbk9wdGlvbnModXNlck9wdGlvbnMpXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgZm9yIChjb25zdCB0YXJnZXQgb2YgY29uZmlnLnRhcmdldHMpIHtcbiAgICBjb25zdCBwa2dEaXIgPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpciwgdGFyZ2V0LnBsYXRmb3JtQXJjaEFCSSlcblxuICAgIGRlYnVnKGBVcGRhdGUgdmVyc2lvbiB0byAlaSBpbiBbJWldYCwgY29uZmlnLnBhY2thZ2VKc29uLnZlcnNpb24sIHBrZ0RpcilcbiAgICBhd2FpdCB1cGRhdGVQYWNrYWdlSnNvbihqb2luKHBrZ0RpciwgJ3BhY2thZ2UuanNvbicpLCB7XG4gICAgICB2ZXJzaW9uOiBjb25maWcucGFja2FnZUpzb24udmVyc2lvbixcbiAgICB9KVxuICB9XG59XG4iLCJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGV4aXN0c1N5bmMsIHN0YXRTeW5jIH0gZnJvbSAnbm9kZTpmcydcbmltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IE9jdG9raXQgfSBmcm9tICdAb2N0b2tpdC9yZXN0J1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyxcbiAgUHJlUHVibGlzaE9wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7XG4gIHJlYWRGaWxlQXN5bmMsXG4gIHJlYWROYXBpQ29uZmlnLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIHVwZGF0ZVBhY2thZ2VKc29uLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3ByZS1wdWJsaXNoJylcblxuaW50ZXJmYWNlIFBhY2thZ2VJbmZvIHtcbiAgbmFtZTogc3RyaW5nXG4gIHZlcnNpb246IHN0cmluZ1xuICB0YWc6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlUHVibGlzaCh1c2VyT3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMpIHtcbiAgZGVidWcoJ1JlY2VpdmUgcHJlLXB1Ymxpc2ggb3B0aW9uczonKVxuICBkZWJ1ZygnICAlTycsIHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCB7IHBhY2thZ2VKc29uLCB0YXJnZXRzLCBwYWNrYWdlTmFtZSwgYmluYXJ5TmFtZSwgbnBtQ2xpZW50IH0gPVxuICAgIGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgICAgcGFja2FnZUpzb25QYXRoLFxuICAgICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgICApXG5cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2hSZWxlYXNlKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIGlmICghb3B0aW9ucy5naFJlbGVhc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHJlcG8sIG93bmVyLCBwa2dJbmZvLCBvY3Rva2l0IH0gPSBnZXRSZXBvSW5mbyhwYWNrYWdlTmFtZSwgdmVyc2lvbilcblxuICAgIGlmICghcmVwbyB8fCAhb3duZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9jdG9raXQucmVwb3MuY3JlYXRlUmVsZWFzZSh7XG4gICAgICAgICAgb3duZXIsXG4gICAgICAgICAgcmVwbyxcbiAgICAgICAgICB0YWdfbmFtZTogcGtnSW5mby50YWcsXG4gICAgICAgICAgbmFtZTogb3B0aW9ucy5naFJlbGVhc2VOYW1lLFxuICAgICAgICAgIHByZXJlbGVhc2U6XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdhbHBoYScpIHx8XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdiZXRhJykgfHxcbiAgICAgICAgICAgIHZlcnNpb24uaW5jbHVkZXMoJ3JjJyksXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIGBQYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7IG93bmVyLCByZXBvLCB0YWdfbmFtZTogcGtnSW5mby50YWcgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKVxuICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG93bmVyLCByZXBvLCBwa2dJbmZvLCBvY3Rva2l0IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlcG9JbmZvKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIGNvbnN0IGhlYWRDb21taXQgPSBleGVjU3luYygnZ2l0IGxvZyAtMSAtLXByZXR0eT0lQicsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIH0pLnRyaW0oKVxuXG4gICAgY29uc3QgeyBHSVRIVUJfUkVQT1NJVE9SWSB9ID0gcHJvY2Vzcy5lbnZcbiAgICBpZiAoIUdJVEhVQl9SRVBPU0lUT1JZKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgcmVwbzogbnVsbCxcbiAgICAgICAgcGtnSW5mbzogeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsLCB0YWc6IG51bGwgfSxcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoYEdpdGh1YiByZXBvc2l0b3J5OiAke0dJVEhVQl9SRVBPU0lUT1JZfWApXG4gICAgY29uc3QgW293bmVyLCByZXBvXSA9IEdJVEhVQl9SRVBPU0lUT1JZLnNwbGl0KCcvJylcbiAgICBjb25zdCBvY3Rva2l0ID0gbmV3IE9jdG9raXQoe1xuICAgICAgYXV0aDogcHJvY2Vzcy5lbnYuR0lUSFVCX1RPS0VOLFxuICAgIH0pXG4gICAgbGV0IHBrZ0luZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkXG4gICAgaWYgKG9wdGlvbnMudGFnU3R5bGUgPT09ICdsZXJuYScpIHtcbiAgICAgIGNvbnN0IHBhY2thZ2VzVG9QdWJsaXNoID0gaGVhZENvbW1pdFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKChsaW5lLCBpbmRleCkgPT4gbGluZS5sZW5ndGggJiYgaW5kZXgpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUuc3Vic3RyaW5nKDIpKVxuICAgICAgICAubWFwKHBhcnNlVGFnKVxuXG4gICAgICBwa2dJbmZvID0gcGFja2FnZXNUb1B1Ymxpc2guZmluZChcbiAgICAgICAgKHBrZ0luZm8pID0+IHBrZ0luZm8ubmFtZSA9PT0gcGFja2FnZU5hbWUsXG4gICAgICApXG5cbiAgICAgIGlmICghcGtnSW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBObyByZWxlYXNlIGNvbW1pdCBmb3VuZCB3aXRoICR7cGFja2FnZU5hbWV9LCBvcmlnaW5hbCBjb21taXQgaW5mbzogJHtoZWFkQ29tbWl0fWAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGtnSW5mbyA9IHtcbiAgICAgICAgdGFnOiBgdiR7dmVyc2lvbn1gLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBuYW1lOiBwYWNrYWdlTmFtZSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3duZXIsIHJlcG8sIHBrZ0luZm8sIG9jdG9raXQgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgIGF3YWl0IHZlcnNpb24odXNlck9wdGlvbnMpXG4gICAgYXdhaXQgdXBkYXRlUGFja2FnZUpzb24ocGFja2FnZUpzb25QYXRoLCB7XG4gICAgICBvcHRpb25hbERlcGVuZGVuY2llczogdGFyZ2V0cy5yZWR1Y2UoXG4gICAgICAgIChkZXBzLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICBkZXBzW2Ake3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YF0gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbiAgICAgICAgICByZXR1cm4gZGVwc1xuICAgICAgICB9LFxuICAgICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgICAgKSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgeyBvd25lciwgcmVwbywgcGtnSW5mbywgb2N0b2tpdCB9ID0gb3B0aW9ucy5naFJlbGVhc2VJZFxuICAgID8gZ2V0UmVwb0luZm8ocGFja2FnZU5hbWUsIHBhY2thZ2VKc29uLnZlcnNpb24pXG4gICAgOiBhd2FpdCBjcmVhdGVHaFJlbGVhc2UocGFja2FnZU5hbWUsIHBhY2thZ2VKc29uLnZlcnNpb24pXG5cbiAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgIGNvbnN0IHBrZ0RpciA9IHJlc29sdmUoXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMubnBtRGlyLFxuICAgICAgYCR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgIClcbiAgICBjb25zdCBleHQgPVxuICAgICAgdGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScgfHwgdGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzbScgPyAnd2FzbScgOiAnbm9kZSdcbiAgICBjb25zdCBmaWxlbmFtZSA9IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0uJHtleHR9YFxuICAgIGNvbnN0IGRzdFBhdGggPSBqb2luKHBrZ0RpciwgZmlsZW5hbWUpXG5cbiAgICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICBpZiAoIWV4aXN0c1N5bmMoZHN0UGF0aCkpIHtcbiAgICAgICAgZGVidWcud2FybihgJXMgZG9lc24ndCBleGlzdGAsIGRzdFBhdGgpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5za2lwT3B0aW9uYWxQdWJsaXNoKSB7XG4gICAgICAgIGV4ZWNTeW5jKGAke25wbUNsaWVudH0gcHVibGlzaGAsIHtcbiAgICAgICAgICBjd2Q6IHBrZ0RpcixcbiAgICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5naFJlbGVhc2UgJiYgcmVwbyAmJiBvd25lcikge1xuICAgICAgICBkZWJ1Zy5pbmZvKGBDcmVhdGluZyBHaXRIdWIgcmVsZWFzZSAke3BrZ0luZm8udGFnfWApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVsZWFzZUlkID0gb3B0aW9ucy5naFJlbGVhc2VJZFxuICAgICAgICAgICAgPyBOdW1iZXIob3B0aW9ucy5naFJlbGVhc2VJZClcbiAgICAgICAgICAgIDogKFxuICAgICAgICAgICAgICAgIGF3YWl0IG9jdG9raXQhLnJlcG9zLmdldFJlbGVhc2VCeVRhZyh7XG4gICAgICAgICAgICAgICAgICByZXBvOiByZXBvLFxuICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgICAgICAgdGFnOiBwa2dJbmZvLnRhZyxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApLmRhdGEuaWRcbiAgICAgICAgICBjb25zdCBkc3RGaWxlU3RhdHMgPSBzdGF0U3luYyhkc3RQYXRoKVxuICAgICAgICAgIGNvbnN0IGFzc2V0SW5mbyA9IGF3YWl0IG9jdG9raXQhLnJlcG9zLnVwbG9hZFJlbGVhc2VBc3NldCh7XG4gICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICByZXBvOiByZXBvLFxuICAgICAgICAgICAgbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgICByZWxlYXNlX2lkOiByZWxlYXNlSWQsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IHsgZm9ybWF0OiAncmF3JyB9LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnY29udGVudC1sZW5ndGgnOiBkc3RGaWxlU3RhdHMuc2l6ZSxcbiAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igb2N0b2tpdCB0eXBlcyBhcmUgd3JvbmdcbiAgICAgICAgICAgIGRhdGE6IGF3YWl0IHJlYWRGaWxlQXN5bmMoZHN0UGF0aCksXG4gICAgICAgICAgfSlcbiAgICAgICAgICBkZWJ1Zy5pbmZvKGBHaXRIdWIgcmVsZWFzZSBjcmVhdGVkYClcbiAgICAgICAgICBkZWJ1Zy5pbmZvKGBEb3dubG9hZCBVUkw6ICVzYCwgYXNzZXRJbmZvLmRhdGEuYnJvd3Nlcl9kb3dubG9hZF91cmwpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihcbiAgICAgICAgICAgIGBQYXJhbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgeyBvd25lciwgcmVwbywgdGFnOiBwa2dJbmZvLnRhZywgZmlsZW5hbWU6IGRzdFBhdGggfSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRhZyh0YWc6IHN0cmluZykge1xuICBjb25zdCBzZWdtZW50cyA9IHRhZy5zcGxpdCgnQCcpXG4gIGNvbnN0IHZlcnNpb24gPSBzZWdtZW50cy5wb3AoKSFcbiAgY29uc3QgbmFtZSA9IHNlZ21lbnRzLmpvaW4oJ0AnKVxuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICB2ZXJzaW9uLFxuICAgIHRhZyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgcHJlUHVibGlzaCB9IGZyb20gJy4uL2FwaS9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7IEJhc2VQcmVQdWJsaXNoQ29tbWFuZCB9IGZyb20gJy4uL2RlZi9wcmUtcHVibGlzaC5qcydcblxuZXhwb3J0IGNsYXNzIFByZVB1Ymxpc2hDb21tYW5kIGV4dGVuZHMgQmFzZVByZVB1Ymxpc2hDb21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNvbnN0ICducG0nIHwgJ2xlcm5hJyB0byBzdHJpbmdcbiAgICBhd2FpdCBwcmVQdWJsaXNoKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyBpbnB1dCB9IGZyb20gJ0BpbnF1aXJlci9wcm9tcHRzJ1xuXG5pbXBvcnQgeyByZW5hbWVQcm9qZWN0IH0gZnJvbSAnLi4vYXBpL3JlbmFtZS5qcydcbmltcG9ydCB7IEJhc2VSZW5hbWVDb21tYW5kIH0gZnJvbSAnLi4vZGVmL3JlbmFtZS5qcydcblxuZXhwb3J0IGNsYXNzIFJlbmFtZUNvbW1hbmQgZXh0ZW5kcyBCYXNlUmVuYW1lQ29tbWFuZCB7XG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpXG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBpbnB1dCh7XG4gICAgICAgIG1lc3NhZ2U6IGBFbnRlciB0aGUgbmV3IHBhY2thZ2UgbmFtZSBpbiB0aGUgcGFja2FnZS5qc29uYCxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB9KVxuICAgICAgb3B0aW9ucy5uYW1lID0gbmFtZVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgICAgY29uc3QgYmluYXJ5TmFtZSA9IGF3YWl0IGlucHV0KHtcbiAgICAgICAgbWVzc2FnZTogYEVudGVyIHRoZSBuZXcgYmluYXJ5IG5hbWVgLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBvcHRpb25zLmJpbmFyeU5hbWUgPSBiaW5hcnlOYW1lXG4gICAgfVxuICAgIGF3YWl0IHJlbmFtZVByb2plY3Qob3B0aW9ucylcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VVbml2ZXJzYWxpemVDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3VuaXZlcnNhbGl6ZSddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ29tYmlsZSBidWlsdCBiaW5hcmllcyBpbnRvIG9uZSB1bml2ZXJzYWwgYmluYXJ5JyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBvdXRwdXREaXIgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8nLCAnLi8nLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG91dHB1dERpcjogdGhpcy5vdXRwdXREaXIsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tYmlsZSBidWlsdCBiaW5hcmllcyBpbnRvIG9uZSB1bml2ZXJzYWwgYmluYXJ5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5pdmVyc2FsaXplT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZFxuICAgKlxuICAgKiBAZGVmYXVsdCAnLi8nXG4gICAqL1xuICBvdXRwdXREaXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFVuaXZlcnNhbGl6ZU9wdGlvbnMob3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG91dHB1dERpcjogJy4vJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgeyBzcGF3blN5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRVbml2ZXJzYWxpemVPcHRpb25zLFxuICBVbml2ZXJzYWxpemVPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgcmVhZE5hcGlDb25maWcgfSBmcm9tICcuLi91dGlscy9jb25maWcuanMnXG5pbXBvcnQgeyBkZWJ1Z0ZhY3RvcnkgfSBmcm9tICcuLi91dGlscy9sb2cuanMnXG5pbXBvcnQgeyBmaWxlRXhpc3RzIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy5qcydcbmltcG9ydCB7IFVuaUFyY2hzQnlQbGF0Zm9ybSB9IGZyb20gJy4uL3V0aWxzL3RhcmdldC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3VuaXZlcnNhbGl6ZScpXG5cbmNvbnN0IHVuaXZlcnNhbGl6ZXJzOiBQYXJ0aWFsPFxuICBSZWNvcmQ8Tm9kZUpTLlBsYXRmb3JtLCAoaW5wdXRzOiBzdHJpbmdbXSwgb3V0cHV0OiBzdHJpbmcpID0+IHZvaWQ+XG4+ID0ge1xuICBkYXJ3aW46IChpbnB1dHMsIG91dHB1dCkgPT4ge1xuICAgIHNwYXduU3luYygnbGlwbycsIFsnLWNyZWF0ZScsICctb3V0cHV0Jywgb3V0cHV0LCAuLi5pbnB1dHNdLCB7XG4gICAgICBzdGRpbzogJ2luaGVyaXQnLFxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1bml2ZXJzYWxpemVCaW5hcmllcyh1c2VyT3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGNvbnN0IHRhcmdldCA9IGNvbmZpZy50YXJnZXRzLmZpbmQoXG4gICAgKHQpID0+IHQucGxhdGZvcm0gPT09IHByb2Nlc3MucGxhdGZvcm0gJiYgdC5hcmNoID09PSAndW5pdmVyc2FsJyxcbiAgKVxuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCd1bml2ZXJzYWwnIGFyY2ggZm9yIHBsYXRmb3JtICcke3Byb2Nlc3MucGxhdGZvcm19JyBub3QgZm91bmQgaW4gY29uZmlnIWAsXG4gICAgKVxuICB9XG5cbiAgY29uc3Qgc3JjRmlsZXMgPSBVbmlBcmNoc0J5UGxhdGZvcm1bcHJvY2Vzcy5wbGF0Zm9ybV0/Lm1hcCgoYXJjaCkgPT5cbiAgICByZXNvbHZlKFxuICAgICAgb3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm91dHB1dERpcixcbiAgICAgIGAke2NvbmZpZy5iaW5hcnlOYW1lfS4ke3Byb2Nlc3MucGxhdGZvcm19LSR7YXJjaH0ubm9kZWAsXG4gICAgKSxcbiAgKVxuXG4gIGlmICghc3JjRmlsZXMgfHwgIXVuaXZlcnNhbGl6ZXJzW3Byb2Nlc3MucGxhdGZvcm1dKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCd1bml2ZXJzYWwnIGFyY2ggZm9yIHBsYXRmb3JtICcke3Byb2Nlc3MucGxhdGZvcm19JyBub3Qgc3VwcG9ydGVkLmAsXG4gICAgKVxuICB9XG5cbiAgZGVidWcoYExvb2tpbmcgdXAgc291cmNlIGJpbmFyaWVzIHRvIGNvbWJpbmU6IGApXG4gIGRlYnVnKCcgICVPJywgc3JjRmlsZXMpXG5cbiAgY29uc3Qgc3JjRmlsZUxvb2t1cCA9IGF3YWl0IFByb21pc2UuYWxsKHNyY0ZpbGVzLm1hcCgoZikgPT4gZmlsZUV4aXN0cyhmKSkpXG5cbiAgY29uc3Qgbm90Rm91bmRGaWxlcyA9IHNyY0ZpbGVzLmZpbHRlcigoXywgaSkgPT4gIXNyY0ZpbGVMb29rdXBbaV0pXG5cbiAgaWYgKG5vdEZvdW5kRmlsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFNvbWUgYmluYXJ5IGZpbGVzIHdlcmUgbm90IGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KG5vdEZvdW5kRmlsZXMpfWAsXG4gICAgKVxuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gcmVzb2x2ZShcbiAgICBvcHRpb25zLmN3ZCxcbiAgICBvcHRpb25zLm91dHB1dERpcixcbiAgICBgJHtjb25maWcuYmluYXJ5TmFtZX0uJHtwcm9jZXNzLnBsYXRmb3JtfS11bml2ZXJzYWwubm9kZWAsXG4gIClcblxuICB1bml2ZXJzYWxpemVyc1twcm9jZXNzLnBsYXRmb3JtXT8uKHNyY0ZpbGVzLCBvdXRwdXQpXG5cbiAgZGVidWcoYFByb2R1Y2VkIHVuaXZlcnNhbCBiaW5hcnk6ICR7b3V0cHV0fWApXG59XG4iLCJpbXBvcnQgeyB1bml2ZXJzYWxpemVCaW5hcmllcyB9IGZyb20gJy4uL2FwaS91bml2ZXJzYWxpemUuanMnXG5pbXBvcnQgeyBCYXNlVW5pdmVyc2FsaXplQ29tbWFuZCB9IGZyb20gJy4uL2RlZi91bml2ZXJzYWxpemUuanMnXG5cbmV4cG9ydCBjbGFzcyBVbml2ZXJzYWxpemVDb21tYW5kIGV4dGVuZHMgQmFzZVVuaXZlcnNhbGl6ZUNvbW1hbmQge1xuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IHVuaXZlcnNhbGl6ZUJpbmFyaWVzKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vYXBpL3ZlcnNpb24uanMnXG5pbXBvcnQgeyBCYXNlVmVyc2lvbkNvbW1hbmQgfSBmcm9tICcuLi9kZWYvdmVyc2lvbi5qcydcblxuZXhwb3J0IGNsYXNzIFZlcnNpb25Db21tYW5kIGV4dGVuZHMgQmFzZVZlcnNpb25Db21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCB2ZXJzaW9uKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCIjIS91c3IvYmluL2VudiBub2RlXG5cbmltcG9ydCB7IENsaSB9IGZyb20gJ2NsaXBhbmlvbidcblxuaW1wb3J0IHsgQXJ0aWZhY3RzQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvYXJ0aWZhY3RzLmpzJ1xuaW1wb3J0IHsgQnVpbGRDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9idWlsZC5qcydcbmltcG9ydCB7IENyZWF0ZU5wbURpcnNDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQgeyBIZWxwQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvaGVscC5qcydcbmltcG9ydCB7IE5ld0NvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL25ldy5qcydcbmltcG9ydCB7IFByZVB1Ymxpc2hDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7IFJlbmFtZUNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3JlbmFtZS5qcydcbmltcG9ydCB7IFVuaXZlcnNhbGl6ZUNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3VuaXZlcnNhbGl6ZS5qcydcbmltcG9ydCB7IFZlcnNpb25Db21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgQ0xJX1ZFUlNJT04gfSBmcm9tICcuL3V0aWxzL21pc2MuanMnXG5cbmNvbnN0IGNsaSA9IG5ldyBDbGkoe1xuICBiaW5hcnlOYW1lOiAnbmFwaScsXG4gIGJpbmFyeVZlcnNpb246IENMSV9WRVJTSU9OLFxufSlcblxuY2xpLnJlZ2lzdGVyKE5ld0NvbW1hbmQpXG5jbGkucmVnaXN0ZXIoQnVpbGRDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKENyZWF0ZU5wbURpcnNDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKEFydGlmYWN0c0NvbW1hbmQpXG5jbGkucmVnaXN0ZXIoVW5pdmVyc2FsaXplQ29tbWFuZClcbmNsaS5yZWdpc3RlcihSZW5hbWVDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKFByZVB1Ymxpc2hDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKFZlcnNpb25Db21tYW5kKVxuY2xpLnJlZ2lzdGVyKEhlbHBDb21tYW5kKVxuXG52b2lkIGNsaS5ydW5FeGl0KHByb2Nlc3MuYXJndi5zbGljZSgyKSlcbiJdLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMjQsMjUsMjYsMjcsMjhdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLElBQXNCLHVCQUF0QixjQUFtRCxRQUFRO0NBQ3pELE9BQU8sUUFBUSxDQUFDLENBQUMsV0FBWSxDQUFDO0NBRTlCLE9BQU8sUUFBUSxRQUFRLE1BQU0sRUFDM0IsYUFDRSw0RUFDSCxFQUFDO0NBRUYsTUFBTSxPQUFPLE9BQU8sU0FBUyxRQUFRLEtBQUssRUFBRSxFQUMxQyxhQUNFLHFIQUNILEVBQUM7Q0FFRixhQUFzQixPQUFPLE9BQU8sb0JBQW9CLEVBQ3RELGFBQWEsa0NBQ2QsRUFBQztDQUVGLGtCQUFrQixPQUFPLE9BQU8sdUJBQXVCLGdCQUFnQixFQUNyRSxhQUFhLHlCQUNkLEVBQUM7Q0FFRixZQUFZLE9BQU8sT0FBTyxzQkFBc0IsZUFBZSxFQUM3RCxhQUNFLGdHQUNILEVBQUM7Q0FFRixTQUFTLE9BQU8sT0FBTyxhQUFhLE9BQU8sRUFDekMsYUFBYSxnREFDZCxFQUFDO0NBRUYsaUJBQTBCLE9BQU8sT0FBTyxzQkFBc0IsRUFDNUQsYUFDRSxrRkFDSCxFQUFDO0NBRUYsYUFBYTtBQUNYLFNBQU87R0FDTCxLQUFLLEtBQUs7R0FDVixZQUFZLEtBQUs7R0FDakIsaUJBQWlCLEtBQUs7R0FDdEIsV0FBVyxLQUFLO0dBQ2hCLFFBQVEsS0FBSztHQUNiLGdCQUFnQixLQUFLO0VBQ3RCO0NBQ0Y7QUFDRjtBQXdDRCxTQUFnQiw2QkFBNkJBLFNBQTJCO0FBQ3RFLFFBQU87RUFDTCxLQUFLLFFBQVEsS0FBSztFQUNsQixpQkFBaUI7RUFDakIsV0FBVztFQUNYLFFBQVE7RUFDUixHQUFHO0NBQ0o7QUFDRjs7OztBQzdGRCxT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