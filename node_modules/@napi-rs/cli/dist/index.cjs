//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys$1 = __getOwnPropNames(from), i = 0, n = keys$1.length, key; i < n; i++) {
		key = keys$1[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const node_path = __toESM(require("node:path"));
const colorette = __toESM(require("colorette"));
const clipanion = __toESM(require("clipanion"));
const debug = __toESM(require("debug"));
const node_fs = __toESM(require("node:fs"));
const node_util = __toESM(require("node:util"));
const node_child_process = __toESM(require("node:child_process"));
const node_crypto = __toESM(require("node:crypto"));
const node_module = __toESM(require("node:module"));
const node_os = __toESM(require("node:os"));
const semver = __toESM(require("semver"));
const js_yaml = __toESM(require("js-yaml"));
const typanion = __toESM(require("typanion"));
const node_fs_promises = __toESM(require("node:fs/promises"));
const find_up = __toESM(require("find-up"));

//#region src/def/artifacts.ts
var BaseArtifactsCommand = class extends clipanion.Command {
	static paths = [["artifacts"]];
	static usage = clipanion.Command.Usage({ description: "Copy artifacts from Github Actions into npm packages and ready to publish" });
	cwd = clipanion.Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = clipanion.Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = clipanion.Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = clipanion.Option.String("--output-dir,-o,-d", "./artifacts", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	npmDir = clipanion.Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	buildOutputDir = clipanion.Option.String("--build-output-dir", { description: "Path to the build output dir, only needed when targets contains `wasm32-wasi-*`" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir,
			npmDir: this.npmDir,
			buildOutputDir: this.buildOutputDir
		};
	}
};
function applyDefaultArtifactsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./artifacts",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/utils/log.ts
debug.default.formatters.i = (v) => {
	return colorette.green(v);
};
const debugFactory = (namespace) => {
	const debug$9 = (0, debug.default)(`napi:${namespace}`);
	debug$9.info = (...args) => console.error(colorette.black(colorette.bgGreen(" INFO ")), ...args);
	debug$9.warn = (...args) => console.error(colorette.black(colorette.bgYellow(" WARNING ")), ...args);
	debug$9.error = (...args) => console.error(colorette.white(colorette.bgRed(" ERROR ")), ...args.map((arg) => arg instanceof Error ? arg.stack ?? arg.message : arg));
	return debug$9;
};
const debug$8 = debugFactory("utils");

//#endregion
//#region package.json
var name = "@napi-rs/cli";
var version$1 = "3.0.4";
var description = "Cli tools for napi-rs";
var author = "LongYinan <lynweklm@gmail.com>";
var homepage = "https://github.com/napi-rs/napi-rs";
var license = "MIT";
var type = "module";
var engines = { "node": ">= 16" };
var bin = {
	"napi": "./dist/cli.js",
	"napi-raw": "./cli.mjs"
};
var main = "./dist/index.cjs";
var module$1 = "./dist/index.js";
var exports$1 = {
	".": {
		"import": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.js"
		},
		"require": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.cjs"
		}
	},
	"./package.json": {
		"import": "./package.json",
		"require": "./package.json"
	}
};
var files = ["dist", "src"];
var keywords = [
	"cli",
	"rust",
	"napi",
	"n-api",
	"node-api",
	"node-addon",
	"neon"
];
var maintainers = [{
	"name": "LongYinan",
	"email": "lynweklm@gmail.com",
	"homepage": "https://github.com/Brooooooklyn"
}, {
	"name": "forehalo",
	"homepage": "https://github.com/forehalo"
}];
var repository = {
	"type": "git",
	"url": "git+https://github.com/napi-rs/napi-rs.git"
};
var publishConfig = {
	"registry": "https://registry.npmjs.org/",
	"access": "public"
};
var bugs = { "url": "https://github.com/napi-rs/napi-rs/issues" };
var dependencies = {
	"@inquirer/prompts": "^7.4.0",
	"@napi-rs/cross-toolchain": "^1.0.0",
	"@napi-rs/wasm-tools": "^1.0.0",
	"@octokit/rest": "^22.0.0",
	"clipanion": "^4.0.0-rc.4",
	"colorette": "^2.0.20",
	"debug": "^4.4.0",
	"emnapi": "^1.4.0",
	"find-up": "^7.0.0",
	"js-yaml": "^4.1.0",
	"lodash-es": "^4.17.21",
	"semver": "^7.7.1",
	"typanion": "^3.14.0"
};
var devDependencies = {
	"@emnapi/core": "^1.4.0",
	"@emnapi/runtime": "^1.4.0",
	"@oxc-node/core": "^0.0.30",
	"@std/toml": "npm:@jsr/std__toml@^1.0.8",
	"@types/debug": "^4.1.12",
	"@types/inquirer": "^9.0.7",
	"@types/js-yaml": "^4.0.9",
	"@types/lodash-es": "^4.17.12",
	"@types/node": "^22.13.16",
	"@types/semver": "^7.7.0",
	"ava": "^6.2.0",
	"env-paths": "^3.0.0",
	"prettier": "^3.5.3",
	"rolldown": "latest",
	"tslib": "^2.8.1",
	"typescript": "^5.8.2"
};
var peerDependencies = {
	"@emnapi/runtime": "^1.1.0",
	"emnapi": "^1.1.0"
};
var peerDependenciesMeta = {
	"@emnapi/runtime": { "optional": true },
	"emnapi": { "optional": true }
};
var funding = {
	"type": "github",
	"url": "https://github.com/sponsors/Brooooooklyn"
};
var scripts = {
	"clean": "node --import @oxc-node/core/register ./clean.ts",
	"codegen": "node --import @oxc-node/core/register ./codegen/index.ts",
	"build": "tsc && yarn clean && rolldown -c rolldown.config.js",
	"test": "node --import @oxc-node/core/register ../node_modules/ava/entrypoints/cli.mjs"
};
var ava = {
	"extensions": { "ts": "module" },
	"timeout": "1m",
	"files": ["**/__tests__/**/*.spec.ts", "e2e/**/*.spec.ts"]
};
var gitHead = "521b5774aa89f1a7c807a6ddba509ce43973f624";
var package_default = {
	name,
	version: version$1,
	description,
	author,
	homepage,
	license,
	type,
	engines,
	bin,
	main,
	module: module$1,
	exports: exports$1,
	files,
	keywords,
	maintainers,
	repository,
	publishConfig,
	bugs,
	dependencies,
	devDependencies,
	peerDependencies,
	peerDependenciesMeta,
	funding,
	scripts,
	ava,
	gitHead
};

//#endregion
//#region src/utils/misc.ts
const readFileAsync = (0, node_util.promisify)(node_fs.readFile);
const writeFileAsync = (0, node_util.promisify)(node_fs.writeFile);
const unlinkAsync = (0, node_util.promisify)(node_fs.unlink);
const copyFileAsync = (0, node_util.promisify)(node_fs.copyFile);
const mkdirAsync = (0, node_util.promisify)(node_fs.mkdir);
const statAsync = (0, node_util.promisify)(node_fs.stat);
const readdirAsync = (0, node_util.promisify)(node_fs.readdir);
async function fileExists(path$1) {
	const exists = await statAsync(path$1).then(() => true).catch(() => false);
	return exists;
}
async function dirExistsAsync(path$1) {
	try {
		const stats = await statAsync(path$1);
		return stats.isDirectory();
	} catch {
		return false;
	}
}
function pick(o, ...keys$1) {
	return keys$1.reduce((acc, key) => {
		acc[key] = o[key];
		return acc;
	}, {});
}
async function updatePackageJson(path$1, partial) {
	const exists = await fileExists(path$1);
	if (!exists) {
		debug$8(`File not exists ${path$1}`);
		return;
	}
	const old = JSON.parse(await readFileAsync(path$1, "utf8"));
	await writeFileAsync(path$1, JSON.stringify({
		...old,
		...partial
	}, null, 2));
}
const CLI_VERSION = package_default.version;

//#endregion
//#region src/utils/target.ts
const AVAILABLE_TARGETS = [
	"aarch64-apple-darwin",
	"aarch64-linux-android",
	"aarch64-unknown-linux-gnu",
	"aarch64-unknown-linux-musl",
	"aarch64-unknown-linux-ohos",
	"aarch64-pc-windows-msvc",
	"x86_64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu",
	"x86_64-unknown-linux-musl",
	"x86_64-unknown-linux-ohos",
	"x86_64-unknown-freebsd",
	"i686-pc-windows-msvc",
	"armv7-unknown-linux-gnueabihf",
	"armv7-unknown-linux-musleabihf",
	"armv7-linux-androideabi",
	"universal-apple-darwin",
	"riscv64gc-unknown-linux-gnu",
	"powerpc64le-unknown-linux-gnu",
	"s390x-unknown-linux-gnu",
	"wasm32-wasi-preview1-threads",
	"wasm32-wasip1-threads"
];
const DEFAULT_TARGETS = [
	"x86_64-apple-darwin",
	"aarch64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu"
];
const TARGET_LINKER = {
	"aarch64-unknown-linux-musl": "aarch64-linux-musl-gcc",
	"riscv64gc-unknown-linux-gnu": "riscv64-linux-gnu-gcc",
	"powerpc64le-unknown-linux-gnu": "powerpc64le-linux-gnu-gcc",
	"s390x-unknown-linux-gnu": "s390x-linux-gnu-gcc"
};
const CpuToNodeArch = {
	x86_64: "x64",
	aarch64: "arm64",
	i686: "ia32",
	armv7: "arm",
	riscv64gc: "riscv64",
	powerpc64le: "ppc64"
};
const SysToNodePlatform = {
	linux: "linux",
	freebsd: "freebsd",
	darwin: "darwin",
	windows: "win32",
	ohos: "openharmony"
};
const UniArchsByPlatform = { darwin: ["x64", "arm64"] };
/**
* A triple is a specific format for specifying a target architecture.
* Triples may be referred to as a target triple which is the architecture for the artifact produced, and the host triple which is the architecture that the compiler is running on.
* The general format of the triple is `<arch><sub>-<vendor>-<sys>-<abi>` where:
*   - `arch` = The base CPU architecture, for example `x86_64`, `i686`, `arm`, `thumb`, `mips`, etc.
*   - `sub` = The CPU sub-architecture, for example `arm` has `v7`, `v7s`, `v5te`, etc.
*   - `vendor` = The vendor, for example `unknown`, `apple`, `pc`, `nvidia`, etc.
*   - `sys` = The system name, for example `linux`, `windows`, `darwin`, etc. none is typically used for bare-metal without an OS.
*   - `abi` = The ABI, for example `gnu`, `android`, `eabi`, etc.
*/
function parseTriple(rawTriple) {
	if (rawTriple === "wasm32-wasi" || rawTriple === "wasm32-wasi-preview1-threads" || rawTriple.startsWith("wasm32-wasip")) return {
		triple: rawTriple,
		platformArchABI: "wasm32-wasi",
		platform: "wasi",
		arch: "wasm32",
		abi: "wasi"
	};
	const triple = rawTriple.endsWith("eabi") ? `${rawTriple.slice(0, -4)}-eabi` : rawTriple;
	const triples = triple.split("-");
	let cpu;
	let sys;
	let abi = null;
	if (triples.length === 2) [cpu, sys] = triples;
	else [cpu, , sys, abi = null] = triples;
	const platform = SysToNodePlatform[sys] ?? sys;
	const arch = CpuToNodeArch[cpu] ?? cpu;
	if (rawTriple.includes("ohos")) return {
		triple: rawTriple,
		platformArchABI: `linux-${arch}-ohos`,
		platform: "openharmony",
		arch,
		abi: null
	};
	return {
		triple: rawTriple,
		platformArchABI: abi ? `${platform}-${arch}-${abi}` : `${platform}-${arch}`,
		platform,
		arch,
		abi
	};
}
function getSystemDefaultTarget() {
	const host = (0, node_child_process.execSync)(`rustc -vV`, { env: process.env }).toString("utf8").split("\n").find((line) => line.startsWith("host: "));
	const triple = host?.slice(6);
	if (!triple) throw new TypeError(`Can not parse target triple from host`);
	return parseTriple(triple);
}
function getTargetLinker(target) {
	return TARGET_LINKER[target];
}
function targetToEnvVar(target) {
	return target.replace(/-/g, "_").toUpperCase();
}

//#endregion
//#region src/utils/version.ts
let NapiVersion = /* @__PURE__ */ function(NapiVersion$1) {
	NapiVersion$1[NapiVersion$1["Napi1"] = 1] = "Napi1";
	NapiVersion$1[NapiVersion$1["Napi2"] = 2] = "Napi2";
	NapiVersion$1[NapiVersion$1["Napi3"] = 3] = "Napi3";
	NapiVersion$1[NapiVersion$1["Napi4"] = 4] = "Napi4";
	NapiVersion$1[NapiVersion$1["Napi5"] = 5] = "Napi5";
	NapiVersion$1[NapiVersion$1["Napi6"] = 6] = "Napi6";
	NapiVersion$1[NapiVersion$1["Napi7"] = 7] = "Napi7";
	NapiVersion$1[NapiVersion$1["Napi8"] = 8] = "Napi8";
	NapiVersion$1[NapiVersion$1["Napi9"] = 9] = "Napi9";
	return NapiVersion$1;
}({});
const NAPI_VERSION_MATRIX = new Map([
	[NapiVersion.Napi1, "8.6.0 | 9.0.0 | 10.0.0"],
	[NapiVersion.Napi2, "8.10.0 | 9.3.0 | 10.0.0"],
	[NapiVersion.Napi3, "6.14.2 | 8.11.2 | 9.11.0 | 10.0.0"],
	[NapiVersion.Napi4, "10.16.0 | 11.8.0 | 12.0.0"],
	[NapiVersion.Napi5, "10.17.0 | 12.11.0 | 13.0.0"],
	[NapiVersion.Napi6, "10.20.0 | 12.17.0 | 14.0.0"],
	[NapiVersion.Napi7, "10.23.0 | 12.19.0 | 14.12.0 | 15.0.0"],
	[NapiVersion.Napi8, "12.22.0 | 14.17.0 | 15.12.0 | 16.0.0"],
	[NapiVersion.Napi9, "18.17.0 | 20.3.0 | 21.1.0"]
]);
function parseNodeVersion(v) {
	const matches = v.match(/v?([0-9]+)\.([0-9]+)\.([0-9]+)/i);
	if (!matches) throw new Error("Unknown node version number: " + v);
	const [, major, minor, patch] = matches;
	return {
		major: parseInt(major),
		minor: parseInt(minor),
		patch: parseInt(patch)
	};
}
function requiredNodeVersions(napiVersion) {
	const requirement = NAPI_VERSION_MATRIX.get(napiVersion);
	if (!requirement) return [parseNodeVersion("10.0.0")];
	return requirement.split("|").map(parseNodeVersion);
}
function toEngineRequirement(versions) {
	const requirements = [];
	versions.forEach((v, i) => {
		let req = "";
		if (i !== 0) {
			const lastVersion = versions[i - 1];
			req += `< ${lastVersion.major + 1}`;
		}
		req += `${i === 0 ? "" : " || "}>= ${v.major}.${v.minor}.${v.patch}`;
		requirements.push(req);
	});
	return requirements.join(" ");
}
function napiEngineRequirement(napiVersion) {
	return toEngineRequirement(requiredNodeVersions(napiVersion));
}

//#endregion
//#region src/utils/metadata.ts
async function parseMetadata(manifestPath) {
	if (!node_fs.default.existsSync(manifestPath)) throw new Error(`No crate found in manifest: ${manifestPath}`);
	const childProcess = (0, node_child_process.spawn)("cargo", [
		"metadata",
		"--manifest-path",
		manifestPath,
		"--format-version",
		"1"
	], { stdio: "pipe" });
	let stdout = "";
	let stderr = "";
	let status = 0;
	let error = null;
	childProcess.stdout.on("data", (data) => {
		stdout += data;
	});
	childProcess.stderr.on("data", (data) => {
		stderr += data;
	});
	await new Promise((resolve$7) => {
		childProcess.on("close", (code) => {
			status = code ?? 0;
			resolve$7();
		});
	});
	if (error) throw new Error("cargo metadata failed to run", { cause: error });
	if (status !== 0) {
		const simpleMessage = `cargo metadata exited with code ${status}`;
		throw new Error(`${simpleMessage} and error message:\n\n${stderr}`, { cause: new Error(simpleMessage) });
	}
	try {
		return JSON.parse(stdout);
	} catch (e) {
		throw new Error("Failed to parse cargo metadata JSON", { cause: e });
	}
}

//#endregion
//#region ../node_modules/lodash-es/_freeGlobal.js
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var _freeGlobal_default = freeGlobal;

//#endregion
//#region ../node_modules/lodash-es/_root.js
/** Detect free variable `self`. */
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */
var root = _freeGlobal_default || freeSelf || Function("return this")();
var _root_default = root;

//#endregion
//#region ../node_modules/lodash-es/_Symbol.js
/** Built-in value references. */
var Symbol$1 = _root_default.Symbol;
var _Symbol_default = Symbol$1;

//#endregion
//#region ../node_modules/lodash-es/_getRawTag.js
/** Used for built-in method references. */
var objectProto$15 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$12 = objectProto$15.hasOwnProperty;
/**
* Used to resolve the
* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
* of values.
*/
var nativeObjectToString$1 = objectProto$15.toString;
/** Built-in value references. */
var symToStringTag$1 = _Symbol_default ? _Symbol_default.toStringTag : void 0;
/**
* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
*
* @private
* @param {*} value The value to query.
* @returns {string} Returns the raw `toStringTag`.
*/
function getRawTag(value$1) {
	var isOwn = hasOwnProperty$12.call(value$1, symToStringTag$1), tag = value$1[symToStringTag$1];
	try {
		value$1[symToStringTag$1] = void 0;
		var unmasked = true;
	} catch (e) {}
	var result = nativeObjectToString$1.call(value$1);
	if (unmasked) if (isOwn) value$1[symToStringTag$1] = tag;
	else delete value$1[symToStringTag$1];
	return result;
}
var _getRawTag_default = getRawTag;

//#endregion
//#region ../node_modules/lodash-es/_objectToString.js
/** Used for built-in method references. */
var objectProto$14 = Object.prototype;
/**
* Used to resolve the
* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
* of values.
*/
var nativeObjectToString = objectProto$14.toString;
/**
* Converts `value` to a string using `Object.prototype.toString`.
*
* @private
* @param {*} value The value to convert.
* @returns {string} Returns the converted string.
*/
function objectToString(value$1) {
	return nativeObjectToString.call(value$1);
}
var _objectToString_default = objectToString;

//#endregion
//#region ../node_modules/lodash-es/_baseGetTag.js
/** `Object#toString` result references. */
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
/** Built-in value references. */
var symToStringTag = _Symbol_default ? _Symbol_default.toStringTag : void 0;
/**
* The base implementation of `getTag` without fallbacks for buggy environments.
*
* @private
* @param {*} value The value to query.
* @returns {string} Returns the `toStringTag`.
*/
function baseGetTag(value$1) {
	if (value$1 == null) return value$1 === void 0 ? undefinedTag : nullTag;
	return symToStringTag && symToStringTag in Object(value$1) ? _getRawTag_default(value$1) : _objectToString_default(value$1);
}
var _baseGetTag_default = baseGetTag;

//#endregion
//#region ../node_modules/lodash-es/isObjectLike.js
/**
* Checks if `value` is object-like. A value is object-like if it's not `null`
* and has a `typeof` result of "object".
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
* @example
*
* _.isObjectLike({});
* // => true
*
* _.isObjectLike([1, 2, 3]);
* // => true
*
* _.isObjectLike(_.noop);
* // => false
*
* _.isObjectLike(null);
* // => false
*/
function isObjectLike(value$1) {
	return value$1 != null && typeof value$1 == "object";
}
var isObjectLike_default = isObjectLike;

//#endregion
//#region ../node_modules/lodash-es/isSymbol.js
/** `Object#toString` result references. */
var symbolTag$3 = "[object Symbol]";
/**
* Checks if `value` is classified as a `Symbol` primitive or object.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
* @example
*
* _.isSymbol(Symbol.iterator);
* // => true
*
* _.isSymbol('abc');
* // => false
*/
function isSymbol(value$1) {
	return typeof value$1 == "symbol" || isObjectLike_default(value$1) && _baseGetTag_default(value$1) == symbolTag$3;
}
var isSymbol_default = isSymbol;

//#endregion
//#region ../node_modules/lodash-es/_arrayMap.js
/**
* A specialized version of `_.map` for arrays without support for iteratee
* shorthands.
*
* @private
* @param {Array} [array] The array to iterate over.
* @param {Function} iteratee The function invoked per iteration.
* @returns {Array} Returns the new mapped array.
*/
function arrayMap(array, iteratee) {
	var index = -1, length = array == null ? 0 : array.length, result = Array(length);
	while (++index < length) result[index] = iteratee(array[index], index, array);
	return result;
}
var _arrayMap_default = arrayMap;

//#endregion
//#region ../node_modules/lodash-es/isArray.js
/**
* Checks if `value` is classified as an `Array` object.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an array, else `false`.
* @example
*
* _.isArray([1, 2, 3]);
* // => true
*
* _.isArray(document.body.children);
* // => false
*
* _.isArray('abc');
* // => false
*
* _.isArray(_.noop);
* // => false
*/
var isArray = Array.isArray;
var isArray_default = isArray;

//#endregion
//#region ../node_modules/lodash-es/_baseToString.js
/** Used as references for various `Number` constants. */
var INFINITY$1 = Infinity;
/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = _Symbol_default ? _Symbol_default.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
/**
* The base implementation of `_.toString` which doesn't convert nullish
* values to empty strings.
*
* @private
* @param {*} value The value to process.
* @returns {string} Returns the string.
*/
function baseToString(value$1) {
	if (typeof value$1 == "string") return value$1;
	if (isArray_default(value$1)) return _arrayMap_default(value$1, baseToString) + "";
	if (isSymbol_default(value$1)) return symbolToString ? symbolToString.call(value$1) : "";
	var result = value$1 + "";
	return result == "0" && 1 / value$1 == -INFINITY$1 ? "-0" : result;
}
var _baseToString_default = baseToString;

//#endregion
//#region ../node_modules/lodash-es/isObject.js
/**
* Checks if `value` is the
* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an object, else `false`.
* @example
*
* _.isObject({});
* // => true
*
* _.isObject([1, 2, 3]);
* // => true
*
* _.isObject(_.noop);
* // => true
*
* _.isObject(null);
* // => false
*/
function isObject$1(value$1) {
	var type$1 = typeof value$1;
	return value$1 != null && (type$1 == "object" || type$1 == "function");
}
var isObject_default = isObject$1;

//#endregion
//#region ../node_modules/lodash-es/identity.js
/**
* This method returns the first argument it receives.
*
* @static
* @since 0.1.0
* @memberOf _
* @category Util
* @param {*} value Any value.
* @returns {*} Returns `value`.
* @example
*
* var object = { 'a': 1 };
*
* console.log(_.identity(object) === object);
* // => true
*/
function identity(value$1) {
	return value$1;
}
var identity_default = identity;

//#endregion
//#region ../node_modules/lodash-es/isFunction.js
/** `Object#toString` result references. */
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
/**
* Checks if `value` is classified as a `Function` object.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a function, else `false`.
* @example
*
* _.isFunction(_);
* // => true
*
* _.isFunction(/abc/);
* // => false
*/
function isFunction(value$1) {
	if (!isObject_default(value$1)) return false;
	var tag = _baseGetTag_default(value$1);
	return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

//#endregion
//#region ../node_modules/lodash-es/_coreJsData.js
/** Used to detect overreaching core-js shims. */
var coreJsData = _root_default["__core-js_shared__"];
var _coreJsData_default = coreJsData;

//#endregion
//#region ../node_modules/lodash-es/_isMasked.js
/** Used to detect methods masquerading as native. */
var maskSrcKey = function() {
	var uid = /[^.]+$/.exec(_coreJsData_default && _coreJsData_default.keys && _coreJsData_default.keys.IE_PROTO || "");
	return uid ? "Symbol(src)_1." + uid : "";
}();
/**
* Checks if `func` has its source masked.
*
* @private
* @param {Function} func The function to check.
* @returns {boolean} Returns `true` if `func` is masked, else `false`.
*/
function isMasked(func) {
	return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked_default = isMasked;

//#endregion
//#region ../node_modules/lodash-es/_toSource.js
/** Used for built-in method references. */
var funcProto$2 = Function.prototype;
/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;
/**
* Converts `func` to its source code.
*
* @private
* @param {Function} func The function to convert.
* @returns {string} Returns the source code.
*/
function toSource(func) {
	if (func != null) {
		try {
			return funcToString$2.call(func);
		} catch (e) {}
		try {
			return func + "";
		} catch (e) {}
	}
	return "";
}
var _toSource_default = toSource;

//#endregion
//#region ../node_modules/lodash-es/_baseIsNative.js
/**
* Used to match `RegExp`
* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
*/
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */
var funcProto$1 = Function.prototype, objectProto$13 = Object.prototype;
/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */
var hasOwnProperty$11 = objectProto$13.hasOwnProperty;
/** Used to detect if a method is native. */
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$11).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/**
* The base implementation of `_.isNative` without bad shim checks.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a native function,
*  else `false`.
*/
function baseIsNative(value$1) {
	if (!isObject_default(value$1) || _isMasked_default(value$1)) return false;
	var pattern = isFunction_default(value$1) ? reIsNative : reIsHostCtor;
	return pattern.test(_toSource_default(value$1));
}
var _baseIsNative_default = baseIsNative;

//#endregion
//#region ../node_modules/lodash-es/_getValue.js
/**
* Gets the value at `key` of `object`.
*
* @private
* @param {Object} [object] The object to query.
* @param {string} key The key of the property to get.
* @returns {*} Returns the property value.
*/
function getValue(object, key) {
	return object == null ? void 0 : object[key];
}
var _getValue_default = getValue;

//#endregion
//#region ../node_modules/lodash-es/_getNative.js
/**
* Gets the native function at `key` of `object`.
*
* @private
* @param {Object} object The object to query.
* @param {string} key The key of the method to get.
* @returns {*} Returns the function if it's native, else `undefined`.
*/
function getNative(object, key) {
	var value$1 = _getValue_default(object, key);
	return _baseIsNative_default(value$1) ? value$1 : void 0;
}
var _getNative_default = getNative;

//#endregion
//#region ../node_modules/lodash-es/_WeakMap.js
var WeakMap = _getNative_default(_root_default, "WeakMap");
var _WeakMap_default = WeakMap;

//#endregion
//#region ../node_modules/lodash-es/_baseCreate.js
/** Built-in value references. */
var objectCreate = Object.create;
/**
* The base implementation of `_.create` without support for assigning
* properties to the created object.
*
* @private
* @param {Object} proto The object to inherit from.
* @returns {Object} Returns the new object.
*/
var baseCreate = function() {
	function object() {}
	return function(proto) {
		if (!isObject_default(proto)) return {};
		if (objectCreate) return objectCreate(proto);
		object.prototype = proto;
		var result = new object();
		object.prototype = void 0;
		return result;
	};
}();
var _baseCreate_default = baseCreate;

//#endregion
//#region ../node_modules/lodash-es/_apply.js
/**
* A faster alternative to `Function#apply`, this function invokes `func`
* with the `this` binding of `thisArg` and the arguments of `args`.
*
* @private
* @param {Function} func The function to invoke.
* @param {*} thisArg The `this` binding of `func`.
* @param {Array} args The arguments to invoke `func` with.
* @returns {*} Returns the result of `func`.
*/
function apply(func, thisArg, args) {
	switch (args.length) {
		case 0: return func.call(thisArg);
		case 1: return func.call(thisArg, args[0]);
		case 2: return func.call(thisArg, args[0], args[1]);
		case 3: return func.call(thisArg, args[0], args[1], args[2]);
	}
	return func.apply(thisArg, args);
}
var _apply_default = apply;

//#endregion
//#region ../node_modules/lodash-es/_copyArray.js
/**
* Copies the values of `source` to `array`.
*
* @private
* @param {Array} source The array to copy values from.
* @param {Array} [array=[]] The array to copy values to.
* @returns {Array} Returns `array`.
*/
function copyArray(source, array) {
	var index = -1, length = source.length;
	array || (array = Array(length));
	while (++index < length) array[index] = source[index];
	return array;
}
var _copyArray_default = copyArray;

//#endregion
//#region ../node_modules/lodash-es/_shortOut.js
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
/**
* Creates a function that'll short out and invoke `identity` instead
* of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
* milliseconds.
*
* @private
* @param {Function} func The function to restrict.
* @returns {Function} Returns the new shortable function.
*/
function shortOut(func) {
	var count = 0, lastCalled = 0;
	return function() {
		var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
		lastCalled = stamp;
		if (remaining > 0) {
			if (++count >= HOT_COUNT) return arguments[0];
		} else count = 0;
		return func.apply(void 0, arguments);
	};
}
var _shortOut_default = shortOut;

//#endregion
//#region ../node_modules/lodash-es/constant.js
/**
* Creates a function that returns `value`.
*
* @static
* @memberOf _
* @since 2.4.0
* @category Util
* @param {*} value The value to return from the new function.
* @returns {Function} Returns the new constant function.
* @example
*
* var objects = _.times(2, _.constant({ 'a': 1 }));
*
* console.log(objects);
* // => [{ 'a': 1 }, { 'a': 1 }]
*
* console.log(objects[0] === objects[1]);
* // => true
*/
function constant(value$1) {
	return function() {
		return value$1;
	};
}
var constant_default = constant;

//#endregion
//#region ../node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
	try {
		var func = _getNative_default(Object, "defineProperty");
		func({}, "", {});
		return func;
	} catch (e) {}
}();
var _defineProperty_default = defineProperty;

//#endregion
//#region ../node_modules/lodash-es/_baseSetToString.js
/**
* The base implementation of `setToString` without support for hot loop shorting.
*
* @private
* @param {Function} func The function to modify.
* @param {Function} string The `toString` result.
* @returns {Function} Returns `func`.
*/
var baseSetToString = !_defineProperty_default ? identity_default : function(func, string) {
	return _defineProperty_default(func, "toString", {
		"configurable": true,
		"enumerable": false,
		"value": constant_default(string),
		"writable": true
	});
};
var _baseSetToString_default = baseSetToString;

//#endregion
//#region ../node_modules/lodash-es/_setToString.js
/**
* Sets the `toString` method of `func` to return `string`.
*
* @private
* @param {Function} func The function to modify.
* @param {Function} string The `toString` result.
* @returns {Function} Returns `func`.
*/
var setToString = _shortOut_default(_baseSetToString_default);
var _setToString_default = setToString;

//#endregion
//#region ../node_modules/lodash-es/_arrayEach.js
/**
* A specialized version of `_.forEach` for arrays without support for
* iteratee shorthands.
*
* @private
* @param {Array} [array] The array to iterate over.
* @param {Function} iteratee The function invoked per iteration.
* @returns {Array} Returns `array`.
*/
function arrayEach(array, iteratee) {
	var index = -1, length = array == null ? 0 : array.length;
	while (++index < length) if (iteratee(array[index], index, array) === false) break;
	return array;
}
var _arrayEach_default = arrayEach;

//#endregion
//#region ../node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
* Checks if `value` is a valid array-like index.
*
* @private
* @param {*} value The value to check.
* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
*/
function isIndex(value$1, length) {
	var type$1 = typeof value$1;
	length = length == null ? MAX_SAFE_INTEGER$1 : length;
	return !!length && (type$1 == "number" || type$1 != "symbol" && reIsUint.test(value$1)) && value$1 > -1 && value$1 % 1 == 0 && value$1 < length;
}
var _isIndex_default = isIndex;

//#endregion
//#region ../node_modules/lodash-es/_baseAssignValue.js
/**
* The base implementation of `assignValue` and `assignMergeValue` without
* value checks.
*
* @private
* @param {Object} object The object to modify.
* @param {string} key The key of the property to assign.
* @param {*} value The value to assign.
*/
function baseAssignValue(object, key, value$1) {
	if (key == "__proto__" && _defineProperty_default) _defineProperty_default(object, key, {
		"configurable": true,
		"enumerable": true,
		"value": value$1,
		"writable": true
	});
	else object[key] = value$1;
}
var _baseAssignValue_default = baseAssignValue;

//#endregion
//#region ../node_modules/lodash-es/eq.js
/**
* Performs a
* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
* comparison between two values to determine if they are equivalent.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to compare.
* @param {*} other The other value to compare.
* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
* @example
*
* var object = { 'a': 1 };
* var other = { 'a': 1 };
*
* _.eq(object, object);
* // => true
*
* _.eq(object, other);
* // => false
*
* _.eq('a', 'a');
* // => true
*
* _.eq('a', Object('a'));
* // => false
*
* _.eq(NaN, NaN);
* // => true
*/
function eq(value$1, other) {
	return value$1 === other || value$1 !== value$1 && other !== other;
}
var eq_default = eq;

//#endregion
//#region ../node_modules/lodash-es/_assignValue.js
/** Used for built-in method references. */
var objectProto$12 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$10 = objectProto$12.hasOwnProperty;
/**
* Assigns `value` to `key` of `object` if the existing value is not equivalent
* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
* for equality comparisons.
*
* @private
* @param {Object} object The object to modify.
* @param {string} key The key of the property to assign.
* @param {*} value The value to assign.
*/
function assignValue(object, key, value$1) {
	var objValue = object[key];
	if (!(hasOwnProperty$10.call(object, key) && eq_default(objValue, value$1)) || value$1 === void 0 && !(key in object)) _baseAssignValue_default(object, key, value$1);
}
var _assignValue_default = assignValue;

//#endregion
//#region ../node_modules/lodash-es/_copyObject.js
/**
* Copies properties of `source` to `object`.
*
* @private
* @param {Object} source The object to copy properties from.
* @param {Array} props The property identifiers to copy.
* @param {Object} [object={}] The object to copy properties to.
* @param {Function} [customizer] The function to customize copied values.
* @returns {Object} Returns `object`.
*/
function copyObject(source, props, object, customizer) {
	var isNew = !object;
	object || (object = {});
	var index = -1, length = props.length;
	while (++index < length) {
		var key = props[index];
		var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
		if (newValue === void 0) newValue = source[key];
		if (isNew) _baseAssignValue_default(object, key, newValue);
		else _assignValue_default(object, key, newValue);
	}
	return object;
}
var _copyObject_default = copyObject;

//#endregion
//#region ../node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
/**
* A specialized version of `baseRest` which transforms the rest array.
*
* @private
* @param {Function} func The function to apply a rest parameter to.
* @param {number} [start=func.length-1] The start position of the rest parameter.
* @param {Function} transform The rest array transform.
* @returns {Function} Returns the new function.
*/
function overRest(func, start, transform) {
	start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
	return function() {
		var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
		while (++index < length) array[index] = args[start + index];
		index = -1;
		var otherArgs = Array(start + 1);
		while (++index < start) otherArgs[index] = args[index];
		otherArgs[start] = transform(array);
		return _apply_default(func, this, otherArgs);
	};
}
var _overRest_default = overRest;

//#endregion
//#region ../node_modules/lodash-es/_baseRest.js
/**
* The base implementation of `_.rest` which doesn't validate or coerce arguments.
*
* @private
* @param {Function} func The function to apply a rest parameter to.
* @param {number} [start=func.length-1] The start position of the rest parameter.
* @returns {Function} Returns the new function.
*/
function baseRest(func, start) {
	return _setToString_default(_overRest_default(func, start, identity_default), func + "");
}
var _baseRest_default = baseRest;

//#endregion
//#region ../node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
* Checks if `value` is a valid array-like length.
*
* **Note:** This method is loosely based on
* [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
* @example
*
* _.isLength(3);
* // => true
*
* _.isLength(Number.MIN_VALUE);
* // => false
*
* _.isLength(Infinity);
* // => false
*
* _.isLength('3');
* // => false
*/
function isLength(value$1) {
	return typeof value$1 == "number" && value$1 > -1 && value$1 % 1 == 0 && value$1 <= MAX_SAFE_INTEGER;
}
var isLength_default = isLength;

//#endregion
//#region ../node_modules/lodash-es/isArrayLike.js
/**
* Checks if `value` is array-like. A value is considered array-like if it's
* not a function and has a `value.length` that's an integer greater than or
* equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is array-like, else `false`.
* @example
*
* _.isArrayLike([1, 2, 3]);
* // => true
*
* _.isArrayLike(document.body.children);
* // => true
*
* _.isArrayLike('abc');
* // => true
*
* _.isArrayLike(_.noop);
* // => false
*/
function isArrayLike(value$1) {
	return value$1 != null && isLength_default(value$1.length) && !isFunction_default(value$1);
}
var isArrayLike_default = isArrayLike;

//#endregion
//#region ../node_modules/lodash-es/_isIterateeCall.js
/**
* Checks if the given arguments are from an iteratee call.
*
* @private
* @param {*} value The potential iteratee value argument.
* @param {*} index The potential iteratee index or key argument.
* @param {*} object The potential iteratee object argument.
* @returns {boolean} Returns `true` if the arguments are from an iteratee call,
*  else `false`.
*/
function isIterateeCall(value$1, index, object) {
	if (!isObject_default(object)) return false;
	var type$1 = typeof index;
	if (type$1 == "number" ? isArrayLike_default(object) && _isIndex_default(index, object.length) : type$1 == "string" && index in object) return eq_default(object[index], value$1);
	return false;
}
var _isIterateeCall_default = isIterateeCall;

//#endregion
//#region ../node_modules/lodash-es/_createAssigner.js
/**
* Creates a function like `_.assign`.
*
* @private
* @param {Function} assigner The function to assign values.
* @returns {Function} Returns the new assigner function.
*/
function createAssigner(assigner) {
	return _baseRest_default(function(object, sources) {
		var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
		customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
		if (guard && _isIterateeCall_default(sources[0], sources[1], guard)) {
			customizer = length < 3 ? void 0 : customizer;
			length = 1;
		}
		object = Object(object);
		while (++index < length) {
			var source = sources[index];
			if (source) assigner(object, source, index, customizer);
		}
		return object;
	});
}
var _createAssigner_default = createAssigner;

//#endregion
//#region ../node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var objectProto$11 = Object.prototype;
/**
* Checks if `value` is likely a prototype object.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
*/
function isPrototype(value$1) {
	var Ctor = value$1 && value$1.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$11;
	return value$1 === proto;
}
var _isPrototype_default = isPrototype;

//#endregion
//#region ../node_modules/lodash-es/_baseTimes.js
/**
* The base implementation of `_.times` without support for iteratee shorthands
* or max array length checks.
*
* @private
* @param {number} n The number of times to invoke `iteratee`.
* @param {Function} iteratee The function invoked per iteration.
* @returns {Array} Returns the array of results.
*/
function baseTimes(n, iteratee) {
	var index = -1, result = Array(n);
	while (++index < n) result[index] = iteratee(index);
	return result;
}
var _baseTimes_default = baseTimes;

//#endregion
//#region ../node_modules/lodash-es/_baseIsArguments.js
/** `Object#toString` result references. */
var argsTag$3 = "[object Arguments]";
/**
* The base implementation of `_.isArguments`.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an `arguments` object,
*/
function baseIsArguments(value$1) {
	return isObjectLike_default(value$1) && _baseGetTag_default(value$1) == argsTag$3;
}
var _baseIsArguments_default = baseIsArguments;

//#endregion
//#region ../node_modules/lodash-es/isArguments.js
/** Used for built-in method references. */
var objectProto$10 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$10.hasOwnProperty;
/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$10.propertyIsEnumerable;
/**
* Checks if `value` is likely an `arguments` object.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an `arguments` object,
*  else `false`.
* @example
*
* _.isArguments(function() { return arguments; }());
* // => true
*
* _.isArguments([1, 2, 3]);
* // => false
*/
var isArguments = _baseIsArguments_default(function() {
	return arguments;
}()) ? _baseIsArguments_default : function(value$1) {
	return isObjectLike_default(value$1) && hasOwnProperty$9.call(value$1, "callee") && !propertyIsEnumerable$1.call(value$1, "callee");
};
var isArguments_default = isArguments;

//#endregion
//#region ../node_modules/lodash-es/stubFalse.js
/**
* This method returns `false`.
*
* @static
* @memberOf _
* @since 4.13.0
* @category Util
* @returns {boolean} Returns `false`.
* @example
*
* _.times(2, _.stubFalse);
* // => [false, false]
*/
function stubFalse() {
	return false;
}
var stubFalse_default = stubFalse;

//#endregion
//#region ../node_modules/lodash-es/isBuffer.js
/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */
var Buffer$2 = moduleExports$2 ? _root_default.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
/**
* Checks if `value` is a buffer.
*
* @static
* @memberOf _
* @since 4.3.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
* @example
*
* _.isBuffer(new Buffer(2));
* // => true
*
* _.isBuffer(new Uint8Array(2));
* // => false
*/
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

//#endregion
//#region ../node_modules/lodash-es/_baseIsTypedArray.js
/** `Object#toString` result references. */
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
/**
* The base implementation of `_.isTypedArray` without Node.js optimizations.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
*/
function baseIsTypedArray(value$1) {
	return isObjectLike_default(value$1) && isLength_default(value$1.length) && !!typedArrayTags[_baseGetTag_default(value$1)];
}
var _baseIsTypedArray_default = baseIsTypedArray;

//#endregion
//#region ../node_modules/lodash-es/_baseUnary.js
/**
* The base implementation of `_.unary` without support for storing metadata.
*
* @private
* @param {Function} func The function to cap arguments for.
* @returns {Function} Returns the new capped function.
*/
function baseUnary(func) {
	return function(value$1) {
		return func(value$1);
	};
}
var _baseUnary_default = baseUnary;

//#endregion
//#region ../node_modules/lodash-es/_nodeUtil.js
/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && _freeGlobal_default.process;
/** Used to access faster Node.js helpers. */
var nodeUtil = function() {
	try {
		var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
		if (types) return types;
		return freeProcess && freeProcess.binding && freeProcess.binding("util");
	} catch (e) {}
}();
var _nodeUtil_default = nodeUtil;

//#endregion
//#region ../node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = _nodeUtil_default && _nodeUtil_default.isTypedArray;
/**
* Checks if `value` is classified as a typed array.
*
* @static
* @memberOf _
* @since 3.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
* @example
*
* _.isTypedArray(new Uint8Array);
* // => true
*
* _.isTypedArray([]);
* // => false
*/
var isTypedArray = nodeIsTypedArray ? _baseUnary_default(nodeIsTypedArray) : _baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

//#endregion
//#region ../node_modules/lodash-es/_arrayLikeKeys.js
/** Used for built-in method references. */
var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
/**
* Creates an array of the enumerable property names of the array-like `value`.
*
* @private
* @param {*} value The value to query.
* @param {boolean} inherited Specify returning inherited property names.
* @returns {Array} Returns the array of property names.
*/
function arrayLikeKeys(value$1, inherited) {
	var isArr = isArray_default(value$1), isArg = !isArr && isArguments_default(value$1), isBuff = !isArr && !isArg && isBuffer_default(value$1), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value$1), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes_default(value$1.length, String) : [], length = result.length;
	for (var key in value$1) if ((inherited || hasOwnProperty$8.call(value$1, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || _isIndex_default(key, length)))) result.push(key);
	return result;
}
var _arrayLikeKeys_default = arrayLikeKeys;

//#endregion
//#region ../node_modules/lodash-es/_overArg.js
/**
* Creates a unary function that invokes `func` with its argument transformed.
*
* @private
* @param {Function} func The function to wrap.
* @param {Function} transform The argument transform.
* @returns {Function} Returns the new function.
*/
function overArg(func, transform) {
	return function(arg) {
		return func(transform(arg));
	};
}
var _overArg_default = overArg;

//#endregion
//#region ../node_modules/lodash-es/_nativeKeys.js
var nativeKeys = _overArg_default(Object.keys, Object);
var _nativeKeys_default = nativeKeys;

//#endregion
//#region ../node_modules/lodash-es/_baseKeys.js
/** Used for built-in method references. */
var objectProto$8 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
/**
* The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names.
*/
function baseKeys(object) {
	if (!_isPrototype_default(object)) return _nativeKeys_default(object);
	var result = [];
	for (var key in Object(object)) if (hasOwnProperty$7.call(object, key) && key != "constructor") result.push(key);
	return result;
}
var _baseKeys_default = baseKeys;

//#endregion
//#region ../node_modules/lodash-es/keys.js
/**
* Creates an array of the own enumerable property names of `object`.
*
* **Note:** Non-object values are coerced to objects. See the
* [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
* for more details.
*
* @static
* @since 0.1.0
* @memberOf _
* @category Object
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names.
* @example
*
* function Foo() {
*   this.a = 1;
*   this.b = 2;
* }
*
* Foo.prototype.c = 3;
*
* _.keys(new Foo);
* // => ['a', 'b'] (iteration order is not guaranteed)
*
* _.keys('hi');
* // => ['0', '1']
*/
function keys(object) {
	return isArrayLike_default(object) ? _arrayLikeKeys_default(object) : _baseKeys_default(object);
}
var keys_default = keys;

//#endregion
//#region ../node_modules/lodash-es/_nativeKeysIn.js
/**
* This function is like
* [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
* except that it includes inherited enumerable properties.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names.
*/
function nativeKeysIn(object) {
	var result = [];
	if (object != null) for (var key in Object(object)) result.push(key);
	return result;
}
var _nativeKeysIn_default = nativeKeysIn;

//#endregion
//#region ../node_modules/lodash-es/_baseKeysIn.js
/** Used for built-in method references. */
var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
/**
* The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names.
*/
function baseKeysIn(object) {
	if (!isObject_default(object)) return _nativeKeysIn_default(object);
	var isProto = _isPrototype_default(object), result = [];
	for (var key in object) if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) result.push(key);
	return result;
}
var _baseKeysIn_default = baseKeysIn;

//#endregion
//#region ../node_modules/lodash-es/keysIn.js
/**
* Creates an array of the own and inherited enumerable property names of `object`.
*
* **Note:** Non-object values are coerced to objects.
*
* @static
* @memberOf _
* @since 3.0.0
* @category Object
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names.
* @example
*
* function Foo() {
*   this.a = 1;
*   this.b = 2;
* }
*
* Foo.prototype.c = 3;
*
* _.keysIn(new Foo);
* // => ['a', 'b', 'c'] (iteration order is not guaranteed)
*/
function keysIn(object) {
	return isArrayLike_default(object) ? _arrayLikeKeys_default(object, true) : _baseKeysIn_default(object);
}
var keysIn_default = keysIn;

//#endregion
//#region ../node_modules/lodash-es/_isKey.js
/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
/**
* Checks if `value` is a property name and not a property path.
*
* @private
* @param {*} value The value to check.
* @param {Object} [object] The object to query keys on.
* @returns {boolean} Returns `true` if `value` is a property name, else `false`.
*/
function isKey(value$1, object) {
	if (isArray_default(value$1)) return false;
	var type$1 = typeof value$1;
	if (type$1 == "number" || type$1 == "symbol" || type$1 == "boolean" || value$1 == null || isSymbol_default(value$1)) return true;
	return reIsPlainProp.test(value$1) || !reIsDeepProp.test(value$1) || object != null && value$1 in Object(object);
}
var _isKey_default = isKey;

//#endregion
//#region ../node_modules/lodash-es/_nativeCreate.js
var nativeCreate = _getNative_default(Object, "create");
var _nativeCreate_default = nativeCreate;

//#endregion
//#region ../node_modules/lodash-es/_hashClear.js
/**
* Removes all key-value entries from the hash.
*
* @private
* @name clear
* @memberOf Hash
*/
function hashClear() {
	this.__data__ = _nativeCreate_default ? _nativeCreate_default(null) : {};
	this.size = 0;
}
var _hashClear_default = hashClear;

//#endregion
//#region ../node_modules/lodash-es/_hashDelete.js
/**
* Removes `key` and its value from the hash.
*
* @private
* @name delete
* @memberOf Hash
* @param {Object} hash The hash to modify.
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function hashDelete(key) {
	var result = this.has(key) && delete this.__data__[key];
	this.size -= result ? 1 : 0;
	return result;
}
var _hashDelete_default = hashDelete;

//#endregion
//#region ../node_modules/lodash-es/_hashGet.js
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
/** Used for built-in method references. */
var objectProto$6 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
/**
* Gets the hash value for `key`.
*
* @private
* @name get
* @memberOf Hash
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function hashGet(key) {
	var data = this.__data__;
	if (_nativeCreate_default) {
		var result = data[key];
		return result === HASH_UNDEFINED$2 ? void 0 : result;
	}
	return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
}
var _hashGet_default = hashGet;

//#endregion
//#region ../node_modules/lodash-es/_hashHas.js
/** Used for built-in method references. */
var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/**
* Checks if a hash value for `key` exists.
*
* @private
* @name has
* @memberOf Hash
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function hashHas(key) {
	var data = this.__data__;
	return _nativeCreate_default ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
}
var _hashHas_default = hashHas;

//#endregion
//#region ../node_modules/lodash-es/_hashSet.js
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
/**
* Sets the hash `key` to `value`.
*
* @private
* @name set
* @memberOf Hash
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the hash instance.
*/
function hashSet(key, value$1) {
	var data = this.__data__;
	this.size += this.has(key) ? 0 : 1;
	data[key] = _nativeCreate_default && value$1 === void 0 ? HASH_UNDEFINED$1 : value$1;
	return this;
}
var _hashSet_default = hashSet;

//#endregion
//#region ../node_modules/lodash-es/_Hash.js
/**
* Creates a hash object.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function Hash(entries) {
	var index = -1, length = entries == null ? 0 : entries.length;
	this.clear();
	while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
	}
}
Hash.prototype.clear = _hashClear_default;
Hash.prototype["delete"] = _hashDelete_default;
Hash.prototype.get = _hashGet_default;
Hash.prototype.has = _hashHas_default;
Hash.prototype.set = _hashSet_default;
var _Hash_default = Hash;

//#endregion
//#region ../node_modules/lodash-es/_listCacheClear.js
/**
* Removes all key-value entries from the list cache.
*
* @private
* @name clear
* @memberOf ListCache
*/
function listCacheClear() {
	this.__data__ = [];
	this.size = 0;
}
var _listCacheClear_default = listCacheClear;

//#endregion
//#region ../node_modules/lodash-es/_assocIndexOf.js
/**
* Gets the index at which the `key` is found in `array` of key-value pairs.
*
* @private
* @param {Array} array The array to inspect.
* @param {*} key The key to search for.
* @returns {number} Returns the index of the matched value, else `-1`.
*/
function assocIndexOf(array, key) {
	var length = array.length;
	while (length--) if (eq_default(array[length][0], key)) return length;
	return -1;
}
var _assocIndexOf_default = assocIndexOf;

//#endregion
//#region ../node_modules/lodash-es/_listCacheDelete.js
/** Used for built-in method references. */
var arrayProto = Array.prototype;
/** Built-in value references. */
var splice = arrayProto.splice;
/**
* Removes `key` and its value from the list cache.
*
* @private
* @name delete
* @memberOf ListCache
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function listCacheDelete(key) {
	var data = this.__data__, index = _assocIndexOf_default(data, key);
	if (index < 0) return false;
	var lastIndex = data.length - 1;
	if (index == lastIndex) data.pop();
	else splice.call(data, index, 1);
	--this.size;
	return true;
}
var _listCacheDelete_default = listCacheDelete;

//#endregion
//#region ../node_modules/lodash-es/_listCacheGet.js
/**
* Gets the list cache value for `key`.
*
* @private
* @name get
* @memberOf ListCache
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function listCacheGet(key) {
	var data = this.__data__, index = _assocIndexOf_default(data, key);
	return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet_default = listCacheGet;

//#endregion
//#region ../node_modules/lodash-es/_listCacheHas.js
/**
* Checks if a list cache value for `key` exists.
*
* @private
* @name has
* @memberOf ListCache
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function listCacheHas(key) {
	return _assocIndexOf_default(this.__data__, key) > -1;
}
var _listCacheHas_default = listCacheHas;

//#endregion
//#region ../node_modules/lodash-es/_listCacheSet.js
/**
* Sets the list cache `key` to `value`.
*
* @private
* @name set
* @memberOf ListCache
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the list cache instance.
*/
function listCacheSet(key, value$1) {
	var data = this.__data__, index = _assocIndexOf_default(data, key);
	if (index < 0) {
		++this.size;
		data.push([key, value$1]);
	} else data[index][1] = value$1;
	return this;
}
var _listCacheSet_default = listCacheSet;

//#endregion
//#region ../node_modules/lodash-es/_ListCache.js
/**
* Creates an list cache object.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function ListCache(entries) {
	var index = -1, length = entries == null ? 0 : entries.length;
	this.clear();
	while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
	}
}
ListCache.prototype.clear = _listCacheClear_default;
ListCache.prototype["delete"] = _listCacheDelete_default;
ListCache.prototype.get = _listCacheGet_default;
ListCache.prototype.has = _listCacheHas_default;
ListCache.prototype.set = _listCacheSet_default;
var _ListCache_default = ListCache;

//#endregion
//#region ../node_modules/lodash-es/_Map.js
var Map$1 = _getNative_default(_root_default, "Map");
var _Map_default = Map$1;

//#endregion
//#region ../node_modules/lodash-es/_mapCacheClear.js
/**
* Removes all key-value entries from the map.
*
* @private
* @name clear
* @memberOf MapCache
*/
function mapCacheClear() {
	this.size = 0;
	this.__data__ = {
		"hash": new _Hash_default(),
		"map": new (_Map_default || _ListCache_default)(),
		"string": new _Hash_default()
	};
}
var _mapCacheClear_default = mapCacheClear;

//#endregion
//#region ../node_modules/lodash-es/_isKeyable.js
/**
* Checks if `value` is suitable for use as unique object key.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is suitable, else `false`.
*/
function isKeyable(value$1) {
	var type$1 = typeof value$1;
	return type$1 == "string" || type$1 == "number" || type$1 == "symbol" || type$1 == "boolean" ? value$1 !== "__proto__" : value$1 === null;
}
var _isKeyable_default = isKeyable;

//#endregion
//#region ../node_modules/lodash-es/_getMapData.js
/**
* Gets the data for `map`.
*
* @private
* @param {Object} map The map to query.
* @param {string} key The reference key.
* @returns {*} Returns the map data.
*/
function getMapData(map, key) {
	var data = map.__data__;
	return _isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData_default = getMapData;

//#endregion
//#region ../node_modules/lodash-es/_mapCacheDelete.js
/**
* Removes `key` and its value from the map.
*
* @private
* @name delete
* @memberOf MapCache
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function mapCacheDelete(key) {
	var result = _getMapData_default(this, key)["delete"](key);
	this.size -= result ? 1 : 0;
	return result;
}
var _mapCacheDelete_default = mapCacheDelete;

//#endregion
//#region ../node_modules/lodash-es/_mapCacheGet.js
/**
* Gets the map value for `key`.
*
* @private
* @name get
* @memberOf MapCache
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function mapCacheGet(key) {
	return _getMapData_default(this, key).get(key);
}
var _mapCacheGet_default = mapCacheGet;

//#endregion
//#region ../node_modules/lodash-es/_mapCacheHas.js
/**
* Checks if a map value for `key` exists.
*
* @private
* @name has
* @memberOf MapCache
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function mapCacheHas(key) {
	return _getMapData_default(this, key).has(key);
}
var _mapCacheHas_default = mapCacheHas;

//#endregion
//#region ../node_modules/lodash-es/_mapCacheSet.js
/**
* Sets the map `key` to `value`.
*
* @private
* @name set
* @memberOf MapCache
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the map cache instance.
*/
function mapCacheSet(key, value$1) {
	var data = _getMapData_default(this, key), size = data.size;
	data.set(key, value$1);
	this.size += data.size == size ? 0 : 1;
	return this;
}
var _mapCacheSet_default = mapCacheSet;

//#endregion
//#region ../node_modules/lodash-es/_MapCache.js
/**
* Creates a map cache object to store key-value pairs.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function MapCache(entries) {
	var index = -1, length = entries == null ? 0 : entries.length;
	this.clear();
	while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
	}
}
MapCache.prototype.clear = _mapCacheClear_default;
MapCache.prototype["delete"] = _mapCacheDelete_default;
MapCache.prototype.get = _mapCacheGet_default;
MapCache.prototype.has = _mapCacheHas_default;
MapCache.prototype.set = _mapCacheSet_default;
var _MapCache_default = MapCache;

//#endregion
//#region ../node_modules/lodash-es/memoize.js
/** Error message constants. */
var FUNC_ERROR_TEXT$1 = "Expected a function";
/**
* Creates a function that memoizes the result of `func`. If `resolver` is
* provided, it determines the cache key for storing the result based on the
* arguments provided to the memoized function. By default, the first argument
* provided to the memoized function is used as the map cache key. The `func`
* is invoked with the `this` binding of the memoized function.
*
* **Note:** The cache is exposed as the `cache` property on the memoized
* function. Its creation may be customized by replacing the `_.memoize.Cache`
* constructor with one whose instances implement the
* [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
* method interface of `clear`, `delete`, `get`, `has`, and `set`.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Function
* @param {Function} func The function to have its output memoized.
* @param {Function} [resolver] The function to resolve the cache key.
* @returns {Function} Returns the new memoized function.
* @example
*
* var object = { 'a': 1, 'b': 2 };
* var other = { 'c': 3, 'd': 4 };
*
* var values = _.memoize(_.values);
* values(object);
* // => [1, 2]
*
* values(other);
* // => [3, 4]
*
* object.a = 2;
* values(object);
* // => [1, 2]
*
* // Modify the result cache.
* values.cache.set(object, ['a', 'b']);
* values(object);
* // => ['a', 'b']
*
* // Replace `_.memoize.Cache`.
* _.memoize.Cache = WeakMap;
*/
function memoize(func, resolver) {
	if (typeof func != "function" || resolver != null && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT$1);
	var memoized = function() {
		var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
		if (cache.has(key)) return cache.get(key);
		var result = func.apply(this, args);
		memoized.cache = cache.set(key, result) || cache;
		return result;
	};
	memoized.cache = new (memoize.Cache || _MapCache_default)();
	return memoized;
}
memoize.Cache = _MapCache_default;
var memoize_default = memoize;

//#endregion
//#region ../node_modules/lodash-es/_memoizeCapped.js
/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;
/**
* A specialized version of `_.memoize` which clears the memoized function's
* cache when it exceeds `MAX_MEMOIZE_SIZE`.
*
* @private
* @param {Function} func The function to have its output memoized.
* @returns {Function} Returns the new memoized function.
*/
function memoizeCapped(func) {
	var result = memoize_default(func, function(key) {
		if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
		return key;
	});
	var cache = result.cache;
	return result;
}
var _memoizeCapped_default = memoizeCapped;

//#endregion
//#region ../node_modules/lodash-es/_stringToPath.js
/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;
/**
* Converts `string` to a property path array.
*
* @private
* @param {string} string The string to convert.
* @returns {Array} Returns the property path array.
*/
var stringToPath = _memoizeCapped_default(function(string) {
	var result = [];
	if (string.charCodeAt(0) === 46) result.push("");
	string.replace(rePropName, function(match, number, quote, subString) {
		result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
	});
	return result;
});
var _stringToPath_default = stringToPath;

//#endregion
//#region ../node_modules/lodash-es/toString.js
/**
* Converts `value` to a string. An empty string is returned for `null`
* and `undefined` values. The sign of `-0` is preserved.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to convert.
* @returns {string} Returns the converted string.
* @example
*
* _.toString(null);
* // => ''
*
* _.toString(-0);
* // => '-0'
*
* _.toString([1, 2, 3]);
* // => '1,2,3'
*/
function toString(value$1) {
	return value$1 == null ? "" : _baseToString_default(value$1);
}
var toString_default = toString;

//#endregion
//#region ../node_modules/lodash-es/_castPath.js
/**
* Casts `value` to a path array if it's not one.
*
* @private
* @param {*} value The value to inspect.
* @param {Object} [object] The object to query keys on.
* @returns {Array} Returns the cast property path array.
*/
function castPath(value$1, object) {
	if (isArray_default(value$1)) return value$1;
	return _isKey_default(value$1, object) ? [value$1] : _stringToPath_default(toString_default(value$1));
}
var _castPath_default = castPath;

//#endregion
//#region ../node_modules/lodash-es/_toKey.js
/** Used as references for various `Number` constants. */
var INFINITY = Infinity;
/**
* Converts `value` to a string key if it's not a string or symbol.
*
* @private
* @param {*} value The value to inspect.
* @returns {string|symbol} Returns the key.
*/
function toKey(value$1) {
	if (typeof value$1 == "string" || isSymbol_default(value$1)) return value$1;
	var result = value$1 + "";
	return result == "0" && 1 / value$1 == -INFINITY ? "-0" : result;
}
var _toKey_default = toKey;

//#endregion
//#region ../node_modules/lodash-es/_baseGet.js
/**
* The base implementation of `_.get` without support for default values.
*
* @private
* @param {Object} object The object to query.
* @param {Array|string} path The path of the property to get.
* @returns {*} Returns the resolved value.
*/
function baseGet(object, path$1) {
	path$1 = _castPath_default(path$1, object);
	var index = 0, length = path$1.length;
	while (object != null && index < length) object = object[_toKey_default(path$1[index++])];
	return index && index == length ? object : void 0;
}
var _baseGet_default = baseGet;

//#endregion
//#region ../node_modules/lodash-es/get.js
/**
* Gets the value at `path` of `object`. If the resolved value is
* `undefined`, the `defaultValue` is returned in its place.
*
* @static
* @memberOf _
* @since 3.7.0
* @category Object
* @param {Object} object The object to query.
* @param {Array|string} path The path of the property to get.
* @param {*} [defaultValue] The value returned for `undefined` resolved values.
* @returns {*} Returns the resolved value.
* @example
*
* var object = { 'a': [{ 'b': { 'c': 3 } }] };
*
* _.get(object, 'a[0].b.c');
* // => 3
*
* _.get(object, ['a', '0', 'b', 'c']);
* // => 3
*
* _.get(object, 'a.b.c', 'default');
* // => 'default'
*/
function get(object, path$1, defaultValue) {
	var result = object == null ? void 0 : _baseGet_default(object, path$1);
	return result === void 0 ? defaultValue : result;
}
var get_default = get;

//#endregion
//#region ../node_modules/lodash-es/_arrayPush.js
/**
* Appends the elements of `values` to `array`.
*
* @private
* @param {Array} array The array to modify.
* @param {Array} values The values to append.
* @returns {Array} Returns `array`.
*/
function arrayPush(array, values) {
	var index = -1, length = values.length, offset = array.length;
	while (++index < length) array[offset + index] = values[index];
	return array;
}
var _arrayPush_default = arrayPush;

//#endregion
//#region ../node_modules/lodash-es/_isFlattenable.js
/** Built-in value references. */
var spreadableSymbol = _Symbol_default ? _Symbol_default.isConcatSpreadable : void 0;
/**
* Checks if `value` is a flattenable `arguments` object or array.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
*/
function isFlattenable(value$1) {
	return isArray_default(value$1) || isArguments_default(value$1) || !!(spreadableSymbol && value$1 && value$1[spreadableSymbol]);
}
var _isFlattenable_default = isFlattenable;

//#endregion
//#region ../node_modules/lodash-es/_baseFlatten.js
/**
* The base implementation of `_.flatten` with support for restricting flattening.
*
* @private
* @param {Array} array The array to flatten.
* @param {number} depth The maximum recursion depth.
* @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
* @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
* @param {Array} [result=[]] The initial result value.
* @returns {Array} Returns the new flattened array.
*/
function baseFlatten(array, depth, predicate, isStrict, result) {
	var index = -1, length = array.length;
	predicate || (predicate = _isFlattenable_default);
	result || (result = []);
	while (++index < length) {
		var value$1 = array[index];
		if (depth > 0 && predicate(value$1)) if (depth > 1) baseFlatten(value$1, depth - 1, predicate, isStrict, result);
		else _arrayPush_default(result, value$1);
		else if (!isStrict) result[result.length] = value$1;
	}
	return result;
}
var _baseFlatten_default = baseFlatten;

//#endregion
//#region ../node_modules/lodash-es/flatten.js
/**
* Flattens `array` a single level deep.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Array
* @param {Array} array The array to flatten.
* @returns {Array} Returns the new flattened array.
* @example
*
* _.flatten([1, [2, [3, [4]], 5]]);
* // => [1, 2, [3, [4]], 5]
*/
function flatten(array) {
	var length = array == null ? 0 : array.length;
	return length ? _baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten;

//#endregion
//#region ../node_modules/lodash-es/_flatRest.js
/**
* A specialized version of `baseRest` which flattens the rest array.
*
* @private
* @param {Function} func The function to apply a rest parameter to.
* @returns {Function} Returns the new function.
*/
function flatRest(func) {
	return _setToString_default(_overRest_default(func, void 0, flatten_default), func + "");
}
var _flatRest_default = flatRest;

//#endregion
//#region ../node_modules/lodash-es/_getPrototype.js
/** Built-in value references. */
var getPrototype = _overArg_default(Object.getPrototypeOf, Object);
var _getPrototype_default = getPrototype;

//#endregion
//#region ../node_modules/lodash-es/isPlainObject.js
/** `Object#toString` result references. */
var objectTag$3 = "[object Object]";
/** Used for built-in method references. */
var funcProto = Function.prototype, objectProto$4 = Object.prototype;
/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;
/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);
/**
* Checks if `value` is a plain object, that is, an object created by the
* `Object` constructor or one with a `[[Prototype]]` of `null`.
*
* @static
* @memberOf _
* @since 0.8.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
* @example
*
* function Foo() {
*   this.a = 1;
* }
*
* _.isPlainObject(new Foo);
* // => false
*
* _.isPlainObject([1, 2, 3]);
* // => false
*
* _.isPlainObject({ 'x': 0, 'y': 0 });
* // => true
*
* _.isPlainObject(Object.create(null));
* // => true
*/
function isPlainObject$2(value$1) {
	if (!isObjectLike_default(value$1) || _baseGetTag_default(value$1) != objectTag$3) return false;
	var proto = _getPrototype_default(value$1);
	if (proto === null) return true;
	var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
	return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject$2;

//#endregion
//#region ../node_modules/lodash-es/_baseSlice.js
/**
* The base implementation of `_.slice` without an iteratee call guard.
*
* @private
* @param {Array} array The array to slice.
* @param {number} [start=0] The start position.
* @param {number} [end=array.length] The end position.
* @returns {Array} Returns the slice of `array`.
*/
function baseSlice(array, start, end) {
	var index = -1, length = array.length;
	if (start < 0) start = -start > length ? 0 : length + start;
	end = end > length ? length : end;
	if (end < 0) end += length;
	length = start > end ? 0 : end - start >>> 0;
	start >>>= 0;
	var result = Array(length);
	while (++index < length) result[index] = array[index + start];
	return result;
}
var _baseSlice_default = baseSlice;

//#endregion
//#region ../node_modules/lodash-es/_stackClear.js
/**
* Removes all key-value entries from the stack.
*
* @private
* @name clear
* @memberOf Stack
*/
function stackClear() {
	this.__data__ = new _ListCache_default();
	this.size = 0;
}
var _stackClear_default = stackClear;

//#endregion
//#region ../node_modules/lodash-es/_stackDelete.js
/**
* Removes `key` and its value from the stack.
*
* @private
* @name delete
* @memberOf Stack
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function stackDelete(key) {
	var data = this.__data__, result = data["delete"](key);
	this.size = data.size;
	return result;
}
var _stackDelete_default = stackDelete;

//#endregion
//#region ../node_modules/lodash-es/_stackGet.js
/**
* Gets the stack value for `key`.
*
* @private
* @name get
* @memberOf Stack
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function stackGet(key) {
	return this.__data__.get(key);
}
var _stackGet_default = stackGet;

//#endregion
//#region ../node_modules/lodash-es/_stackHas.js
/**
* Checks if a stack value for `key` exists.
*
* @private
* @name has
* @memberOf Stack
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function stackHas(key) {
	return this.__data__.has(key);
}
var _stackHas_default = stackHas;

//#endregion
//#region ../node_modules/lodash-es/_stackSet.js
/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;
/**
* Sets the stack `key` to `value`.
*
* @private
* @name set
* @memberOf Stack
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the stack cache instance.
*/
function stackSet(key, value$1) {
	var data = this.__data__;
	if (data instanceof _ListCache_default) {
		var pairs = data.__data__;
		if (!_Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
			pairs.push([key, value$1]);
			this.size = ++data.size;
			return this;
		}
		data = this.__data__ = new _MapCache_default(pairs);
	}
	data.set(key, value$1);
	this.size = data.size;
	return this;
}
var _stackSet_default = stackSet;

//#endregion
//#region ../node_modules/lodash-es/_Stack.js
/**
* Creates a stack cache object to store key-value pairs.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function Stack(entries) {
	var data = this.__data__ = new _ListCache_default(entries);
	this.size = data.size;
}
Stack.prototype.clear = _stackClear_default;
Stack.prototype["delete"] = _stackDelete_default;
Stack.prototype.get = _stackGet_default;
Stack.prototype.has = _stackHas_default;
Stack.prototype.set = _stackSet_default;
var _Stack_default = Stack;

//#endregion
//#region ../node_modules/lodash-es/_baseAssign.js
/**
* The base implementation of `_.assign` without support for multiple sources
* or `customizer` functions.
*
* @private
* @param {Object} object The destination object.
* @param {Object} source The source object.
* @returns {Object} Returns `object`.
*/
function baseAssign(object, source) {
	return object && _copyObject_default(source, keys_default(source), object);
}
var _baseAssign_default = baseAssign;

//#endregion
//#region ../node_modules/lodash-es/_baseAssignIn.js
/**
* The base implementation of `_.assignIn` without support for multiple sources
* or `customizer` functions.
*
* @private
* @param {Object} object The destination object.
* @param {Object} source The source object.
* @returns {Object} Returns `object`.
*/
function baseAssignIn(object, source) {
	return object && _copyObject_default(source, keysIn_default(source), object);
}
var _baseAssignIn_default = baseAssignIn;

//#endregion
//#region ../node_modules/lodash-es/_cloneBuffer.js
/** Detect free variable `exports`. */
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */
var Buffer$1 = moduleExports ? _root_default.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
/**
* Creates a clone of  `buffer`.
*
* @private
* @param {Buffer} buffer The buffer to clone.
* @param {boolean} [isDeep] Specify a deep clone.
* @returns {Buffer} Returns the cloned buffer.
*/
function cloneBuffer(buffer, isDeep) {
	if (isDeep) return buffer.slice();
	var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	buffer.copy(result);
	return result;
}
var _cloneBuffer_default = cloneBuffer;

//#endregion
//#region ../node_modules/lodash-es/_arrayFilter.js
/**
* A specialized version of `_.filter` for arrays without support for
* iteratee shorthands.
*
* @private
* @param {Array} [array] The array to iterate over.
* @param {Function} predicate The function invoked per iteration.
* @returns {Array} Returns the new filtered array.
*/
function arrayFilter(array, predicate) {
	var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
	while (++index < length) {
		var value$1 = array[index];
		if (predicate(value$1, index, array)) result[resIndex++] = value$1;
	}
	return result;
}
var _arrayFilter_default = arrayFilter;

//#endregion
//#region ../node_modules/lodash-es/stubArray.js
/**
* This method returns a new empty array.
*
* @static
* @memberOf _
* @since 4.13.0
* @category Util
* @returns {Array} Returns the new empty array.
* @example
*
* var arrays = _.times(2, _.stubArray);
*
* console.log(arrays);
* // => [[], []]
*
* console.log(arrays[0] === arrays[1]);
* // => false
*/
function stubArray() {
	return [];
}
var stubArray_default = stubArray;

//#endregion
//#region ../node_modules/lodash-es/_getSymbols.js
/** Used for built-in method references. */
var objectProto$3 = Object.prototype;
/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
/**
* Creates an array of the own enumerable symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of symbols.
*/
var getSymbols = !nativeGetSymbols$1 ? stubArray_default : function(object) {
	if (object == null) return [];
	object = Object(object);
	return _arrayFilter_default(nativeGetSymbols$1(object), function(symbol) {
		return propertyIsEnumerable.call(object, symbol);
	});
};
var _getSymbols_default = getSymbols;

//#endregion
//#region ../node_modules/lodash-es/_copySymbols.js
/**
* Copies own symbols of `source` to `object`.
*
* @private
* @param {Object} source The object to copy symbols from.
* @param {Object} [object={}] The object to copy symbols to.
* @returns {Object} Returns `object`.
*/
function copySymbols(source, object) {
	return _copyObject_default(source, _getSymbols_default(source), object);
}
var _copySymbols_default = copySymbols;

//#endregion
//#region ../node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
* Creates an array of the own and inherited enumerable symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of symbols.
*/
var getSymbolsIn = !nativeGetSymbols ? stubArray_default : function(object) {
	var result = [];
	while (object) {
		_arrayPush_default(result, _getSymbols_default(object));
		object = _getPrototype_default(object);
	}
	return result;
};
var _getSymbolsIn_default = getSymbolsIn;

//#endregion
//#region ../node_modules/lodash-es/_copySymbolsIn.js
/**
* Copies own and inherited symbols of `source` to `object`.
*
* @private
* @param {Object} source The object to copy symbols from.
* @param {Object} [object={}] The object to copy symbols to.
* @returns {Object} Returns `object`.
*/
function copySymbolsIn(source, object) {
	return _copyObject_default(source, _getSymbolsIn_default(source), object);
}
var _copySymbolsIn_default = copySymbolsIn;

//#endregion
//#region ../node_modules/lodash-es/_baseGetAllKeys.js
/**
* The base implementation of `getAllKeys` and `getAllKeysIn` which uses
* `keysFunc` and `symbolsFunc` to get the enumerable property names and
* symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @param {Function} keysFunc The function to get the keys of `object`.
* @param {Function} symbolsFunc The function to get the symbols of `object`.
* @returns {Array} Returns the array of property names and symbols.
*/
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	var result = keysFunc(object);
	return isArray_default(object) ? result : _arrayPush_default(result, symbolsFunc(object));
}
var _baseGetAllKeys_default = baseGetAllKeys;

//#endregion
//#region ../node_modules/lodash-es/_getAllKeys.js
/**
* Creates an array of own enumerable property names and symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names and symbols.
*/
function getAllKeys(object) {
	return _baseGetAllKeys_default(object, keys_default, _getSymbols_default);
}
var _getAllKeys_default = getAllKeys;

//#endregion
//#region ../node_modules/lodash-es/_getAllKeysIn.js
/**
* Creates an array of own and inherited enumerable property names and
* symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names and symbols.
*/
function getAllKeysIn(object) {
	return _baseGetAllKeys_default(object, keysIn_default, _getSymbolsIn_default);
}
var _getAllKeysIn_default = getAllKeysIn;

//#endregion
//#region ../node_modules/lodash-es/_DataView.js
var DataView = _getNative_default(_root_default, "DataView");
var _DataView_default = DataView;

//#endregion
//#region ../node_modules/lodash-es/_Promise.js
var Promise$1 = _getNative_default(_root_default, "Promise");
var _Promise_default = Promise$1;

//#endregion
//#region ../node_modules/lodash-es/_Set.js
var Set$1 = _getNative_default(_root_default, "Set");
var _Set_default = Set$1;

//#endregion
//#region ../node_modules/lodash-es/_getTag.js
/** `Object#toString` result references. */
var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource_default(_DataView_default), mapCtorString = _toSource_default(_Map_default), promiseCtorString = _toSource_default(_Promise_default), setCtorString = _toSource_default(_Set_default), weakMapCtorString = _toSource_default(_WeakMap_default);
/**
* Gets the `toStringTag` of `value`.
*
* @private
* @param {*} value The value to query.
* @returns {string} Returns the `toStringTag`.
*/
var getTag = _baseGetTag_default;
if (_DataView_default && getTag(new _DataView_default(/* @__PURE__ */ new ArrayBuffer(1))) != dataViewTag$3 || _Map_default && getTag(new _Map_default()) != mapTag$4 || _Promise_default && getTag(_Promise_default.resolve()) != promiseTag || _Set_default && getTag(new _Set_default()) != setTag$4 || _WeakMap_default && getTag(new _WeakMap_default()) != weakMapTag$1) getTag = function(value$1) {
	var result = _baseGetTag_default(value$1), Ctor = result == objectTag$2 ? value$1.constructor : void 0, ctorString = Ctor ? _toSource_default(Ctor) : "";
	if (ctorString) switch (ctorString) {
		case dataViewCtorString: return dataViewTag$3;
		case mapCtorString: return mapTag$4;
		case promiseCtorString: return promiseTag;
		case setCtorString: return setTag$4;
		case weakMapCtorString: return weakMapTag$1;
	}
	return result;
};
var _getTag_default = getTag;

//#endregion
//#region ../node_modules/lodash-es/_initCloneArray.js
/** Used for built-in method references. */
var objectProto$2 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
/**
* Initializes an array clone.
*
* @private
* @param {Array} array The array to clone.
* @returns {Array} Returns the initialized clone.
*/
function initCloneArray(array) {
	var length = array.length, result = new array.constructor(length);
	if (length && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
		result.index = array.index;
		result.input = array.input;
	}
	return result;
}
var _initCloneArray_default = initCloneArray;

//#endregion
//#region ../node_modules/lodash-es/_Uint8Array.js
/** Built-in value references. */
var Uint8Array$1 = _root_default.Uint8Array;
var _Uint8Array_default = Uint8Array$1;

//#endregion
//#region ../node_modules/lodash-es/_cloneArrayBuffer.js
/**
* Creates a clone of `arrayBuffer`.
*
* @private
* @param {ArrayBuffer} arrayBuffer The array buffer to clone.
* @returns {ArrayBuffer} Returns the cloned array buffer.
*/
function cloneArrayBuffer(arrayBuffer) {
	var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	new _Uint8Array_default(result).set(new _Uint8Array_default(arrayBuffer));
	return result;
}
var _cloneArrayBuffer_default = cloneArrayBuffer;

//#endregion
//#region ../node_modules/lodash-es/_cloneDataView.js
/**
* Creates a clone of `dataView`.
*
* @private
* @param {Object} dataView The data view to clone.
* @param {boolean} [isDeep] Specify a deep clone.
* @returns {Object} Returns the cloned data view.
*/
function cloneDataView(dataView, isDeep) {
	var buffer = isDeep ? _cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
	return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView_default = cloneDataView;

//#endregion
//#region ../node_modules/lodash-es/_cloneRegExp.js
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
* Creates a clone of `regexp`.
*
* @private
* @param {Object} regexp The regexp to clone.
* @returns {Object} Returns the cloned regexp.
*/
function cloneRegExp(regexp) {
	var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	result.lastIndex = regexp.lastIndex;
	return result;
}
var _cloneRegExp_default = cloneRegExp;

//#endregion
//#region ../node_modules/lodash-es/_cloneSymbol.js
/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = _Symbol_default ? _Symbol_default.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
/**
* Creates a clone of the `symbol` object.
*
* @private
* @param {Object} symbol The symbol object to clone.
* @returns {Object} Returns the cloned symbol object.
*/
function cloneSymbol(symbol) {
	return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol_default = cloneSymbol;

//#endregion
//#region ../node_modules/lodash-es/_cloneTypedArray.js
/**
* Creates a clone of `typedArray`.
*
* @private
* @param {Object} typedArray The typed array to clone.
* @param {boolean} [isDeep] Specify a deep clone.
* @returns {Object} Returns the cloned typed array.
*/
function cloneTypedArray(typedArray, isDeep) {
	var buffer = isDeep ? _cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
	return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray_default = cloneTypedArray;

//#endregion
//#region ../node_modules/lodash-es/_initCloneByTag.js
/** `Object#toString` result references. */
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
/**
* Initializes an object clone based on its `toStringTag`.
*
* **Note:** This function only supports cloning values with tags of
* `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
*
* @private
* @param {Object} object The object to clone.
* @param {string} tag The `toStringTag` of the object to clone.
* @param {boolean} [isDeep] Specify a deep clone.
* @returns {Object} Returns the initialized clone.
*/
function initCloneByTag(object, tag, isDeep) {
	var Ctor = object.constructor;
	switch (tag) {
		case arrayBufferTag$2: return _cloneArrayBuffer_default(object);
		case boolTag$2:
		case dateTag$2: return new Ctor(+object);
		case dataViewTag$2: return _cloneDataView_default(object, isDeep);
		case float32Tag$1:
		case float64Tag$1:
		case int8Tag$1:
		case int16Tag$1:
		case int32Tag$1:
		case uint8Tag$1:
		case uint8ClampedTag$1:
		case uint16Tag$1:
		case uint32Tag$1: return _cloneTypedArray_default(object, isDeep);
		case mapTag$3: return new Ctor();
		case numberTag$2:
		case stringTag$2: return new Ctor(object);
		case regexpTag$2: return _cloneRegExp_default(object);
		case setTag$3: return new Ctor();
		case symbolTag$2: return _cloneSymbol_default(object);
	}
}
var _initCloneByTag_default = initCloneByTag;

//#endregion
//#region ../node_modules/lodash-es/_initCloneObject.js
/**
* Initializes an object clone.
*
* @private
* @param {Object} object The object to clone.
* @returns {Object} Returns the initialized clone.
*/
function initCloneObject(object) {
	return typeof object.constructor == "function" && !_isPrototype_default(object) ? _baseCreate_default(_getPrototype_default(object)) : {};
}
var _initCloneObject_default = initCloneObject;

//#endregion
//#region ../node_modules/lodash-es/_baseIsMap.js
/** `Object#toString` result references. */
var mapTag$2 = "[object Map]";
/**
* The base implementation of `_.isMap` without Node.js optimizations.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a map, else `false`.
*/
function baseIsMap(value$1) {
	return isObjectLike_default(value$1) && _getTag_default(value$1) == mapTag$2;
}
var _baseIsMap_default = baseIsMap;

//#endregion
//#region ../node_modules/lodash-es/isMap.js
var nodeIsMap = _nodeUtil_default && _nodeUtil_default.isMap;
/**
* Checks if `value` is classified as a `Map` object.
*
* @static
* @memberOf _
* @since 4.3.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a map, else `false`.
* @example
*
* _.isMap(new Map);
* // => true
*
* _.isMap(new WeakMap);
* // => false
*/
var isMap = nodeIsMap ? _baseUnary_default(nodeIsMap) : _baseIsMap_default;
var isMap_default = isMap;

//#endregion
//#region ../node_modules/lodash-es/_baseIsSet.js
/** `Object#toString` result references. */
var setTag$2 = "[object Set]";
/**
* The base implementation of `_.isSet` without Node.js optimizations.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a set, else `false`.
*/
function baseIsSet(value$1) {
	return isObjectLike_default(value$1) && _getTag_default(value$1) == setTag$2;
}
var _baseIsSet_default = baseIsSet;

//#endregion
//#region ../node_modules/lodash-es/isSet.js
var nodeIsSet = _nodeUtil_default && _nodeUtil_default.isSet;
/**
* Checks if `value` is classified as a `Set` object.
*
* @static
* @memberOf _
* @since 4.3.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a set, else `false`.
* @example
*
* _.isSet(new Set);
* // => true
*
* _.isSet(new WeakSet);
* // => false
*/
var isSet = nodeIsSet ? _baseUnary_default(nodeIsSet) : _baseIsSet_default;
var isSet_default = isSet;

//#endregion
//#region ../node_modules/lodash-es/_baseClone.js
/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$1 = 4;
/** `Object#toString` result references. */
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
* The base implementation of `_.clone` and `_.cloneDeep` which tracks
* traversed objects.
*
* @private
* @param {*} value The value to clone.
* @param {boolean} bitmask The bitmask flags.
*  1 - Deep clone
*  2 - Flatten inherited properties
*  4 - Clone symbols
* @param {Function} [customizer] The function to customize cloning.
* @param {string} [key] The key of `value`.
* @param {Object} [object] The parent object of `value`.
* @param {Object} [stack] Tracks traversed objects and their clone counterparts.
* @returns {*} Returns the cloned value.
*/
function baseClone(value$1, bitmask, customizer, key, object, stack) {
	var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
	if (customizer) result = object ? customizer(value$1, key, object, stack) : customizer(value$1);
	if (result !== void 0) return result;
	if (!isObject_default(value$1)) return value$1;
	var isArr = isArray_default(value$1);
	if (isArr) {
		result = _initCloneArray_default(value$1);
		if (!isDeep) return _copyArray_default(value$1, result);
	} else {
		var tag = _getTag_default(value$1), isFunc = tag == funcTag || tag == genTag;
		if (isBuffer_default(value$1)) return _cloneBuffer_default(value$1, isDeep);
		if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
			result = isFlat || isFunc ? {} : _initCloneObject_default(value$1);
			if (!isDeep) return isFlat ? _copySymbolsIn_default(value$1, _baseAssignIn_default(result, value$1)) : _copySymbols_default(value$1, _baseAssign_default(result, value$1));
		} else {
			if (!cloneableTags[tag]) return object ? value$1 : {};
			result = _initCloneByTag_default(value$1, tag, isDeep);
		}
	}
	stack || (stack = new _Stack_default());
	var stacked = stack.get(value$1);
	if (stacked) return stacked;
	stack.set(value$1, result);
	if (isSet_default(value$1)) value$1.forEach(function(subValue) {
		result.add(baseClone(subValue, bitmask, customizer, subValue, value$1, stack));
	});
	else if (isMap_default(value$1)) value$1.forEach(function(subValue, key$1) {
		result.set(key$1, baseClone(subValue, bitmask, customizer, key$1, value$1, stack));
	});
	var keysFunc = isFull ? isFlat ? _getAllKeysIn_default : _getAllKeys_default : isFlat ? keysIn_default : keys_default;
	var props = isArr ? void 0 : keysFunc(value$1);
	_arrayEach_default(props || value$1, function(subValue, key$1) {
		if (props) {
			key$1 = subValue;
			subValue = value$1[key$1];
		}
		_assignValue_default(result, key$1, baseClone(subValue, bitmask, customizer, key$1, value$1, stack));
	});
	return result;
}
var _baseClone_default = baseClone;

//#endregion
//#region ../node_modules/lodash-es/_setCacheAdd.js
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = "__lodash_hash_undefined__";
/**
* Adds `value` to the array cache.
*
* @private
* @name add
* @memberOf SetCache
* @alias push
* @param {*} value The value to cache.
* @returns {Object} Returns the cache instance.
*/
function setCacheAdd(value$1) {
	this.__data__.set(value$1, HASH_UNDEFINED);
	return this;
}
var _setCacheAdd_default = setCacheAdd;

//#endregion
//#region ../node_modules/lodash-es/_setCacheHas.js
/**
* Checks if `value` is in the array cache.
*
* @private
* @name has
* @memberOf SetCache
* @param {*} value The value to search for.
* @returns {number} Returns `true` if `value` is found, else `false`.
*/
function setCacheHas(value$1) {
	return this.__data__.has(value$1);
}
var _setCacheHas_default = setCacheHas;

//#endregion
//#region ../node_modules/lodash-es/_SetCache.js
/**
*
* Creates an array cache object to store unique values.
*
* @private
* @constructor
* @param {Array} [values] The values to cache.
*/
function SetCache(values) {
	var index = -1, length = values == null ? 0 : values.length;
	this.__data__ = new _MapCache_default();
	while (++index < length) this.add(values[index]);
}
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd_default;
SetCache.prototype.has = _setCacheHas_default;
var _SetCache_default = SetCache;

//#endregion
//#region ../node_modules/lodash-es/_arraySome.js
/**
* A specialized version of `_.some` for arrays without support for iteratee
* shorthands.
*
* @private
* @param {Array} [array] The array to iterate over.
* @param {Function} predicate The function invoked per iteration.
* @returns {boolean} Returns `true` if any element passes the predicate check,
*  else `false`.
*/
function arraySome(array, predicate) {
	var index = -1, length = array == null ? 0 : array.length;
	while (++index < length) if (predicate(array[index], index, array)) return true;
	return false;
}
var _arraySome_default = arraySome;

//#endregion
//#region ../node_modules/lodash-es/_cacheHas.js
/**
* Checks if a `cache` value for `key` exists.
*
* @private
* @param {Object} cache The cache to query.
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function cacheHas(cache, key) {
	return cache.has(key);
}
var _cacheHas_default = cacheHas;

//#endregion
//#region ../node_modules/lodash-es/_equalArrays.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
/**
* A specialized version of `baseIsEqualDeep` for arrays with support for
* partial deep comparisons.
*
* @private
* @param {Array} array The array to compare.
* @param {Array} other The other array to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} stack Tracks traversed `array` and `other` objects.
* @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
*/
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
	if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
	var arrStacked = stack.get(array);
	var othStacked = stack.get(other);
	if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
	var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new _SetCache_default() : void 0;
	stack.set(array, other);
	stack.set(other, array);
	while (++index < arrLength) {
		var arrValue = array[index], othValue = other[index];
		if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
		if (compared !== void 0) {
			if (compared) continue;
			result = false;
			break;
		}
		if (seen) {
			if (!_arraySome_default(other, function(othValue$1, othIndex) {
				if (!_cacheHas_default(seen, othIndex) && (arrValue === othValue$1 || equalFunc(arrValue, othValue$1, bitmask, customizer, stack))) return seen.push(othIndex);
			})) {
				result = false;
				break;
			}
		} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
			result = false;
			break;
		}
	}
	stack["delete"](array);
	stack["delete"](other);
	return result;
}
var _equalArrays_default = equalArrays;

//#endregion
//#region ../node_modules/lodash-es/_mapToArray.js
/**
* Converts `map` to its key-value pairs.
*
* @private
* @param {Object} map The map to convert.
* @returns {Array} Returns the key-value pairs.
*/
function mapToArray(map) {
	var index = -1, result = Array(map.size);
	map.forEach(function(value$1, key) {
		result[++index] = [key, value$1];
	});
	return result;
}
var _mapToArray_default = mapToArray;

//#endregion
//#region ../node_modules/lodash-es/_setToArray.js
/**
* Converts `set` to an array of its values.
*
* @private
* @param {Object} set The set to convert.
* @returns {Array} Returns the values.
*/
function setToArray(set) {
	var index = -1, result = Array(set.size);
	set.forEach(function(value$1) {
		result[++index] = value$1;
	});
	return result;
}
var _setToArray_default = setToArray;

//#endregion
//#region ../node_modules/lodash-es/_equalByTag.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
/** `Object#toString` result references. */
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol_default ? _Symbol_default.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
/**
* A specialized version of `baseIsEqualDeep` for comparing objects of
* the same `toStringTag`.
*
* **Note:** This function only supports comparing values with tags of
* `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
*
* @private
* @param {Object} object The object to compare.
* @param {Object} other The other object to compare.
* @param {string} tag The `toStringTag` of the objects to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} stack Tracks traversed `object` and `other` objects.
* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
*/
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	switch (tag) {
		case dataViewTag:
			if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
			object = object.buffer;
			other = other.buffer;
		case arrayBufferTag:
			if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array_default(object), new _Uint8Array_default(other))) return false;
			return true;
		case boolTag:
		case dateTag:
		case numberTag: return eq_default(+object, +other);
		case errorTag: return object.name == other.name && object.message == other.message;
		case regexpTag:
		case stringTag: return object == other + "";
		case mapTag: var convert = _mapToArray_default;
		case setTag:
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
			convert || (convert = _setToArray_default);
			if (object.size != other.size && !isPartial) return false;
			var stacked = stack.get(object);
			if (stacked) return stacked == other;
			bitmask |= COMPARE_UNORDERED_FLAG$2;
			stack.set(object, other);
			var result = _equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
			stack["delete"](object);
			return result;
		case symbolTag: if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
	}
	return false;
}
var _equalByTag_default = equalByTag;

//#endregion
//#region ../node_modules/lodash-es/_equalObjects.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;
/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
* A specialized version of `baseIsEqualDeep` for objects with support for
* partial deep comparisons.
*
* @private
* @param {Object} object The object to compare.
* @param {Object} other The other object to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} stack Tracks traversed `object` and `other` objects.
* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
*/
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = _getAllKeys_default(object), objLength = objProps.length, othProps = _getAllKeys_default(other), othLength = othProps.length;
	if (objLength != othLength && !isPartial) return false;
	var index = objLength;
	while (index--) {
		var key = objProps[index];
		if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) return false;
	}
	var objStacked = stack.get(object);
	var othStacked = stack.get(other);
	if (objStacked && othStacked) return objStacked == other && othStacked == object;
	var result = true;
	stack.set(object, other);
	stack.set(other, object);
	var skipCtor = isPartial;
	while (++index < objLength) {
		key = objProps[index];
		var objValue = object[key], othValue = other[key];
		if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
		if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
			result = false;
			break;
		}
		skipCtor || (skipCtor = key == "constructor");
	}
	if (result && !skipCtor) {
		var objCtor = object.constructor, othCtor = other.constructor;
		if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
	}
	stack["delete"](object);
	stack["delete"](other);
	return result;
}
var _equalObjects_default = equalObjects;

//#endregion
//#region ../node_modules/lodash-es/_baseIsEqualDeep.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;
/** `Object#toString` result references. */
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;
/**
* A specialized version of `baseIsEqual` for arrays and objects which performs
* deep comparisons and tracks traversed objects enabling objects with circular
* references to be compared.
*
* @private
* @param {Object} object The object to compare.
* @param {Object} other The other object to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} [stack] Tracks traversed `object` and `other` objects.
* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
*/
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag : _getTag_default(object), othTag = othIsArr ? arrayTag : _getTag_default(other);
	objTag = objTag == argsTag ? objectTag : objTag;
	othTag = othTag == argsTag ? objectTag : othTag;
	var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
	if (isSameTag && isBuffer_default(object)) {
		if (!isBuffer_default(other)) return false;
		objIsArr = true;
		objIsObj = false;
	}
	if (isSameTag && !objIsObj) {
		stack || (stack = new _Stack_default());
		return objIsArr || isTypedArray_default(object) ? _equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
	}
	if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
		var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
		if (objIsWrapped || othIsWrapped) {
			var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
			stack || (stack = new _Stack_default());
			return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		}
	}
	if (!isSameTag) return false;
	stack || (stack = new _Stack_default());
	return _equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep_default = baseIsEqualDeep;

//#endregion
//#region ../node_modules/lodash-es/_baseIsEqual.js
/**
* The base implementation of `_.isEqual` which supports partial comparisons
* and tracks traversed objects.
*
* @private
* @param {*} value The value to compare.
* @param {*} other The other value to compare.
* @param {boolean} bitmask The bitmask flags.
*  1 - Unordered comparison
*  2 - Partial comparison
* @param {Function} [customizer] The function to customize comparisons.
* @param {Object} [stack] Tracks traversed `value` and `other` objects.
* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
*/
function baseIsEqual(value$1, other, bitmask, customizer, stack) {
	if (value$1 === other) return true;
	if (value$1 == null || other == null || !isObjectLike_default(value$1) && !isObjectLike_default(other)) return value$1 !== value$1 && other !== other;
	return _baseIsEqualDeep_default(value$1, other, bitmask, customizer, baseIsEqual, stack);
}
var _baseIsEqual_default = baseIsEqual;

//#endregion
//#region ../node_modules/lodash-es/_baseIsMatch.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
/**
* The base implementation of `_.isMatch` without support for iteratee shorthands.
*
* @private
* @param {Object} object The object to inspect.
* @param {Object} source The object of property values to match.
* @param {Array} matchData The property names, values, and compare flags to match.
* @param {Function} [customizer] The function to customize comparisons.
* @returns {boolean} Returns `true` if `object` is a match, else `false`.
*/
function baseIsMatch(object, source, matchData, customizer) {
	var index = matchData.length, length = index, noCustomizer = !customizer;
	if (object == null) return !length;
	object = Object(object);
	while (index--) {
		var data = matchData[index];
		if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
	}
	while (++index < length) {
		data = matchData[index];
		var key = data[0], objValue = object[key], srcValue = data[1];
		if (noCustomizer && data[2]) {
			if (objValue === void 0 && !(key in object)) return false;
		} else {
			var stack = new _Stack_default();
			if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
			if (!(result === void 0 ? _baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) return false;
		}
	}
	return true;
}
var _baseIsMatch_default = baseIsMatch;

//#endregion
//#region ../node_modules/lodash-es/_isStrictComparable.js
/**
* Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` if suitable for strict
*  equality comparisons, else `false`.
*/
function isStrictComparable(value$1) {
	return value$1 === value$1 && !isObject_default(value$1);
}
var _isStrictComparable_default = isStrictComparable;

//#endregion
//#region ../node_modules/lodash-es/_getMatchData.js
/**
* Gets the property names, values, and compare flags of `object`.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the match data of `object`.
*/
function getMatchData(object) {
	var result = keys_default(object), length = result.length;
	while (length--) {
		var key = result[length], value$1 = object[key];
		result[length] = [
			key,
			value$1,
			_isStrictComparable_default(value$1)
		];
	}
	return result;
}
var _getMatchData_default = getMatchData;

//#endregion
//#region ../node_modules/lodash-es/_matchesStrictComparable.js
/**
* A specialized version of `matchesProperty` for source values suitable
* for strict equality comparisons, i.e. `===`.
*
* @private
* @param {string} key The key of the property to get.
* @param {*} srcValue The value to match.
* @returns {Function} Returns the new spec function.
*/
function matchesStrictComparable(key, srcValue) {
	return function(object) {
		if (object == null) return false;
		return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
	};
}
var _matchesStrictComparable_default = matchesStrictComparable;

//#endregion
//#region ../node_modules/lodash-es/_baseMatches.js
/**
* The base implementation of `_.matches` which doesn't clone `source`.
*
* @private
* @param {Object} source The object of property values to match.
* @returns {Function} Returns the new spec function.
*/
function baseMatches(source) {
	var matchData = _getMatchData_default(source);
	if (matchData.length == 1 && matchData[0][2]) return _matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
	return function(object) {
		return object === source || _baseIsMatch_default(object, source, matchData);
	};
}
var _baseMatches_default = baseMatches;

//#endregion
//#region ../node_modules/lodash-es/_baseHasIn.js
/**
* The base implementation of `_.hasIn` without support for deep paths.
*
* @private
* @param {Object} [object] The object to query.
* @param {Array|string} key The key to check.
* @returns {boolean} Returns `true` if `key` exists, else `false`.
*/
function baseHasIn(object, key) {
	return object != null && key in Object(object);
}
var _baseHasIn_default = baseHasIn;

//#endregion
//#region ../node_modules/lodash-es/_hasPath.js
/**
* Checks if `path` exists on `object`.
*
* @private
* @param {Object} object The object to query.
* @param {Array|string} path The path to check.
* @param {Function} hasFunc The function to check properties.
* @returns {boolean} Returns `true` if `path` exists, else `false`.
*/
function hasPath(object, path$1, hasFunc) {
	path$1 = _castPath_default(path$1, object);
	var index = -1, length = path$1.length, result = false;
	while (++index < length) {
		var key = _toKey_default(path$1[index]);
		if (!(result = object != null && hasFunc(object, key))) break;
		object = object[key];
	}
	if (result || ++index != length) return result;
	length = object == null ? 0 : object.length;
	return !!length && isLength_default(length) && _isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var _hasPath_default = hasPath;

//#endregion
//#region ../node_modules/lodash-es/hasIn.js
/**
* Checks if `path` is a direct or inherited property of `object`.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Object
* @param {Object} object The object to query.
* @param {Array|string} path The path to check.
* @returns {boolean} Returns `true` if `path` exists, else `false`.
* @example
*
* var object = _.create({ 'a': _.create({ 'b': 2 }) });
*
* _.hasIn(object, 'a');
* // => true
*
* _.hasIn(object, 'a.b');
* // => true
*
* _.hasIn(object, ['a', 'b']);
* // => true
*
* _.hasIn(object, 'b');
* // => false
*/
function hasIn(object, path$1) {
	return object != null && _hasPath_default(object, path$1, _baseHasIn_default);
}
var hasIn_default = hasIn;

//#endregion
//#region ../node_modules/lodash-es/_baseMatchesProperty.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
* The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
*
* @private
* @param {string} path The path of the property to get.
* @param {*} srcValue The value to match.
* @returns {Function} Returns the new spec function.
*/
function baseMatchesProperty(path$1, srcValue) {
	if (_isKey_default(path$1) && _isStrictComparable_default(srcValue)) return _matchesStrictComparable_default(_toKey_default(path$1), srcValue);
	return function(object) {
		var objValue = get_default(object, path$1);
		return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path$1) : _baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	};
}
var _baseMatchesProperty_default = baseMatchesProperty;

//#endregion
//#region ../node_modules/lodash-es/_baseProperty.js
/**
* The base implementation of `_.property` without support for deep paths.
*
* @private
* @param {string} key The key of the property to get.
* @returns {Function} Returns the new accessor function.
*/
function baseProperty(key) {
	return function(object) {
		return object == null ? void 0 : object[key];
	};
}
var _baseProperty_default = baseProperty;

//#endregion
//#region ../node_modules/lodash-es/_basePropertyDeep.js
/**
* A specialized version of `baseProperty` which supports deep paths.
*
* @private
* @param {Array|string} path The path of the property to get.
* @returns {Function} Returns the new accessor function.
*/
function basePropertyDeep(path$1) {
	return function(object) {
		return _baseGet_default(object, path$1);
	};
}
var _basePropertyDeep_default = basePropertyDeep;

//#endregion
//#region ../node_modules/lodash-es/property.js
/**
* Creates a function that returns the value at `path` of a given object.
*
* @static
* @memberOf _
* @since 2.4.0
* @category Util
* @param {Array|string} path The path of the property to get.
* @returns {Function} Returns the new accessor function.
* @example
*
* var objects = [
*   { 'a': { 'b': 2 } },
*   { 'a': { 'b': 1 } }
* ];
*
* _.map(objects, _.property('a.b'));
* // => [2, 1]
*
* _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
* // => [1, 2]
*/
function property(path$1) {
	return _isKey_default(path$1) ? _baseProperty_default(_toKey_default(path$1)) : _basePropertyDeep_default(path$1);
}
var property_default = property;

//#endregion
//#region ../node_modules/lodash-es/_baseIteratee.js
/**
* The base implementation of `_.iteratee`.
*
* @private
* @param {*} [value=_.identity] The value to convert to an iteratee.
* @returns {Function} Returns the iteratee.
*/
function baseIteratee(value$1) {
	if (typeof value$1 == "function") return value$1;
	if (value$1 == null) return identity_default;
	if (typeof value$1 == "object") return isArray_default(value$1) ? _baseMatchesProperty_default(value$1[0], value$1[1]) : _baseMatches_default(value$1);
	return property_default(value$1);
}
var _baseIteratee_default = baseIteratee;

//#endregion
//#region ../node_modules/lodash-es/_createBaseFor.js
/**
* Creates a base function for methods like `_.forIn` and `_.forOwn`.
*
* @private
* @param {boolean} [fromRight] Specify iterating from right to left.
* @returns {Function} Returns the new base function.
*/
function createBaseFor(fromRight) {
	return function(object, iteratee, keysFunc) {
		var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
		while (length--) {
			var key = props[fromRight ? length : ++index];
			if (iteratee(iterable[key], key, iterable) === false) break;
		}
		return object;
	};
}
var _createBaseFor_default = createBaseFor;

//#endregion
//#region ../node_modules/lodash-es/_baseFor.js
/**
* The base implementation of `baseForOwn` which iterates over `object`
* properties returned by `keysFunc` and invokes `iteratee` for each property.
* Iteratee functions may exit iteration early by explicitly returning `false`.
*
* @private
* @param {Object} object The object to iterate over.
* @param {Function} iteratee The function invoked per iteration.
* @param {Function} keysFunc The function to get the keys of `object`.
* @returns {Object} Returns `object`.
*/
var baseFor = _createBaseFor_default();
var _baseFor_default = baseFor;

//#endregion
//#region ../node_modules/lodash-es/_baseForOwn.js
/**
* The base implementation of `_.forOwn` without support for iteratee shorthands.
*
* @private
* @param {Object} object The object to iterate over.
* @param {Function} iteratee The function invoked per iteration.
* @returns {Object} Returns `object`.
*/
function baseForOwn(object, iteratee) {
	return object && _baseFor_default(object, iteratee, keys_default);
}
var _baseForOwn_default = baseForOwn;

//#endregion
//#region ../node_modules/lodash-es/_createBaseEach.js
/**
* Creates a `baseEach` or `baseEachRight` function.
*
* @private
* @param {Function} eachFunc The function to iterate over a collection.
* @param {boolean} [fromRight] Specify iterating from right to left.
* @returns {Function} Returns the new base function.
*/
function createBaseEach(eachFunc, fromRight) {
	return function(collection, iteratee) {
		if (collection == null) return collection;
		if (!isArrayLike_default(collection)) return eachFunc(collection, iteratee);
		var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
		while (fromRight ? index-- : ++index < length) if (iteratee(iterable[index], index, iterable) === false) break;
		return collection;
	};
}
var _createBaseEach_default = createBaseEach;

//#endregion
//#region ../node_modules/lodash-es/_baseEach.js
/**
* The base implementation of `_.forEach` without support for iteratee shorthands.
*
* @private
* @param {Array|Object} collection The collection to iterate over.
* @param {Function} iteratee The function invoked per iteration.
* @returns {Array|Object} Returns `collection`.
*/
var baseEach = _createBaseEach_default(_baseForOwn_default);
var _baseEach_default = baseEach;

//#endregion
//#region ../node_modules/lodash-es/_assignMergeValue.js
/**
* This function is like `assignValue` except that it doesn't assign
* `undefined` values.
*
* @private
* @param {Object} object The object to modify.
* @param {string} key The key of the property to assign.
* @param {*} value The value to assign.
*/
function assignMergeValue(object, key, value$1) {
	if (value$1 !== void 0 && !eq_default(object[key], value$1) || value$1 === void 0 && !(key in object)) _baseAssignValue_default(object, key, value$1);
}
var _assignMergeValue_default = assignMergeValue;

//#endregion
//#region ../node_modules/lodash-es/isArrayLikeObject.js
/**
* This method is like `_.isArrayLike` except that it also checks if `value`
* is an object.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an array-like object,
*  else `false`.
* @example
*
* _.isArrayLikeObject([1, 2, 3]);
* // => true
*
* _.isArrayLikeObject(document.body.children);
* // => true
*
* _.isArrayLikeObject('abc');
* // => false
*
* _.isArrayLikeObject(_.noop);
* // => false
*/
function isArrayLikeObject(value$1) {
	return isObjectLike_default(value$1) && isArrayLike_default(value$1);
}
var isArrayLikeObject_default = isArrayLikeObject;

//#endregion
//#region ../node_modules/lodash-es/_safeGet.js
/**
* Gets the value at `key`, unless `key` is "__proto__" or "constructor".
*
* @private
* @param {Object} object The object to query.
* @param {string} key The key of the property to get.
* @returns {*} Returns the property value.
*/
function safeGet(object, key) {
	if (key === "constructor" && typeof object[key] === "function") return;
	if (key == "__proto__") return;
	return object[key];
}
var _safeGet_default = safeGet;

//#endregion
//#region ../node_modules/lodash-es/toPlainObject.js
/**
* Converts `value` to a plain object flattening inherited enumerable string
* keyed properties of `value` to own properties of the plain object.
*
* @static
* @memberOf _
* @since 3.0.0
* @category Lang
* @param {*} value The value to convert.
* @returns {Object} Returns the converted plain object.
* @example
*
* function Foo() {
*   this.b = 2;
* }
*
* Foo.prototype.c = 3;
*
* _.assign({ 'a': 1 }, new Foo);
* // => { 'a': 1, 'b': 2 }
*
* _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
* // => { 'a': 1, 'b': 2, 'c': 3 }
*/
function toPlainObject(value$1) {
	return _copyObject_default(value$1, keysIn_default(value$1));
}
var toPlainObject_default = toPlainObject;

//#endregion
//#region ../node_modules/lodash-es/_baseMergeDeep.js
/**
* A specialized version of `baseMerge` for arrays and objects which performs
* deep merges and tracks traversed objects enabling objects with circular
* references to be merged.
*
* @private
* @param {Object} object The destination object.
* @param {Object} source The source object.
* @param {string} key The key of the value to merge.
* @param {number} srcIndex The index of `source`.
* @param {Function} mergeFunc The function to merge values.
* @param {Function} [customizer] The function to customize assigned values.
* @param {Object} [stack] Tracks traversed source values and their merged
*  counterparts.
*/
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	var objValue = _safeGet_default(object, key), srcValue = _safeGet_default(source, key), stacked = stack.get(srcValue);
	if (stacked) {
		_assignMergeValue_default(object, key, stacked);
		return;
	}
	var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
	var isCommon = newValue === void 0;
	if (isCommon) {
		var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
		newValue = srcValue;
		if (isArr || isBuff || isTyped) if (isArray_default(objValue)) newValue = objValue;
		else if (isArrayLikeObject_default(objValue)) newValue = _copyArray_default(objValue);
		else if (isBuff) {
			isCommon = false;
			newValue = _cloneBuffer_default(srcValue, true);
		} else if (isTyped) {
			isCommon = false;
			newValue = _cloneTypedArray_default(srcValue, true);
		} else newValue = [];
		else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
			newValue = objValue;
			if (isArguments_default(objValue)) newValue = toPlainObject_default(objValue);
			else if (!isObject_default(objValue) || isFunction_default(objValue)) newValue = _initCloneObject_default(srcValue);
		} else isCommon = false;
	}
	if (isCommon) {
		stack.set(srcValue, newValue);
		mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		stack["delete"](srcValue);
	}
	_assignMergeValue_default(object, key, newValue);
}
var _baseMergeDeep_default = baseMergeDeep;

//#endregion
//#region ../node_modules/lodash-es/_baseMerge.js
/**
* The base implementation of `_.merge` without support for multiple sources.
*
* @private
* @param {Object} object The destination object.
* @param {Object} source The source object.
* @param {number} srcIndex The index of `source`.
* @param {Function} [customizer] The function to customize merged values.
* @param {Object} [stack] Tracks traversed source values and their merged
*  counterparts.
*/
function baseMerge(object, source, srcIndex, customizer, stack) {
	if (object === source) return;
	_baseFor_default(source, function(srcValue, key) {
		stack || (stack = new _Stack_default());
		if (isObject_default(srcValue)) _baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
		else {
			var newValue = customizer ? customizer(_safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
			if (newValue === void 0) newValue = srcValue;
			_assignMergeValue_default(object, key, newValue);
		}
	}, keysIn_default);
}
var _baseMerge_default = baseMerge;

//#endregion
//#region ../node_modules/lodash-es/last.js
/**
* Gets the last element of `array`.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Array
* @param {Array} array The array to query.
* @returns {*} Returns the last element of `array`.
* @example
*
* _.last([1, 2, 3]);
* // => 3
*/
function last(array) {
	var length = array == null ? 0 : array.length;
	return length ? array[length - 1] : void 0;
}
var last_default = last;

//#endregion
//#region ../node_modules/lodash-es/_baseMap.js
/**
* The base implementation of `_.map` without support for iteratee shorthands.
*
* @private
* @param {Array|Object} collection The collection to iterate over.
* @param {Function} iteratee The function invoked per iteration.
* @returns {Array} Returns the new mapped array.
*/
function baseMap(collection, iteratee) {
	var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
	_baseEach_default(collection, function(value$1, key, collection$1) {
		result[++index] = iteratee(value$1, key, collection$1);
	});
	return result;
}
var _baseMap_default = baseMap;

//#endregion
//#region ../node_modules/lodash-es/_parent.js
/**
* Gets the parent value at `path` of `object`.
*
* @private
* @param {Object} object The object to query.
* @param {Array} path The path to get the parent value of.
* @returns {*} Returns the parent value.
*/
function parent(object, path$1) {
	return path$1.length < 2 ? object : _baseGet_default(object, _baseSlice_default(path$1, 0, -1));
}
var _parent_default = parent;

//#endregion
//#region ../node_modules/lodash-es/isNil.js
/**
* Checks if `value` is `null` or `undefined`.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is nullish, else `false`.
* @example
*
* _.isNil(null);
* // => true
*
* _.isNil(void 0);
* // => true
*
* _.isNil(NaN);
* // => false
*/
function isNil(value$1) {
	return value$1 == null;
}
var isNil_default = isNil;

//#endregion
//#region ../node_modules/lodash-es/merge.js
/**
* This method is like `_.assign` except that it recursively merges own and
* inherited enumerable string keyed properties of source objects into the
* destination object. Source properties that resolve to `undefined` are
* skipped if a destination value exists. Array and plain object properties
* are merged recursively. Other objects and value types are overridden by
* assignment. Source objects are applied from left to right. Subsequent
* sources overwrite property assignments of previous sources.
*
* **Note:** This method mutates `object`.
*
* @static
* @memberOf _
* @since 0.5.0
* @category Object
* @param {Object} object The destination object.
* @param {...Object} [sources] The source objects.
* @returns {Object} Returns `object`.
* @example
*
* var object = {
*   'a': [{ 'b': 2 }, { 'd': 4 }]
* };
*
* var other = {
*   'a': [{ 'c': 3 }, { 'e': 5 }]
* };
*
* _.merge(object, other);
* // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
*/
var merge$2 = _createAssigner_default(function(object, source, srcIndex) {
	_baseMerge_default(object, source, srcIndex);
});
var merge_default = merge$2;

//#endregion
//#region ../node_modules/lodash-es/negate.js
/** Error message constants. */
var FUNC_ERROR_TEXT = "Expected a function";
/**
* Creates a function that negates the result of the predicate `func`. The
* `func` predicate is invoked with the `this` binding and arguments of the
* created function.
*
* @static
* @memberOf _
* @since 3.0.0
* @category Function
* @param {Function} predicate The predicate to negate.
* @returns {Function} Returns the new negated function.
* @example
*
* function isEven(n) {
*   return n % 2 == 0;
* }
*
* _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
* // => [1, 3, 5]
*/
function negate(predicate) {
	if (typeof predicate != "function") throw new TypeError(FUNC_ERROR_TEXT);
	return function() {
		var args = arguments;
		switch (args.length) {
			case 0: return !predicate.call(this);
			case 1: return !predicate.call(this, args[0]);
			case 2: return !predicate.call(this, args[0], args[1]);
			case 3: return !predicate.call(this, args[0], args[1], args[2]);
		}
		return !predicate.apply(this, args);
	};
}
var negate_default = negate;

//#endregion
//#region ../node_modules/lodash-es/_baseUnset.js
/**
* The base implementation of `_.unset`.
*
* @private
* @param {Object} object The object to modify.
* @param {Array|string} path The property path to unset.
* @returns {boolean} Returns `true` if the property is deleted, else `false`.
*/
function baseUnset(object, path$1) {
	path$1 = _castPath_default(path$1, object);
	object = _parent_default(object, path$1);
	return object == null || delete object[_toKey_default(last_default(path$1))];
}
var _baseUnset_default = baseUnset;

//#endregion
//#region ../node_modules/lodash-es/_customOmitClone.js
/**
* Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
* objects.
*
* @private
* @param {*} value The value to inspect.
* @param {string} key The key of the property to inspect.
* @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
*/
function customOmitClone(value$1) {
	return isPlainObject_default(value$1) ? void 0 : value$1;
}
var _customOmitClone_default = customOmitClone;

//#endregion
//#region ../node_modules/lodash-es/omit.js
/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
/**
* The opposite of `_.pick`; this method creates an object composed of the
* own and inherited enumerable property paths of `object` that are not omitted.
*
* **Note:** This method is considerably slower than `_.pick`.
*
* @static
* @since 0.1.0
* @memberOf _
* @category Object
* @param {Object} object The source object.
* @param {...(string|string[])} [paths] The property paths to omit.
* @returns {Object} Returns the new object.
* @example
*
* var object = { 'a': 1, 'b': '2', 'c': 3 };
*
* _.omit(object, ['a', 'c']);
* // => { 'b': '2' }
*/
var omit$1 = _flatRest_default(function(object, paths) {
	var result = {};
	if (object == null) return result;
	var isDeep = false;
	paths = _arrayMap_default(paths, function(path$1) {
		path$1 = _castPath_default(path$1, object);
		isDeep || (isDeep = path$1.length > 1);
		return path$1;
	});
	_copyObject_default(object, _getAllKeysIn_default(object), result);
	if (isDeep) result = _baseClone_default(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, _customOmitClone_default);
	var length = paths.length;
	while (length--) _baseUnset_default(result, paths[length]);
	return result;
});
var omit_default = omit$1;

//#endregion
//#region ../node_modules/lodash-es/_baseSet.js
/**
* The base implementation of `_.set`.
*
* @private
* @param {Object} object The object to modify.
* @param {Array|string} path The path of the property to set.
* @param {*} value The value to set.
* @param {Function} [customizer] The function to customize path creation.
* @returns {Object} Returns `object`.
*/
function baseSet(object, path$1, value$1, customizer) {
	if (!isObject_default(object)) return object;
	path$1 = _castPath_default(path$1, object);
	var index = -1, length = path$1.length, lastIndex = length - 1, nested = object;
	while (nested != null && ++index < length) {
		var key = _toKey_default(path$1[index]), newValue = value$1;
		if (key === "__proto__" || key === "constructor" || key === "prototype") return object;
		if (index != lastIndex) {
			var objValue = nested[key];
			newValue = customizer ? customizer(objValue, key, nested) : void 0;
			if (newValue === void 0) newValue = isObject_default(objValue) ? objValue : _isIndex_default(path$1[index + 1]) ? [] : {};
		}
		_assignValue_default(nested, key, newValue);
		nested = nested[key];
	}
	return object;
}
var _baseSet_default = baseSet;

//#endregion
//#region ../node_modules/lodash-es/_basePickBy.js
/**
* The base implementation of  `_.pickBy` without support for iteratee shorthands.
*
* @private
* @param {Object} object The source object.
* @param {string[]} paths The property paths to pick.
* @param {Function} predicate The function invoked per property.
* @returns {Object} Returns the new object.
*/
function basePickBy(object, paths, predicate) {
	var index = -1, length = paths.length, result = {};
	while (++index < length) {
		var path$1 = paths[index], value$1 = _baseGet_default(object, path$1);
		if (predicate(value$1, path$1)) _baseSet_default(result, _castPath_default(path$1, object), value$1);
	}
	return result;
}
var _basePickBy_default = basePickBy;

//#endregion
//#region ../node_modules/lodash-es/pickBy.js
/**
* Creates an object composed of the `object` properties `predicate` returns
* truthy for. The predicate is invoked with two arguments: (value, key).
*
* @static
* @memberOf _
* @since 4.0.0
* @category Object
* @param {Object} object The source object.
* @param {Function} [predicate=_.identity] The function invoked per property.
* @returns {Object} Returns the new object.
* @example
*
* var object = { 'a': 1, 'b': '2', 'c': 3 };
*
* _.pickBy(object, _.isNumber);
* // => { 'a': 1, 'c': 3 }
*/
function pickBy(object, predicate) {
	if (object == null) return {};
	var props = _arrayMap_default(_getAllKeysIn_default(object), function(prop) {
		return [prop];
	});
	predicate = _baseIteratee_default(predicate);
	return _basePickBy_default(object, props, function(value$1, path$1) {
		return predicate(value$1, path$1[0]);
	});
}
var pickBy_default = pickBy;

//#endregion
//#region ../node_modules/lodash-es/omitBy.js
/**
* The opposite of `_.pickBy`; this method creates an object composed of
* the own and inherited enumerable string keyed properties of `object` that
* `predicate` doesn't return truthy for. The predicate is invoked with two
* arguments: (value, key).
*
* @static
* @memberOf _
* @since 4.0.0
* @category Object
* @param {Object} object The source object.
* @param {Function} [predicate=_.identity] The function invoked per property.
* @returns {Object} Returns the new object.
* @example
*
* var object = { 'a': 1, 'b': '2', 'c': 3 };
*
* _.omitBy(object, _.isNumber);
* // => { 'b': '2' }
*/
function omitBy(object, predicate) {
	return pickBy_default(object, negate_default(_baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

//#endregion
//#region ../node_modules/lodash-es/_baseSortBy.js
/**
* The base implementation of `_.sortBy` which uses `comparer` to define the
* sort order of `array` and replaces criteria objects with their corresponding
* values.
*
* @private
* @param {Array} array The array to sort.
* @param {Function} comparer The function to define sort order.
* @returns {Array} Returns `array`.
*/
function baseSortBy(array, comparer) {
	var length = array.length;
	array.sort(comparer);
	while (length--) array[length] = array[length].value;
	return array;
}
var _baseSortBy_default = baseSortBy;

//#endregion
//#region ../node_modules/lodash-es/_compareAscending.js
/**
* Compares values to sort them in ascending order.
*
* @private
* @param {*} value The value to compare.
* @param {*} other The other value to compare.
* @returns {number} Returns the sort order indicator for `value`.
*/
function compareAscending(value$1, other) {
	if (value$1 !== other) {
		var valIsDefined = value$1 !== void 0, valIsNull = value$1 === null, valIsReflexive = value$1 === value$1, valIsSymbol = isSymbol_default(value$1);
		var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
		if (!othIsNull && !othIsSymbol && !valIsSymbol && value$1 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
		if (!valIsNull && !valIsSymbol && !othIsSymbol && value$1 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
	}
	return 0;
}
var _compareAscending_default = compareAscending;

//#endregion
//#region ../node_modules/lodash-es/_compareMultiple.js
/**
* Used by `_.orderBy` to compare multiple properties of a value to another
* and stable sort them.
*
* If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
* specify an order of "desc" for descending or "asc" for ascending sort order
* of corresponding values.
*
* @private
* @param {Object} object The object to compare.
* @param {Object} other The other object to compare.
* @param {boolean[]|string[]} orders The order to sort by for each property.
* @returns {number} Returns the sort order indicator for `object`.
*/
function compareMultiple(object, other, orders) {
	var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
	while (++index < length) {
		var result = _compareAscending_default(objCriteria[index], othCriteria[index]);
		if (result) {
			if (index >= ordersLength) return result;
			var order = orders[index];
			return result * (order == "desc" ? -1 : 1);
		}
	}
	return object.index - other.index;
}
var _compareMultiple_default = compareMultiple;

//#endregion
//#region ../node_modules/lodash-es/_baseOrderBy.js
/**
* The base implementation of `_.orderBy` without param guards.
*
* @private
* @param {Array|Object} collection The collection to iterate over.
* @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
* @param {string[]} orders The sort orders of `iteratees`.
* @returns {Array} Returns the new sorted array.
*/
function baseOrderBy(collection, iteratees, orders) {
	if (iteratees.length) iteratees = _arrayMap_default(iteratees, function(iteratee) {
		if (isArray_default(iteratee)) return function(value$1) {
			return _baseGet_default(value$1, iteratee.length === 1 ? iteratee[0] : iteratee);
		};
		return iteratee;
	});
	else iteratees = [identity_default];
	var index = -1;
	iteratees = _arrayMap_default(iteratees, _baseUnary_default(_baseIteratee_default));
	var result = _baseMap_default(collection, function(value$1, key, collection$1) {
		var criteria = _arrayMap_default(iteratees, function(iteratee) {
			return iteratee(value$1);
		});
		return {
			"criteria": criteria,
			"index": ++index,
			"value": value$1
		};
	});
	return _baseSortBy_default(result, function(object, other) {
		return _compareMultiple_default(object, other, orders);
	});
}
var _baseOrderBy_default = baseOrderBy;

//#endregion
//#region ../node_modules/lodash-es/_basePick.js
/**
* The base implementation of `_.pick` without support for individual
* property identifiers.
*
* @private
* @param {Object} object The source object.
* @param {string[]} paths The property paths to pick.
* @returns {Object} Returns the new object.
*/
function basePick(object, paths) {
	return _basePickBy_default(object, paths, function(value$1, path$1) {
		return hasIn_default(object, path$1);
	});
}
var _basePick_default = basePick;

//#endregion
//#region ../node_modules/lodash-es/pick.js
/**
* Creates an object composed of the picked `object` properties.
*
* @static
* @since 0.1.0
* @memberOf _
* @category Object
* @param {Object} object The source object.
* @param {...(string|string[])} [paths] The property paths to pick.
* @returns {Object} Returns the new object.
* @example
*
* var object = { 'a': 1, 'b': '2', 'c': 3 };
*
* _.pick(object, ['a', 'c']);
* // => { 'a': 1, 'c': 3 }
*/
var pick$1 = _flatRest_default(function(object, paths) {
	return object == null ? {} : _basePick_default(object, paths);
});
var pick_default = pick$1;

//#endregion
//#region ../node_modules/lodash-es/sortBy.js
/**
* Creates an array of elements, sorted in ascending order by the results of
* running each element in a collection thru each iteratee. This method
* performs a stable sort, that is, it preserves the original sort order of
* equal elements. The iteratees are invoked with one argument: (value).
*
* @static
* @memberOf _
* @since 0.1.0
* @category Collection
* @param {Array|Object} collection The collection to iterate over.
* @param {...(Function|Function[])} [iteratees=[_.identity]]
*  The iteratees to sort by.
* @returns {Array} Returns the new sorted array.
* @example
*
* var users = [
*   { 'user': 'fred',   'age': 48 },
*   { 'user': 'barney', 'age': 36 },
*   { 'user': 'fred',   'age': 30 },
*   { 'user': 'barney', 'age': 34 }
* ];
*
* _.sortBy(users, [function(o) { return o.user; }]);
* // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
*
* _.sortBy(users, ['user', 'age']);
* // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
*/
var sortBy = _baseRest_default(function(collection, iteratees) {
	if (collection == null) return [];
	var length = iteratees.length;
	if (length > 1 && _isIterateeCall_default(collection, iteratees[0], iteratees[1])) iteratees = [];
	else if (length > 2 && _isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) iteratees = [iteratees[0]];
	return _baseOrderBy_default(collection, _baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

//#endregion
//#region src/utils/config.ts
async function readNapiConfig(path$1, configPath) {
	if (configPath && !await fileExists(configPath)) throw new Error(`NAPI-RS config not found at ${configPath}`);
	if (!await fileExists(path$1)) throw new Error(`package.json not found at ${path$1}`);
	const content = await readFileAsync(path$1, "utf8");
	let pkgJson;
	try {
		pkgJson = JSON.parse(content);
	} catch (e) {
		throw new Error(`Failed to parse package.json at ${path$1}`, { cause: e });
	}
	let separatedConfig;
	if (configPath) {
		const configContent = await readFileAsync(configPath, "utf8");
		try {
			separatedConfig = JSON.parse(configContent);
		} catch (e) {
			throw new Error(`Failed to parse NAPI-RS config at ${configPath}`, { cause: e });
		}
	}
	const userNapiConfig = pkgJson.napi ?? {};
	if (pkgJson.napi && separatedConfig) {
		const pkgJsonPath = (0, colorette.underline)(path$1);
		const configPathUnderline = (0, colorette.underline)(configPath);
		console.warn((0, colorette.yellow)(`Both napi field in ${pkgJsonPath} and [NAPI-RS config](${configPathUnderline}) file are found, the NAPI-RS config file will be used.`));
		Object.assign(userNapiConfig, separatedConfig);
	}
	const napiConfig = merge_default({
		binaryName: "index",
		packageName: pkgJson.name,
		targets: [],
		packageJson: pkgJson,
		npmClient: "npm"
	}, omit_default(userNapiConfig, "targets"));
	let targets = userNapiConfig.targets ?? [];
	if (userNapiConfig?.name) {
		console.warn((0, colorette.yellow)(`[DEPRECATED] napi.name is deprecated, use napi.binaryName instead.`));
		napiConfig.binaryName = userNapiConfig.name;
	}
	if (!targets.length) {
		let deprecatedWarned = false;
		const warning = (0, colorette.yellow)(`[DEPRECATED] napi.triples is deprecated, use napi.targets instead.`);
		if (userNapiConfig.triples?.defaults) {
			deprecatedWarned = true;
			console.warn(warning);
			targets = targets.concat(DEFAULT_TARGETS);
		}
		if (userNapiConfig.triples?.additional?.length) {
			targets = targets.concat(userNapiConfig.triples.additional);
			if (!deprecatedWarned) console.warn(warning);
		}
	}
	const uniqueTargets = new Set(targets);
	if (uniqueTargets.size !== targets.length) {
		const duplicateTarget = targets.find((target, index) => targets.indexOf(target) !== index);
		throw new Error(`Duplicate targets are not allowed: ${duplicateTarget}`);
	}
	napiConfig.targets = targets.map(parseTriple);
	return napiConfig;
}

//#endregion
//#region src/utils/cargo.ts
function tryInstallCargoBinary(name$1, bin$1) {
	if (detectCargoBinary(bin$1)) {
		debug$8("Cargo binary already installed: %s", name$1);
		return;
	}
	try {
		debug$8("Installing cargo binary: %s", name$1);
		(0, node_child_process.execSync)(`cargo install ${name$1}`, { stdio: "inherit" });
	} catch (e) {
		throw new Error(`Failed to install cargo binary: ${name$1}`, { cause: e });
	}
}
function detectCargoBinary(bin$1) {
	debug$8("Detecting cargo binary: %s", bin$1);
	try {
		(0, node_child_process.execSync)(`cargo help ${bin$1}`, { stdio: "ignore" });
		debug$8("Cargo binary detected: %s", bin$1);
		return true;
	} catch {
		debug$8("Cargo binary not detected: %s", bin$1);
		return false;
	}
}

//#endregion
//#region src/utils/typegen.ts
const TOP_LEVEL_NAMESPACE = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER = `/* auto-generated by NAPI-RS */
/* eslint-disable */
`;
var TypeDefKind = /* @__PURE__ */ function(TypeDefKind$1) {
	TypeDefKind$1["Const"] = "const";
	TypeDefKind$1["Enum"] = "enum";
	TypeDefKind$1["StringEnum"] = "string_enum";
	TypeDefKind$1["Interface"] = "interface";
	TypeDefKind$1["Type"] = "type";
	TypeDefKind$1["Fn"] = "fn";
	TypeDefKind$1["Struct"] = "struct";
	TypeDefKind$1["Impl"] = "impl";
	return TypeDefKind$1;
}(TypeDefKind || {});
function prettyPrint(line, constEnum, ident, ambient = false) {
	let s = line.js_doc ?? "";
	switch (line.kind) {
		case TypeDefKind.Interface:
			s += `export interface ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.Type:
			s += `export type ${line.name} = \n${line.def}`;
			break;
		case TypeDefKind.Enum:
			const enumName = constEnum ? "const enum" : "enum";
			s += `${exportDeclare(ambient)} ${enumName} ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.StringEnum:
			if (constEnum) s += `${exportDeclare(ambient)} const enum ${line.name} {\n${line.def}\n}`;
			else s += `export type ${line.name} = ${line.def.replaceAll(/.*=/g, "").replaceAll(",", "|")};`;
			break;
		case TypeDefKind.Struct:
			s += `${exportDeclare(ambient)} class ${line.name} {\n${line.def}\n}`;
			if (line.original_name && line.original_name !== line.name) s += `\nexport type ${line.original_name} = ${line.name}`;
			break;
		case TypeDefKind.Fn:
			s += `${exportDeclare(ambient)} ${line.def}`;
			break;
		default: s += line.def;
	}
	return correctStringIdent(s, ident);
}
function exportDeclare(ambient) {
	if (ambient) return "export";
	return "export declare";
}
async function processTypeDef(intermediateTypeFile, constEnum) {
	const exports$2 = [];
	const defs = await readIntermediateTypeFile(intermediateTypeFile);
	const groupedDefs = preprocessTypeDef(defs);
	const dts = sortBy_default(Array.from(groupedDefs), ([namespace]) => namespace).map(([namespace, defs$1]) => {
		if (namespace === TOP_LEVEL_NAMESPACE) return defs$1.map((def) => {
			switch (def.kind) {
				case TypeDefKind.Const:
				case TypeDefKind.Enum:
				case TypeDefKind.StringEnum:
				case TypeDefKind.Fn:
				case TypeDefKind.Struct: {
					exports$2.push(def.name);
					if (def.original_name && def.original_name !== def.name) exports$2.push(def.original_name);
					break;
				}
				default: break;
			}
			return prettyPrint(def, constEnum, 0);
		}).join("\n\n");
		else {
			exports$2.push(namespace);
			let declaration = "";
			declaration += `export declare namespace ${namespace} {\n`;
			for (const def of defs$1) declaration += prettyPrint(def, constEnum, 2, true) + "\n";
			declaration += "}";
			return declaration;
		}
	}).join("\n\n") + "\n";
	return {
		dts,
		exports: exports$2
	};
}
async function readIntermediateTypeFile(file) {
	const content = await readFileAsync(file, "utf8");
	const defs = content.split("\n").filter(Boolean).map((line) => {
		line = line.trim();
		const parsed = JSON.parse(line);
		if (parsed.js_doc) parsed.js_doc = parsed.js_doc.replace(/\\n/g, "\n");
		if (parsed.def) parsed.def = parsed.def.replace(/\\n/g, "\n");
		return parsed;
	});
	return defs.sort((a, b) => {
		if (a.kind === TypeDefKind.Struct) {
			if (b.kind === TypeDefKind.Struct) return a.name.localeCompare(b.name);
			return -1;
		} else if (b.kind === TypeDefKind.Struct) return 1;
		else return a.name.localeCompare(b.name);
	});
}
function preprocessTypeDef(defs) {
	const namespaceGrouped = /* @__PURE__ */ new Map();
	const classDefs = /* @__PURE__ */ new Map();
	for (const def of defs) {
		const namespace = def.js_mod ?? TOP_LEVEL_NAMESPACE;
		if (!namespaceGrouped.has(namespace)) namespaceGrouped.set(namespace, []);
		const group = namespaceGrouped.get(namespace);
		if (def.kind === TypeDefKind.Struct) {
			group.push(def);
			classDefs.set(def.name, def);
		} else if (def.kind === TypeDefKind.Impl) {
			const classDef = classDefs.get(def.name);
			if (classDef) {
				if (classDef.def) classDef.def += "\n";
				classDef.def += def.def;
				if (classDef.def) classDef.def = classDef.def.replace(/\\n/g, "\n");
			}
		} else group.push(def);
	}
	return namespaceGrouped;
}
function correctStringIdent(src, ident) {
	let bracketDepth = 0;
	const result = src.split("\n").map((line) => {
		line = line.trim();
		if (line === "") return "";
		const isInMultilineComment = line.startsWith("*");
		const isClosingBracket = line.endsWith("}");
		const isOpeningBracket = line.endsWith("{");
		const isTypeDeclaration = line.endsWith("=");
		const isTypeVariant = line.startsWith("|");
		let rightIndent = ident;
		if ((isOpeningBracket || isTypeDeclaration) && !isInMultilineComment) {
			bracketDepth += 1;
			rightIndent += (bracketDepth - 1) * 2;
		} else {
			if (isClosingBracket && bracketDepth > 0 && !isInMultilineComment && !isTypeVariant) bracketDepth -= 1;
			rightIndent += bracketDepth * 2;
		}
		if (isInMultilineComment) rightIndent += 1;
		const s = `${" ".repeat(rightIndent)}${line}`;
		return s;
	}).join("\n");
	return result;
}

//#endregion
//#region src/utils/read-config.ts
async function readConfig(options) {
	const resolvePath = (...paths) => (0, node_path.resolve)(options.cwd, ...paths);
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	return config;
}

//#endregion
//#region src/api/artifacts.ts
const debug$7 = debugFactory("artifacts");
async function collectArtifacts(userOptions) {
	const options = applyDefaultArtifactsOptions(userOptions);
	const packageJsonPath = (0, node_path.join)(options.cwd, options.packageJsonPath);
	const { targets, binaryName, packageName } = await readNapiConfig(packageJsonPath);
	const distDirs = targets.map((platform) => (0, node_path.join)(options.cwd, options.npmDir, platform.platformArchABI));
	const universalSourceBins = new Set(targets.filter((platform) => platform.arch === "universal").flatMap((p) => UniArchsByPlatform[p.platform]?.map((a) => `${p.platform}-${a}`)).filter(Boolean));
	await collectNodeBinaries((0, node_path.join)(options.cwd, options.outputDir)).then((output) => Promise.all(output.map(async (filePath) => {
		debug$7.info(`Read [${colorette.yellowBright(filePath)}]`);
		const sourceContent = await readFileAsync(filePath);
		const parsedName = (0, node_path.parse)(filePath);
		const terms = parsedName.name.split(".");
		const platformArchABI = terms.pop();
		const _binaryName = terms.join(".");
		if (_binaryName !== binaryName) {
			debug$7.warn(`[${_binaryName}] is not matched with [${binaryName}], skip`);
			return;
		}
		const dir = distDirs.find((dir$1) => dir$1.includes(platformArchABI));
		if (!dir && universalSourceBins.has(platformArchABI)) {
			debug$7.warn(`[${platformArchABI}] has no dist dir but it is source bin for universal arch, skip`);
			return;
		}
		if (!dir) throw new Error(`No dist dir found for ${filePath}`);
		const distFilePath = (0, node_path.join)(dir, parsedName.base);
		debug$7.info(`Write file content to [${colorette.yellowBright(distFilePath)}]`);
		await writeFileAsync(distFilePath, sourceContent);
		const distFilePathLocal = (0, node_path.join)((0, node_path.parse)(packageJsonPath).dir, parsedName.base);
		debug$7.info(`Write file content to [${colorette.yellowBright(distFilePathLocal)}]`);
		await writeFileAsync(distFilePathLocal, sourceContent);
	})));
	const wasiTarget = targets.find((t) => t.platform === "wasi");
	if (wasiTarget) {
		const wasiDir = (0, node_path.join)(options.cwd, options.npmDir, wasiTarget.platformArchABI);
		const cjsFile = (0, node_path.join)(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi.cjs`);
		const workerFile = (0, node_path.join)(options.buildOutputDir ?? options.cwd, `wasi-worker.mjs`);
		const browserEntry = (0, node_path.join)(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi-browser.js`);
		const browserWorkerFile = (0, node_path.join)(options.buildOutputDir ?? options.cwd, `wasi-worker-browser.mjs`);
		debug$7.info(`Move wasi binding file [${colorette.yellowBright(cjsFile)}] to [${colorette.yellowBright(wasiDir)}]`);
		await writeFileAsync((0, node_path.join)(wasiDir, `${binaryName}.wasi.cjs`), await readFileAsync(cjsFile));
		debug$7.info(`Move wasi worker file [${colorette.yellowBright(workerFile)}] to [${colorette.yellowBright(wasiDir)}]`);
		await writeFileAsync((0, node_path.join)(wasiDir, `wasi-worker.mjs`), await readFileAsync(workerFile));
		debug$7.info(`Move wasi browser entry file [${colorette.yellowBright(browserEntry)}] to [${colorette.yellowBright(wasiDir)}]`);
		await writeFileAsync((0, node_path.join)(wasiDir, `${binaryName}.wasi-browser.js`), (await readFileAsync(browserEntry, "utf8")).replace(`new URL('./wasi-worker-browser.mjs', import.meta.url)`, `new URL('${packageName}-wasm32-wasi/wasi-worker-browser.mjs', import.meta.url)`));
		debug$7.info(`Move wasi browser worker file [${colorette.yellowBright(browserWorkerFile)}] to [${colorette.yellowBright(wasiDir)}]`);
		await writeFileAsync((0, node_path.join)(wasiDir, `wasi-worker-browser.mjs`), await readFileAsync(browserWorkerFile));
	}
}
async function collectNodeBinaries(root$1) {
	const files$1 = await readdirAsync(root$1, { withFileTypes: true });
	const nodeBinaries = files$1.filter((file) => file.isFile() && (file.name.endsWith(".node") || file.name.endsWith(".wasm"))).map((file) => (0, node_path.join)(root$1, file.name));
	const dirs = files$1.filter((file) => file.isDirectory());
	for (const dir of dirs) if (dir.name !== "node_modules") nodeBinaries.push(...await collectNodeBinaries((0, node_path.join)(root$1, dir.name)));
	return nodeBinaries;
}

//#endregion
//#region src/api/templates/js-binding.ts
function createCjsBinding(localName, pkgName, idents) {
	return `${bindingHeader}
const { createRequire } = require('node:module')
require = createRequire(__filename)

${createCommonBinding(localName, pkgName)}
module.exports = nativeBinding
${idents.map((ident) => `module.exports.${ident} = nativeBinding.${ident}`).join("\n")}
`;
}
function createEsmBinding(localName, pkgName, idents) {
	return `${bindingHeader}
import { createRequire } from 'node:module'
const require = createRequire(import.meta.url)
const __dirname = new URL('.', import.meta.url).pathname

${createCommonBinding(localName, pkgName)}
const { ${idents.join(", ")} } = nativeBinding
${idents.map((ident) => `export { ${ident} }`).join("\n")}
`;
}
const bindingHeader = `// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */
`;
function createCommonBinding(localName, pkgName) {
	function requireTuple(tuple, identSize = 8) {
		const identLow = " ".repeat(identSize - 2);
		const ident = " ".repeat(identSize);
		return `try {
${ident}return require('./${localName}.${tuple}.node')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}
${identLow}try {
${ident}return require('${pkgName}-${tuple}')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}`;
	}
	return `const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      nativeBinding = require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      ${requireTuple("android-arm64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("android-arm-eabi")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Android \${process.arch}\`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      ${requireTuple("win32-x64-msvc")}
    } else if (process.arch === 'ia32') {
      ${requireTuple("win32-ia32-msvc")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("win32-arm64-msvc")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Windows: \${process.arch}\`))
    }
  } else if (process.platform === 'darwin') {
    ${requireTuple("darwin-universal", 6)}
    if (process.arch === 'x64') {
      ${requireTuple("darwin-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("darwin-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on macOS: \${process.arch}\`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      ${requireTuple("freebsd-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("freebsd-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on FreeBSD: \${process.arch}\`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        ${requireTuple("linux-x64-musl", 10)}
      } else {
        ${requireTuple("linux-x64-gnu", 10)}
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        ${requireTuple("linux-arm64-musl", 10)}
      } else {
        ${requireTuple("linux-arm64-gnu", 10)}
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        ${requireTuple("linux-arm-musleabihf", 10)}
      } else {
        ${requireTuple("linux-arm-gnueabihf", 10)}
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        ${requireTuple("linux-riscv64-musl", 10)}
      } else {
        ${requireTuple("linux-riscv64-gnu", 10)}
      }
    } else if (process.arch === 'ppc64') {
      ${requireTuple("linux-ppc64-gnu")}
    } else if (process.arch === 's390x') {
      ${requireTuple("linux-s390x-gnu")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Linux: \${process.arch}\`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      ${requireTuple("linux-arm64-ohos")}
    } else if (process.arch === 'x64') {
      ${requireTuple("linux-x64-ohos")}
    } else if (process.arch === 'arm') {
      ${requireTuple("linux-arm-ohos")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on OpenHarmony: \${process.arch}\`))
    }
  } else {
    loadErrors.push(new Error(\`Unsupported OS: \${process.platform}, architecture: \${process.arch}\`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  try {
    nativeBinding = require('./${localName}.wasi.cjs')
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      loadErrors.push(err)
    }
  }
  if (!nativeBinding) {
    try {
      nativeBinding = require('${pkgName}-wasm32-wasi')
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        loadErrors.push(err)
      }
    }
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      \`Cannot find native binding. \` +
        \`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). \` +
        'Please try \`npm i\` again after removing both package-lock.json and node_modules directory.',
      { cause: loadErrors }
    )
  }
  throw new Error(\`Failed to load native binding\`)
}
`;
}

//#endregion
//#region src/api/templates/load-wasi-template.ts
const createWasiBrowserBinding = (wasiFilename, initialMemory = 4e3, maximumMemory = 65536, fs$2 = false, asyncInit = false, buffer = false) => {
	const fsImport = fs$2 ? buffer ? `import { memfs, Buffer } from '@napi-rs/wasm-runtime/fs'` : `import { memfs } from '@napi-rs/wasm-runtime/fs'` : "";
	const bufferImport = buffer && !fs$2 ? `import { Buffer } from 'buffer'` : "";
	const wasiCreation = fs$2 ? `
export const { fs: __fs, vol: __volume } = memfs()

const __wasi = new __WASI({
  version: 'preview1',
  fs: __fs,
  preopens: {
    '/': '/',
  },
})` : `
const __wasi = new __WASI({
  version: 'preview1',
})`;
	const workerFsHandler = fs$2 ? `    worker.addEventListener('message', __wasmCreateOnMessageForFsProxy(__fs))\n` : "";
	const emnapiInjectBuffer = buffer ? "__emnapiContext.feature.Buffer = Buffer" : "";
	const emnapiInstantiateImport = asyncInit ? `instantiateNapiModule as __emnapiInstantiateNapiModule` : `instantiateNapiModuleSync as __emnapiInstantiateNapiModuleSync`;
	const emnapiInstantiateCall = asyncInit ? `await __emnapiInstantiateNapiModule` : `__emnapiInstantiateNapiModuleSync`;
	return `import {
  createOnMessage as __wasmCreateOnMessageForFsProxy,
  getDefaultContext as __emnapiGetDefaultContext,
  ${emnapiInstantiateImport},
  WASI as __WASI,
} from '@napi-rs/wasm-runtime'
${fsImport}
${bufferImport}
${wasiCreation}

const __wasmUrl = new URL('./${wasiFilename}.wasm', import.meta.url).href
const __emnapiContext = __emnapiGetDefaultContext()
${emnapiInjectBuffer}

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

const __wasmFile = await fetch(__wasmUrl).then((res) => res.arrayBuffer())

const {
  instance: __napiInstance,
  module: __wasiModule,
  napiModule: __napiModule,
} = ${emnapiInstantiateCall}(__wasmFile, {
  context: __emnapiContext,
  asyncWorkPoolSize: 4,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(new URL('./wasi-worker-browser.mjs', import.meta.url), {
      type: 'module',
    })
${workerFsHandler}
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;
};
const createWasiBinding = (wasmFileName, packageName, initialMemory = 4e3, maximumMemory = 65536) => `/* eslint-disable */
/* prettier-ignore */

/* auto-generated by NAPI-RS */

const __nodeFs = require('node:fs')
const __nodePath = require('node:path')
const { WASI: __nodeWASI } = require('node:wasi')
const { Worker } = require('node:worker_threads')

const {
  createOnMessage: __wasmCreateOnMessageForFsProxy,
  getDefaultContext: __emnapiGetDefaultContext,
  instantiateNapiModuleSync: __emnapiInstantiateNapiModuleSync,
} = require('@napi-rs/wasm-runtime')

const __rootDir = __nodePath.parse(process.cwd()).root

const __wasi = new __nodeWASI({
  version: 'preview1',
  env: process.env,
  preopens: {
    [__rootDir]: __rootDir,
  }
})

const __emnapiContext = __emnapiGetDefaultContext()

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

let __wasmFilePath = __nodePath.join(__dirname, '${wasmFileName}.wasm')
const __wasmDebugFilePath = __nodePath.join(__dirname, '${wasmFileName}.debug.wasm')

if (__nodeFs.existsSync(__wasmDebugFilePath)) {
  __wasmFilePath = __wasmDebugFilePath
} else if (!__nodeFs.existsSync(__wasmFilePath)) {
  try {
    __wasmFilePath = __nodePath.resolve('${packageName}-wasm32-wasi')
  } catch {
    throw new Error('Cannot find ${wasmFileName}.wasm file, and ${packageName}-wasm32-wasi package is not installed.')
  }
}

const { instance: __napiInstance, module: __wasiModule, napiModule: __napiModule } = __emnapiInstantiateNapiModuleSync(__nodeFs.readFileSync(__wasmFilePath), {
  context: __emnapiContext,
  asyncWorkPoolSize: (function() {
    const threadsSizeFromEnv = Number(process.env.NAPI_RS_ASYNC_WORK_POOL_SIZE ?? process.env.UV_THREADPOOL_SIZE)
    // NaN > 0 is false
    if (threadsSizeFromEnv > 0) {
      return threadsSizeFromEnv
    } else {
      return 4
    }
  })(),
  reuseWorker: true,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(__nodePath.join(__dirname, 'wasi-worker.mjs'), {
      env: process.env,
    })
    worker.onmessage = ({ data }) => {
      __wasmCreateOnMessageForFsProxy(__nodeFs)(data)
    }

    // The main thread of Node.js waits for all the active handles before exiting.
    // But Rust threads are never waited without \`thread::join\`.
    // So here we hack the code of Node.js to prevent the workers from being referenced (active).
    // According to https://github.com/nodejs/node/blob/19e0d472728c79d418b74bddff588bea70a403d0/lib/internal/worker.js#L415,
    // a worker is consist of two handles: kPublicPort and kHandle.
    {
      const kPublicPort = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kPublicPort")
      );
      if (kPublicPort) {
        worker[kPublicPort].ref = () => {};
      }

      const kHandle = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kHandle")
      );
      if (kHandle) {
        worker[kHandle].ref = () => {};
      }

      worker.unref();
    }
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;

//#endregion
//#region src/api/templates/wasi-worker-template.ts
const WASI_WORKER_TEMPLATE = `import fs from "node:fs";
import { createRequire } from "node:module";
import { parse } from "node:path";
import { WASI } from "node:wasi";
import { parentPort, Worker } from "node:worker_threads";

const require = createRequire(import.meta.url);

const { instantiateNapiModuleSync, MessageHandler, getDefaultContext } = require("@napi-rs/wasm-runtime");

if (parentPort) {
  parentPort.on("message", (data) => {
    globalThis.onmessage({ data });
  });
}

Object.assign(globalThis, {
  self: globalThis,
  require,
  Worker,
  importScripts: function (f) {
    ;(0, eval)(fs.readFileSync(f, "utf8") + "//# sourceURL=" + f);
  },
  postMessage: function (msg) {
    if (parentPort) {
      parentPort.postMessage(msg);
    }
  },
});

const emnapiContext = getDefaultContext();

const __rootDir = parse(process.cwd()).root;

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    const wasi = new WASI({
      version: 'preview1',
      env: process.env,
      preopens: {
        [__rootDir]: __rootDir,
      },
    });

    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      context: emnapiContext,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory
        };
      },
    });
  },
});

globalThis.onmessage = function (e) {
  handler.handle(e);
};
`;
const createWasiBrowserWorkerBinding = (fs$2) => {
	const fsImport = fs$2 ? `import { instantiateNapiModuleSync, MessageHandler, WASI, createFsProxy } from '@napi-rs/wasm-runtime'
import { memfsExported as __memfsExported } from '@napi-rs/wasm-runtime/fs'

const fs = createFsProxy(__memfsExported)` : `import { instantiateNapiModuleSync, MessageHandler, WASI } from '@napi-rs/wasm-runtime'`;
	const wasiCreation = fs$2 ? `const wasi = new WASI({
      fs,
      preopens: {
        '/': '/',
      },
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })` : `const wasi = new WASI({
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })`;
	return `${fsImport}

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    ${wasiCreation}
    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory,
        }
      },
    })
  },
})

globalThis.onmessage = function (e) {
  handler.handle(e)
}
`;
};

//#endregion
//#region src/api/build.ts
const debug$6 = debugFactory("build");
const require$1 = (0, node_module.createRequire)(require("url").pathToFileURL(__filename).href);
async function buildProject(rawOptions) {
	debug$6("napi build command receive options: %O", rawOptions);
	const options = {
		dtsCache: true,
		...rawOptions,
		cwd: rawOptions.cwd ?? process.cwd()
	};
	const resolvePath = (...paths) => (0, node_path.resolve)(options.cwd, ...paths);
	const manifestPath = resolvePath(options.manifestPath ?? "Cargo.toml");
	const metadata = await parseMetadata(manifestPath);
	const crate = metadata.packages.find((p) => {
		if (options.package) return p.name === options.package;
		else return p.manifest_path === manifestPath;
	});
	if (!crate) throw new Error("Unable to find crate to build. It seems you are trying to build a crate in a workspace, try using `--package` option to specify the package to build.");
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	const builder = new Builder(metadata, crate, config, options);
	return builder.build();
}
var Builder = class {
	args = [];
	envs = {};
	outputs = [];
	target;
	crateDir;
	outputDir;
	targetDir;
	enableTypeDef = false;
	constructor(metadata, crate, config, options) {
		this.metadata = metadata;
		this.crate = crate;
		this.config = config;
		this.options = options;
		this.target = options.target ? parseTriple(options.target) : process.env.CARGO_BUILD_TARGET ? parseTriple(process.env.CARGO_BUILD_TARGET) : getSystemDefaultTarget();
		this.crateDir = (0, node_path.parse)(crate.manifest_path).dir;
		this.outputDir = (0, node_path.resolve)(this.options.cwd, options.outputDir ?? this.crateDir);
		this.targetDir = options.targetDir ?? process.env.CARGO_BUILD_TARGET_DIR ?? metadata.target_directory;
		this.enableTypeDef = this.crate.dependencies.some((dep) => dep.name === "napi-derive" && (dep.uses_default_features || dep.features.includes("type-def")));
		if (!this.enableTypeDef) {
			const requirementWarning = "`napi-derive` crate is not used or `type-def` feature is not enabled for `napi-derive` crate";
			debug$6.warn(`${requirementWarning}. Will skip binding generation for \`.node\`, \`.wasi\` and \`.d.ts\` files.`);
			if (this.options.dts || this.options.dtsHeader || this.config.dtsHeader || this.config.dtsHeaderFile) debug$6.warn(`${requirementWarning}. \`dts\` related options are enabled but will be ignored.`);
		}
	}
	get cdyLibName() {
		return this.crate.targets.find((t) => t.crate_types.includes("cdylib"))?.name;
	}
	get binName() {
		return this.options.bin ?? (this.cdyLibName ? null : this.crate.targets.find((t) => t.crate_types.includes("bin"))?.name);
	}
	build() {
		if (!this.cdyLibName) {
			const warning = "Missing `crate-type = [\"cdylib\"]` in [lib] config. The build result will not be available as node addon.";
			if (this.binName) debug$6.warn(warning);
			else throw new Error(warning);
		}
		return this.pickBinary().setPackage().setFeatures().setTarget().pickCrossToolchain().setEnvs().setBypassArgs().exec();
	}
	pickCrossToolchain() {
		if (!this.options.useNapiCross) return this;
		if (this.options.useCross) debug$6.warn("You are trying to use both `--cross` and `--use-napi-cross` options, `--use-cross` will be ignored.");
		if (this.options.crossCompile) debug$6.warn("You are trying to use both `--cross-compile` and `--use-napi-cross` options, `--cross-compile` will be ignored.");
		try {
			const { version: version$2, download } = require$1("@napi-rs/cross-toolchain");
			const alias = { "s390x-unknown-linux-gnu": "s390x-ibm-linux-gnu" };
			const toolchainPath = (0, node_path.join)((0, node_os.homedir)(), ".napi-rs", "cross-toolchain", version$2, this.target.triple);
			(0, node_fs.mkdirSync)(toolchainPath, { recursive: true });
			if ((0, node_fs.existsSync)((0, node_path.join)(toolchainPath, "package.json"))) debug$6(`Toolchain ${toolchainPath} exists, skip extracting`);
			else {
				const tarArchive = download(process.arch, this.target.triple);
				tarArchive.unpack(toolchainPath);
			}
			const upperCaseTarget = targetToEnvVar(this.target.triple);
			const crossTargetName = alias[this.target.triple] ?? this.target.triple;
			const linkerEnv = `CARGO_TARGET_${upperCaseTarget}_LINKER`;
			this.envs[linkerEnv] = (0, node_path.join)(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_SYSROOT) this.envs[`TARGET_SYSROOT`] = (0, node_path.join)(toolchainPath, crossTargetName, "sysroot");
			if (!process.env.TARGET_AR) this.envs[`TARGET_AR`] = (0, node_path.join)(toolchainPath, "bin", `${crossTargetName}-ar`);
			if (!process.env.TARGET_RANLIB) this.envs[`TARGET_RANLIB`] = (0, node_path.join)(toolchainPath, "bin", `${crossTargetName}-ranlib`);
			if (!process.env.TARGET_READELF) this.envs[`TARGET_READELF`] = (0, node_path.join)(toolchainPath, "bin", `${crossTargetName}-readelf`);
			if (!process.env.TARGET_C_INCLUDE_PATH) this.envs[`TARGET_C_INCLUDE_PATH`] = (0, node_path.join)(toolchainPath, crossTargetName, "sysroot", "usr", "include/");
			if (!process.env.TARGET_CC) this.envs[`TARGET_CC`] = (0, node_path.join)(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_CXX) this.envs[`TARGET_CXX`] = (0, node_path.join)(toolchainPath, "bin", `${crossTargetName}-g++`);
			if (process.env.TARGET_CC?.startsWith("clang") || process.env.CC?.startsWith("clang") && !process.env.TARGET_CC) {
				const TARGET_CFLAGS = process.env.TARGET_CFLAGS ?? "";
				this.envs.TARGET_CFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CFLAGS}`;
			}
			if (process.env.CXX?.startsWith("clang++") && !process.env.TARGET_CXX || process.env.TARGET_CXX?.startsWith("clang++")) {
				const TARGET_CXXFLAGS = process.env.TARGET_CXXFLAGS ?? "";
				this.envs.TARGET_CXXFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CXXFLAGS}`;
			}
			this.envs.PATH = this.envs.PATH ? `${toolchainPath}/bin:${this.envs.PATH}:${process.env.PATH}` : `${toolchainPath}/bin:${process.env.PATH}`;
		} catch (e) {
			debug$6.warn("Pick cross toolchain failed", e);
		}
		return this;
	}
	exec() {
		debug$6(`Start building crate: ${this.crate.name}`);
		debug$6("  %i", `cargo ${this.args.join(" ")}`);
		const controller = new AbortController();
		const watch = this.options.watch;
		const buildTask = new Promise((resolve$7, reject) => {
			if (this.options.useCross && this.options.crossCompile) throw new Error("`--use-cross` and `--cross-compile` can not be used together");
			const command = process.env.CARGO ?? (this.options.useCross ? "cross" : "cargo");
			const buildProcess = (0, node_child_process.spawn)(command, this.args, {
				env: {
					...process.env,
					...this.envs
				},
				stdio: watch ? [
					"inherit",
					"inherit",
					"pipe"
				] : "inherit",
				cwd: this.options.cwd,
				signal: controller.signal
			});
			buildProcess.once("exit", (code) => {
				if (code === 0) {
					debug$6("%i", `Build crate ${this.crate.name} successfully!`);
					resolve$7();
				} else reject(/* @__PURE__ */ new Error(`Build failed with exit code ${code}`));
			});
			buildProcess.once("error", (e) => {
				reject(new Error(`Build failed with error: ${e.message}`, { cause: e }));
			});
			buildProcess.stderr?.on("data", (data) => {
				const output = data.toString();
				console.error(output);
				if (/Finished\s(`dev`|`release`)/.test(output)) this.postBuild().catch(() => {});
			});
		});
		return {
			task: buildTask.then(() => this.postBuild()),
			abort: () => controller.abort()
		};
	}
	pickBinary() {
		let set = false;
		if (this.options.watch) if (process.env.CI) debug$6.warn("Watch mode is not supported in CI environment");
		else {
			debug$6("Use %i", "cargo-watch");
			tryInstallCargoBinary("cargo-watch", "watch");
			this.args.push("watch", "--why", "-i", "*.{js,ts,node}", "-w", this.crateDir, "--", "cargo", "build");
			set = true;
		}
		if (this.options.crossCompile) if (this.target.platform === "win32") if (process.platform === "win32") debug$6.warn("You are trying to cross compile to win32 platform on win32 platform which is unnecessary.");
		else {
			debug$6("Use %i", "cargo-xwin");
			tryInstallCargoBinary("cargo-xwin", "xwin");
			this.args.push("xwin", "build");
			if (this.target.arch === "ia32") this.envs.XWIN_ARCH = "x86";
			set = true;
		}
		else if (this.target.platform === "linux" && process.platform === "linux" && this.target.arch === process.arch && function(abi) {
			const glibcVersionRuntime = process.report?.getReport()?.header?.glibcVersionRuntime;
			const libc = glibcVersionRuntime ? "gnu" : "musl";
			return abi === libc;
		}(this.target.abi)) debug$6.warn("You are trying to cross compile to linux target on linux platform which is unnecessary.");
		else if (this.target.platform === "darwin" && process.platform === "darwin") debug$6.warn("You are trying to cross compile to darwin target on darwin platform which is unnecessary.");
		else {
			debug$6("Use %i", "cargo-zigbuild");
			tryInstallCargoBinary("cargo-zigbuild", "zigbuild");
			this.args.push("zigbuild");
			set = true;
		}
		if (!set) this.args.push("build");
		return this;
	}
	setPackage() {
		const args = [];
		if (this.options.package) args.push("--package", this.options.package);
		if (this.binName) args.push("--bin", this.binName);
		if (args.length) {
			debug$6("Set package flags: ");
			debug$6("  %O", args);
			this.args.push(...args);
		}
		return this;
	}
	setTarget() {
		debug$6("Set compiling target to: ");
		debug$6("  %i", this.target.triple);
		this.args.push("--target", this.target.triple);
		return this;
	}
	setEnvs() {
		if (this.enableTypeDef) {
			this.envs.NAPI_TYPE_DEF_TMP_FOLDER = this.generateIntermediateTypeDefFolder();
			this.setForceBuildEnvs(this.envs.NAPI_TYPE_DEF_TMP_FOLDER);
		}
		let rustflags = process.env.RUSTFLAGS ?? process.env.CARGO_BUILD_RUSTFLAGS ?? "";
		if (this.target.abi?.includes("musl") && !rustflags.includes("target-feature=-crt-static")) rustflags += " -C target-feature=-crt-static";
		if (this.options.strip && !rustflags.includes("link-arg=-s")) rustflags += " -C link-arg=-s";
		if (rustflags.length) this.envs.RUSTFLAGS = rustflags;
		const linker = this.options.crossCompile ? void 0 : getTargetLinker(this.target.triple);
		const linkerEnv = `CARGO_TARGET_${targetToEnvVar(this.target.triple)}_LINKER`;
		if (linker && !process.env[linkerEnv] && !this.envs[linkerEnv]) this.envs[linkerEnv] = linker;
		if (this.target.platform === "android") this.setAndroidEnv();
		if (this.target.platform === "wasi") this.setWasiEnv();
		if (this.target.platform === "openharmony") this.setOpenHarmonyEnv();
		debug$6("Set envs: ");
		Object.entries(this.envs).forEach(([k, v]) => {
			debug$6("  %i", `${k}=${v}`);
		});
		return this;
	}
	setForceBuildEnvs(typeDefTmpFolder) {
		this.metadata.packages.forEach((crate) => {
			if (crate.dependencies.some((d) => d.name === "napi-derive") && !(0, node_fs.existsSync)((0, node_path.join)(typeDefTmpFolder, crate.name))) this.envs[`NAPI_FORCE_BUILD_${crate.name.replace(/-/g, "_").toUpperCase()}`] = Date.now().toString();
		});
	}
	setAndroidEnv() {
		const { ANDROID_NDK_LATEST_HOME } = process.env;
		if (!ANDROID_NDK_LATEST_HOME) debug$6.warn(`${colorette.red("ANDROID_NDK_LATEST_HOME")} environment variable is missing`);
		if (process.platform === "android") return;
		const targetArch = this.target.arch === "arm" ? "armv7a" : "aarch64";
		const targetPlatform = this.target.arch === "arm" ? "androideabi24" : "android24";
		const hostPlatform = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "windows" : "linux";
		Object.assign(this.envs, {
			CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-android24-clang`,
			CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-androideabi24-clang`,
			TARGET_CC: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang`,
			TARGET_CXX: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang++`,
			TARGET_AR: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ar`,
			TARGET_RANLIB: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ranlib`,
			ANDROID_NDK: ANDROID_NDK_LATEST_HOME,
			PATH: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`
		});
	}
	setWasiEnv() {
		const emnapi = (0, node_path.join)(require$1.resolve("emnapi"), "..", "lib", "wasm32-wasi-threads");
		this.envs.EMNAPI_LINK_DIR = emnapi;
		const { WASI_SDK_PATH } = process.env;
		if (WASI_SDK_PATH && (0, node_fs.existsSync)(WASI_SDK_PATH)) {
			this.envs.CARGO_TARGET_WASM32_WASI_PREVIEW1_THREADS_LINKER = (0, node_path.join)(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_LINKER = (0, node_path.join)(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_THREADS_LINKER = (0, node_path.join)(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP2_LINKER = (0, node_path.join)(WASI_SDK_PATH, "bin", "wasm-ld");
			this.setEnvIfNotExists("TARGET_CC", (0, node_path.join)(WASI_SDK_PATH, "bin", "clang"));
			this.setEnvIfNotExists("TARGET_CXX", (0, node_path.join)(WASI_SDK_PATH, "bin", "clang++"));
			this.setEnvIfNotExists("TARGET_AR", (0, node_path.join)(WASI_SDK_PATH, "bin", "ar"));
			this.setEnvIfNotExists("TARGET_RANLIB", (0, node_path.join)(WASI_SDK_PATH, "bin", "ranlib"));
			this.setEnvIfNotExists("TARGET_CFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists("TARGET_CXXFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists(`TARGET_LDFLAGS`, `-fuse-ld=${WASI_SDK_PATH}/bin/wasm-ld --target=wasm32-wasi-threads`);
		}
	}
	setOpenHarmonyEnv() {
		const { OHOS_SDK_PATH, OHOS_SDK_NATIVE } = process.env;
		const ndkPath = OHOS_SDK_PATH ? `${OHOS_SDK_NATIVE}/native` : OHOS_SDK_NATIVE;
		if (!ndkPath && process.platform !== "openharmony") {
			debug$6.warn(`${colorette.red("OHOS_SDK_PATH")} or ${colorette.red("OHOS_SDK_NATIVE")} environment variable is missing`);
			return;
		}
		const linkerName = `CARGO_TARGET_${this.target.triple.toUpperCase().replace(/-/g, "_")}_LINKER`;
		const ranPath = `${ndkPath}/llvm/bin/llvm-ranlib`;
		const arPath = `${ndkPath}/llvm/bin/llvm-ar`;
		const ccPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang`;
		const cxxPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang++`;
		const asPath = `${ndkPath}/llvm/bin/llvm-as`;
		const ldPath = `${ndkPath}/llvm/bin/ld.lld`;
		const stripPath = `${ndkPath}/llvm/bin/llvm-strip`;
		const objDumpPath = `${ndkPath}/llvm/bin/llvm-objdump`;
		const objCopyPath = `${ndkPath}/llvm/bin/llvm-objcopy`;
		const nmPath = `${ndkPath}/llvm/bin/llvm-nm`;
		const binPath = `${ndkPath}/llvm/bin`;
		const libPath = `${ndkPath}/llvm/lib`;
		this.setEnvIfNotExists("LIBCLANG_PATH", libPath);
		this.setEnvIfNotExists("DEP_ATOMIC", "clang_rt.builtins");
		this.setEnvIfNotExists(linkerName, ccPath);
		this.setEnvIfNotExists("TARGET_CC", ccPath);
		this.setEnvIfNotExists("TARGET_CXX", cxxPath);
		this.setEnvIfNotExists("TARGET_AR", arPath);
		this.setEnvIfNotExists("TARGET_RANLIB", ranPath);
		this.setEnvIfNotExists("TARGET_AS", asPath);
		this.setEnvIfNotExists("TARGET_LD", ldPath);
		this.setEnvIfNotExists("TARGET_STRIP", stripPath);
		this.setEnvIfNotExists("TARGET_OBJDUMP", objDumpPath);
		this.setEnvIfNotExists("TARGET_OBJCOPY", objCopyPath);
		this.setEnvIfNotExists("TARGET_NM", nmPath);
		this.envs.PATH = `${binPath}${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`;
	}
	setFeatures() {
		const args = [];
		if (this.options.allFeatures && this.options.noDefaultFeatures) throw new Error("Cannot specify --all-features and --no-default-features together");
		if (this.options.allFeatures) args.push("--all-features");
		else if (this.options.noDefaultFeatures) args.push("--no-default-features");
		if (this.options.features) args.push("--features", ...this.options.features);
		debug$6("Set features flags: ");
		debug$6("  %O", args);
		this.args.push(...args);
		return this;
	}
	setBypassArgs() {
		if (this.options.release) this.args.push("--release");
		if (this.options.verbose) this.args.push("--verbose");
		if (this.options.targetDir) this.args.push("--target-dir", this.options.targetDir);
		if (this.options.profile) this.args.push("--profile", this.options.profile);
		if (this.options.manifestPath) this.args.push("--manifest-path", this.options.manifestPath);
		if (this.options.cargoOptions?.length) this.args.push(...this.options.cargoOptions);
		return this;
	}
	generateIntermediateTypeDefFolder() {
		let folder = (0, node_path.join)(this.targetDir, "napi-rs", `${this.crate.name}-${(0, node_crypto.createHash)("sha256").update(this.crate.manifest_path).update(CLI_VERSION).digest("hex").substring(0, 8)}`);
		if (!this.options.dtsCache) {
			(0, node_fs.rmSync)(folder, {
				recursive: true,
				force: true
			});
			folder += `_${Date.now()}`;
		}
		mkdirAsync(folder, { recursive: true });
		return folder;
	}
	async postBuild() {
		try {
			debug$6(`Try to create output directory:`);
			debug$6("  %i", this.outputDir);
			await mkdirAsync(this.outputDir, { recursive: true });
			debug$6(`Output directory created`);
		} catch (e) {
			throw new Error(`Failed to create output directory ${this.outputDir}`, { cause: e });
		}
		const wasmBinaryName = await this.copyArtifact();
		if (this.cdyLibName) {
			const idents = await this.generateTypeDef();
			const jsOutput = await this.writeJsBinding(idents);
			const wasmBindingsOutput = await this.writeWasiBinding(wasmBinaryName, idents);
			if (jsOutput) this.outputs.push(jsOutput);
			if (wasmBindingsOutput) this.outputs.push(...wasmBindingsOutput);
		}
		return this.outputs;
	}
	async copyArtifact() {
		const [srcName, destName, wasmBinaryName] = this.getArtifactNames();
		if (!srcName || !destName) return;
		const profile = this.options.profile ?? (this.options.release ? "release" : "debug");
		const src = (0, node_path.join)(this.targetDir, this.target.triple, profile, srcName);
		debug$6(`Copy artifact from: [${src}]`);
		const dest = (0, node_path.join)(this.outputDir, destName);
		const isWasm = dest.endsWith(".wasm");
		try {
			if (await fileExists(dest)) {
				debug$6("Old artifact found, remove it first");
				await unlinkAsync(dest);
			}
			debug$6("Copy artifact to:");
			debug$6("  %i", dest);
			if (isWasm) {
				const { ModuleConfig } = await import("@napi-rs/wasm-tools");
				debug$6("Generate debug wasm module");
				try {
					const debugWasmModule = new ModuleConfig().generateDwarf(true).generateNameSection(true).generateProducersSection(true).preserveCodeTransform(true).strictValidate(false).parse(await readFileAsync(src));
					const debugWasmBinary = debugWasmModule.emitWasm(true);
					await writeFileAsync(dest.replace(/\.wasm$/, ".debug.wasm"), debugWasmBinary);
					debug$6("Generate release wasm module");
					const releaseWasmModule = new ModuleConfig().generateDwarf(false).generateNameSection(false).generateProducersSection(false).preserveCodeTransform(false).strictValidate(false).onlyStableFeatures(false).parse(debugWasmBinary);
					const releaseWasmBinary = releaseWasmModule.emitWasm(false);
					await writeFileAsync(dest, releaseWasmBinary);
				} catch (e) {
					debug$6.warn(`Failed to generate debug wasm module: ${e.message ?? e}`);
					await copyFileAsync(src, dest);
				}
			} else await copyFileAsync(src, dest);
			this.outputs.push({
				kind: dest.endsWith(".node") ? "node" : isWasm ? "wasm" : "exe",
				path: dest
			});
			return wasmBinaryName ? (0, node_path.join)(this.outputDir, wasmBinaryName) : null;
		} catch (e) {
			throw new Error("Failed to copy artifact", { cause: e });
		}
	}
	getArtifactNames() {
		if (this.cdyLibName) {
			const cdyLib = this.cdyLibName.replace(/-/g, "_");
			const wasiTarget = this.config.targets.find((t) => t.platform === "wasi");
			const srcName = this.target.platform === "darwin" ? `lib${cdyLib}.dylib` : this.target.platform === "win32" ? `${cdyLib}.dll` : this.target.platform === "wasi" || this.target.platform === "wasm" ? `${cdyLib}.wasm` : `lib${cdyLib}.so`;
			let destName = this.config.binaryName;
			if (this.options.platform) destName += `.${this.target.platformArchABI}`;
			if (srcName.endsWith(".wasm")) destName += ".wasm";
			else destName += ".node";
			return [
				srcName,
				destName,
				wasiTarget ? `${this.config.binaryName}.${wasiTarget.platformArchABI}.wasm` : null
			];
		} else if (this.binName) {
			const srcName = this.target.platform === "win32" ? `${this.binName}.exe` : this.binName;
			return [srcName, srcName];
		}
		return [];
	}
	async generateTypeDef() {
		const typeDefDir = this.envs.NAPI_TYPE_DEF_TMP_FOLDER;
		if (!this.enableTypeDef || !await dirExistsAsync(typeDefDir)) return [];
		const dest = (0, node_path.join)(this.outputDir, this.options.dts ?? "index.d.ts");
		let header = "";
		let dts = "";
		let exports$2 = [];
		if (!this.options.noDtsHeader) {
			const dtsHeader = this.options.dtsHeader ?? this.config.dtsHeader;
			if (this.config.dtsHeaderFile) try {
				header = await readFileAsync((0, node_path.join)(this.options.cwd, this.config.dtsHeaderFile), "utf-8");
			} catch (e) {
				debug$6.warn(`Failed to read dts header file ${this.config.dtsHeaderFile}`, e);
			}
			else if (dtsHeader) header = dtsHeader;
			else header = DEFAULT_TYPE_DEF_HEADER;
		}
		const files$1 = await readdirAsync(typeDefDir, { withFileTypes: true });
		if (!files$1.length) {
			debug$6("No type def files found. Skip generating dts file.");
			return [];
		}
		for (const file of files$1) {
			if (!file.isFile()) continue;
			const { dts: fileDts, exports: fileExports } = await processTypeDef((0, node_path.join)(typeDefDir, file.name), this.options.constEnum ?? this.config.constEnum ?? true);
			dts += fileDts;
			exports$2.push(...fileExports);
		}
		if (dts.indexOf("ExternalObject<") > -1) header += `
export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`;
		if (dts.indexOf("TypedArray") > -1) header += `
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array
`;
		dts = header + dts;
		try {
			debug$6("Writing type def to:");
			debug$6("  %i", dest);
			await writeFileAsync(dest, dts, "utf-8");
			this.outputs.push({
				kind: "dts",
				path: dest
			});
		} catch (e) {
			debug$6.error("Failed to write type def file");
			debug$6.error(e);
		}
		return exports$2;
	}
	async writeJsBinding(idents) {
		if (!this.options.platform || this.options.noJsBinding || idents.length === 0) return;
		const name$1 = this.options.jsBinding ?? "index.js";
		const createBinding = this.options.esm ? createEsmBinding : createCjsBinding;
		const binding = createBinding(this.config.binaryName, this.config.packageName, idents);
		try {
			const dest = (0, node_path.join)(this.outputDir, name$1);
			debug$6("Writing js binding to:");
			debug$6("  %i", dest);
			await writeFileAsync(dest, binding, "utf-8");
			return {
				kind: "js",
				path: dest
			};
		} catch (e) {
			throw new Error("Failed to write js binding file", { cause: e });
		}
	}
	async writeWasiBinding(distFileName, idents) {
		if (distFileName) {
			const { name: name$1, dir } = (0, node_path.parse)(distFileName);
			const bindingPath = (0, node_path.join)(dir, `${this.config.binaryName}.wasi.cjs`);
			const browserBindingPath = (0, node_path.join)(dir, `${this.config.binaryName}.wasi-browser.js`);
			const workerPath = (0, node_path.join)(dir, "wasi-worker.mjs");
			const browserWorkerPath = (0, node_path.join)(dir, "wasi-worker-browser.mjs");
			const browserEntryPath = (0, node_path.join)(dir, "browser.js");
			const exportsCode = `module.exports = __napiModule.exports\n` + idents.map((ident) => `module.exports.${ident} = __napiModule.exports.${ident}`).join("\n");
			await writeFileAsync(bindingPath, createWasiBinding(name$1, this.config.packageName, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory) + exportsCode + "\n", "utf8");
			await writeFileAsync(browserBindingPath, createWasiBrowserBinding(name$1, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory, this.config.wasm?.browser?.fs, this.config.wasm?.browser?.asyncInit, this.config.wasm?.browser?.buffer) + `export default __napiModule.exports\n` + idents.map((ident) => `export const ${ident} = __napiModule.exports.${ident}`).join("\n") + "\n", "utf8");
			await writeFileAsync(workerPath, WASI_WORKER_TEMPLATE, "utf8");
			await writeFileAsync(browserWorkerPath, createWasiBrowserWorkerBinding(this.config.wasm?.browser?.fs ?? false), "utf8");
			await writeFileAsync(browserEntryPath, `export * from '${this.config.packageName}-wasm32-wasi'\n`);
			return [
				{
					kind: "js",
					path: bindingPath
				},
				{
					kind: "js",
					path: browserBindingPath
				},
				{
					kind: "js",
					path: workerPath
				},
				{
					kind: "js",
					path: browserWorkerPath
				},
				{
					kind: "js",
					path: browserEntryPath
				}
			];
		}
		return [];
	}
	setEnvIfNotExists(env, value$1) {
		if (!process.env[env]) this.envs[env] = value$1;
	}
};

//#endregion
//#region src/def/create-npm-dirs.ts
var BaseCreateNpmDirsCommand = class extends clipanion.Command {
	static paths = [["create-npm-dirs"]];
	static usage = clipanion.Command.Usage({ description: "Create npm package dirs for different platforms" });
	cwd = clipanion.Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = clipanion.Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = clipanion.Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = clipanion.Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	dryRun = clipanion.Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultCreateNpmDirsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/api/create-npm-dirs.ts
const debug$5 = debugFactory("create-npm-dirs");
async function createNpmDirs(userOptions) {
	const options = applyDefaultCreateNpmDirsOptions(userOptions);
	async function mkdirAsync$1(dir) {
		debug$5("Try to create dir: %i", dir);
		if (options.dryRun) return;
		await mkdirAsync(dir, { recursive: true });
	}
	async function writeFileAsync$1(file, content) {
		debug$5("Writing file %i", file);
		if (options.dryRun) {
			debug$5(content);
			return;
		}
		await writeFileAsync(file, content);
	}
	const packageJsonPath = (0, node_path.resolve)(options.cwd, options.packageJsonPath);
	const npmPath = (0, node_path.resolve)(options.cwd, options.npmDir);
	debug$5(`Read content from [${options.configPath ?? packageJsonPath}]`);
	const { targets, binaryName, packageName, packageJson } = await readNapiConfig(packageJsonPath, options.configPath ? (0, node_path.resolve)(options.cwd, options.configPath) : void 0);
	for (const target of targets) {
		const targetDir = (0, node_path.join)(npmPath, `${target.platformArchABI}`);
		await mkdirAsync$1(targetDir);
		const binaryFileName = target.arch === "wasm32" ? `${binaryName}.${target.platformArchABI}.wasm` : `${binaryName}.${target.platformArchABI}.node`;
		const scopedPackageJson = {
			name: `${packageName}-${target.platformArchABI}`,
			version: packageJson.version,
			cpu: target.arch !== "universal" ? [target.arch] : void 0,
			main: binaryFileName,
			files: [binaryFileName],
			...pick(packageJson, "description", "keywords", "author", "authors", "homepage", "license", "engines", "repository", "bugs")
		};
		if (packageJson.publishConfig) scopedPackageJson.publishConfig = pick(packageJson.publishConfig, "registry", "access");
		if (target.arch !== "wasm32") scopedPackageJson.os = [target.platform];
		else {
			const entry = `${binaryName}.wasi.cjs`;
			scopedPackageJson.main = entry;
			scopedPackageJson.browser = `${binaryName}.wasi-browser.js`;
			scopedPackageJson.files?.push(entry, scopedPackageJson.browser, `wasi-worker.mjs`, `wasi-worker-browser.mjs`);
			let needRestrictNodeVersion = true;
			if (scopedPackageJson.engines?.node) try {
				const { major } = (0, semver.parse)(scopedPackageJson.engines.node) ?? { major: 0 };
				if (major >= 14) needRestrictNodeVersion = false;
			} catch {}
			if (needRestrictNodeVersion) scopedPackageJson.engines = { node: ">=14.0.0" };
			const wasmRuntime = await fetch(`https://registry.npmjs.org/@napi-rs/wasm-runtime`).then((res) => res.json());
			scopedPackageJson.dependencies = { "@napi-rs/wasm-runtime": `^${wasmRuntime["dist-tags"].latest}` };
		}
		if (target.abi === "gnu") scopedPackageJson.libc = ["glibc"];
		else if (target.abi === "musl") scopedPackageJson.libc = ["musl"];
		const targetPackageJson = (0, node_path.join)(targetDir, "package.json");
		await writeFileAsync$1(targetPackageJson, JSON.stringify(scopedPackageJson, null, 2) + "\n");
		const targetReadme = (0, node_path.join)(targetDir, "README.md");
		await writeFileAsync$1(targetReadme, readme(packageName, target));
		debug$5.info(`${packageName} -${target.platformArchABI} created`);
	}
}
function readme(packageName, target) {
	return `# \`${packageName}-${target.platformArchABI}\`

This is the **${target.triple}** binary for \`${packageName}\`
`;
}

//#endregion
//#region src/def/new.ts
var BaseNewCommand = class extends clipanion.Command {
	static paths = [["new"]];
	static usage = clipanion.Command.Usage({ description: "Create a new project with pre-configured boilerplate" });
	$$path = clipanion.Option.String({ required: false });
	$$name = clipanion.Option.String("--name,-n", { description: "The name of the project, default to the name of the directory if not provided" });
	minNodeApiVersion = clipanion.Option.String("--min-node-api,-v", "4", {
		validator: typanion.isNumber(),
		description: "The minimum Node-API version to support"
	});
	packageManager = clipanion.Option.String("--package-manager", "yarn", { description: "The package manager to use. Only support yarn 4.x for now." });
	license = clipanion.Option.String("--license,-l", "MIT", { description: "License for open-sourced project" });
	targets = clipanion.Option.Array("--targets,-t", [], { description: "All targets the crate will be compiled for." });
	enableDefaultTargets = clipanion.Option.Boolean("--enable-default-targets", true, { description: "Whether enable default targets" });
	enableAllTargets = clipanion.Option.Boolean("--enable-all-targets", false, { description: "Whether enable all targets" });
	enableTypeDef = clipanion.Option.Boolean("--enable-type-def", true, { description: "Whether enable the `type-def` feature for typescript definitions auto-generation" });
	enableGithubActions = clipanion.Option.Boolean("--enable-github-actions", true, { description: "Whether generate preconfigured GitHub Actions workflow" });
	testFramework = clipanion.Option.String("--test-framework", "ava", { description: "The JavaScript test framework to use, only support `ava` for now" });
	dryRun = clipanion.Option.Boolean("--dry-run", false, { description: "Whether to run the command in dry-run mode" });
	getOptions() {
		return {
			path: this.$$path,
			name: this.$$name,
			minNodeApiVersion: this.minNodeApiVersion,
			packageManager: this.packageManager,
			license: this.license,
			targets: this.targets,
			enableDefaultTargets: this.enableDefaultTargets,
			enableAllTargets: this.enableAllTargets,
			enableTypeDef: this.enableTypeDef,
			enableGithubActions: this.enableGithubActions,
			testFramework: this.testFramework,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultNewOptions(options) {
	return {
		minNodeApiVersion: 4,
		packageManager: "yarn",
		license: "MIT",
		targets: [],
		enableDefaultTargets: true,
		enableAllTargets: false,
		enableTypeDef: true,
		enableGithubActions: true,
		testFramework: "ava",
		dryRun: false,
		...options
	};
}

//#endregion
//#region ../node_modules/@std/toml/stringify.js
function joinKeys(keys$1) {
	return keys$1.map((str) => {
		return str.length === 0 || str.match(/[^A-Za-z0-9_-]/) ? JSON.stringify(str) : str;
	}).join(".");
}
var Dumper = class {
	maxPad = 0;
	srcObject;
	output = [];
	#arrayTypeCache = /* @__PURE__ */ new Map();
	constructor(srcObjc) {
		this.srcObject = srcObjc;
	}
	dump(fmtOptions = {}) {
		this.output = this.#printObject(this.srcObject);
		this.output = this.#format(fmtOptions);
		return this.output;
	}
	#printObject(obj, keys$1 = []) {
		const out = [];
		const props = Object.keys(obj);
		const inlineProps = [];
		const multilineProps = [];
		for (const prop of props) if (this.#isSimplySerializable(obj[prop])) inlineProps.push(prop);
		else multilineProps.push(prop);
		const sortedProps = inlineProps.concat(multilineProps);
		for (const prop of sortedProps) {
			const value$1 = obj[prop];
			if (value$1 instanceof Date) out.push(this.#dateDeclaration([prop], value$1));
			else if (typeof value$1 === "string" || value$1 instanceof RegExp) out.push(this.#strDeclaration([prop], value$1.toString()));
			else if (typeof value$1 === "number") out.push(this.#numberDeclaration([prop], value$1));
			else if (typeof value$1 === "boolean") out.push(this.#boolDeclaration([prop], value$1));
			else if (value$1 instanceof Array) {
				const arrayType = this.#getTypeOfArray(value$1);
				if (arrayType === "ONLY_PRIMITIVE") out.push(this.#arrayDeclaration([prop], value$1));
				else if (arrayType === "ONLY_OBJECT_EXCLUDING_ARRAY") for (let i = 0; i < value$1.length; i++) {
					out.push("");
					out.push(this.#headerGroup([...keys$1, prop]));
					out.push(...this.#printObject(value$1[i], [...keys$1, prop]));
				}
				else {
					const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
					out.push(`${this.#declaration([prop])}[${str}]`);
				}
			} else if (typeof value$1 === "object") {
				out.push("");
				out.push(this.#header([...keys$1, prop]));
				if (value$1) {
					const toParse = value$1;
					out.push(...this.#printObject(toParse, [...keys$1, prop]));
				}
			}
		}
		out.push("");
		return out;
	}
	#isPrimitive(value$1) {
		return value$1 instanceof Date || value$1 instanceof RegExp || [
			"string",
			"number",
			"boolean"
		].includes(typeof value$1);
	}
	#getTypeOfArray(arr) {
		if (this.#arrayTypeCache.has(arr)) return this.#arrayTypeCache.get(arr);
		const type$1 = this.#doGetTypeOfArray(arr);
		this.#arrayTypeCache.set(arr, type$1);
		return type$1;
	}
	#doGetTypeOfArray(arr) {
		if (!arr.length) return "ONLY_PRIMITIVE";
		const onlyPrimitive = this.#isPrimitive(arr[0]);
		if (arr[0] instanceof Array) return "MIXED";
		for (let i = 1; i < arr.length; i++) if (onlyPrimitive !== this.#isPrimitive(arr[i]) || arr[i] instanceof Array) return "MIXED";
		return onlyPrimitive ? "ONLY_PRIMITIVE" : "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#printAsInlineValue(value$1) {
		if (value$1 instanceof Date) return `"${this.#printDate(value$1)}"`;
		else if (typeof value$1 === "string" || value$1 instanceof RegExp) return JSON.stringify(value$1.toString());
		else if (typeof value$1 === "number") return value$1;
		else if (typeof value$1 === "boolean") return value$1.toString();
		else if (value$1 instanceof Array) {
			const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
			return `[${str}]`;
		} else if (typeof value$1 === "object") {
			if (!value$1) throw new Error("Should never reach");
			const str = Object.keys(value$1).map((key) => {
				return `${joinKeys([key])} = ${this.#printAsInlineValue(value$1[key])}`;
			}).join(",");
			return `{${str}}`;
		}
		throw new Error("Should never reach");
	}
	#isSimplySerializable(value$1) {
		return typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || value$1 instanceof RegExp || value$1 instanceof Date || value$1 instanceof Array && this.#getTypeOfArray(value$1) !== "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#header(keys$1) {
		return `[${joinKeys(keys$1)}]`;
	}
	#headerGroup(keys$1) {
		return `[[${joinKeys(keys$1)}]]`;
	}
	#declaration(keys$1) {
		const title = joinKeys(keys$1);
		if (title.length > this.maxPad) this.maxPad = title.length;
		return `${title} = `;
	}
	#arrayDeclaration(keys$1, value$1) {
		return `${this.#declaration(keys$1)}${JSON.stringify(value$1)}`;
	}
	#strDeclaration(keys$1, value$1) {
		return `${this.#declaration(keys$1)}${JSON.stringify(value$1)}`;
	}
	#numberDeclaration(keys$1, value$1) {
		if (Number.isNaN(value$1)) return `${this.#declaration(keys$1)}nan`;
		switch (value$1) {
			case Infinity: return `${this.#declaration(keys$1)}inf`;
			case -Infinity: return `${this.#declaration(keys$1)}-inf`;
			default: return `${this.#declaration(keys$1)}${value$1}`;
		}
	}
	#boolDeclaration(keys$1, value$1) {
		return `${this.#declaration(keys$1)}${value$1}`;
	}
	#printDate(value$1) {
		function dtPad(v, lPad = 2) {
			return v.padStart(lPad, "0");
		}
		const m = dtPad((value$1.getUTCMonth() + 1).toString());
		const d = dtPad(value$1.getUTCDate().toString());
		const h = dtPad(value$1.getUTCHours().toString());
		const min = dtPad(value$1.getUTCMinutes().toString());
		const s = dtPad(value$1.getUTCSeconds().toString());
		const ms = dtPad(value$1.getUTCMilliseconds().toString(), 3);
		const fData = `${value$1.getUTCFullYear()}-${m}-${d}T${h}:${min}:${s}.${ms}`;
		return fData;
	}
	#dateDeclaration(keys$1, value$1) {
		return `${this.#declaration(keys$1)}${this.#printDate(value$1)}`;
	}
	#format(options = {}) {
		const { keyAlignment = false } = options;
		const rDeclaration = /^(\".*\"|[^=]*)\s=/;
		const out = [];
		for (let i = 0; i < this.output.length; i++) {
			const l = this.output[i];
			if (l[0] === "[" && l[1] !== "[") {
				if (this.output[i + 1] === "" && this.output[i + 2]?.slice(0, l.length) === l.slice(0, -1) + ".") {
					i += 1;
					continue;
				}
				out.push(l);
			} else if (keyAlignment) {
				const m = rDeclaration.exec(l);
				if (m && m[1]) out.push(l.replace(m[1], m[1].padEnd(this.maxPad)));
				else out.push(l);
			} else out.push(l);
		}
		const cleanedOutput = [];
		for (let i = 0; i < out.length; i++) {
			const l = out[i];
			if (!(l === "" && out[i + 1] === "")) cleanedOutput.push(l);
		}
		return cleanedOutput;
	}
};
/**
* Converts an object to a {@link https://toml.io | TOML} string.
*
* @example Usage
* ```ts
* import { stringify } from "@std/toml/stringify";
* import { assertEquals } from "@std/assert";
*
* const obj = {
*   title: "TOML Example",
*   owner: {
*     name: "Bob",
*     bio: "Bob is a cool guy",
*  }
* };
* const tomlString = stringify(obj);
* assertEquals(tomlString, `title = "TOML Example"\n\n[owner]\nname = "Bob"\nbio = "Bob is a cool guy"\n`);
* ```
* @param obj Source object
* @param options Options for stringifying.
* @returns TOML string
*/ function stringify(obj, options) {
	return new Dumper(obj).dump(options).join("\n");
}

//#endregion
//#region ../node_modules/@jsr/std__collections/_utils.js
/**
* Filters the given array, removing all elements that do not match the given predicate
* **in place. This means `array` will be modified!**.
*/ function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}

//#endregion
//#region ../node_modules/@jsr/std__collections/deep_merge.js
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, /* @__PURE__ */ new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys$1 = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys$1) {
		if (key === "__proto__") continue;
		const a = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a;
			continue;
		}
		const b = other[key];
		if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
			seen.add(a);
			seen.add(b);
			result[key] = mergeObjects(a, b, seen, options);
			continue;
		}
		result[key] = b;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
/**
* Test whether a value is mergeable or not
* Builtins that look like objects, null and user defined classes
* are not considered mergeable (it means that reference will be copied)
*/ function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}

//#endregion
//#region ../node_modules/@std/toml/_parser.js
/**
* Copy of `import { isLeap } from "@std/datetime";` because it cannot be impoted as long as it is unstable.
*/ function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
var Scanner = class {
	#whitespace = /[ \t]/;
	#position = 0;
	#source;
	constructor(source) {
		this.#source = source;
	}
	get position() {
		return this.#position;
	}
	get source() {
		return this.#source;
	}
	/**
	* Get current character
	* @param index - relative index from current position
	*/ char(index = 0) {
		return this.#source[this.#position + index] ?? "";
	}
	/**
	* Get sliced string
	* @param start - start position relative from current position
	* @param end - end position relative from current position
	*/ slice(start, end) {
		return this.#source.slice(this.#position + start, this.#position + end);
	}
	/**
	* Move position to next
	*/ next(count = 1) {
		this.#position += count;
	}
	skipWhitespaces() {
		while (this.#whitespace.test(this.char()) && !this.eof()) this.next();
		if (!this.isCurrentCharEOL() && /\s/.test(this.char())) {
			const escaped = "\\u" + this.char().charCodeAt(0).toString(16);
			const position = this.#position;
			throw new SyntaxError(`Cannot parse the TOML: It contains invalid whitespace at position '${position}': \`${escaped}\``);
		}
	}
	nextUntilChar(options = { skipComments: true }) {
		while (!this.eof()) {
			const char = this.char();
			if (this.#whitespace.test(char) || this.isCurrentCharEOL()) this.next();
			else if (options.skipComments && this.char() === "#") while (!this.isCurrentCharEOL() && !this.eof()) this.next();
			else break;
		}
	}
	/**
	* Position reached EOF or not
	*/ eof() {
		return this.#position >= this.#source.length;
	}
	isCurrentCharEOL() {
		return this.char() === "\n" || this.startsWith("\r\n");
	}
	startsWith(searchString) {
		return this.#source.startsWith(searchString, this.#position);
	}
	match(regExp) {
		if (!regExp.sticky) throw new Error(`RegExp ${regExp} does not have a sticky 'y' flag`);
		regExp.lastIndex = this.#position;
		return this.#source.match(regExp);
	}
};
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
/**
* Creates a nested object from the keys and values.
*
* e.g. `unflat(["a", "b", "c"], 1)` returns `{ a: { b: { c: 1 } } }`
*/ function unflat(keys$1, values = {}) {
	return keys$1.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function isObject(value$1) {
	return typeof value$1 === "object" && value$1 !== null;
}
function getTargetValue(target, keys$1) {
	const key = keys$1[0];
	if (!key) throw new Error("Cannot parse the TOML: key length is not a positive number");
	return target[key];
}
function deepAssignTable(target, table$1) {
	const { keys: keys$1, type: type$1, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys$1);
	if (currentValue === void 0) return Object.assign(target, unflat(keys$1, value$1));
	if (Array.isArray(currentValue)) {
		const last$1 = currentValue.at(-1);
		deepAssign(last$1, {
			type: type$1,
			keys: keys$1.slice(1),
			value: value$1
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys$1.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssignTableArray(target, table$1) {
	const { type: type$1, keys: keys$1, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys$1);
	if (currentValue === void 0) return Object.assign(target, unflat(keys$1, [value$1]));
	if (Array.isArray(currentValue)) {
		currentValue.push(value$1);
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys$1.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssign(target, body) {
	switch (body.type) {
		case "Block": return deepMerge(target, body.value);
		case "Table": return deepAssignTable(target, body);
		case "TableArray": return deepAssignTableArray(target, body);
	}
}
function or(parsers) {
	return (scanner) => {
		for (const parse$6 of parsers) {
			const result = parse$6(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
/** Join the parse results of the given parser into an array.
*
* If the parser fails at the first attempt, it will return an empty array.
*/ function join$4(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
/** Join the parse results of the given parser into an array.
*
* This requires the parser to succeed at least once.
*/ function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		const sep$1 = Separator(scanner);
		if (!sep$1.ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function merge$1(parser) {
	return (scanner) => {
		const result = parser(scanner);
		if (!result.ok) return failure();
		let body = {};
		for (const record of result.body) if (typeof record === "object" && record !== null) body = deepMerge(body, record);
		return success(body);
	};
}
function repeat(parser) {
	return (scanner) => {
		const body = [];
		while (!scanner.eof()) {
			const result = parser(scanner);
			if (!result.ok) break;
			body.push(result.body);
			scanner.nextUntilChar();
		}
		if (body.length === 0) return failure();
		return success(body);
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str)) return failure();
		scanner.next(str.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	scanner.skipWhitespaces();
	const key = scanner.match(BARE_KEY_REGEXP)?.[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = string === "true";
	return success(value$1);
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = INFINITY_MAP.get(string);
	return success(value$1);
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = NaN;
	return success(value$1);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BINARY_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 2);
	return isNaN(number) ? failure() : success(number);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(OCTAL_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 8);
	return isNaN(number) ? failure() : success(number);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(HEX_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 16);
	return isNaN(number) ? failure() : success(number);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INTEGER_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const int = parseInt(value$1, 10);
	return success(int);
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(FLOAT_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$1 = parseFloat(value$1);
	if (isNaN(float$1)) return failure();
	return success(float$1);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(LOCAL_TIME_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({});
	}
	const pairs = surround("{", join$4(pair, ","), "}")(scanner);
	if (!pairs.ok) return failure();
	let table$1 = {};
	for (const pair$1 of pairs.body) table$1 = deepMerge(table$1, pair$1);
	return success(table$1);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary,
	octal,
	hex,
	float,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
function block(scanner) {
	scanner.nextUntilChar();
	const result = merge$1(repeat(pair))(scanner);
	if (result.ok) return success({
		type: "Block",
		value: result.body
	});
	return failure();
}
const tableHeader = surround("[", dottedKey, "]");
function table(scanner) {
	scanner.nextUntilChar();
	const header = tableHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "Table",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
const tableArrayHeader = surround("[[", dottedKey, "]]");
function tableArray(scanner) {
	scanner.nextUntilChar();
	const header = tableArrayHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "TableArray",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
function toml(scanner) {
	const blocks = repeat(or([
		block,
		tableArray,
		table
	]))(scanner);
	if (!blocks.ok) return success({});
	const body = blocks.body.reduce(deepAssign, {});
	return success(body);
}
function createParseErrorMessage(scanner, message) {
	const string = scanner.source.slice(0, scanner.position);
	const lines = string.split("\n");
	const row = lines.length;
	const column = lines.at(-1)?.length ?? 0;
	return `Parse error on line ${row}, column ${column}: ${message}`;
}
function parserFactory(parser) {
	return (tomlString) => {
		const scanner = new Scanner(tomlString);
		try {
			const result = parser(scanner);
			if (result.ok && scanner.eof()) return result.body;
			const message = `Unexpected character: "${scanner.char()}"`;
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		} catch (error) {
			if (error instanceof Error) throw new SyntaxError(createParseErrorMessage(scanner, error.message));
			const message = "Invalid error type caught";
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		}
	};
}

//#endregion
//#region ../node_modules/@std/toml/parse.js
/**
* Parses a {@link https://toml.io | TOML} string into an object.
*
* @example Usage
* ```ts
* import { parse } from "@std/toml/parse";
* import { assertEquals } from "@std/assert";
*
* const tomlString = `title = "TOML Example"
* [owner]
* name = "Alice"
* bio = "Alice is a programmer."`;
*
* const obj = parse(tomlString);
* assertEquals(obj, { title: "TOML Example", owner: { name: "Alice", bio: "Alice is a programmer." } });
* ```
* @param tomlString TOML string to be parsed.
* @returns The parsed JS object.
*/ function parse$2(tomlString) {
	return parserFactory(toml)(tomlString);
}

//#endregion
//#region src/def/rename.ts
var BaseRenameCommand = class extends clipanion.Command {
	static paths = [["rename"]];
	static usage = clipanion.Command.Usage({ description: "Rename the NAPI-RS project" });
	cwd = clipanion.Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = clipanion.Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = clipanion.Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = clipanion.Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	$$name = clipanion.Option.String("--name,-n", { description: "The new name of the project" });
	binaryName = clipanion.Option.String("--binary-name,-b", { description: "The new binary name *.node files" });
	packageName = clipanion.Option.String("--package-name", { description: "The new package name of the project" });
	manifestPath = clipanion.Option.String("--manifest-path", "Cargo.toml", { description: "Path to `Cargo.toml`" });
	repository = clipanion.Option.String("--repository", { description: "The new repository of the project" });
	description = clipanion.Option.String("--description", { description: "The new description of the project" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			name: this.$$name,
			binaryName: this.binaryName,
			packageName: this.packageName,
			manifestPath: this.manifestPath,
			repository: this.repository,
			description: this.description
		};
	}
};
function applyDefaultRenameOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		manifestPath: "Cargo.toml",
		...options
	};
}

//#endregion
//#region src/api/rename.ts
async function renameProject(userOptions) {
	const options = applyDefaultRenameOptions(userOptions);
	const napiConfig = await readConfig(options);
	const oldName = napiConfig.binaryName;
	const packageJsonPath = (0, node_path.resolve)(options.cwd, options.packageJsonPath);
	const cargoTomlPath = (0, node_path.resolve)(options.cwd, options.manifestPath);
	const packageJsonContent = await readFileAsync(packageJsonPath, "utf8");
	const packageJsonData = JSON.parse(packageJsonContent);
	merge_default(packageJsonData, omitBy_default(pick_default(options, [
		"name",
		"description",
		"author",
		"license"
	]), isNil_default), { napi: omitBy_default({
		binaryName: options.binaryName,
		packageName: options.packageName
	}, isNil_default) });
	if (options.configPath) {
		const configPath = (0, node_path.resolve)(options.cwd, options.configPath);
		const configContent = await readFileAsync(configPath, "utf8");
		const configData = JSON.parse(configContent);
		configData.binaryName = options.binaryName;
		configData.packageName = options.packageName;
		await writeFileAsync(configPath, JSON.stringify(configData, null, 2));
	}
	await writeFileAsync(packageJsonPath, JSON.stringify(packageJsonData, null, 2));
	const tomlContent = await readFileAsync(cargoTomlPath, "utf8");
	const cargoToml = parse$2(tomlContent);
	if (cargoToml.package && options.binaryName) {
		const sanitizedName = options.binaryName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
		cargoToml.package.name = sanitizedName;
	}
	const updatedTomlContent = stringify(cargoToml);
	await writeFileAsync(cargoTomlPath, updatedTomlContent);
	if (oldName !== options.binaryName) {
		const githubActionsPath = await (0, find_up.findUp)(".github", {
			cwd: options.cwd,
			type: "directory"
		});
		if (githubActionsPath) {
			const githubActionsCIYmlPath = (0, node_path.join)(githubActionsPath, "workflows", "CI.yml");
			if ((0, node_fs.existsSync)(githubActionsCIYmlPath)) {
				const githubActionsContent = await readFileAsync(githubActionsCIYmlPath, "utf8");
				const githubActionsData = (0, js_yaml.load)(githubActionsContent);
				if (githubActionsData.env?.APP_NAME) {
					githubActionsData.env.APP_NAME = options.binaryName;
					await writeFileAsync(githubActionsCIYmlPath, (0, js_yaml.dump)(githubActionsData, {
						lineWidth: -1,
						noRefs: true,
						sortKeys: false
					}));
				}
			}
		}
		const oldWasiBrowserBindingPath = (0, node_path.join)(options.cwd, `${oldName}.wasi-browser.js`);
		if ((0, node_fs.existsSync)(oldWasiBrowserBindingPath)) await (0, node_fs_promises.rename)(oldWasiBrowserBindingPath, (0, node_path.join)(options.cwd, `${options.binaryName}.wasi-browser.js`));
		const oldWasiBindingPath = (0, node_path.join)(options.cwd, `${oldName}.wasi.cjs`);
		if ((0, node_fs.existsSync)(oldWasiBindingPath)) await (0, node_fs_promises.rename)(oldWasiBindingPath, (0, node_path.join)(options.cwd, `${options.binaryName}.wasi.cjs`));
		const gitAttributesPath = (0, node_path.join)(options.cwd, ".gitattributes");
		if ((0, node_fs.existsSync)(gitAttributesPath)) {
			const gitAttributesContent = await readFileAsync(gitAttributesPath, "utf8");
			const gitAttributesData = gitAttributesContent.split("\n").map((line) => {
				return line.replace(`${oldName}.wasi-browser.js`, `${options.binaryName}.wasi-browser.js`).replace(`${oldName}.wasi.cjs`, `${options.binaryName}.wasi.cjs`);
			}).join("\n");
			await writeFileAsync(gitAttributesPath, gitAttributesData);
		}
	}
}

//#endregion
//#region src/api/new.ts
const debug$4 = debugFactory("new");
const TEMPLATE_REPOS = {
	yarn: "https://github.com/napi-rs/package-template",
	pnpm: "https://github.com/napi-rs/package-template-pnpm"
};
async function checkGitCommand() {
	try {
		await new Promise((resolve$7) => {
			const cp = (0, node_child_process.exec)("git --version");
			cp.on("error", () => {
				resolve$7(false);
			});
			cp.on("exit", (code) => {
				if (code === 0) resolve$7(true);
				else resolve$7(false);
			});
		});
		return true;
	} catch {
		return false;
	}
}
async function ensureCacheDir(packageManager) {
	const cacheDir = node_path.default.join((0, node_os.homedir)(), ".napi-rs", "template", packageManager);
	await mkdirAsync(cacheDir, { recursive: true });
	return cacheDir;
}
async function downloadTemplate(packageManager, cacheDir) {
	const repoUrl = TEMPLATE_REPOS[packageManager];
	const templatePath = node_path.default.join(cacheDir, "repo");
	if ((0, node_fs.existsSync)(templatePath)) {
		debug$4(`Template cache found at ${templatePath}, updating...`);
		try {
			await new Promise((resolve$7, reject) => {
				const cp = (0, node_child_process.exec)("git fetch origin", { cwd: templatePath });
				cp.on("error", reject);
				cp.on("exit", (code) => {
					if (code === 0) resolve$7();
					else reject(/* @__PURE__ */ new Error(`Failed to fetch latest changes, git process exited with code ${code}`));
				});
			});
			(0, node_child_process.execSync)("git reset --hard origin/main", {
				cwd: templatePath,
				stdio: "ignore"
			});
			debug$4("Template updated successfully");
		} catch (error) {
			debug$4(`Failed to update template: ${error}`);
			throw new Error(`Failed to update template from ${repoUrl}: ${error}`);
		}
	} else {
		debug$4(`Cloning template from ${repoUrl}...`);
		try {
			(0, node_child_process.execSync)(`git clone ${repoUrl} repo`, {
				cwd: cacheDir,
				stdio: "inherit"
			});
			debug$4("Template cloned successfully");
		} catch (error) {
			throw new Error(`Failed to clone template from ${repoUrl}: ${error}`);
		}
	}
}
async function copyDirectory(src, dest, includeWasiBindings) {
	await mkdirAsync(dest, { recursive: true });
	const entries = await node_fs.promises.readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = node_path.default.join(src, entry.name);
		const destPath = node_path.default.join(dest, entry.name);
		if (entry.name === ".git") continue;
		if (entry.isDirectory()) await copyDirectory(srcPath, destPath, includeWasiBindings);
		else {
			if (!includeWasiBindings && (entry.name.endsWith(".wasi-browser.js") || entry.name.endsWith(".wasi.cjs") || entry.name.endsWith("wasi-worker.browser.mjs ") || entry.name.endsWith("wasi-worker.mjs") || entry.name.endsWith("browser.js"))) continue;
			await node_fs.promises.copyFile(srcPath, destPath);
		}
	}
}
async function filterTargetsInPackageJson(filePath, enabledTargets) {
	const content = await node_fs.promises.readFile(filePath, "utf-8");
	const packageJson = JSON.parse(content);
	if (packageJson.napi?.targets) packageJson.napi.targets = packageJson.napi.targets.filter((target) => enabledTargets.includes(target));
	await node_fs.promises.writeFile(filePath, JSON.stringify(packageJson, null, 2) + "\n");
}
async function filterTargetsInGithubActions(filePath, enabledTargets) {
	const content = await node_fs.promises.readFile(filePath, "utf-8");
	const yaml = (0, js_yaml.load)(content);
	const macOSAndWindowsTargets = new Set([
		"x86_64-pc-windows-msvc",
		"aarch64-pc-windows-msvc",
		"x86_64-apple-darwin"
	]);
	const linuxTargets = new Set([
		"x86_64-unknown-linux-gnu",
		"x86_64-unknown-linux-musl",
		"aarch64-unknown-linux-gnu",
		"aarch64-unknown-linux-musl",
		"armv7-unknown-linux-gnueabihf",
		"armv7-unknown-linux-musleabihf",
		"riscv64gc-unknown-linux-gnu",
		"powerpc64le-unknown-linux-gnu",
		"s390x-unknown-linux-gnu",
		"aarch64-linux-android",
		"armv7-linux-androideabi"
	]);
	const hasLinuxTargets = enabledTargets.some((target) => linuxTargets.has(target));
	if (yaml?.jobs?.build?.strategy?.matrix?.settings) yaml.jobs.build.strategy.matrix.settings = yaml.jobs.build.strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	const jobsToRemove = [];
	if (enabledTargets.every((target) => !macOSAndWindowsTargets.has(target))) jobsToRemove.push("test-macOS-windows-binding");
	else if (yaml?.jobs?.["test-macOS-windows-binding"]?.strategy?.matrix?.settings) yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings = yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	if (!hasLinuxTargets) {
		if (yaml?.jobs?.["test-linux-binding"]) jobsToRemove.push("test-linux-binding");
	} else if (yaml?.jobs?.["test-linux-binding"]?.strategy?.matrix?.target) yaml.jobs["test-linux-binding"].strategy.matrix.target = yaml.jobs["test-linux-binding"].strategy.matrix.target.filter((target) => {
		if (target) return enabledTargets.includes(target);
		return true;
	});
	if (!enabledTargets.includes("wasm32-wasip1-threads")) jobsToRemove.push("test-wasi");
	if (!enabledTargets.includes("x86_64-unknown-freebsd")) jobsToRemove.push("build-freebsd");
	for (const [jobName, jobConfig] of Object.entries(yaml.jobs || {})) if (jobName.startsWith("test-") && jobName !== "test-macOS-windows-binding" && jobName !== "test-linux-x64-gnu-binding") {
		const job = jobConfig;
		if (job.strategy?.matrix?.settings?.[0]?.target) {
			const target = job.strategy.matrix.settings[0].target;
			if (!enabledTargets.includes(target)) jobsToRemove.push(jobName);
		}
	}
	for (const jobName of jobsToRemove) delete yaml.jobs[jobName];
	if (Array.isArray(yaml.jobs?.publish?.needs)) yaml.jobs.publish.needs = yaml.jobs.publish.needs.filter((need) => !jobsToRemove.includes(need));
	const updatedYaml = (0, js_yaml.dump)(yaml, {
		lineWidth: -1,
		noRefs: true,
		sortKeys: false
	});
	await node_fs.promises.writeFile(filePath, updatedYaml);
}
function processOptions(options) {
	debug$4("Processing options...");
	if (!options.path) throw new Error("Please provide the path as the argument");
	options.path = node_path.default.resolve(process.cwd(), options.path);
	debug$4(`Resolved target path to: ${options.path}`);
	if (!options.name) {
		options.name = node_path.default.parse(options.path).base;
		debug$4(`No project name provided, fix it to dir name: ${options.name}`);
	}
	if (!options.targets?.length) if (options.enableAllTargets) {
		options.targets = AVAILABLE_TARGETS.concat();
		debug$4("Enable all targets");
	} else if (options.enableDefaultTargets) {
		options.targets = DEFAULT_TARGETS.concat();
		debug$4("Enable default targets");
	} else throw new Error("At least one target must be enabled");
	if (options.targets.some((target) => target === "wasm32-wasi-preview1-threads")) {
		const out = (0, node_child_process.execSync)(`rustup target list`, { encoding: "utf8" });
		if (out.includes("wasm32-wasip1-threads")) options.targets = options.targets.map((target) => target === "wasm32-wasi-preview1-threads" ? "wasm32-wasip1-threads" : target);
	}
	return applyDefaultNewOptions(options);
}
async function newProject(userOptions) {
	debug$4("Will create napi-rs project with given options:");
	debug$4(userOptions);
	const options = processOptions(userOptions);
	debug$4("Targets to be enabled:");
	debug$4(options.targets);
	if (!await checkGitCommand()) throw new Error("Git is not installed or not available in PATH. Please install Git to continue.");
	const packageManager = options.packageManager;
	await ensurePath(options.path, options.dryRun);
	if (!options.dryRun) try {
		const cacheDir = await ensureCacheDir(packageManager);
		await downloadTemplate(packageManager, cacheDir);
		const templatePath = node_path.default.join(cacheDir, "repo");
		await copyDirectory(templatePath, options.path, options.targets.includes("wasm32-wasip1-threads"));
		await renameProject({
			cwd: options.path,
			name: options.name,
			binaryName: getBinaryName(options.name)
		});
		const packageJsonPath = node_path.default.join(options.path, "package.json");
		if ((0, node_fs.existsSync)(packageJsonPath)) await filterTargetsInPackageJson(packageJsonPath, options.targets);
		const ciPath = node_path.default.join(options.path, ".github", "workflows", "CI.yml");
		if ((0, node_fs.existsSync)(ciPath) && options.enableGithubActions) await filterTargetsInGithubActions(ciPath, options.targets);
		else if (!options.enableGithubActions && (0, node_fs.existsSync)(node_path.default.join(options.path, ".github"))) await node_fs.promises.rm(node_path.default.join(options.path, ".github"), {
			recursive: true,
			force: true
		});
		const pkgJsonContent = await node_fs.promises.readFile(packageJsonPath, "utf-8");
		const pkgJson = JSON.parse(pkgJsonContent);
		if (!pkgJson.engines) pkgJson.engines = {};
		pkgJson.engines.node = napiEngineRequirement(options.minNodeApiVersion);
		if (options.license && pkgJson.license !== options.license) pkgJson.license = options.license;
		if (options.testFramework !== "ava") debug$4(`Test framework ${options.testFramework} requested but not yet implemented`);
		await node_fs.promises.writeFile(packageJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
	} catch (error) {
		throw new Error(`Failed to create project: ${error}`);
	}
	debug$4(`Project created at: ${options.path}`);
}
async function ensurePath(path$1, dryRun = false) {
	const stat$1 = await statAsync(path$1, {}).catch(() => void 0);
	if (stat$1) {
		if (stat$1.isFile()) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not a directory.`);
		else if (stat$1.isDirectory()) {
			const files$1 = await readdirAsync(path$1);
			if (files$1.length) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not empty.`);
		}
	}
	if (!dryRun) try {
		debug$4(`Try to create target directory: ${path$1}`);
		if (!dryRun) await mkdirAsync(path$1, { recursive: true });
	} catch (e) {
		throw new Error(`Failed to create target directory: ${path$1}`, { cause: e });
	}
}
function getBinaryName(name$1) {
	return name$1.split("/").pop();
}

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/universal-user-agent/index.js
function getUserAgent() {
	if (typeof navigator === "object" && "userAgent" in navigator) return navigator.userAgent;
	if (typeof process === "object" && process.version !== void 0) return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
	return "<environment undetectable>";
}

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/before-after-hook/lib/register.js
function register(state, name$1, method, options) {
	if (typeof method !== "function") throw new Error("method for before hook must be a function");
	if (!options) options = {};
	if (Array.isArray(name$1)) return name$1.reverse().reduce((callback, name$2) => {
		return register.bind(null, state, name$2, callback, options);
	}, method)();
	return Promise.resolve().then(() => {
		if (!state.registry[name$1]) return method(options);
		return state.registry[name$1].reduce((method$1, registered) => {
			return registered.hook.bind(null, method$1, options);
		}, method)();
	});
}

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name$1, hook$1) {
	const orig = hook$1;
	if (!state.registry[name$1]) state.registry[name$1] = [];
	if (kind === "before") hook$1 = (method, options) => {
		return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
	};
	if (kind === "after") hook$1 = (method, options) => {
		let result;
		return Promise.resolve().then(method.bind(null, options)).then((result_) => {
			result = result_;
			return orig(result, options);
		}).then(() => {
			return result;
		});
	};
	if (kind === "error") hook$1 = (method, options) => {
		return Promise.resolve().then(method.bind(null, options)).catch((error) => {
			return orig(error, options);
		});
	};
	state.registry[name$1].push({
		hook: hook$1,
		orig
	});
}

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/before-after-hook/lib/remove.js
function removeHook(state, name$1, method) {
	if (!state.registry[name$1]) return;
	const index = state.registry[name$1].map((registered) => {
		return registered.orig;
	}).indexOf(method);
	if (index === -1) return;
	state.registry[name$1].splice(index, 1);
}

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/before-after-hook/index.js
const bind = Function.bind;
const bindable = bind.bind(bind);
function bindApi(hook$1, state, name$1) {
	const removeHookRef = bindable(removeHook, null).apply(null, name$1 ? [state, name$1] : [state]);
	hook$1.api = { remove: removeHookRef };
	hook$1.remove = removeHookRef;
	[
		"before",
		"error",
		"after",
		"wrap"
	].forEach((kind) => {
		const args = name$1 ? [
			state,
			kind,
			name$1
		] : [state, kind];
		hook$1[kind] = hook$1.api[kind] = bindable(addHook, null).apply(null, args);
	});
}
function Singular() {
	const singularHookName = Symbol("Singular");
	const singularHookState = { registry: {} };
	const singularHook = register.bind(null, singularHookState, singularHookName);
	bindApi(singularHook, singularHookState, singularHookName);
	return singularHook;
}
function Collection() {
	const state = { registry: {} };
	const hook$1 = register.bind(null, state);
	bindApi(hook$1, state);
	return hook$1;
}
var before_after_hook_default = {
	Singular,
	Collection
};

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION$7 = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION$7} ${getUserAgent()}`;
var DEFAULTS = {
	method: "GET",
	baseUrl: "https://api.github.com",
	headers: {
		accept: "application/vnd.github.v3+json",
		"user-agent": userAgent
	},
	mediaType: { format: "" }
};
function lowercaseKeys(object) {
	if (!object) return {};
	return Object.keys(object).reduce((newObj, key) => {
		newObj[key.toLowerCase()] = object[key];
		return newObj;
	}, {});
}
function isPlainObject$1(value$1) {
	if (typeof value$1 !== "object" || value$1 === null) return false;
	if (Object.prototype.toString.call(value$1) !== "[object Object]") return false;
	const proto = Object.getPrototypeOf(value$1);
	if (proto === null) return true;
	const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
	return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value$1);
}
function mergeDeep(defaults, options) {
	const result = Object.assign({}, defaults);
	Object.keys(options).forEach((key) => {
		if (isPlainObject$1(options[key])) if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
		else result[key] = mergeDeep(defaults[key], options[key]);
		else Object.assign(result, { [key]: options[key] });
	});
	return result;
}
function removeUndefinedProperties(obj) {
	for (const key in obj) if (obj[key] === void 0) delete obj[key];
	return obj;
}
function merge(defaults, route, options) {
	if (typeof route === "string") {
		let [method, url] = route.split(" ");
		options = Object.assign(url ? {
			method,
			url
		} : { url: method }, options);
	} else options = Object.assign({}, route);
	options.headers = lowercaseKeys(options.headers);
	removeUndefinedProperties(options);
	removeUndefinedProperties(options.headers);
	const mergedOptions = mergeDeep(defaults || {}, options);
	if (options.url === "/graphql") {
		if (defaults && defaults.mediaType.previews?.length) mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
		mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
	}
	return mergedOptions;
}
function addQueryParameters(url, parameters) {
	const separator = /\?/.test(url) ? "&" : "?";
	const names = Object.keys(parameters);
	if (names.length === 0) return url;
	return url + separator + names.map((name$1) => {
		if (name$1 === "q") return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
		return `${name$1}=${encodeURIComponent(parameters[name$1])}`;
	}).join("&");
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
	return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
	const matches = url.match(urlVariableRegex);
	if (!matches) return [];
	return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
	const result = { __proto__: null };
	for (const key of Object.keys(object)) if (keysToOmit.indexOf(key) === -1) result[key] = object[key];
	return result;
}
function encodeReserved(str) {
	return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
		if (!/%[0-9A-Fa-f]/.test(part)) part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
		return part;
	}).join("");
}
function encodeUnreserved(str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
		return "%" + c.charCodeAt(0).toString(16).toUpperCase();
	});
}
function encodeValue(operator, value$1, key) {
	value$1 = operator === "+" || operator === "#" ? encodeReserved(value$1) : encodeUnreserved(value$1);
	if (key) return encodeUnreserved(key) + "=" + value$1;
	else return value$1;
}
function isDefined(value$1) {
	return value$1 !== void 0 && value$1 !== null;
}
function isKeyOperator(operator) {
	return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
	var value$1 = context[key], result = [];
	if (isDefined(value$1) && value$1 !== "") if (typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean") {
		value$1 = value$1.toString();
		if (modifier && modifier !== "*") value$1 = value$1.substring(0, parseInt(modifier, 10));
		result.push(encodeValue(operator, value$1, isKeyOperator(operator) ? key : ""));
	} else if (modifier === "*") if (Array.isArray(value$1)) value$1.filter(isDefined).forEach(function(value2) {
		result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
	});
	else Object.keys(value$1).forEach(function(k) {
		if (isDefined(value$1[k])) result.push(encodeValue(operator, value$1[k], k));
	});
	else {
		const tmp = [];
		if (Array.isArray(value$1)) value$1.filter(isDefined).forEach(function(value2) {
			tmp.push(encodeValue(operator, value2));
		});
		else Object.keys(value$1).forEach(function(k) {
			if (isDefined(value$1[k])) {
				tmp.push(encodeUnreserved(k));
				tmp.push(encodeValue(operator, value$1[k].toString()));
			}
		});
		if (isKeyOperator(operator)) result.push(encodeUnreserved(key) + "=" + tmp.join(","));
		else if (tmp.length !== 0) result.push(tmp.join(","));
	}
	else if (operator === ";") {
		if (isDefined(value$1)) result.push(encodeUnreserved(key));
	} else if (value$1 === "" && (operator === "&" || operator === "?")) result.push(encodeUnreserved(key) + "=");
	else if (value$1 === "") result.push("");
	return result;
}
function parseUrl(template) {
	return { expand: expand.bind(null, template) };
}
function expand(template, context) {
	var operators = [
		"+",
		"#",
		".",
		"/",
		";",
		"?",
		"&"
	];
	template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
		if (expression) {
			let operator = "";
			const values = [];
			if (operators.indexOf(expression.charAt(0)) !== -1) {
				operator = expression.charAt(0);
				expression = expression.substr(1);
			}
			expression.split(/,/g).forEach(function(variable) {
				var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
				values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
			});
			if (operator && operator !== "+") {
				var separator = ",";
				if (operator === "?") separator = "&";
				else if (operator !== "#") separator = operator;
				return (values.length !== 0 ? operator : "") + values.join(separator);
			} else return values.join(",");
		} else return encodeReserved(literal);
	});
	if (template === "/") return template;
	else return template.replace(/\/$/, "");
}
function parse$1(options) {
	let method = options.method.toUpperCase();
	let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
	let headers = Object.assign({}, options.headers);
	let body;
	let parameters = omit(options, [
		"method",
		"baseUrl",
		"url",
		"headers",
		"request",
		"mediaType"
	]);
	const urlVariableNames = extractUrlVariableNames(url);
	url = parseUrl(url).expand(parameters);
	if (!/^http/.test(url)) url = options.baseUrl + url;
	const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
	const remainingParameters = omit(parameters, omittedParameters);
	const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
	if (!isBinaryRequest) {
		if (options.mediaType.format) headers.accept = headers.accept.split(/,/).map((format) => format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
		if (url.endsWith("/graphql")) {
			if (options.mediaType.previews?.length) {
				const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
				headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
					const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
					return `application/vnd.github.${preview}-preview${format}`;
				}).join(",");
			}
		}
	}
	if (["GET", "HEAD"].includes(method)) url = addQueryParameters(url, remainingParameters);
	else if ("data" in remainingParameters) body = remainingParameters.data;
	else if (Object.keys(remainingParameters).length) body = remainingParameters;
	if (!headers["content-type"] && typeof body !== "undefined") headers["content-type"] = "application/json; charset=utf-8";
	if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") body = "";
	return Object.assign({
		method,
		url,
		headers
	}, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
	return parse$1(merge(defaults, route, options));
}
function withDefaults$2(oldDefaults, newDefaults) {
	const DEFAULTS2 = merge(oldDefaults, newDefaults);
	const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
	return Object.assign(endpoint2, {
		DEFAULTS: DEFAULTS2,
		defaults: withDefaults$2.bind(null, DEFAULTS2),
		merge: merge.bind(null, DEFAULTS2),
		parse: parse$1
	});
}
var endpoint = withDefaults$2(null, DEFAULTS);

//#endregion
//#region ../node_modules/fast-content-type-parse/index.js
var require_fast_content_type_parse = __commonJS({ "../node_modules/fast-content-type-parse/index.js"(exports, module) {
	const NullObject = function NullObject$1() {};
	NullObject.prototype = Object.create(null);
	/**
	* RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	*
	* parameter     = token "=" ( token / quoted-string )
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	* quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	* qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	* obs-text      = %x80-FF
	* quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	*/
	const paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
	/**
	* RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	*
	* quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	* obs-text    = %x80-FF
	*/
	const quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
	/**
	* RegExp to match type in RFC 7231 sec 3.1.1.1
	*
	* media-type = type "/" subtype
	* type       = token
	* subtype    = token
	*/
	const mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
	const defaultContentType = {
		type: "",
		parameters: new NullObject()
	};
	Object.freeze(defaultContentType.parameters);
	Object.freeze(defaultContentType);
	/**
	* Parse media type to object.
	*
	* @param {string|object} header
	* @return {Object}
	* @public
	*/
	function parse(header) {
		if (typeof header !== "string") throw new TypeError("argument header is required and must be a string");
		let index = header.indexOf(";");
		const type$1 = index !== -1 ? header.slice(0, index).trim() : header.trim();
		if (mediaTypeRE.test(type$1) === false) throw new TypeError("invalid media type");
		const result = {
			type: type$1.toLowerCase(),
			parameters: new NullObject()
		};
		if (index === -1) return result;
		let key;
		let match;
		let value$1;
		paramRE.lastIndex = index;
		while (match = paramRE.exec(header)) {
			if (match.index !== index) throw new TypeError("invalid parameter format");
			index += match[0].length;
			key = match[1].toLowerCase();
			value$1 = match[2];
			if (value$1[0] === "\"") {
				value$1 = value$1.slice(1, value$1.length - 1);
				quotedPairRE.test(value$1) && (value$1 = value$1.replace(quotedPairRE, "$1"));
			}
			result.parameters[key] = value$1;
		}
		if (index !== header.length) throw new TypeError("invalid parameter format");
		return result;
	}
	function safeParse$1(header) {
		if (typeof header !== "string") return defaultContentType;
		let index = header.indexOf(";");
		const type$1 = index !== -1 ? header.slice(0, index).trim() : header.trim();
		if (mediaTypeRE.test(type$1) === false) return defaultContentType;
		const result = {
			type: type$1.toLowerCase(),
			parameters: new NullObject()
		};
		if (index === -1) return result;
		let key;
		let match;
		let value$1;
		paramRE.lastIndex = index;
		while (match = paramRE.exec(header)) {
			if (match.index !== index) return defaultContentType;
			index += match[0].length;
			key = match[1].toLowerCase();
			value$1 = match[2];
			if (value$1[0] === "\"") {
				value$1 = value$1.slice(1, value$1.length - 1);
				quotedPairRE.test(value$1) && (value$1 = value$1.replace(quotedPairRE, "$1"));
			}
			result.parameters[key] = value$1;
		}
		if (index !== header.length) return defaultContentType;
		return result;
	}
	module.exports.default = {
		parse,
		safeParse: safeParse$1
	};
	module.exports.parse = parse;
	module.exports.safeParse = safeParse$1;
	module.exports.defaultContentType = defaultContentType;
} });

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
	name;
	/**
	* http status code
	*/
	status;
	/**
	* Request options that lead to the error.
	*/
	request;
	/**
	* Response object if a response was received
	*/
	response;
	constructor(message, statusCode, options) {
		super(message);
		this.name = "HttpError";
		this.status = Number.parseInt(statusCode);
		if (Number.isNaN(this.status)) this.status = 0;
		if ("response" in options) this.response = options.response;
		const requestCopy = Object.assign({}, options.request);
		if (options.request.headers.authorization) requestCopy.headers = Object.assign({}, options.request.headers, { authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]") });
		requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
		this.request = requestCopy;
	}
};

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/request/dist-bundle/index.js
var import_fast_content_type_parse = __toESM(require_fast_content_type_parse(), 1);
var VERSION$6 = "10.0.3";
var defaults_default = { headers: { "user-agent": `octokit-request.js/${VERSION$6} ${getUserAgent()}` } };
function isPlainObject(value$1) {
	if (typeof value$1 !== "object" || value$1 === null) return false;
	if (Object.prototype.toString.call(value$1) !== "[object Object]") return false;
	const proto = Object.getPrototypeOf(value$1);
	if (proto === null) return true;
	const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
	return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value$1);
}
async function fetchWrapper(requestOptions) {
	const fetch$1 = requestOptions.request?.fetch || globalThis.fetch;
	if (!fetch$1) throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
	const log = requestOptions.request?.log || console;
	const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
	const body = isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
	const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name$1, value$1]) => [name$1, String(value$1)]));
	let fetchResponse;
	try {
		fetchResponse = await fetch$1(requestOptions.url, {
			method: requestOptions.method,
			body,
			redirect: requestOptions.request?.redirect,
			headers: requestHeaders,
			signal: requestOptions.request?.signal,
			...requestOptions.body && { duplex: "half" }
		});
	} catch (error) {
		let message = "Unknown Error";
		if (error instanceof Error) {
			if (error.name === "AbortError") {
				error.status = 500;
				throw error;
			}
			message = error.message;
			if (error.name === "TypeError" && "cause" in error) {
				if (error.cause instanceof Error) message = error.cause.message;
				else if (typeof error.cause === "string") message = error.cause;
			}
		}
		const requestError = new RequestError(message, 500, { request: requestOptions });
		requestError.cause = error;
		throw requestError;
	}
	const status = fetchResponse.status;
	const url = fetchResponse.url;
	const responseHeaders = {};
	for (const [key, value$1] of fetchResponse.headers) responseHeaders[key] = value$1;
	const octokitResponse = {
		url,
		status,
		headers: responseHeaders,
		data: ""
	};
	if ("deprecation" in responseHeaders) {
		const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
		const deprecationLink = matches && matches.pop();
		log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
	}
	if (status === 204 || status === 205) return octokitResponse;
	if (requestOptions.method === "HEAD") {
		if (status < 400) return octokitResponse;
		throw new RequestError(fetchResponse.statusText, status, {
			response: octokitResponse,
			request: requestOptions
		});
	}
	if (status === 304) {
		octokitResponse.data = await getResponseData(fetchResponse);
		throw new RequestError("Not modified", status, {
			response: octokitResponse,
			request: requestOptions
		});
	}
	if (status >= 400) {
		octokitResponse.data = await getResponseData(fetchResponse);
		throw new RequestError(toErrorMessage(octokitResponse.data), status, {
			response: octokitResponse,
			request: requestOptions
		});
	}
	octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
	return octokitResponse;
}
async function getResponseData(response) {
	const contentType = response.headers.get("content-type");
	if (!contentType) return response.text().catch(() => "");
	const mimetype = (0, import_fast_content_type_parse.safeParse)(contentType);
	if (isJSONResponse(mimetype)) {
		let text = "";
		try {
			text = await response.text();
			return JSON.parse(text);
		} catch (err) {
			return text;
		}
	} else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") return response.text().catch(() => "");
	else return response.arrayBuffer().catch(() => /* @__PURE__ */ new ArrayBuffer(0));
}
function isJSONResponse(mimetype) {
	return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
	if (typeof data === "string") return data;
	if (data instanceof ArrayBuffer) return "Unknown error";
	if ("message" in data) {
		const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
		return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(", ")}${suffix}` : `${data.message}${suffix}`;
	}
	return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults$1(oldEndpoint, newDefaults) {
	const endpoint2 = oldEndpoint.defaults(newDefaults);
	const newApi = function(route, parameters) {
		const endpointOptions = endpoint2.merge(route, parameters);
		if (!endpointOptions.request || !endpointOptions.request.hook) return fetchWrapper(endpoint2.parse(endpointOptions));
		const request2 = (route2, parameters2) => {
			return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
		};
		Object.assign(request2, {
			endpoint: endpoint2,
			defaults: withDefaults$1.bind(null, endpoint2)
		});
		return endpointOptions.request.hook(request2, endpointOptions);
	};
	return Object.assign(newApi, {
		endpoint: endpoint2,
		defaults: withDefaults$1.bind(null, endpoint2)
	});
}
var request = withDefaults$1(endpoint, defaults_default);

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION$5 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
	return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
	constructor(request2, headers, response) {
		super(_buildMessageForResponseErrors(response));
		this.request = request2;
		this.headers = headers;
		this.response = response;
		this.errors = response.errors;
		this.data = response.data;
		if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
	}
	name = "GraphqlResponseError";
	errors;
	data;
};
var NON_VARIABLE_OPTIONS = [
	"method",
	"baseUrl",
	"url",
	"headers",
	"request",
	"query",
	"mediaType",
	"operationName"
];
var FORBIDDEN_VARIABLE_OPTIONS = [
	"query",
	"method",
	"url"
];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
	if (options) {
		if (typeof query === "string" && "query" in options) return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
		for (const key in options) {
			if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
			return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
		}
	}
	const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
	const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
		if (NON_VARIABLE_OPTIONS.includes(key)) {
			result[key] = parsedOptions[key];
			return result;
		}
		if (!result.variables) result.variables = {};
		result.variables[key] = parsedOptions[key];
		return result;
	}, {});
	const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
	if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
	return request2(requestOptions).then((response) => {
		if (response.data.errors) {
			const headers = {};
			for (const key of Object.keys(response.headers)) headers[key] = response.headers[key];
			throw new GraphqlResponseError(requestOptions, headers, response.data);
		}
		return response.data.data;
	});
}
function withDefaults(request2, newDefaults) {
	const newRequest = request2.defaults(newDefaults);
	const newApi = (query, options) => {
		return graphql(newRequest, query, options);
	};
	return Object.assign(newApi, {
		defaults: withDefaults.bind(null, newRequest),
		endpoint: newRequest.endpoint
	});
}
var graphql2 = withDefaults(request, {
	headers: { "user-agent": `octokit-graphql.js/${VERSION$5} ${getUserAgent()}` },
	method: "POST",
	url: "/graphql"
});
function withCustomRequest(customRequest) {
	return withDefaults(customRequest, {
		method: "POST",
		url: "/graphql"
	});
}

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/auth-token/dist-bundle/index.js
var b64url = "(?:[a-zA-Z0-9_-]+)";
var sep = "\\.";
var jwtRE = /* @__PURE__ */ new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
async function auth(token) {
	const isApp = isJWT(token);
	const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
	const isUserToServer = token.startsWith("ghu_");
	const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
	return {
		type: "token",
		token,
		tokenType
	};
}
function withAuthorizationPrefix(token) {
	if (token.split(/\./).length === 3) return `bearer ${token}`;
	return `token ${token}`;
}
async function hook(token, request$1, route, parameters) {
	const endpoint$1 = request$1.endpoint.merge(route, parameters);
	endpoint$1.headers.authorization = withAuthorizationPrefix(token);
	return request$1(endpoint$1);
}
var createTokenAuth = function createTokenAuth2(token) {
	if (!token) throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
	if (typeof token !== "string") throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
	token = token.replace(/^(token|bearer) +/i, "");
	return Object.assign(auth.bind(null, token), { hook: hook.bind(null, token) });
};

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/core/dist-src/version.js
const VERSION$4 = "7.0.3";

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/core/dist-src/index.js
const noop = () => {};
const consoleWarn = console.warn.bind(console);
const consoleError = console.error.bind(console);
function createLogger(logger = {}) {
	if (typeof logger.debug !== "function") logger.debug = noop;
	if (typeof logger.info !== "function") logger.info = noop;
	if (typeof logger.warn !== "function") logger.warn = consoleWarn;
	if (typeof logger.error !== "function") logger.error = consoleError;
	return logger;
}
const userAgentTrail = `octokit-core.js/${VERSION$4} ${getUserAgent()}`;
var Octokit$1 = class {
	static VERSION = VERSION$4;
	static defaults(defaults) {
		const OctokitWithDefaults = class extends this {
			constructor(...args) {
				const options = args[0] || {};
				if (typeof defaults === "function") {
					super(defaults(options));
					return;
				}
				super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? { userAgent: `${options.userAgent} ${defaults.userAgent}` } : null));
			}
		};
		return OctokitWithDefaults;
	}
	static plugins = [];
	/**
	* Attach a plugin (or many) to your Octokit instance.
	*
	* @example
	* const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
	*/
	static plugin(...newPlugins) {
		const currentPlugins = this.plugins;
		const NewOctokit = class extends this {
			static plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
		};
		return NewOctokit;
	}
	constructor(options = {}) {
		const hook$1 = new before_after_hook_default.Collection();
		const requestDefaults = {
			baseUrl: request.endpoint.DEFAULTS.baseUrl,
			headers: {},
			request: Object.assign({}, options.request, { hook: hook$1.bind(null, "request") }),
			mediaType: {
				previews: [],
				format: ""
			}
		};
		requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
		if (options.baseUrl) requestDefaults.baseUrl = options.baseUrl;
		if (options.previews) requestDefaults.mediaType.previews = options.previews;
		if (options.timeZone) requestDefaults.headers["time-zone"] = options.timeZone;
		this.request = request.defaults(requestDefaults);
		this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
		this.log = createLogger(options.log);
		this.hook = hook$1;
		if (!options.authStrategy) if (!options.auth) this.auth = async () => ({ type: "unauthenticated" });
		else {
			const auth$1 = createTokenAuth(options.auth);
			hook$1.wrap("request", auth$1.hook);
			this.auth = auth$1;
		}
		else {
			const { authStrategy,...otherOptions } = options;
			const auth$1 = authStrategy(Object.assign({
				request: this.request,
				log: this.log,
				octokit: this,
				octokitOptions: otherOptions
			}, options.auth));
			hook$1.wrap("request", auth$1.hook);
			this.auth = auth$1;
		}
		const classConstructor = this.constructor;
		for (let i = 0; i < classConstructor.plugins.length; ++i) Object.assign(this, classConstructor.plugins[i](this, options));
	}
	request;
	graphql;
	log;
	hook;
	auth;
};

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/plugin-request-log/dist-src/version.js
const VERSION$3 = "6.0.0";

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit) {
	octokit.hook.wrap("request", (request$1, options) => {
		octokit.log.debug("request", options);
		const start = Date.now();
		const requestOptions = octokit.request.endpoint.parse(options);
		const path$1 = requestOptions.url.replace(options.baseUrl, "");
		return request$1(options).then((response) => {
			const requestId = response.headers["x-github-request-id"];
			octokit.log.info(`${requestOptions.method} ${path$1} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`);
			return response;
		}).catch((error) => {
			const requestId = error.response?.headers["x-github-request-id"] || "UNKNOWN";
			octokit.log.error(`${requestOptions.method} ${path$1} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`);
			throw error;
		});
	});
}
requestLog.VERSION = VERSION$3;

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js
var VERSION$2 = "0.0.0-development";
function normalizePaginatedListResponse(response) {
	if (!response.data) return {
		...response,
		data: []
	};
	const responseNeedsNormalization = ("total_count" in response.data || "total_commits" in response.data) && !("url" in response.data);
	if (!responseNeedsNormalization) return response;
	const incompleteResults = response.data.incomplete_results;
	const repositorySelection = response.data.repository_selection;
	const totalCount = response.data.total_count;
	const totalCommits = response.data.total_commits;
	delete response.data.incomplete_results;
	delete response.data.repository_selection;
	delete response.data.total_count;
	delete response.data.total_commits;
	const namespaceKey = Object.keys(response.data)[0];
	const data = response.data[namespaceKey];
	response.data = data;
	if (typeof incompleteResults !== "undefined") response.data.incomplete_results = incompleteResults;
	if (typeof repositorySelection !== "undefined") response.data.repository_selection = repositorySelection;
	response.data.total_count = totalCount;
	response.data.total_commits = totalCommits;
	return response;
}
function iterator(octokit, route, parameters) {
	const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
	const requestMethod = typeof route === "function" ? route : octokit.request;
	const method = options.method;
	const headers = options.headers;
	let url = options.url;
	return { [Symbol.asyncIterator]: () => ({ async next() {
		if (!url) return { done: true };
		try {
			const response = await requestMethod({
				method,
				url,
				headers
			});
			const normalizedResponse = normalizePaginatedListResponse(response);
			url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
			if (!url && "total_commits" in normalizedResponse.data) {
				const parsedUrl = new URL(normalizedResponse.url);
				const params = parsedUrl.searchParams;
				const page = parseInt(params.get("page") || "1", 10);
				const per_page = parseInt(params.get("per_page") || "250", 10);
				if (page * per_page < normalizedResponse.data.total_commits) {
					params.set("page", String(page + 1));
					url = parsedUrl.toString();
				}
			}
			return { value: normalizedResponse };
		} catch (error) {
			if (error.status !== 409) throw error;
			url = "";
			return { value: {
				status: 200,
				headers: {},
				data: []
			} };
		}
	} }) };
}
function paginate(octokit, route, parameters, mapFn) {
	if (typeof parameters === "function") {
		mapFn = parameters;
		parameters = void 0;
	}
	return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator2, mapFn) {
	return iterator2.next().then((result) => {
		if (result.done) return results;
		let earlyExit = false;
		function done() {
			earlyExit = true;
		}
		results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
		if (earlyExit) return results;
		return gather(octokit, results, iterator2, mapFn);
	});
}
var composePaginateRest = Object.assign(paginate, { iterator });
function paginateRest(octokit) {
	return { paginate: Object.assign(paginate.bind(null, octokit), { iterator: iterator.bind(null, octokit) }) };
}
paginateRest.VERSION = VERSION$2;

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
const VERSION$1 = "16.0.0";

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
const Endpoints = {
	actions: {
		addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
		addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
		addRepoAccessToSelfHostedRunnerGroupInOrg: ["PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"],
		addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
		addSelectedRepoToOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
		approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
		cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
		createEnvironmentVariable: ["POST /repos/{owner}/{repo}/environments/{environment_name}/variables"],
		createHostedRunnerForOrg: ["POST /orgs/{org}/actions/hosted-runners"],
		createOrUpdateEnvironmentSecret: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"],
		createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
		createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
		createOrgVariable: ["POST /orgs/{org}/actions/variables"],
		createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
		createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
		createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
		createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
		createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
		createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
		deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
		deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
		deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
		deleteEnvironmentSecret: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"],
		deleteEnvironmentVariable: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"],
		deleteHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"],
		deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
		deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
		deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
		deleteRepoVariable: ["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],
		deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
		deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
		deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
		deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
		disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
		disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
		downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
		downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
		downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
		downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
		enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
		enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
		forceCancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],
		generateRunnerJitconfigForOrg: ["POST /orgs/{org}/actions/runners/generate-jitconfig"],
		generateRunnerJitconfigForRepo: ["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],
		getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
		getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
		getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
		getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
		getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
		getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
		getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
		getCustomOidcSubClaimForRepo: ["GET /repos/{owner}/{repo}/actions/oidc/customization/sub"],
		getEnvironmentPublicKey: ["GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"],
		getEnvironmentSecret: ["GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"],
		getEnvironmentVariable: ["GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"],
		getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
		getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
		getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
		getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
		getHostedRunnerForOrg: ["GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"],
		getHostedRunnersGithubOwnedImagesForOrg: ["GET /orgs/{org}/actions/hosted-runners/images/github-owned"],
		getHostedRunnersLimitsForOrg: ["GET /orgs/{org}/actions/hosted-runners/limits"],
		getHostedRunnersMachineSpecsForOrg: ["GET /orgs/{org}/actions/hosted-runners/machine-sizes"],
		getHostedRunnersPartnerImagesForOrg: ["GET /orgs/{org}/actions/hosted-runners/images/partner"],
		getHostedRunnersPlatformsForOrg: ["GET /orgs/{org}/actions/hosted-runners/platforms"],
		getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
		getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
		getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
		getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
		getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
		getRepoPermissions: [
			"GET /repos/{owner}/{repo}/actions/permissions",
			{},
			{ renamed: ["actions", "getGithubActionsPermissionsRepository"] }
		],
		getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
		getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
		getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
		getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
		getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
		getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
		getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
		getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
		getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
		getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
		getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
		getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
		listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
		listEnvironmentSecrets: ["GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"],
		listEnvironmentVariables: ["GET /repos/{owner}/{repo}/environments/{environment_name}/variables"],
		listGithubHostedRunnersInGroupForOrg: ["GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"],
		listHostedRunnersForOrg: ["GET /orgs/{org}/actions/hosted-runners"],
		listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
		listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
		listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
		listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
		listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
		listOrgVariables: ["GET /orgs/{org}/actions/variables"],
		listRepoOrganizationSecrets: ["GET /repos/{owner}/{repo}/actions/organization-secrets"],
		listRepoOrganizationVariables: ["GET /repos/{owner}/{repo}/actions/organization-variables"],
		listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
		listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
		listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
		listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
		listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
		listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
		listSelectedReposForOrgVariable: ["GET /orgs/{org}/actions/variables/{name}/repositories"],
		listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
		listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
		listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
		listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
		listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
		listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
		reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
		reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
		reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
		removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
		removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
		removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
		removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
		removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
		removeSelectedRepoFromOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
		reviewCustomGatesForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],
		reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
		setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
		setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
		setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
		setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
		setCustomOidcSubClaimForRepo: ["PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"],
		setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
		setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
		setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
		setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
		setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
		setSelectedReposForOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories"],
		setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
		setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"],
		updateEnvironmentVariable: ["PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"],
		updateHostedRunnerForOrg: ["PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"],
		updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
		updateRepoVariable: ["PATCH /repos/{owner}/{repo}/actions/variables/{name}"]
	},
	activity: {
		checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
		deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
		deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
		getFeeds: ["GET /feeds"],
		getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
		getThread: ["GET /notifications/threads/{thread_id}"],
		getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
		listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
		listNotificationsForAuthenticatedUser: ["GET /notifications"],
		listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
		listPublicEvents: ["GET /events"],
		listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
		listPublicEventsForUser: ["GET /users/{username}/events/public"],
		listPublicOrgEvents: ["GET /orgs/{org}/events"],
		listReceivedEventsForUser: ["GET /users/{username}/received_events"],
		listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
		listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
		listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
		listReposStarredByAuthenticatedUser: ["GET /user/starred"],
		listReposStarredByUser: ["GET /users/{username}/starred"],
		listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
		listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
		listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
		listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
		markNotificationsAsRead: ["PUT /notifications"],
		markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
		markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
		markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
		setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
		setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
		starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
		unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
	},
	apps: {
		addRepoToInstallation: [
			"PUT /user/installations/{installation_id}/repositories/{repository_id}",
			{},
			{ renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
		],
		addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
		checkToken: ["POST /applications/{client_id}/token"],
		createFromManifest: ["POST /app-manifests/{code}/conversions"],
		createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
		deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
		deleteInstallation: ["DELETE /app/installations/{installation_id}"],
		deleteToken: ["DELETE /applications/{client_id}/token"],
		getAuthenticated: ["GET /app"],
		getBySlug: ["GET /apps/{app_slug}"],
		getInstallation: ["GET /app/installations/{installation_id}"],
		getOrgInstallation: ["GET /orgs/{org}/installation"],
		getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
		getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
		getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
		getUserInstallation: ["GET /users/{username}/installation"],
		getWebhookConfigForApp: ["GET /app/hook/config"],
		getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
		listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
		listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
		listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
		listInstallationRequestsForAuthenticatedApp: ["GET /app/installation-requests"],
		listInstallations: ["GET /app/installations"],
		listInstallationsForAuthenticatedUser: ["GET /user/installations"],
		listPlans: ["GET /marketplace_listing/plans"],
		listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
		listReposAccessibleToInstallation: ["GET /installation/repositories"],
		listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
		listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
		listWebhookDeliveries: ["GET /app/hook/deliveries"],
		redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
		removeRepoFromInstallation: [
			"DELETE /user/installations/{installation_id}/repositories/{repository_id}",
			{},
			{ renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
		],
		removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
		resetToken: ["PATCH /applications/{client_id}/token"],
		revokeInstallationAccessToken: ["DELETE /installation/token"],
		scopeToken: ["POST /applications/{client_id}/token/scoped"],
		suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
		unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
		updateWebhookConfigForApp: ["PATCH /app/hook/config"]
	},
	billing: {
		getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
		getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
		getGithubBillingUsageReportOrg: ["GET /organizations/{org}/settings/billing/usage"],
		getGithubBillingUsageReportUser: ["GET /users/{username}/settings/billing/usage"],
		getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
		getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
		getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
		getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
	},
	campaigns: {
		createCampaign: ["POST /orgs/{org}/campaigns"],
		deleteCampaign: ["DELETE /orgs/{org}/campaigns/{campaign_number}"],
		getCampaignSummary: ["GET /orgs/{org}/campaigns/{campaign_number}"],
		listOrgCampaigns: ["GET /orgs/{org}/campaigns"],
		updateCampaign: ["PATCH /orgs/{org}/campaigns/{campaign_number}"]
	},
	checks: {
		create: ["POST /repos/{owner}/{repo}/check-runs"],
		createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
		get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
		getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
		listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
		listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
		listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
		listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
		rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
		rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
		setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
		update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
	},
	codeScanning: {
		commitAutofix: ["POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"],
		createAutofix: ["POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"],
		createVariantAnalysis: ["POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"],
		deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
		deleteCodeqlDatabase: ["DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
		getAlert: [
			"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
			{},
			{ renamedParameters: { alert_id: "alert_number" } }
		],
		getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
		getAutofix: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"],
		getCodeqlDatabase: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
		getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
		getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
		getVariantAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"],
		getVariantAnalysisRepoTask: ["GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"],
		listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
		listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
		listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
		listAlertsInstances: [
			"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
			{},
			{ renamed: ["codeScanning", "listAlertInstances"] }
		],
		listCodeqlDatabases: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],
		listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
		updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
		updateDefaultSetup: ["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],
		uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
	},
	codeSecurity: {
		attachConfiguration: ["POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"],
		attachEnterpriseConfiguration: ["POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"],
		createConfiguration: ["POST /orgs/{org}/code-security/configurations"],
		createConfigurationForEnterprise: ["POST /enterprises/{enterprise}/code-security/configurations"],
		deleteConfiguration: ["DELETE /orgs/{org}/code-security/configurations/{configuration_id}"],
		deleteConfigurationForEnterprise: ["DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"],
		detachConfiguration: ["DELETE /orgs/{org}/code-security/configurations/detach"],
		getConfiguration: ["GET /orgs/{org}/code-security/configurations/{configuration_id}"],
		getConfigurationForRepository: ["GET /repos/{owner}/{repo}/code-security-configuration"],
		getConfigurationsForEnterprise: ["GET /enterprises/{enterprise}/code-security/configurations"],
		getConfigurationsForOrg: ["GET /orgs/{org}/code-security/configurations"],
		getDefaultConfigurations: ["GET /orgs/{org}/code-security/configurations/defaults"],
		getDefaultConfigurationsForEnterprise: ["GET /enterprises/{enterprise}/code-security/configurations/defaults"],
		getRepositoriesForConfiguration: ["GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"],
		getRepositoriesForEnterpriseConfiguration: ["GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"],
		getSingleConfigurationForEnterprise: ["GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"],
		setConfigurationAsDefault: ["PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"],
		setConfigurationAsDefaultForEnterprise: ["PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"],
		updateConfiguration: ["PATCH /orgs/{org}/code-security/configurations/{configuration_id}"],
		updateEnterpriseConfiguration: ["PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"]
	},
	codesOfConduct: {
		getAllCodesOfConduct: ["GET /codes_of_conduct"],
		getConductCode: ["GET /codes_of_conduct/{key}"]
	},
	codespaces: {
		addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
		addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
		checkPermissionsForDevcontainer: ["GET /repos/{owner}/{repo}/codespaces/permissions_check"],
		codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
		createForAuthenticatedUser: ["POST /user/codespaces"],
		createOrUpdateOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],
		createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
		createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
		createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
		createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
		deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
		deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
		deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
		deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
		deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
		exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
		getCodespacesForUserInOrg: ["GET /orgs/{org}/members/{username}/codespaces"],
		getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
		getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
		getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
		getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
		getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
		getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
		getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
		getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
		listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
		listForAuthenticatedUser: ["GET /user/codespaces"],
		listInOrganization: [
			"GET /orgs/{org}/codespaces",
			{},
			{ renamedParameters: { org_id: "org" } }
		],
		listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
		listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
		listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
		listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
		listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
		listSelectedReposForOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
		preFlightWithRepoForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/new"],
		publishForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/publish"],
		removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
		removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
		repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
		setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
		setSelectedReposForOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
		startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
		stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
		stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
		updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
	},
	copilot: {
		addCopilotSeatsForTeams: ["POST /orgs/{org}/copilot/billing/selected_teams"],
		addCopilotSeatsForUsers: ["POST /orgs/{org}/copilot/billing/selected_users"],
		cancelCopilotSeatAssignmentForTeams: ["DELETE /orgs/{org}/copilot/billing/selected_teams"],
		cancelCopilotSeatAssignmentForUsers: ["DELETE /orgs/{org}/copilot/billing/selected_users"],
		copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
		copilotMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/metrics"],
		getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
		getCopilotSeatDetailsForUser: ["GET /orgs/{org}/members/{username}/copilot"],
		listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
	},
	credentials: { revoke: ["POST /credentials/revoke"] },
	dependabot: {
		addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
		createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
		createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
		deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
		deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
		getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
		getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
		getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
		getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
		getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
		listAlertsForEnterprise: ["GET /enterprises/{enterprise}/dependabot/alerts"],
		listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
		listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
		listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
		listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
		listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
		removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
		setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
		updateAlert: ["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"]
	},
	dependencyGraph: {
		createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
		diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],
		exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
	},
	emojis: { get: ["GET /emojis"] },
	gists: {
		checkIsStarred: ["GET /gists/{gist_id}/star"],
		create: ["POST /gists"],
		createComment: ["POST /gists/{gist_id}/comments"],
		delete: ["DELETE /gists/{gist_id}"],
		deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
		fork: ["POST /gists/{gist_id}/forks"],
		get: ["GET /gists/{gist_id}"],
		getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
		getRevision: ["GET /gists/{gist_id}/{sha}"],
		list: ["GET /gists"],
		listComments: ["GET /gists/{gist_id}/comments"],
		listCommits: ["GET /gists/{gist_id}/commits"],
		listForUser: ["GET /users/{username}/gists"],
		listForks: ["GET /gists/{gist_id}/forks"],
		listPublic: ["GET /gists/public"],
		listStarred: ["GET /gists/starred"],
		star: ["PUT /gists/{gist_id}/star"],
		unstar: ["DELETE /gists/{gist_id}/star"],
		update: ["PATCH /gists/{gist_id}"],
		updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
	},
	git: {
		createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
		createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
		createRef: ["POST /repos/{owner}/{repo}/git/refs"],
		createTag: ["POST /repos/{owner}/{repo}/git/tags"],
		createTree: ["POST /repos/{owner}/{repo}/git/trees"],
		deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
		getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
		getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
		getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
		getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
		getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
		listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
		updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
	},
	gitignore: {
		getAllTemplates: ["GET /gitignore/templates"],
		getTemplate: ["GET /gitignore/templates/{name}"]
	},
	hostedCompute: {
		createNetworkConfigurationForOrg: ["POST /orgs/{org}/settings/network-configurations"],
		deleteNetworkConfigurationFromOrg: ["DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}"],
		getNetworkConfigurationForOrg: ["GET /orgs/{org}/settings/network-configurations/{network_configuration_id}"],
		getNetworkSettingsForOrg: ["GET /orgs/{org}/settings/network-settings/{network_settings_id}"],
		listNetworkConfigurationsForOrg: ["GET /orgs/{org}/settings/network-configurations"],
		updateNetworkConfigurationForOrg: ["PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}"]
	},
	interactions: {
		getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
		getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
		getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
		getRestrictionsForYourPublicRepos: [
			"GET /user/interaction-limits",
			{},
			{ renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
		],
		removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
		removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
		removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
		removeRestrictionsForYourPublicRepos: [
			"DELETE /user/interaction-limits",
			{},
			{ renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
		],
		setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
		setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
		setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
		setRestrictionsForYourPublicRepos: [
			"PUT /user/interaction-limits",
			{},
			{ renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
		]
	},
	issues: {
		addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
		addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
		addSubIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"],
		checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
		checkUserCanBeAssignedToIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],
		create: ["POST /repos/{owner}/{repo}/issues"],
		createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
		createLabel: ["POST /repos/{owner}/{repo}/labels"],
		createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
		deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
		deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
		deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
		get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
		getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
		getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
		getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
		getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
		list: ["GET /issues"],
		listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
		listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
		listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
		listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
		listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
		listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
		listForAuthenticatedUser: ["GET /user/issues"],
		listForOrg: ["GET /orgs/{org}/issues"],
		listForRepo: ["GET /repos/{owner}/{repo}/issues"],
		listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
		listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
		listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
		listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
		listSubIssues: ["GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"],
		lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
		removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
		removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
		removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
		removeSubIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"],
		reprioritizeSubIssue: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"],
		setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
		unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
		update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
		updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
		updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
		updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
	},
	licenses: {
		get: ["GET /licenses/{license}"],
		getAllCommonlyUsed: ["GET /licenses"],
		getForRepo: ["GET /repos/{owner}/{repo}/license"]
	},
	markdown: {
		render: ["POST /markdown"],
		renderRaw: ["POST /markdown/raw", { headers: { "content-type": "text/plain; charset=utf-8" } }]
	},
	meta: {
		get: ["GET /meta"],
		getAllVersions: ["GET /versions"],
		getOctocat: ["GET /octocat"],
		getZen: ["GET /zen"],
		root: ["GET /"]
	},
	migrations: {
		deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
		deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
		downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
		getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
		getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
		getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
		listForAuthenticatedUser: ["GET /user/migrations"],
		listForOrg: ["GET /orgs/{org}/migrations"],
		listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
		listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
		listReposForUser: [
			"GET /user/migrations/{migration_id}/repositories",
			{},
			{ renamed: ["migrations", "listReposForAuthenticatedUser"] }
		],
		startForAuthenticatedUser: ["POST /user/migrations"],
		startForOrg: ["POST /orgs/{org}/migrations"],
		unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
		unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"]
	},
	oidc: {
		getOidcCustomSubTemplateForOrg: ["GET /orgs/{org}/actions/oidc/customization/sub"],
		updateOidcCustomSubTemplateForOrg: ["PUT /orgs/{org}/actions/oidc/customization/sub"]
	},
	orgs: {
		addSecurityManagerTeam: [
			"PUT /orgs/{org}/security-managers/teams/{team_slug}",
			{},
			{ deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team" }
		],
		assignTeamToOrgRole: ["PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
		assignUserToOrgRole: ["PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"],
		blockUser: ["PUT /orgs/{org}/blocks/{username}"],
		cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
		checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
		checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
		checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
		convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
		createInvitation: ["POST /orgs/{org}/invitations"],
		createIssueType: ["POST /orgs/{org}/issue-types"],
		createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
		createOrUpdateCustomPropertiesValuesForRepos: ["PATCH /orgs/{org}/properties/values"],
		createOrUpdateCustomProperty: ["PUT /orgs/{org}/properties/schema/{custom_property_name}"],
		createWebhook: ["POST /orgs/{org}/hooks"],
		delete: ["DELETE /orgs/{org}"],
		deleteIssueType: ["DELETE /orgs/{org}/issue-types/{issue_type_id}"],
		deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
		enableOrDisableSecurityProductOnAllOrgRepos: [
			"POST /orgs/{org}/{security_product}/{enablement}",
			{},
			{ deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization" }
		],
		get: ["GET /orgs/{org}"],
		getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
		getCustomProperty: ["GET /orgs/{org}/properties/schema/{custom_property_name}"],
		getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
		getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
		getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
		getOrgRulesetHistory: ["GET /orgs/{org}/rulesets/{ruleset_id}/history"],
		getOrgRulesetVersion: ["GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"],
		getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
		getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
		getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
		list: ["GET /organizations"],
		listAppInstallations: ["GET /orgs/{org}/installations"],
		listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
		listBlockedUsers: ["GET /orgs/{org}/blocks"],
		listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
		listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
		listForAuthenticatedUser: ["GET /user/orgs"],
		listForUser: ["GET /users/{username}/orgs"],
		listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
		listIssueTypes: ["GET /orgs/{org}/issue-types"],
		listMembers: ["GET /orgs/{org}/members"],
		listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
		listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
		listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
		listOrgRoles: ["GET /orgs/{org}/organization-roles"],
		listOrganizationFineGrainedPermissions: ["GET /orgs/{org}/organization-fine-grained-permissions"],
		listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
		listPatGrantRepositories: ["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],
		listPatGrantRequestRepositories: ["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],
		listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
		listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
		listPendingInvitations: ["GET /orgs/{org}/invitations"],
		listPublicMembers: ["GET /orgs/{org}/public_members"],
		listSecurityManagerTeams: [
			"GET /orgs/{org}/security-managers",
			{},
			{ deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams" }
		],
		listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
		listWebhooks: ["GET /orgs/{org}/hooks"],
		pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
		redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
		removeCustomProperty: ["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],
		removeMember: ["DELETE /orgs/{org}/members/{username}"],
		removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
		removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
		removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
		removeSecurityManagerTeam: [
			"DELETE /orgs/{org}/security-managers/teams/{team_slug}",
			{},
			{ deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team" }
		],
		reviewPatGrantRequest: ["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],
		reviewPatGrantRequestsInBulk: ["POST /orgs/{org}/personal-access-token-requests"],
		revokeAllOrgRolesTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}"],
		revokeAllOrgRolesUser: ["DELETE /orgs/{org}/organization-roles/users/{username}"],
		revokeOrgRoleTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
		revokeOrgRoleUser: ["DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"],
		setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
		setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
		unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
		update: ["PATCH /orgs/{org}"],
		updateIssueType: ["PUT /orgs/{org}/issue-types/{issue_type_id}"],
		updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
		updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
		updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
		updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
		updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
	},
	packages: {
		deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
		deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
		deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
		deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
		deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
		deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
		getAllPackageVersionsForAPackageOwnedByAnOrg: [
			"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
			{},
			{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
		],
		getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
			"GET /user/packages/{package_type}/{package_name}/versions",
			{},
			{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"] }
		],
		getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
		getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
		getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
		getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
		getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
		getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
		getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
		getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
		getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
		listDockerMigrationConflictingPackagesForAuthenticatedUser: ["GET /user/docker/conflicts"],
		listDockerMigrationConflictingPackagesForOrganization: ["GET /orgs/{org}/docker/conflicts"],
		listDockerMigrationConflictingPackagesForUser: ["GET /users/{username}/docker/conflicts"],
		listPackagesForAuthenticatedUser: ["GET /user/packages"],
		listPackagesForOrganization: ["GET /orgs/{org}/packages"],
		listPackagesForUser: ["GET /users/{username}/packages"],
		restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
		restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
		restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
		restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
		restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
		restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
	},
	privateRegistries: {
		createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
		deleteOrgPrivateRegistry: ["DELETE /orgs/{org}/private-registries/{secret_name}"],
		getOrgPrivateRegistry: ["GET /orgs/{org}/private-registries/{secret_name}"],
		getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
		listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
		updateOrgPrivateRegistry: ["PATCH /orgs/{org}/private-registries/{secret_name}"]
	},
	pulls: {
		checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
		create: ["POST /repos/{owner}/{repo}/pulls"],
		createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
		createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
		createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
		deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
		deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
		dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
		get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
		getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
		getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
		list: ["GET /repos/{owner}/{repo}/pulls"],
		listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
		listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
		listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
		listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
		listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
		listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
		listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
		merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
		removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
		requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
		submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
		update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
		updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
		updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
		updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
	},
	rateLimit: { get: ["GET /rate_limit"] },
	reactions: {
		createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
		createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
		createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
		createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
		createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
		createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
		createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
		deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
		deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
		deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
		deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
		deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
		deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
		deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
		listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
		listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
		listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
		listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
		listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
		listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
		listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
	},
	repos: {
		acceptInvitation: [
			"PATCH /user/repository_invitations/{invitation_id}",
			{},
			{ renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
		],
		acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
		addAppAccessRestrictions: [
			"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
			{},
			{ mapToData: "apps" }
		],
		addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
		addStatusCheckContexts: [
			"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
			{},
			{ mapToData: "contexts" }
		],
		addTeamAccessRestrictions: [
			"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
			{},
			{ mapToData: "teams" }
		],
		addUserAccessRestrictions: [
			"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
			{},
			{ mapToData: "users" }
		],
		cancelPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"],
		checkAutomatedSecurityFixes: ["GET /repos/{owner}/{repo}/automated-security-fixes"],
		checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
		checkPrivateVulnerabilityReporting: ["GET /repos/{owner}/{repo}/private-vulnerability-reporting"],
		checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
		codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
		compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
		compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
		createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
		createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
		createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
		createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
		createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
		createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
		createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
		createDeploymentBranchPolicy: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
		createDeploymentProtectionRule: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
		createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
		createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
		createForAuthenticatedUser: ["POST /user/repos"],
		createFork: ["POST /repos/{owner}/{repo}/forks"],
		createInOrg: ["POST /orgs/{org}/repos"],
		createOrUpdateCustomPropertiesValues: ["PATCH /repos/{owner}/{repo}/properties/values"],
		createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
		createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
		createOrgRuleset: ["POST /orgs/{org}/rulesets"],
		createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
		createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
		createRelease: ["POST /repos/{owner}/{repo}/releases"],
		createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
		createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
		createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
		declineInvitation: [
			"DELETE /user/repository_invitations/{invitation_id}",
			{},
			{ renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
		],
		declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
		delete: ["DELETE /repos/{owner}/{repo}"],
		deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
		deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
		deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
		deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
		deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
		deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
		deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
		deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
		deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
		deleteDeploymentBranchPolicy: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
		deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
		deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
		deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
		deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
		deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
		deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
		deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
		deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
		deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
		disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
		disableDeploymentProtectionRule: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
		disablePrivateVulnerabilityReporting: ["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],
		disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
		downloadArchive: [
			"GET /repos/{owner}/{repo}/zipball/{ref}",
			{},
			{ renamed: ["repos", "downloadZipballArchive"] }
		],
		downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
		downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
		enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
		enablePrivateVulnerabilityReporting: ["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],
		enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
		generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
		get: ["GET /repos/{owner}/{repo}"],
		getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
		getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
		getAllDeploymentProtectionRules: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
		getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
		getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
		getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
		getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
		getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
		getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
		getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
		getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
		getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
		getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
		getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
		getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
		getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
		getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
		getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
		getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
		getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
		getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
		getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
		getCustomDeploymentProtectionRule: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
		getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
		getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
		getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
		getDeploymentBranchPolicy: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
		getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
		getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
		getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
		getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
		getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
		getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
		getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
		getOrgRulesets: ["GET /orgs/{org}/rulesets"],
		getPages: ["GET /repos/{owner}/{repo}/pages"],
		getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
		getPagesDeployment: ["GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"],
		getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
		getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
		getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
		getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
		getReadme: ["GET /repos/{owner}/{repo}/readme"],
		getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
		getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
		getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
		getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
		getRepoRuleSuite: ["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],
		getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
		getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
		getRepoRulesetHistory: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history"],
		getRepoRulesetVersion: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"],
		getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
		getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
		getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
		getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
		getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
		getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
		getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
		getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
		getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
		getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
		listActivities: ["GET /repos/{owner}/{repo}/activity"],
		listAttestations: ["GET /repos/{owner}/{repo}/attestations/{subject_digest}"],
		listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
		listBranches: ["GET /repos/{owner}/{repo}/branches"],
		listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
		listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
		listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
		listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
		listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
		listCommits: ["GET /repos/{owner}/{repo}/commits"],
		listContributors: ["GET /repos/{owner}/{repo}/contributors"],
		listCustomDeploymentRuleIntegrations: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],
		listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
		listDeploymentBranchPolicies: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
		listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
		listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
		listForAuthenticatedUser: ["GET /user/repos"],
		listForOrg: ["GET /orgs/{org}/repos"],
		listForUser: ["GET /users/{username}/repos"],
		listForks: ["GET /repos/{owner}/{repo}/forks"],
		listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
		listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
		listLanguages: ["GET /repos/{owner}/{repo}/languages"],
		listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
		listPublic: ["GET /repositories"],
		listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
		listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
		listReleases: ["GET /repos/{owner}/{repo}/releases"],
		listTags: ["GET /repos/{owner}/{repo}/tags"],
		listTeams: ["GET /repos/{owner}/{repo}/teams"],
		listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
		listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
		merge: ["POST /repos/{owner}/{repo}/merges"],
		mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
		pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
		redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
		removeAppAccessRestrictions: [
			"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
			{},
			{ mapToData: "apps" }
		],
		removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
		removeStatusCheckContexts: [
			"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
			{},
			{ mapToData: "contexts" }
		],
		removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
		removeTeamAccessRestrictions: [
			"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
			{},
			{ mapToData: "teams" }
		],
		removeUserAccessRestrictions: [
			"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
			{},
			{ mapToData: "users" }
		],
		renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
		replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
		requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
		setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
		setAppAccessRestrictions: [
			"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
			{},
			{ mapToData: "apps" }
		],
		setStatusCheckContexts: [
			"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
			{},
			{ mapToData: "contexts" }
		],
		setTeamAccessRestrictions: [
			"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
			{},
			{ mapToData: "teams" }
		],
		setUserAccessRestrictions: [
			"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
			{},
			{ mapToData: "users" }
		],
		testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
		transfer: ["POST /repos/{owner}/{repo}/transfer"],
		update: ["PATCH /repos/{owner}/{repo}"],
		updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
		updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
		updateDeploymentBranchPolicy: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
		updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
		updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
		updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
		updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
		updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
		updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
		updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
		updateStatusCheckPotection: [
			"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
			{},
			{ renamed: ["repos", "updateStatusCheckProtection"] }
		],
		updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
		updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
		updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
		uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", { baseUrl: "https://uploads.github.com" }]
	},
	search: {
		code: ["GET /search/code"],
		commits: ["GET /search/commits"],
		issuesAndPullRequests: [
			"GET /search/issues",
			{},
			{ deprecated: "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests" }
		],
		labels: ["GET /search/labels"],
		repos: ["GET /search/repositories"],
		topics: ["GET /search/topics"],
		users: ["GET /search/users"]
	},
	secretScanning: {
		createPushProtectionBypass: ["POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"],
		getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
		getScanHistory: ["GET /repos/{owner}/{repo}/secret-scanning/scan-history"],
		listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
		listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
		listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
		listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
		updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
	},
	securityAdvisories: {
		createFork: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"],
		createPrivateVulnerabilityReport: ["POST /repos/{owner}/{repo}/security-advisories/reports"],
		createRepositoryAdvisory: ["POST /repos/{owner}/{repo}/security-advisories"],
		createRepositoryAdvisoryCveRequest: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],
		getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
		getRepositoryAdvisory: ["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
		listGlobalAdvisories: ["GET /advisories"],
		listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
		listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
		updateRepositoryAdvisory: ["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"]
	},
	teams: {
		addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
		addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
		checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
		create: ["POST /orgs/{org}/teams"],
		createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
		createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
		deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
		deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
		deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
		getByName: ["GET /orgs/{org}/teams/{team_slug}"],
		getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
		getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
		getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
		list: ["GET /orgs/{org}/teams"],
		listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
		listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
		listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
		listForAuthenticatedUser: ["GET /user/teams"],
		listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
		listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
		listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
		removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
		removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
		updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
		updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
		updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
	},
	users: {
		addEmailForAuthenticated: [
			"POST /user/emails",
			{},
			{ renamed: ["users", "addEmailForAuthenticatedUser"] }
		],
		addEmailForAuthenticatedUser: ["POST /user/emails"],
		addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
		block: ["PUT /user/blocks/{username}"],
		checkBlocked: ["GET /user/blocks/{username}"],
		checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
		checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
		createGpgKeyForAuthenticated: [
			"POST /user/gpg_keys",
			{},
			{ renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
		],
		createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
		createPublicSshKeyForAuthenticated: [
			"POST /user/keys",
			{},
			{ renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
		],
		createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
		createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
		deleteEmailForAuthenticated: [
			"DELETE /user/emails",
			{},
			{ renamed: ["users", "deleteEmailForAuthenticatedUser"] }
		],
		deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
		deleteGpgKeyForAuthenticated: [
			"DELETE /user/gpg_keys/{gpg_key_id}",
			{},
			{ renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
		],
		deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
		deletePublicSshKeyForAuthenticated: [
			"DELETE /user/keys/{key_id}",
			{},
			{ renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
		],
		deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
		deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
		deleteSshSigningKeyForAuthenticatedUser: ["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],
		follow: ["PUT /user/following/{username}"],
		getAuthenticated: ["GET /user"],
		getById: ["GET /user/{account_id}"],
		getByUsername: ["GET /users/{username}"],
		getContextForUser: ["GET /users/{username}/hovercard"],
		getGpgKeyForAuthenticated: [
			"GET /user/gpg_keys/{gpg_key_id}",
			{},
			{ renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
		],
		getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
		getPublicSshKeyForAuthenticated: [
			"GET /user/keys/{key_id}",
			{},
			{ renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
		],
		getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
		getSshSigningKeyForAuthenticatedUser: ["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],
		list: ["GET /users"],
		listAttestations: ["GET /users/{username}/attestations/{subject_digest}"],
		listBlockedByAuthenticated: [
			"GET /user/blocks",
			{},
			{ renamed: ["users", "listBlockedByAuthenticatedUser"] }
		],
		listBlockedByAuthenticatedUser: ["GET /user/blocks"],
		listEmailsForAuthenticated: [
			"GET /user/emails",
			{},
			{ renamed: ["users", "listEmailsForAuthenticatedUser"] }
		],
		listEmailsForAuthenticatedUser: ["GET /user/emails"],
		listFollowedByAuthenticated: [
			"GET /user/following",
			{},
			{ renamed: ["users", "listFollowedByAuthenticatedUser"] }
		],
		listFollowedByAuthenticatedUser: ["GET /user/following"],
		listFollowersForAuthenticatedUser: ["GET /user/followers"],
		listFollowersForUser: ["GET /users/{username}/followers"],
		listFollowingForUser: ["GET /users/{username}/following"],
		listGpgKeysForAuthenticated: [
			"GET /user/gpg_keys",
			{},
			{ renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
		],
		listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
		listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
		listPublicEmailsForAuthenticated: [
			"GET /user/public_emails",
			{},
			{ renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
		],
		listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
		listPublicKeysForUser: ["GET /users/{username}/keys"],
		listPublicSshKeysForAuthenticated: [
			"GET /user/keys",
			{},
			{ renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
		],
		listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
		listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
		listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
		listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
		listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
		setPrimaryEmailVisibilityForAuthenticated: [
			"PATCH /user/email/visibility",
			{},
			{ renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
		],
		setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
		unblock: ["DELETE /user/blocks/{username}"],
		unfollow: ["DELETE /user/following/{username}"],
		updateAuthenticated: ["PATCH /user"]
	}
};
var endpoints_default = Endpoints;

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
const endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) for (const [methodName, endpoint$1] of Object.entries(endpoints)) {
	const [route, defaults, decorations] = endpoint$1;
	const [method, url] = route.split(/ /);
	const endpointDefaults = Object.assign({
		method,
		url
	}, defaults);
	if (!endpointMethodsMap.has(scope)) endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
	endpointMethodsMap.get(scope).set(methodName, {
		scope,
		methodName,
		endpointDefaults,
		decorations
	});
}
const handler = {
	has({ scope }, methodName) {
		return endpointMethodsMap.get(scope).has(methodName);
	},
	getOwnPropertyDescriptor(target, methodName) {
		return {
			value: this.get(target, methodName),
			configurable: true,
			writable: true,
			enumerable: true
		};
	},
	defineProperty(target, methodName, descriptor) {
		Object.defineProperty(target.cache, methodName, descriptor);
		return true;
	},
	deleteProperty(target, methodName) {
		delete target.cache[methodName];
		return true;
	},
	ownKeys({ scope }) {
		return [...endpointMethodsMap.get(scope).keys()];
	},
	set(target, methodName, value$1) {
		return target.cache[methodName] = value$1;
	},
	get({ octokit, scope, cache }, methodName) {
		if (cache[methodName]) return cache[methodName];
		const method = endpointMethodsMap.get(scope).get(methodName);
		if (!method) return void 0;
		const { endpointDefaults, decorations } = method;
		if (decorations) cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
		else cache[methodName] = octokit.request.defaults(endpointDefaults);
		return cache[methodName];
	}
};
function endpointsToMethods(octokit) {
	const newMethods = {};
	for (const scope of endpointMethodsMap.keys()) newMethods[scope] = new Proxy({
		octokit,
		scope,
		cache: {}
	}, handler);
	return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
	const requestWithDefaults = octokit.request.defaults(defaults);
	function withDecorations(...args) {
		let options = requestWithDefaults.endpoint.merge(...args);
		if (decorations.mapToData) {
			options = Object.assign({}, options, {
				data: options[decorations.mapToData],
				[decorations.mapToData]: void 0
			});
			return requestWithDefaults(options);
		}
		if (decorations.renamed) {
			const [newScope, newMethodName] = decorations.renamed;
			octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
		}
		if (decorations.deprecated) octokit.log.warn(decorations.deprecated);
		if (decorations.renamedParameters) {
			const options2 = requestWithDefaults.endpoint.merge(...args);
			for (const [name$1, alias] of Object.entries(decorations.renamedParameters)) if (name$1 in options2) {
				octokit.log.warn(`"${name$1}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
				if (!(alias in options2)) options2[alias] = options2[name$1];
				delete options2[name$1];
			}
			return requestWithDefaults(options2);
		}
		return requestWithDefaults(...args);
	}
	return Object.assign(withDecorations, requestWithDefaults);
}

//#endregion
//#region ../node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit) {
	const api = endpointsToMethods(octokit);
	return { rest: api };
}
restEndpointMethods.VERSION = VERSION$1;
function legacyRestEndpointMethods(octokit) {
	const api = endpointsToMethods(octokit);
	return {
		...api,
		rest: api
	};
}
legacyRestEndpointMethods.VERSION = VERSION$1;

//#endregion
//#region ../node_modules/@octokit/rest/dist-src/version.js
const VERSION = "22.0.0";

//#endregion
//#region ../node_modules/@octokit/rest/dist-src/index.js
const Octokit = Octokit$1.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults({ userAgent: `octokit-rest.js/${VERSION}` });

//#endregion
//#region src/def/pre-publish.ts
var BasePrePublishCommand = class extends clipanion.Command {
	static paths = [["pre-publish"], ["prepublish"]];
	static usage = clipanion.Command.Usage({ description: "Update package.json and copy addons into per platform packages" });
	cwd = clipanion.Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = clipanion.Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = clipanion.Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = clipanion.Option.String("--npm-dir,-p", "npm", { description: "Path to the folder where the npm packages put" });
	tagStyle = clipanion.Option.String("--tag-style,--tagstyle,-t", "lerna", { description: "git tag style, `npm` or `lerna`" });
	ghRelease = clipanion.Option.Boolean("--gh-release", true, { description: "Whether create GitHub release" });
	ghReleaseName = clipanion.Option.String("--gh-release-name", { description: "GitHub release name" });
	ghReleaseId = clipanion.Option.String("--gh-release-id", { description: "Existing GitHub release id" });
	skipOptionalPublish = clipanion.Option.Boolean("--skip-optional-publish", false, { description: "Whether skip optionalDependencies packages publish" });
	dryRun = clipanion.Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			tagStyle: this.tagStyle,
			ghRelease: this.ghRelease,
			ghReleaseName: this.ghReleaseName,
			ghReleaseId: this.ghReleaseId,
			skipOptionalPublish: this.skipOptionalPublish,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultPrePublishOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		tagStyle: "lerna",
		ghRelease: true,
		skipOptionalPublish: false,
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/def/version.ts
var BaseVersionCommand = class extends clipanion.Command {
	static paths = [["version"]];
	static usage = clipanion.Command.Usage({ description: "Update version in created npm packages" });
	cwd = clipanion.Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = clipanion.Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = clipanion.Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = clipanion.Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir
		};
	}
};
function applyDefaultVersionOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/api/version.ts
const debug$3 = debugFactory("version");
async function version(userOptions) {
	const options = applyDefaultVersionOptions(userOptions);
	const packageJsonPath = (0, node_path.resolve)(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? (0, node_path.resolve)(options.cwd, options.configPath) : void 0);
	for (const target of config.targets) {
		const pkgDir = (0, node_path.resolve)(options.cwd, options.npmDir, target.platformArchABI);
		debug$3(`Update version to %i in [%i]`, config.packageJson.version, pkgDir);
		await updatePackageJson((0, node_path.join)(pkgDir, "package.json"), { version: config.packageJson.version });
	}
}

//#endregion
//#region src/api/pre-publish.ts
const debug$2 = debugFactory("pre-publish");
async function prePublish(userOptions) {
	debug$2("Receive pre-publish options:");
	debug$2("  %O", userOptions);
	const options = applyDefaultPrePublishOptions(userOptions);
	const packageJsonPath = (0, node_path.resolve)(options.cwd, options.packageJsonPath);
	const { packageJson, targets, packageName, binaryName, npmClient } = await readNapiConfig(packageJsonPath, options.configPath ? (0, node_path.resolve)(options.cwd, options.configPath) : void 0);
	async function createGhRelease(packageName$1, version$2) {
		if (!options.ghRelease) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		const { repo: repo$1, owner: owner$1, pkgInfo: pkgInfo$1, octokit: octokit$1 } = getRepoInfo(packageName$1, version$2);
		if (!repo$1 || !owner$1) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		if (!options.dryRun) try {
			await octokit$1.repos.createRelease({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag,
				name: options.ghReleaseName,
				prerelease: version$2.includes("alpha") || version$2.includes("beta") || version$2.includes("rc")
			});
		} catch (e) {
			debug$2(`Params: ${JSON.stringify({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag
			}, null, 2)}`);
			console.error(e);
		}
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	function getRepoInfo(packageName$1, version$2) {
		const headCommit = (0, node_child_process.execSync)("git log -1 --pretty=%B", { encoding: "utf-8" }).trim();
		const { GITHUB_REPOSITORY } = process.env;
		if (!GITHUB_REPOSITORY) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		debug$2(`Github repository: ${GITHUB_REPOSITORY}`);
		const [owner$1, repo$1] = GITHUB_REPOSITORY.split("/");
		const octokit$1 = new Octokit({ auth: process.env.GITHUB_TOKEN });
		let pkgInfo$1;
		if (options.tagStyle === "lerna") {
			const packagesToPublish = headCommit.split("\n").map((line) => line.trim()).filter((line, index) => line.length && index).map((line) => line.substring(2)).map(parseTag);
			pkgInfo$1 = packagesToPublish.find((pkgInfo$2) => pkgInfo$2.name === packageName$1);
			if (!pkgInfo$1) throw new TypeError(`No release commit found with ${packageName$1}, original commit info: ${headCommit}`);
		} else pkgInfo$1 = {
			tag: `v${version$2}`,
			version: version$2,
			name: packageName$1
		};
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	if (!options.dryRun) {
		await version(userOptions);
		await updatePackageJson(packageJsonPath, { optionalDependencies: targets.reduce((deps, target) => {
			deps[`${packageName}-${target.platformArchABI}`] = packageJson.version;
			return deps;
		}, {}) });
	}
	const { owner, repo, pkgInfo, octokit } = options.ghReleaseId ? getRepoInfo(packageName, packageJson.version) : await createGhRelease(packageName, packageJson.version);
	for (const target of targets) {
		const pkgDir = (0, node_path.resolve)(options.cwd, options.npmDir, `${target.platformArchABI}`);
		const ext = target.platform === "wasi" || target.platform === "wasm" ? "wasm" : "node";
		const filename = `${binaryName}.${target.platformArchABI}.${ext}`;
		const dstPath = (0, node_path.join)(pkgDir, filename);
		if (!options.dryRun) {
			if (!(0, node_fs.existsSync)(dstPath)) {
				debug$2.warn(`%s doesn't exist`, dstPath);
				continue;
			}
			if (!options.skipOptionalPublish) (0, node_child_process.execSync)(`${npmClient} publish`, {
				cwd: pkgDir,
				env: process.env
			});
			if (options.ghRelease && repo && owner) {
				debug$2.info(`Creating GitHub release ${pkgInfo.tag}`);
				try {
					const releaseId = options.ghReleaseId ? Number(options.ghReleaseId) : (await octokit.repos.getReleaseByTag({
						repo,
						owner,
						tag: pkgInfo.tag
					})).data.id;
					const dstFileStats = (0, node_fs.statSync)(dstPath);
					const assetInfo = await octokit.repos.uploadReleaseAsset({
						owner,
						repo,
						name: filename,
						release_id: releaseId,
						mediaType: { format: "raw" },
						headers: {
							"content-length": dstFileStats.size,
							"content-type": "application/octet-stream"
						},
						data: await readFileAsync(dstPath)
					});
					debug$2.info(`GitHub release created`);
					debug$2.info(`Download URL: %s`, assetInfo.data.browser_download_url);
				} catch (e) {
					debug$2.error(`Param: ${JSON.stringify({
						owner,
						repo,
						tag: pkgInfo.tag,
						filename: dstPath
					}, null, 2)}`);
					debug$2.error(e);
				}
			}
		}
	}
}
function parseTag(tag) {
	const segments = tag.split("@");
	const version$2 = segments.pop();
	const name$1 = segments.join("@");
	return {
		name: name$1,
		version: version$2,
		tag
	};
}

//#endregion
//#region src/def/universalize.ts
var BaseUniversalizeCommand = class extends clipanion.Command {
	static paths = [["universalize"]];
	static usage = clipanion.Command.Usage({ description: "Combile built binaries into one universal binary" });
	cwd = clipanion.Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = clipanion.Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = clipanion.Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = clipanion.Option.String("--output-dir,-o", "./", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir
		};
	}
};
function applyDefaultUniversalizeOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./",
		...options
	};
}

//#endregion
//#region src/api/universalize.ts
const debug$1 = debugFactory("universalize");
const universalizers = { darwin: (inputs, output) => {
	(0, node_child_process.spawnSync)("lipo", [
		"-create",
		"-output",
		output,
		...inputs
	], { stdio: "inherit" });
} };
async function universalizeBinaries(userOptions) {
	const options = applyDefaultUniversalizeOptions(userOptions);
	const packageJsonPath = (0, node_path.join)(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? (0, node_path.resolve)(options.cwd, options.configPath) : void 0);
	const target = config.targets.find((t) => t.platform === process.platform && t.arch === "universal");
	if (!target) throw new Error(`'universal' arch for platform '${process.platform}' not found in config!`);
	const srcFiles = UniArchsByPlatform[process.platform]?.map((arch) => (0, node_path.resolve)(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-${arch}.node`));
	if (!srcFiles || !universalizers[process.platform]) throw new Error(`'universal' arch for platform '${process.platform}' not supported.`);
	debug$1(`Looking up source binaries to combine: `);
	debug$1("  %O", srcFiles);
	const srcFileLookup = await Promise.all(srcFiles.map((f) => fileExists(f)));
	const notFoundFiles = srcFiles.filter((_, i) => !srcFileLookup[i]);
	if (notFoundFiles.length) throw new Error(`Some binary files were not found: ${JSON.stringify(notFoundFiles)}`);
	const output = (0, node_path.resolve)(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-universal.node`);
	universalizers[process.platform]?.(srcFiles, output);
	debug$1(`Produced universal binary: ${output}`);
}

//#endregion
//#region src/index.ts
/**
*
* @usage
*
* ```ts
* const cli = new NapiCli()
*
* cli.build({
*   cwd: '/path/to/your/project',
* })
* ```
*/
var NapiCli = class {
	artifacts = collectArtifacts;
	new = newProject;
	build = buildProject;
	createNpmDirs = createNpmDirs;
	prePublish = prePublish;
	rename = renameProject;
	universalize = universalizeBinaries;
	version = version;
};

//#endregion
exports.NapiCli = NapiCli;
exports.parseTriple = parseTriple;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwibmFtZXMiOlsiQ29tbWFuZCIsIk9wdGlvbiIsIm9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMiLCJyYXdEZWJ1ZyIsImNvbG9ycyIsIm5hbWVzcGFjZTogc3RyaW5nIiwiZGVidWciLCJyZWFkRmlsZSIsIndyaXRlRmlsZSIsInVubGluayIsImNvcHlGaWxlIiwibWtkaXIiLCJzdGF0IiwicmVhZGRpciIsInBhdGg6IHN0cmluZyIsInBhdGgiLCJvOiBPIiwia2V5cyIsInBhcnRpYWw6IFJlY29yZDxzdHJpbmcsIGFueT4iLCJkZWJ1ZyIsInBrZ0pzb24iLCJUQVJHRVRfTElOS0VSOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwiQ3B1VG9Ob2RlQXJjaDogUmVjb3JkPHN0cmluZywgTm9kZUpTQXJjaD4iLCJTeXNUb05vZGVQbGF0Zm9ybTogUmVjb3JkPHN0cmluZywgUGxhdGZvcm0+IiwiVW5pQXJjaHNCeVBsYXRmb3JtOiBQYXJ0aWFsPFJlY29yZDxQbGF0Zm9ybSwgTm9kZUpTQXJjaFtdPj4iLCJyYXdUcmlwbGU6IHN0cmluZyIsImNwdTogc3RyaW5nIiwic3lzOiBzdHJpbmciLCJhYmk6IHN0cmluZyB8IG51bGwiLCJ0YXJnZXQ6IHN0cmluZyIsInY6IHN0cmluZyIsIm5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbiIsInZlcnNpb25zOiBOb2RlVmVyc2lvbltdIiwicmVxdWlyZW1lbnRzOiBzdHJpbmdbXSIsIm1hbmlmZXN0UGF0aDogc3RyaW5nIiwiZnMiLCJyZXNvbHZlIiwiZnJlZUdsb2JhbCIsIlN5bWJvbCIsInJvb3QiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsIlN5bWJvbCIsInZhbHVlIiwib2JqZWN0UHJvdG8iLCJ2YWx1ZSIsIlN5bWJvbCIsInZhbHVlIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJ2YWx1ZSIsInN5bWJvbFRhZyIsInZhbHVlIiwiaXNPYmplY3RMaWtlIiwiYmFzZUdldFRhZyIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJTeW1ib2wiLCJ2YWx1ZSIsImlzQXJyYXkiLCJhcnJheU1hcCIsImlzU3ltYm9sIiwiaXNPYmplY3QiLCJ2YWx1ZSIsInR5cGUiLCJ2YWx1ZSIsImZ1bmNUYWciLCJnZW5UYWciLCJ2YWx1ZSIsImlzT2JqZWN0IiwiYmFzZUdldFRhZyIsInJvb3QiLCJjb3JlSnNEYXRhIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJmdW5jVG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsInZhbHVlIiwiaXNPYmplY3QiLCJpc01hc2tlZCIsImlzRnVuY3Rpb24iLCJ0b1NvdXJjZSIsInZhbHVlIiwiZ2V0VmFsdWUiLCJiYXNlSXNOYXRpdmUiLCJnZXROYXRpdmUiLCJyb290IiwiaXNPYmplY3QiLCJ2YWx1ZSIsImdldE5hdGl2ZSIsImRlZmluZVByb3BlcnR5IiwiaWRlbnRpdHkiLCJjb25zdGFudCIsInNob3J0T3V0IiwiYmFzZVNldFRvU3RyaW5nIiwiTUFYX1NBRkVfSU5URUdFUiIsInZhbHVlIiwidHlwZSIsInZhbHVlIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJ2YWx1ZSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJhcHBseSIsInNldFRvU3RyaW5nIiwib3ZlclJlc3QiLCJpZGVudGl0eSIsInZhbHVlIiwidmFsdWUiLCJpc0xlbmd0aCIsImlzRnVuY3Rpb24iLCJ2YWx1ZSIsImlzT2JqZWN0IiwidHlwZSIsImlzQXJyYXlMaWtlIiwiaXNJbmRleCIsImVxIiwiYmFzZVJlc3QiLCJpc0l0ZXJhdGVlQ2FsbCIsIm9iamVjdFByb3RvIiwidmFsdWUiLCJhcmdzVGFnIiwidmFsdWUiLCJpc09iamVjdExpa2UiLCJiYXNlR2V0VGFnIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiYmFzZUlzQXJndW1lbnRzIiwidmFsdWUiLCJpc09iamVjdExpa2UiLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwicm9vdCIsInN0dWJGYWxzZSIsImFyZ3NUYWciLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ2YWx1ZSIsImlzT2JqZWN0TGlrZSIsImlzTGVuZ3RoIiwiYmFzZUdldFRhZyIsInZhbHVlIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVHbG9iYWwiLCJub2RlVXRpbCIsImJhc2VVbmFyeSIsImJhc2VJc1R5cGVkQXJyYXkiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwidmFsdWUiLCJpc0FycmF5IiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzVHlwZWRBcnJheSIsImJhc2VUaW1lcyIsImlzSW5kZXgiLCJvdmVyQXJnIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsImlzUHJvdG90eXBlIiwibmF0aXZlS2V5cyIsImlzQXJyYXlMaWtlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsImlzT2JqZWN0IiwibmF0aXZlS2V5c0luIiwiaXNQcm90b3R5cGUiLCJpc0FycmF5TGlrZSIsImFycmF5TGlrZUtleXMiLCJiYXNlS2V5c0luIiwidmFsdWUiLCJpc0FycmF5IiwidHlwZSIsImlzU3ltYm9sIiwiZ2V0TmF0aXZlIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwibmF0aXZlQ3JlYXRlIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsIm5hdGl2ZUNyZWF0ZSIsIkhBU0hfVU5ERUZJTkVEIiwidmFsdWUiLCJuYXRpdmVDcmVhdGUiLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiZXEiLCJhc3NvY0luZGV4T2YiLCJhc3NvY0luZGV4T2YiLCJhc3NvY0luZGV4T2YiLCJ2YWx1ZSIsImFzc29jSW5kZXhPZiIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwIiwiZ2V0TmF0aXZlIiwicm9vdCIsIkhhc2giLCJNYXAiLCJMaXN0Q2FjaGUiLCJ2YWx1ZSIsInR5cGUiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiZ2V0TWFwRGF0YSIsImdldE1hcERhdGEiLCJ2YWx1ZSIsImdldE1hcERhdGEiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJGVU5DX0VSUk9SX1RFWFQiLCJNYXBDYWNoZSIsIm1lbW9pemUiLCJtZW1vaXplQ2FwcGVkIiwidmFsdWUiLCJiYXNlVG9TdHJpbmciLCJ2YWx1ZSIsImlzQXJyYXkiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsInRvU3RyaW5nIiwidmFsdWUiLCJpc1N5bWJvbCIsInBhdGgiLCJjYXN0UGF0aCIsInRvS2V5IiwicGF0aCIsImJhc2VHZXQiLCJTeW1ib2wiLCJ2YWx1ZSIsImlzQXJyYXkiLCJpc0FyZ3VtZW50cyIsImlzRmxhdHRlbmFibGUiLCJ2YWx1ZSIsImFycmF5UHVzaCIsImJhc2VGbGF0dGVuIiwic2V0VG9TdHJpbmciLCJvdmVyUmVzdCIsImZsYXR0ZW4iLCJvdmVyQXJnIiwib2JqZWN0VGFnIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsImlzT2JqZWN0TGlrZSIsImJhc2VHZXRUYWciLCJnZXRQcm90b3R5cGUiLCJMaXN0Q2FjaGUiLCJ2YWx1ZSIsIkxpc3RDYWNoZSIsIk1hcCIsIk1hcENhY2hlIiwiTGlzdENhY2hlIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiY29weU9iamVjdCIsImtleXMiLCJjb3B5T2JqZWN0Iiwia2V5c0luIiwiQnVmZmVyIiwicm9vdCIsInZhbHVlIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVHZXRTeW1ib2xzIiwic3R1YkFycmF5IiwiYXJyYXlGaWx0ZXIiLCJjb3B5T2JqZWN0IiwiZ2V0U3ltYm9scyIsInN0dWJBcnJheSIsImFycmF5UHVzaCIsImdldFN5bWJvbHMiLCJnZXRQcm90b3R5cGUiLCJjb3B5T2JqZWN0IiwiZ2V0U3ltYm9sc0luIiwiaXNBcnJheSIsImFycmF5UHVzaCIsImJhc2VHZXRBbGxLZXlzIiwia2V5cyIsImdldFN5bWJvbHMiLCJiYXNlR2V0QWxsS2V5cyIsImtleXNJbiIsImdldFN5bWJvbHNJbiIsImdldE5hdGl2ZSIsInJvb3QiLCJQcm9taXNlIiwiZ2V0TmF0aXZlIiwicm9vdCIsIlNldCIsImdldE5hdGl2ZSIsInJvb3QiLCJtYXBUYWciLCJvYmplY3RUYWciLCJzZXRUYWciLCJ3ZWFrTWFwVGFnIiwiZGF0YVZpZXdUYWciLCJ0b1NvdXJjZSIsIkRhdGFWaWV3IiwiTWFwIiwiUHJvbWlzZSIsIlNldCIsIldlYWtNYXAiLCJiYXNlR2V0VGFnIiwidmFsdWUiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwiVWludDhBcnJheSIsInJvb3QiLCJVaW50OEFycmF5IiwiY2xvbmVBcnJheUJ1ZmZlciIsInN5bWJvbFByb3RvIiwiU3ltYm9sIiwic3ltYm9sVmFsdWVPZiIsImNsb25lQXJyYXlCdWZmZXIiLCJib29sVGFnIiwiZGF0ZVRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJjbG9uZUFycmF5QnVmZmVyIiwiY2xvbmVEYXRhVmlldyIsImNsb25lVHlwZWRBcnJheSIsImNsb25lUmVnRXhwIiwiY2xvbmVTeW1ib2wiLCJpc1Byb3RvdHlwZSIsImJhc2VDcmVhdGUiLCJnZXRQcm90b3R5cGUiLCJtYXBUYWciLCJ2YWx1ZSIsImlzT2JqZWN0TGlrZSIsImdldFRhZyIsIm5vZGVVdGlsIiwiYmFzZVVuYXJ5IiwiYmFzZUlzTWFwIiwic2V0VGFnIiwidmFsdWUiLCJpc09iamVjdExpa2UiLCJnZXRUYWciLCJub2RlVXRpbCIsImJhc2VVbmFyeSIsImJhc2VJc1NldCIsIkNMT05FX0RFRVBfRkxBRyIsIkNMT05FX0ZMQVRfRkxBRyIsIkNMT05FX1NZTUJPTFNfRkxBRyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwidmFsdWUiLCJpc09iamVjdCIsImlzQXJyYXkiLCJpbml0Q2xvbmVBcnJheSIsImNvcHlBcnJheSIsImdldFRhZyIsImlzQnVmZmVyIiwiY2xvbmVCdWZmZXIiLCJpbml0Q2xvbmVPYmplY3QiLCJjb3B5U3ltYm9sc0luIiwiYmFzZUFzc2lnbkluIiwiY29weVN5bWJvbHMiLCJiYXNlQXNzaWduIiwiaW5pdENsb25lQnlUYWciLCJTdGFjayIsImlzU2V0IiwiaXNNYXAiLCJrZXkiLCJnZXRBbGxLZXlzSW4iLCJnZXRBbGxLZXlzIiwia2V5c0luIiwia2V5cyIsImFycmF5RWFjaCIsImFzc2lnblZhbHVlIiwidmFsdWUiLCJ2YWx1ZSIsIk1hcENhY2hlIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsIlNldENhY2hlIiwiYXJyYXlTb21lIiwib3RoVmFsdWUiLCJjYWNoZUhhcyIsInZhbHVlIiwidmFsdWUiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJTeW1ib2wiLCJVaW50OEFycmF5IiwiZXEiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsImVxdWFsQXJyYXlzIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwiZ2V0QWxsS2V5cyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiaXNBcnJheSIsImdldFRhZyIsImlzQnVmZmVyIiwiU3RhY2siLCJpc1R5cGVkQXJyYXkiLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJ2YWx1ZSIsImlzT2JqZWN0TGlrZSIsImJhc2VJc0VxdWFsRGVlcCIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsIlN0YWNrIiwiYmFzZUlzRXF1YWwiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwia2V5cyIsInZhbHVlIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiZ2V0TWF0Y2hEYXRhIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJiYXNlSXNNYXRjaCIsInBhdGgiLCJjYXN0UGF0aCIsInRvS2V5IiwiaXNMZW5ndGgiLCJpc0luZGV4IiwiaXNBcnJheSIsImlzQXJndW1lbnRzIiwicGF0aCIsImhhc1BhdGgiLCJiYXNlSGFzSW4iLCJwYXRoIiwiaXNLZXkiLCJpc1N0cmljdENvbXBhcmFibGUiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsInRvS2V5IiwiZ2V0IiwiaGFzSW4iLCJiYXNlSXNFcXVhbCIsInBhdGgiLCJiYXNlR2V0IiwicGF0aCIsImlzS2V5IiwiYmFzZVByb3BlcnR5IiwidG9LZXkiLCJiYXNlUHJvcGVydHlEZWVwIiwidmFsdWUiLCJpZGVudGl0eSIsImlzQXJyYXkiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJwcm9wZXJ0eSIsImNyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yIiwia2V5cyIsImlzQXJyYXlMaWtlIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwidmFsdWUiLCJlcSIsImJhc2VBc3NpZ25WYWx1ZSIsInZhbHVlIiwiaXNPYmplY3RMaWtlIiwiaXNBcnJheUxpa2UiLCJ2YWx1ZSIsImNvcHlPYmplY3QiLCJrZXlzSW4iLCJzYWZlR2V0IiwiYXNzaWduTWVyZ2VWYWx1ZSIsImlzQXJyYXkiLCJpc0J1ZmZlciIsImlzVHlwZWRBcnJheSIsImlzQXJyYXlMaWtlT2JqZWN0IiwiY29weUFycmF5IiwiY2xvbmVCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwiaXNBcmd1bWVudHMiLCJ0b1BsYWluT2JqZWN0IiwiaXNPYmplY3QiLCJpc0Z1bmN0aW9uIiwiaW5pdENsb25lT2JqZWN0IiwiYmFzZUZvciIsIlN0YWNrIiwiaXNPYmplY3QiLCJiYXNlTWVyZ2VEZWVwIiwic2FmZUdldCIsImFzc2lnbk1lcmdlVmFsdWUiLCJrZXlzSW4iLCJpc0FycmF5TGlrZSIsImJhc2VFYWNoIiwidmFsdWUiLCJjb2xsZWN0aW9uIiwicGF0aCIsImJhc2VHZXQiLCJiYXNlU2xpY2UiLCJ2YWx1ZSIsIm1lcmdlIiwiY3JlYXRlQXNzaWduZXIiLCJiYXNlTWVyZ2UiLCJwYXRoIiwiY2FzdFBhdGgiLCJwYXJlbnQiLCJ0b0tleSIsImxhc3QiLCJ2YWx1ZSIsImlzUGxhaW5PYmplY3QiLCJvbWl0IiwiZmxhdFJlc3QiLCJhcnJheU1hcCIsInBhdGgiLCJjYXN0UGF0aCIsImNvcHlPYmplY3QiLCJnZXRBbGxLZXlzSW4iLCJiYXNlQ2xvbmUiLCJjdXN0b21PbWl0Q2xvbmUiLCJiYXNlVW5zZXQiLCJwYXRoIiwidmFsdWUiLCJpc09iamVjdCIsImNhc3RQYXRoIiwidG9LZXkiLCJpc0luZGV4IiwiYXNzaWduVmFsdWUiLCJwYXRoIiwidmFsdWUiLCJiYXNlR2V0IiwiYmFzZVNldCIsImNhc3RQYXRoIiwiYXJyYXlNYXAiLCJnZXRBbGxLZXlzSW4iLCJiYXNlSXRlcmF0ZWUiLCJiYXNlUGlja0J5IiwidmFsdWUiLCJwYXRoIiwicGlja0J5IiwibmVnYXRlIiwiYmFzZUl0ZXJhdGVlIiwidmFsdWUiLCJpc1N5bWJvbCIsImNvbXBhcmVBc2NlbmRpbmciLCJhcnJheU1hcCIsImlzQXJyYXkiLCJ2YWx1ZSIsImJhc2VHZXQiLCJpZGVudGl0eSIsImJhc2VVbmFyeSIsImJhc2VJdGVyYXRlZSIsImJhc2VNYXAiLCJjb2xsZWN0aW9uIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVNdWx0aXBsZSIsImJhc2VQaWNrQnkiLCJ2YWx1ZSIsInBhdGgiLCJoYXNJbiIsInBpY2siLCJmbGF0UmVzdCIsImJhc2VQaWNrIiwiYmFzZVJlc3QiLCJpc0l0ZXJhdGVlQ2FsbCIsImJhc2VPcmRlckJ5IiwiYmFzZUZsYXR0ZW4iLCJwYXRoOiBzdHJpbmciLCJjb25maWdQYXRoPzogc3RyaW5nIiwicGF0aCIsInNlcGFyYXRlZENvbmZpZzogVXNlck5hcGlDb25maWcgfCB1bmRlZmluZWQiLCJuYXBpQ29uZmlnOiBOYXBpQ29uZmlnIiwibWVyZ2UiLCJvbWl0IiwidGFyZ2V0czogc3RyaW5nW10iLCJuYW1lOiBzdHJpbmciLCJiaW46IHN0cmluZyIsImJpbiIsImRlYnVnIiwibmFtZSIsImxpbmU6IFR5cGVEZWZMaW5lIiwiY29uc3RFbnVtOiBib29sZWFuIiwiaWRlbnQ6IG51bWJlciIsImFtYmllbnQ6IGJvb2xlYW4iLCJpbnRlcm1lZGlhdGVUeXBlRmlsZTogc3RyaW5nIiwiZXhwb3J0czogc3RyaW5nW10iLCJzb3J0QnkiLCJkZWZzIiwiZXhwb3J0cyIsImZpbGU6IHN0cmluZyIsImRlZnM6IFR5cGVEZWZMaW5lW10iLCJzcmM6IHN0cmluZyIsIm9wdGlvbnM6IE1pbmltYWxOYXBpT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMiLCJjb2xvcnMiLCJkaXIiLCJyb290OiBzdHJpbmciLCJmaWxlcyIsInJvb3QiLCJsb2NhbE5hbWU6IHN0cmluZyIsInBrZ05hbWU6IHN0cmluZyIsImlkZW50czogc3RyaW5nW10iLCJ0dXBsZTogc3RyaW5nIiwid2FzaUZpbGVuYW1lOiBzdHJpbmciLCJmcyIsIndhc21GaWxlTmFtZTogc3RyaW5nIiwicGFja2FnZU5hbWU6IHN0cmluZyIsImZzOiBib29sZWFuIiwiZnMiLCJkZWJ1ZyIsInJlcXVpcmUiLCJyYXdPcHRpb25zOiBCdWlsZE9wdGlvbnMiLCJvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMiLCJtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSIsImNyYXRlOiBDcmF0ZSIsImNvbmZpZzogTmFwaUNvbmZpZyIsImFsaWFzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwidmVyc2lvbiIsInJlc29sdmUiLCJhYmk6IHN0cmluZyB8IG51bGwiLCJ0eXBlRGVmVG1wRm9sZGVyOiBzdHJpbmciLCJjb2xvcnMiLCJleHBvcnRzOiBzdHJpbmdbXSIsImZpbGVzIiwiZXhwb3J0cyIsImlkZW50czogc3RyaW5nW10iLCJuYW1lIiwiZGlzdEZpbGVOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsIiwiZW52OiBzdHJpbmciLCJ2YWx1ZTogc3RyaW5nIiwidmFsdWUiLCJDb21tYW5kIiwiT3B0aW9uIiwib3B0aW9uczogQ3JlYXRlTnBtRGlyc09wdGlvbnMiLCJkZWJ1ZyIsInVzZXJPcHRpb25zOiBDcmVhdGVOcG1EaXJzT3B0aW9ucyIsIm1rZGlyQXN5bmMiLCJkaXI6IHN0cmluZyIsInJhd01rZGlyQXN5bmMiLCJ3cml0ZUZpbGVBc3luYyIsImZpbGU6IHN0cmluZyIsImNvbnRlbnQ6IHN0cmluZyIsInJhd1dyaXRlRmlsZUFzeW5jIiwic2NvcGVkUGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzIiwicGFja2FnZU5hbWU6IHN0cmluZyIsInRhcmdldDogVGFyZ2V0IiwiQ29tbWFuZCIsIk9wdGlvbiIsIm9wdGlvbnM6IE5ld09wdGlvbnMiLCJrZXlzIiwiI3ByaW50T2JqZWN0IiwiI2Zvcm1hdCIsIiNpc1NpbXBseVNlcmlhbGl6YWJsZSIsInZhbHVlIiwiI2RhdGVEZWNsYXJhdGlvbiIsIiNzdHJEZWNsYXJhdGlvbiIsIiNudW1iZXJEZWNsYXJhdGlvbiIsIiNib29sRGVjbGFyYXRpb24iLCIjZ2V0VHlwZU9mQXJyYXkiLCIjYXJyYXlEZWNsYXJhdGlvbiIsIiNoZWFkZXJHcm91cCIsIiNwcmludEFzSW5saW5lVmFsdWUiLCIjZGVjbGFyYXRpb24iLCIjaGVhZGVyIiwiI2FycmF5VHlwZUNhY2hlIiwidHlwZSIsIiNkb0dldFR5cGVPZkFycmF5IiwiI2lzUHJpbWl0aXZlIiwiI3ByaW50RGF0ZSIsImtleXMiLCJ2YWx1ZSIsIiNzb3VyY2UiLCIjcG9zaXRpb24iLCIjd2hpdGVzcGFjZSIsImtleXMiLCJ2YWx1ZSIsInRhYmxlIiwibGFzdCIsInBhcnNlIiwiam9pbiIsInNlcCIsIm1lcmdlIiwiZmxvYXQiLCJwYWlyIiwicGFyc2UiLCJDb21tYW5kIiwiT3B0aW9uIiwib3B0aW9uczogUmVuYW1lT3B0aW9ucyIsInVzZXJPcHRpb25zOiBSZW5hbWVPcHRpb25zIiwibWVyZ2UiLCJvbWl0QnkiLCJwaWNrIiwiaXNOaWwiLCJwYXJzZVRvbWwiLCJzdHJpbmdpZnlUb21sIiwiZGVidWciLCJyZXNvbHZlIiwicGFja2FnZU1hbmFnZXI6IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyIiwicGF0aCIsImNhY2hlRGlyOiBzdHJpbmciLCJzcmM6IHN0cmluZyIsImRlc3Q6IHN0cmluZyIsImluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4iLCJmcyIsImZpbGVQYXRoOiBzdHJpbmciLCJlbmFibGVkVGFyZ2V0czogc3RyaW5nW10iLCJ0YXJnZXQ6IHN0cmluZyIsInNldHRpbmc6IGFueSIsImpvYnNUb1JlbW92ZTogc3RyaW5nW10iLCJuZWVkOiBzdHJpbmciLCJvcHRpb25zOiBSYXdOZXdPcHRpb25zIiwidXNlck9wdGlvbnM6IFJhd05ld09wdGlvbnMiLCJwYXRoOiBzdHJpbmciLCJzdGF0IiwiZmlsZXMiLCJuYW1lOiBzdHJpbmciLCJuYW1lIiwibmFtZSIsIm1ldGhvZCIsIm5hbWUiLCJob29rIiwibmFtZSIsImhvb2siLCJuYW1lIiwiVkVSU0lPTiIsImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsIm5hbWUiLCJwYXJzZSIsIndpdGhEZWZhdWx0cyIsIk51bGxPYmplY3QiLCJ0eXBlIiwidmFsdWUiLCJzYWZlUGFyc2UiLCJWRVJTSU9OIiwidmFsdWUiLCJmZXRjaCIsIm5hbWUiLCJ3aXRoRGVmYXVsdHMiLCJWRVJTSU9OIiwicmVxdWVzdCIsImVuZHBvaW50IiwiVkVSU0lPTiIsIlZFUlNJT04iLCJPY3Rva2l0IiwiaG9vayIsIkhvb2siLCJhdXRoIiwiVkVSU0lPTiIsInJlcXVlc3QiLCJwYXRoIiwiVkVSU0lPTiIsIlZFUlNJT04iLCJWRVJTSU9OIiwiRU5EUE9JTlRTIiwiZW5kcG9pbnQiLCJ2YWx1ZSIsIm5hbWUiLCJWRVJTSU9OIiwiQ29yZSIsIkNvbW1hbmQiLCJPcHRpb24iLCJvcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucyIsIkNvbW1hbmQiLCJPcHRpb24iLCJvcHRpb25zOiBWZXJzaW9uT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IFZlcnNpb25PcHRpb25zIiwiZGVidWciLCJ1c2VyT3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMiLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwidmVyc2lvbjogc3RyaW5nIiwicGFja2FnZU5hbWUiLCJ2ZXJzaW9uIiwicmVwbyIsIm93bmVyIiwib2N0b2tpdCIsInBrZ0luZm8iLCJwa2dJbmZvOiBQYWNrYWdlSW5mbyB8IHVuZGVmaW5lZCIsInRhZzogc3RyaW5nIiwibmFtZSIsIkNvbW1hbmQiLCJPcHRpb24iLCJvcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zIiwiZGVidWciLCJ1bml2ZXJzYWxpemVyczogUGFydGlhbDxcbiAgUmVjb3JkPE5vZGVKUy5QbGF0Zm9ybSwgKGlucHV0czogc3RyaW5nW10sIG91dHB1dDogc3RyaW5nKSA9PiB2b2lkPlxuPiIsInVzZXJPcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zIl0sInNvdXJjZXMiOlsiLi4vc3JjL2RlZi9hcnRpZmFjdHMudHMiLCIuLi9zcmMvdXRpbHMvbG9nLnRzIiwiLi4vcGFja2FnZS5qc29uIiwiLi4vc3JjL3V0aWxzL21pc2MudHMiLCIuLi9zcmMvdXRpbHMvdGFyZ2V0LnRzIiwiLi4vc3JjL3V0aWxzL3ZlcnNpb24udHMiLCIuLi9zcmMvdXRpbHMvbWV0YWRhdGEudHMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaWRlbnRpdHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3JlSnNEYXRhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b1NvdXJjZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc05hdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcHBseS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Nob3J0T3V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9jb25zdGFudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2RlZmluZVByb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnblZhbHVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJSZXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQXNzaWduZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVDcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fSGFzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzb2NJbmRleE9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVDbGVhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE1hcERhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZURlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZVNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZW1vaXplLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWVtb2l6ZUNhcHBlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0cmluZ1RvUGF0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0UGF0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvS2V5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZ2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlQdXNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNGbGF0dGVuYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGbGF0dGVuLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mbGF0dGVuLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZmxhdFJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2xpY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TdGFjay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZUJ1ZmZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5RmlsdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRTeW1ib2xzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weVN5bWJvbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRTeW1ib2xzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5U3ltYm9sc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldEFsbEtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0QWxsS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19VaW50OEFycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVJlZ0V4cC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVUeXBlZEFycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQnlUYWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1NldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbG9uZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldENhY2hlQWRkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TZXRDYWNoZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U29tZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NhY2hlSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxBcnJheXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBUb0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9BcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VxdWFsQnlUYWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbE9iamVjdHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNFcXVhbERlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNFcXVhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc01hdGNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWF0Y2hEYXRhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWF0Y2hlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUl0ZXJhdGVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQmFzZUZvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRm9yT3duLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQmFzZUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2FmZUdldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9QbGFpbk9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNZXJnZURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2xhc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcGFyZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc05pbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVyZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL25lZ2F0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbnNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2N1c3RvbU9taXRDbG9uZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvb21pdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUGlja0J5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9waWNrQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29taXRCeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTb3J0QnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU9yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUGljay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcGljay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc29ydEJ5LmpzIiwiLi4vc3JjL3V0aWxzL2NvbmZpZy50cyIsIi4uL3NyYy91dGlscy9jYXJnby50cyIsIi4uL3NyYy91dGlscy90eXBlZ2VuLnRzIiwiLi4vc3JjL3V0aWxzL3JlYWQtY29uZmlnLnRzIiwiLi4vc3JjL2FwaS9hcnRpZmFjdHMudHMiLCIuLi9zcmMvYXBpL3RlbXBsYXRlcy9qcy1iaW5kaW5nLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvbG9hZC13YXNpLXRlbXBsYXRlLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvd2FzaS13b3JrZXItdGVtcGxhdGUudHMiLCIuLi9zcmMvYXBpL2J1aWxkLnRzIiwiLi4vc3JjL2RlZi9jcmVhdGUtbnBtLWRpcnMudHMiLCIuLi9zcmMvYXBpL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9kZWYvbmV3LnRzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9zdHJpbmdpZnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGpzci9zdGRfX2NvbGxlY3Rpb25zL191dGlscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AanNyL3N0ZF9fY29sbGVjdGlvbnMvZGVlcF9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac3RkL3RvbWwvX3BhcnNlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac3RkL3RvbWwvcGFyc2UuanMiLCIuLi9zcmMvZGVmL3JlbmFtZS50cyIsIi4uL3NyYy9hcGkvcmVuYW1lLnRzIiwiLi4vc3JjL2FwaS9uZXcudHMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVzdC9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVzdC9ub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL3JlZ2lzdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3Jlc3Qvbm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9hZGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVzdC9ub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL3JlbW92ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L25vZGVfbW9kdWxlcy9iZWZvcmUtYWZ0ZXItaG9vay9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9lbmRwb2ludC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9mYXN0LWNvbnRlbnQtdHlwZS1wYXJzZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0LWVycm9yL2Rpc3Qtc3JjL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3Jlc3Qvbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3JlcXVlc3QvZGlzdC1idW5kbGUvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVzdC9ub2RlX21vZHVsZXMvQG9jdG9raXQvZ3JhcGhxbC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9hdXRoLXRva2VuL2Rpc3QtYnVuZGxlL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3Jlc3Qvbm9kZV9tb2R1bGVzL0BvY3Rva2l0L2NvcmUvZGlzdC1zcmMvdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9jb3JlL2Rpc3Qtc3JjL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3Jlc3Qvbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3BsdWdpbi1yZXF1ZXN0LWxvZy9kaXN0LXNyYy92ZXJzaW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3Jlc3Qvbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3BsdWdpbi1yZXF1ZXN0LWxvZy9kaXN0LXNyYy9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9wbHVnaW4tcGFnaW5hdGUtcmVzdC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9wbHVnaW4tcmVzdC1lbmRwb2ludC1tZXRob2RzL2Rpc3Qtc3JjL3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVzdC9ub2RlX21vZHVsZXMvQG9jdG9raXQvcGx1Z2luLXJlc3QtZW5kcG9pbnQtbWV0aG9kcy9kaXN0LXNyYy9nZW5lcmF0ZWQvZW5kcG9pbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3Jlc3Qvbm9kZV9tb2R1bGVzL0BvY3Rva2l0L3BsdWdpbi1yZXN0LWVuZHBvaW50LW1ldGhvZHMvZGlzdC1zcmMvZW5kcG9pbnRzLXRvLW1ldGhvZHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVzdC9ub2RlX21vZHVsZXMvQG9jdG9raXQvcGx1Z2luLXJlc3QtZW5kcG9pbnQtbWV0aG9kcy9kaXN0LXNyYy9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXN0L2Rpc3Qtc3JjL3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVzdC9kaXN0LXNyYy9pbmRleC5qcyIsIi4uL3NyYy9kZWYvcHJlLXB1Ymxpc2gudHMiLCIuLi9zcmMvZGVmL3ZlcnNpb24udHMiLCIuLi9zcmMvYXBpL3ZlcnNpb24udHMiLCIuLi9zcmMvYXBpL3ByZS1wdWJsaXNoLnRzIiwiLi4vc3JjL2RlZi91bml2ZXJzYWxpemUudHMiLCIuLi9zcmMvYXBpL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUFydGlmYWN0c0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1snYXJ0aWZhY3RzJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIG5wbSBwYWNrYWdlcyBhbmQgcmVhZHkgdG8gcHVibGlzaCcsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgb3V0cHV0RGlyID0gT3B0aW9uLlN0cmluZygnLS1vdXRwdXQtZGlyLC1vLC1kJywgJy4vYXJ0aWZhY3RzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgYnVpbGRPdXRwdXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWJ1aWxkLW91dHB1dC1kaXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgYnVpbGQgb3V0cHV0IGRpciwgb25seSBuZWVkZWQgd2hlbiB0YXJnZXRzIGNvbnRhaW5zIGB3YXNtMzItd2FzaS0qYCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBvdXRwdXREaXI6IHRoaXMub3V0cHV0RGlyLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIGJ1aWxkT3V0cHV0RGlyOiB0aGlzLmJ1aWxkT3V0cHV0RGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYXJ0aWZhY3RzIGZyb20gR2l0aHViIEFjdGlvbnMgaW50byBucG0gcGFja2FnZXMgYW5kIHJlYWR5IHRvIHB1Ymxpc2hcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdHNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kXG4gICAqXG4gICAqIEBkZWZhdWx0ICcuL2FydGlmYWN0cydcbiAgICovXG4gIG91dHB1dERpcj86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGJ1aWxkIG91dHB1dCBkaXIsIG9ubHkgbmVlZGVkIHdoZW4gdGFyZ2V0cyBjb250YWlucyBgd2FzbTMyLXdhc2ktKmBcbiAgICovXG4gIGJ1aWxkT3V0cHV0RGlyPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zKG9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBvdXRwdXREaXI6ICcuL2FydGlmYWN0cycsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuaW1wb3J0IHJhd0RlYnVnIGZyb20gJ2RlYnVnJ1xuXG4vLyBkZWJ1ZygnJWknLCAnVGhpcyBpcyBhbiBpbmZvJylcbnJhd0RlYnVnLmZvcm1hdHRlcnMuaSA9ICh2KSA9PiB7XG4gIHJldHVybiBjb2xvcnMuZ3JlZW4odilcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ2RlYnVnJyB7XG4gIGludGVyZmFjZSBEZWJ1Z2dlciB7XG4gICAgaW5mbzogdHlwZW9mIGNvbnNvbGUuZXJyb3JcbiAgICB3YXJuOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICAgIGVycm9yOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWJ1Z0ZhY3RvcnkgPSAobmFtZXNwYWNlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgZGVidWcgPSByYXdEZWJ1ZyhgbmFwaToke25hbWVzcGFjZX1gKVxuXG4gIGRlYnVnLmluZm8gPSAoLi4uYXJnczogYW55W10pID0+XG4gICAgY29uc29sZS5lcnJvcihjb2xvcnMuYmxhY2soY29sb3JzLmJnR3JlZW4oJyBJTkZPICcpKSwgLi4uYXJncylcbiAgZGVidWcud2FybiA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKGNvbG9ycy5ibGFjayhjb2xvcnMuYmdZZWxsb3coJyBXQVJOSU5HICcpKSwgLi4uYXJncylcbiAgZGVidWcuZXJyb3IgPSAoLi4uYXJnczogYW55W10pID0+XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGNvbG9ycy53aGl0ZShjb2xvcnMuYmdSZWQoJyBFUlJPUiAnKSksXG4gICAgICAuLi5hcmdzLm1hcCgoYXJnKSA9PlxuICAgICAgICBhcmcgaW5zdGFuY2VvZiBFcnJvciA/IChhcmcuc3RhY2sgPz8gYXJnLm1lc3NhZ2UpIDogYXJnLFxuICAgICAgKSxcbiAgICApXG5cbiAgcmV0dXJuIGRlYnVnXG59XG5leHBvcnQgY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3V0aWxzJylcbiIsIntcbiAgXCJuYW1lXCI6IFwiQG5hcGktcnMvY2xpXCIsXG4gIFwidmVyc2lvblwiOiBcIjMuMC40XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDbGkgdG9vbHMgZm9yIG5hcGktcnNcIixcbiAgXCJhdXRob3JcIjogXCJMb25nWWluYW4gPGx5bndla2xtQGdtYWlsLmNvbT5cIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL25hcGktcnNcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwidHlwZVwiOiBcIm1vZHVsZVwiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49IDE2XCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwibmFwaVwiOiBcIi4vZGlzdC9jbGkuanNcIixcbiAgICBcIm5hcGktcmF3XCI6IFwiLi9jbGkubWpzXCJcbiAgfSxcbiAgXCJtYWluXCI6IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICBcIm1vZHVsZVwiOiBcIi4vZGlzdC9pbmRleC5qc1wiLFxuICBcImV4cG9ydHNcIjoge1xuICAgIFwiLlwiOiB7XG4gICAgICBcImltcG9ydFwiOiB7XG4gICAgICAgIFwidHlwZXNcIjogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCIuL2Rpc3QvaW5kZXguanNcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZVwiOiB7XG4gICAgICAgIFwidHlwZXNcIjogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCIuL2Rpc3QvaW5kZXguY2pzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiLi9wYWNrYWdlLmpzb25cIjoge1xuICAgICAgXCJpbXBvcnRcIjogXCIuL3BhY2thZ2UuanNvblwiLFxuICAgICAgXCJyZXF1aXJlXCI6IFwiLi9wYWNrYWdlLmpzb25cIlxuICAgIH1cbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJkaXN0XCIsXG4gICAgXCJzcmNcIlxuICBdLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImNsaVwiLFxuICAgIFwicnVzdFwiLFxuICAgIFwibmFwaVwiLFxuICAgIFwibi1hcGlcIixcbiAgICBcIm5vZGUtYXBpXCIsXG4gICAgXCJub2RlLWFkZG9uXCIsXG4gICAgXCJuZW9uXCJcbiAgXSxcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiTG9uZ1lpbmFuXCIsXG4gICAgICBcImVtYWlsXCI6IFwibHlud2VrbG1AZ21haWwuY29tXCIsXG4gICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0Jyb29vb29va2x5blwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJmb3JlaGFsb1wiLFxuICAgICAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9mb3JlaGFsb1wiXG4gICAgfVxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL25hcGktcnMuZ2l0XCJcbiAgfSxcbiAgXCJwdWJsaXNoQ29uZmlnXCI6IHtcbiAgICBcInJlZ2lzdHJ5XCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXCIsXG4gICAgXCJhY2Nlc3NcIjogXCJwdWJsaWNcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1ycy9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAaW5xdWlyZXIvcHJvbXB0c1wiOiBcIl43LjQuMFwiLFxuICAgIFwiQG5hcGktcnMvY3Jvc3MtdG9vbGNoYWluXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJAbmFwaS1ycy93YXNtLXRvb2xzXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJAb2N0b2tpdC9yZXN0XCI6IFwiXjIyLjAuMFwiLFxuICAgIFwiY2xpcGFuaW9uXCI6IFwiXjQuMC4wLXJjLjRcIixcbiAgICBcImNvbG9yZXR0ZVwiOiBcIl4yLjAuMjBcIixcbiAgICBcImRlYnVnXCI6IFwiXjQuNC4wXCIsXG4gICAgXCJlbW5hcGlcIjogXCJeMS40LjBcIixcbiAgICBcImZpbmQtdXBcIjogXCJeNy4wLjBcIixcbiAgICBcImpzLXlhbWxcIjogXCJeNC4xLjBcIixcbiAgICBcImxvZGFzaC1lc1wiOiBcIl40LjE3LjIxXCIsXG4gICAgXCJzZW12ZXJcIjogXCJeNy43LjFcIixcbiAgICBcInR5cGFuaW9uXCI6IFwiXjMuMTQuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBlbW5hcGkvY29yZVwiOiBcIl4xLjQuMFwiLFxuICAgIFwiQGVtbmFwaS9ydW50aW1lXCI6IFwiXjEuNC4wXCIsXG4gICAgXCJAb3hjLW5vZGUvY29yZVwiOiBcIl4wLjAuMzBcIixcbiAgICBcIkBzdGQvdG9tbFwiOiBcIm5wbTpAanNyL3N0ZF9fdG9tbEBeMS4wLjhcIixcbiAgICBcIkB0eXBlcy9kZWJ1Z1wiOiBcIl40LjEuMTJcIixcbiAgICBcIkB0eXBlcy9pbnF1aXJlclwiOiBcIl45LjAuN1wiLFxuICAgIFwiQHR5cGVzL2pzLXlhbWxcIjogXCJeNC4wLjlcIixcbiAgICBcIkB0eXBlcy9sb2Rhc2gtZXNcIjogXCJeNC4xNy4xMlwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMjIuMTMuMTZcIixcbiAgICBcIkB0eXBlcy9zZW12ZXJcIjogXCJeNy43LjBcIixcbiAgICBcImF2YVwiOiBcIl42LjIuMFwiLFxuICAgIFwiZW52LXBhdGhzXCI6IFwiXjMuMC4wXCIsXG4gICAgXCJwcmV0dGllclwiOiBcIl4zLjUuM1wiLFxuICAgIFwicm9sbGRvd25cIjogXCJsYXRlc3RcIixcbiAgICBcInRzbGliXCI6IFwiXjIuOC4xXCIsXG4gICAgXCJ0eXBlc2NyaXB0XCI6IFwiXjUuOC4yXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBlbW5hcGkvcnVudGltZVwiOiBcIl4xLjEuMFwiLFxuICAgIFwiZW1uYXBpXCI6IFwiXjEuMS4wXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzTWV0YVwiOiB7XG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcImVtbmFwaVwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9XG4gIH0sXG4gIFwiZnVuZGluZ1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0aHViXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc3BvbnNvcnMvQnJvb29vb29rbHluXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImNsZWFuXCI6IFwibm9kZSAtLWltcG9ydCBAb3hjLW5vZGUvY29yZS9yZWdpc3RlciAuL2NsZWFuLnRzXCIsXG4gICAgXCJjb2RlZ2VuXCI6IFwibm9kZSAtLWltcG9ydCBAb3hjLW5vZGUvY29yZS9yZWdpc3RlciAuL2NvZGVnZW4vaW5kZXgudHNcIixcbiAgICBcImJ1aWxkXCI6IFwidHNjICYmIHlhcm4gY2xlYW4gJiYgcm9sbGRvd24gLWMgcm9sbGRvd24uY29uZmlnLmpzXCIsXG4gICAgXCJ0ZXN0XCI6IFwibm9kZSAtLWltcG9ydCBAb3hjLW5vZGUvY29yZS9yZWdpc3RlciAuLi9ub2RlX21vZHVsZXMvYXZhL2VudHJ5cG9pbnRzL2NsaS5tanNcIlxuICB9LFxuICBcImF2YVwiOiB7XG4gICAgXCJleHRlbnNpb25zXCI6IHtcbiAgICAgIFwidHNcIjogXCJtb2R1bGVcIlxuICAgIH0sXG4gICAgXCJ0aW1lb3V0XCI6IFwiMW1cIixcbiAgICBcImZpbGVzXCI6IFtcbiAgICAgIFwiKiovX190ZXN0c19fLyoqLyouc3BlYy50c1wiLFxuICAgICAgXCJlMmUvKiovKi5zcGVjLnRzXCJcbiAgICBdXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjUyMWI1Nzc0YWE4OWYxYTdjODA3YTZkZGJhNTA5Y2U0Mzk3M2Y2MjRcIlxufVxuIiwiaW1wb3J0IHtcbiAgcmVhZEZpbGUsXG4gIHdyaXRlRmlsZSxcbiAgY29weUZpbGUsXG4gIG1rZGlyLFxuICB1bmxpbmssXG4gIHN0YXQsXG4gIHJlYWRkaXIsXG59IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICdub2RlOnV0aWwnXG5cbmltcG9ydCBwa2dKc29uIGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbicgd2l0aCB7IHR5cGU6ICdqc29uJyB9XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vbG9nLmpzJ1xuXG5leHBvcnQgY29uc3QgcmVhZEZpbGVBc3luYyA9IHByb21pc2lmeShyZWFkRmlsZSlcbmV4cG9ydCBjb25zdCB3cml0ZUZpbGVBc3luYyA9IHByb21pc2lmeSh3cml0ZUZpbGUpXG5leHBvcnQgY29uc3QgdW5saW5rQXN5bmMgPSBwcm9taXNpZnkodW5saW5rKVxuZXhwb3J0IGNvbnN0IGNvcHlGaWxlQXN5bmMgPSBwcm9taXNpZnkoY29weUZpbGUpXG5leHBvcnQgY29uc3QgbWtkaXJBc3luYyA9IHByb21pc2lmeShta2RpcilcbmV4cG9ydCBjb25zdCBzdGF0QXN5bmMgPSBwcm9taXNpZnkoc3RhdClcbmV4cG9ydCBjb25zdCByZWFkZGlyQXN5bmMgPSBwcm9taXNpZnkocmVhZGRpcilcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbGVFeGlzdHMocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IGV4aXN0cyA9IGF3YWl0IHN0YXRBc3luYyhwYXRoKVxuICAgIC50aGVuKCgpID0+IHRydWUpXG4gICAgLmNhdGNoKCgpID0+IGZhbHNlKVxuICByZXR1cm4gZXhpc3RzXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXJFeGlzdHNBc3luYyhwYXRoOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHN0YXRBc3luYyhwYXRoKVxuICAgIHJldHVybiBzdGF0cy5pc0RpcmVjdG9yeSgpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrPE8sIEsgZXh0ZW5kcyBrZXlvZiBPPihvOiBPLCAuLi5rZXlzOiBLW10pOiBQaWNrPE8sIEs+IHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gb1trZXldXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSBhcyBPKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUGFja2FnZUpzb24oXG4gIHBhdGg6IHN0cmluZyxcbiAgcGFydGlhbDogUmVjb3JkPHN0cmluZywgYW55Pixcbikge1xuICBjb25zdCBleGlzdHMgPSBhd2FpdCBmaWxlRXhpc3RzKHBhdGgpXG4gIGlmICghZXhpc3RzKSB7XG4gICAgZGVidWcoYEZpbGUgbm90IGV4aXN0cyAke3BhdGh9YClcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvbGQgPSBKU09OLnBhcnNlKGF3YWl0IHJlYWRGaWxlQXN5bmMocGF0aCwgJ3V0ZjgnKSlcbiAgYXdhaXQgd3JpdGVGaWxlQXN5bmMocGF0aCwgSlNPTi5zdHJpbmdpZnkoeyAuLi5vbGQsIC4uLnBhcnRpYWwgfSwgbnVsbCwgMikpXG59XG5cbmV4cG9ydCBjb25zdCBDTElfVkVSU0lPTiA9IHBrZ0pzb24udmVyc2lvblxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5cbmV4cG9ydCB0eXBlIFBsYXRmb3JtID0gTm9kZUpTLlBsYXRmb3JtIHwgJ3dhc20nIHwgJ3dhc2knIHwgJ29wZW5oYXJtb255J1xuXG5leHBvcnQgY29uc3QgVU5JVkVSU0FMX1RBUkdFVFMgPSB7XG4gICd1bml2ZXJzYWwtYXBwbGUtZGFyd2luJzogWydhYXJjaDY0LWFwcGxlLWRhcndpbicsICd4ODZfNjQtYXBwbGUtZGFyd2luJ10sXG59IGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBBVkFJTEFCTEVfVEFSR0VUUyA9IFtcbiAgJ2FhcmNoNjQtYXBwbGUtZGFyd2luJyxcbiAgJ2FhcmNoNjQtbGludXgtYW5kcm9pZCcsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtZ251JyxcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1vaG9zJyxcbiAgJ2FhcmNoNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nLFxuICAneDg2XzY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1vaG9zJyxcbiAgJ3g4Nl82NC11bmtub3duLWZyZWVic2QnLFxuICAnaTY4Ni1wYy13aW5kb3dzLW1zdmMnLFxuICAnYXJtdjctdW5rbm93bi1saW51eC1nbnVlYWJpaGYnLFxuICAnYXJtdjctdW5rbm93bi1saW51eC1tdXNsZWFiaWhmJyxcbiAgJ2FybXY3LWxpbnV4LWFuZHJvaWRlYWJpJyxcbiAgJ3VuaXZlcnNhbC1hcHBsZS1kYXJ3aW4nLFxuICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JyxcbiAgJ3Bvd2VycGM2NGxlLXVua25vd24tbGludXgtZ251JyxcbiAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JyxcbiAgJ3dhc20zMi13YXNpLXByZXZpZXcxLXRocmVhZHMnLFxuICAnd2FzbTMyLXdhc2lwMS10aHJlYWRzJyxcbl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgVGFyZ2V0VHJpcGxlID0gKHR5cGVvZiBBVkFJTEFCTEVfVEFSR0VUUylbbnVtYmVyXVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UQVJHRVRTID0gW1xuICAneDg2XzY0LWFwcGxlLWRhcndpbicsXG4gICdhYXJjaDY0LWFwcGxlLWRhcndpbicsXG4gICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LWdudScsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBUQVJHRVRfTElOS0VSOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2wnOiAnYWFyY2g2NC1saW51eC1tdXNsLWdjYycsXG4gICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnOiAncmlzY3Y2NC1saW51eC1nbnUtZ2NjJyxcbiAgJ3Bvd2VycGM2NGxlLXVua25vd24tbGludXgtZ251JzogJ3Bvd2VycGM2NGxlLWxpbnV4LWdudS1nY2MnLFxuICAnczM5MHgtdW5rbm93bi1saW51eC1nbnUnOiAnczM5MHgtbGludXgtZ251LWdjYycsXG59XG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19hcmNoXG50eXBlIE5vZGVKU0FyY2ggPVxuICB8ICdhcm0nXG4gIHwgJ2FybTY0J1xuICB8ICdpYTMyJ1xuICB8ICdtaXBzJ1xuICB8ICdtaXBzZWwnXG4gIHwgJ3BwYydcbiAgfCAncHBjNjQnXG4gIHwgJ3Jpc2N2NjQnXG4gIHwgJ3MzOTAnXG4gIHwgJ3MzOTB4J1xuICB8ICd4MzInXG4gIHwgJ3g2NCdcbiAgfCAndW5pdmVyc2FsJ1xuICB8ICd3YXNtMzInXG5cbmNvbnN0IENwdVRvTm9kZUFyY2g6IFJlY29yZDxzdHJpbmcsIE5vZGVKU0FyY2g+ID0ge1xuICB4ODZfNjQ6ICd4NjQnLFxuICBhYXJjaDY0OiAnYXJtNjQnLFxuICBpNjg2OiAnaWEzMicsXG4gIGFybXY3OiAnYXJtJyxcbiAgcmlzY3Y2NGdjOiAncmlzY3Y2NCcsXG4gIHBvd2VycGM2NGxlOiAncHBjNjQnLFxufVxuXG5leHBvcnQgY29uc3QgTm9kZUFyY2hUb0NwdTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgeDY0OiAneDg2XzY0JyxcbiAgYXJtNjQ6ICdhYXJjaDY0JyxcbiAgaWEzMjogJ2k2ODYnLFxuICBhcm06ICdhcm12NycsXG4gIHJpc2N2NjQ6ICdyaXNjdjY0Z2MnLFxuICBwcGM2NDogJ3Bvd2VycGM2NGxlJyxcbn1cblxuY29uc3QgU3lzVG9Ob2RlUGxhdGZvcm06IFJlY29yZDxzdHJpbmcsIFBsYXRmb3JtPiA9IHtcbiAgbGludXg6ICdsaW51eCcsXG4gIGZyZWVic2Q6ICdmcmVlYnNkJyxcbiAgZGFyd2luOiAnZGFyd2luJyxcbiAgd2luZG93czogJ3dpbjMyJyxcbiAgb2hvczogJ29wZW5oYXJtb255Jyxcbn1cblxuZXhwb3J0IGNvbnN0IFVuaUFyY2hzQnlQbGF0Zm9ybTogUGFydGlhbDxSZWNvcmQ8UGxhdGZvcm0sIE5vZGVKU0FyY2hbXT4+ID0ge1xuICBkYXJ3aW46IFsneDY0JywgJ2FybTY0J10sXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFyZ2V0IHtcbiAgdHJpcGxlOiBzdHJpbmdcbiAgcGxhdGZvcm1BcmNoQUJJOiBzdHJpbmdcbiAgcGxhdGZvcm06IFBsYXRmb3JtXG4gIGFyY2g6IE5vZGVKU0FyY2hcbiAgYWJpOiBzdHJpbmcgfCBudWxsXG59XG5cbi8qKlxuICogQSB0cmlwbGUgaXMgYSBzcGVjaWZpYyBmb3JtYXQgZm9yIHNwZWNpZnlpbmcgYSB0YXJnZXQgYXJjaGl0ZWN0dXJlLlxuICogVHJpcGxlcyBtYXkgYmUgcmVmZXJyZWQgdG8gYXMgYSB0YXJnZXQgdHJpcGxlIHdoaWNoIGlzIHRoZSBhcmNoaXRlY3R1cmUgZm9yIHRoZSBhcnRpZmFjdCBwcm9kdWNlZCwgYW5kIHRoZSBob3N0IHRyaXBsZSB3aGljaCBpcyB0aGUgYXJjaGl0ZWN0dXJlIHRoYXQgdGhlIGNvbXBpbGVyIGlzIHJ1bm5pbmcgb24uXG4gKiBUaGUgZ2VuZXJhbCBmb3JtYXQgb2YgdGhlIHRyaXBsZSBpcyBgPGFyY2g+PHN1Yj4tPHZlbmRvcj4tPHN5cz4tPGFiaT5gIHdoZXJlOlxuICogICAtIGBhcmNoYCA9IFRoZSBiYXNlIENQVSBhcmNoaXRlY3R1cmUsIGZvciBleGFtcGxlIGB4ODZfNjRgLCBgaTY4NmAsIGBhcm1gLCBgdGh1bWJgLCBgbWlwc2AsIGV0Yy5cbiAqICAgLSBgc3ViYCA9IFRoZSBDUFUgc3ViLWFyY2hpdGVjdHVyZSwgZm9yIGV4YW1wbGUgYGFybWAgaGFzIGB2N2AsIGB2N3NgLCBgdjV0ZWAsIGV0Yy5cbiAqICAgLSBgdmVuZG9yYCA9IFRoZSB2ZW5kb3IsIGZvciBleGFtcGxlIGB1bmtub3duYCwgYGFwcGxlYCwgYHBjYCwgYG52aWRpYWAsIGV0Yy5cbiAqICAgLSBgc3lzYCA9IFRoZSBzeXN0ZW0gbmFtZSwgZm9yIGV4YW1wbGUgYGxpbnV4YCwgYHdpbmRvd3NgLCBgZGFyd2luYCwgZXRjLiBub25lIGlzIHR5cGljYWxseSB1c2VkIGZvciBiYXJlLW1ldGFsIHdpdGhvdXQgYW4gT1MuXG4gKiAgIC0gYGFiaWAgPSBUaGUgQUJJLCBmb3IgZXhhbXBsZSBgZ251YCwgYGFuZHJvaWRgLCBgZWFiaWAsIGV0Yy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVHJpcGxlKHJhd1RyaXBsZTogc3RyaW5nKTogVGFyZ2V0IHtcbiAgaWYgKFxuICAgIHJhd1RyaXBsZSA9PT0gJ3dhc20zMi13YXNpJyB8fFxuICAgIHJhd1RyaXBsZSA9PT0gJ3dhc20zMi13YXNpLXByZXZpZXcxLXRocmVhZHMnIHx8XG4gICAgcmF3VHJpcGxlLnN0YXJ0c1dpdGgoJ3dhc20zMi13YXNpcCcpXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmlwbGU6IHJhd1RyaXBsZSxcbiAgICAgIHBsYXRmb3JtQXJjaEFCSTogJ3dhc20zMi13YXNpJyxcbiAgICAgIHBsYXRmb3JtOiAnd2FzaScsXG4gICAgICBhcmNoOiAnd2FzbTMyJyxcbiAgICAgIGFiaTogJ3dhc2knLFxuICAgIH1cbiAgfVxuICBjb25zdCB0cmlwbGUgPSByYXdUcmlwbGUuZW5kc1dpdGgoJ2VhYmknKVxuICAgID8gYCR7cmF3VHJpcGxlLnNsaWNlKDAsIC00KX0tZWFiaWBcbiAgICA6IHJhd1RyaXBsZVxuICBjb25zdCB0cmlwbGVzID0gdHJpcGxlLnNwbGl0KCctJylcbiAgbGV0IGNwdTogc3RyaW5nXG4gIGxldCBzeXM6IHN0cmluZ1xuICBsZXQgYWJpOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBpZiAodHJpcGxlcy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyBhYXJjaDY0LWZ1Y2hzaWFcbiAgICAvLyBeIGNwdSAgIF4gc3lzXG4gICAgO1tjcHUsIHN5c10gPSB0cmlwbGVzXG4gIH0gZWxzZSB7XG4gICAgLy8gYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2xcbiAgICAvLyBeIGNwdSAgICAgICAgICAgXiBzeXMgXiBhYmlcbiAgICAvLyBhYXJjaDY0LWFwcGxlLWRhcndpblxuICAgIC8vIF4gY3B1ICAgICAgICAgXiBzeXMgIChhYmkgaXMgTm9uZSlcbiAgICA7W2NwdSwgLCBzeXMsIGFiaSA9IG51bGxdID0gdHJpcGxlc1xuICB9XG5cbiAgY29uc3QgcGxhdGZvcm0gPSBTeXNUb05vZGVQbGF0Zm9ybVtzeXNdID8/IChzeXMgYXMgUGxhdGZvcm0pXG4gIGNvbnN0IGFyY2ggPSBDcHVUb05vZGVBcmNoW2NwdV0gPz8gKGNwdSBhcyBOb2RlSlNBcmNoKVxuXG4gIGlmIChyYXdUcmlwbGUuaW5jbHVkZXMoJ29ob3MnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmlwbGU6IHJhd1RyaXBsZSxcbiAgICAgIHBsYXRmb3JtQXJjaEFCSTogYGxpbnV4LSR7YXJjaH0tb2hvc2AsXG4gICAgICBwbGF0Zm9ybTogJ29wZW5oYXJtb255JyxcbiAgICAgIGFyY2gsXG4gICAgICBhYmk6IG51bGwsXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgcGxhdGZvcm1BcmNoQUJJOiBhYmkgPyBgJHtwbGF0Zm9ybX0tJHthcmNofS0ke2FiaX1gIDogYCR7cGxhdGZvcm19LSR7YXJjaH1gLFxuICAgIHBsYXRmb3JtLFxuICAgIGFyY2gsXG4gICAgYWJpLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTeXN0ZW1EZWZhdWx0VGFyZ2V0KCk6IFRhcmdldCB7XG4gIGNvbnN0IGhvc3QgPSBleGVjU3luYyhgcnVzdGMgLXZWYCwge1xuICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gIH0pXG4gICAgLnRvU3RyaW5nKCd1dGY4JylcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLmZpbmQoKGxpbmUpID0+IGxpbmUuc3RhcnRzV2l0aCgnaG9zdDogJykpXG4gIGNvbnN0IHRyaXBsZSA9IGhvc3Q/LnNsaWNlKCdob3N0OiAnLmxlbmd0aClcbiAgaWYgKCF0cmlwbGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IHBhcnNlIHRhcmdldCB0cmlwbGUgZnJvbSBob3N0YClcbiAgfVxuICByZXR1cm4gcGFyc2VUcmlwbGUodHJpcGxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFyZ2V0TGlua2VyKHRhcmdldDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIFRBUkdFVF9MSU5LRVJbdGFyZ2V0XVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG9FbnZWYXIodGFyZ2V0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdGFyZ2V0LnJlcGxhY2UoLy0vZywgJ18nKS50b1VwcGVyQ2FzZSgpXG59XG4iLCJleHBvcnQgZW51bSBOYXBpVmVyc2lvbiB7XG4gIE5hcGkxID0gMSxcbiAgTmFwaTIsXG4gIE5hcGkzLFxuICBOYXBpNCxcbiAgTmFwaTUsXG4gIE5hcGk2LFxuICBOYXBpNyxcbiAgTmFwaTgsXG4gIE5hcGk5LFxufVxuXG4vLy8gYmVjYXVzZSBub2RlIHN1cHBvcnQgbmV3IG5hcGkgdmVyc2lvbiBpbiBzb21lIG1pbm9yIHZlcnNpb24gdXBkYXRlcywgc28gd2UgbWlnaHQgbWVldCBzdWNoIHNpdHVhdGlvbjpcbi8vLyBgbm9kZSB2MTAuMjAuMGAgc3VwcG9ydHMgYG5hcGk1YCBhbmQgYG5hcGk2YCwgYnV0IGBub2RlIHYxMi4wLjBgIG9ubHkgc3VwcG9ydCBgbmFwaTRgLFxuLy8vIGJ5IHdoaWNoLCB3ZSBjYW4gbm90IHRlbGwgZGlyZWN0bHkgbmFwaSB2ZXJzaW9uIHN1cHBvcnRsZXNzIGZyb20gbm9kZSB2ZXJzaW9uIGRpcmVjdGx5LlxuY29uc3QgTkFQSV9WRVJTSU9OX01BVFJJWCA9IG5ldyBNYXA8TmFwaVZlcnNpb24sIHN0cmluZz4oW1xuICBbTmFwaVZlcnNpb24uTmFwaTEsICc4LjYuMCB8IDkuMC4wIHwgMTAuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpMiwgJzguMTAuMCB8IDkuMy4wIHwgMTAuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpMywgJzYuMTQuMiB8IDguMTEuMiB8IDkuMTEuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTQsICcxMC4xNi4wIHwgMTEuOC4wIHwgMTIuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNSwgJzEwLjE3LjAgfCAxMi4xMS4wIHwgMTMuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNiwgJzEwLjIwLjAgfCAxMi4xNy4wIHwgMTQuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNywgJzEwLjIzLjAgfCAxMi4xOS4wIHwgMTQuMTIuMCB8IDE1LjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTgsICcxMi4yMi4wIHwgMTQuMTcuMCB8IDE1LjEyLjAgfCAxNi4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk5LCAnMTguMTcuMCB8IDIwLjMuMCB8IDIxLjEuMCddLFxuXSlcblxuaW50ZXJmYWNlIE5vZGVWZXJzaW9uIHtcbiAgbWFqb3I6IG51bWJlclxuICBtaW5vcjogbnVtYmVyXG4gIHBhdGNoOiBudW1iZXJcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlVmVyc2lvbih2OiBzdHJpbmcpOiBOb2RlVmVyc2lvbiB7XG4gIGNvbnN0IG1hdGNoZXMgPSB2Lm1hdGNoKC92PyhbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKS9pKVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHZlcnNpb24gbnVtYmVyOiAnICsgdilcbiAgfVxuXG4gIGNvbnN0IFssIG1ham9yLCBtaW5vciwgcGF0Y2hdID0gbWF0Y2hlc1xuXG4gIHJldHVybiB7XG4gICAgbWFqb3I6IHBhcnNlSW50KG1ham9yKSxcbiAgICBtaW5vcjogcGFyc2VJbnQobWlub3IpLFxuICAgIHBhdGNoOiBwYXJzZUludChwYXRjaCksXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWlyZWROb2RlVmVyc2lvbnMobmFwaVZlcnNpb246IE5hcGlWZXJzaW9uKTogTm9kZVZlcnNpb25bXSB7XG4gIGNvbnN0IHJlcXVpcmVtZW50ID0gTkFQSV9WRVJTSU9OX01BVFJJWC5nZXQobmFwaVZlcnNpb24pXG5cbiAgaWYgKCFyZXF1aXJlbWVudCkge1xuICAgIHJldHVybiBbcGFyc2VOb2RlVmVyc2lvbignMTAuMC4wJyldXG4gIH1cblxuICByZXR1cm4gcmVxdWlyZW1lbnQuc3BsaXQoJ3wnKS5tYXAocGFyc2VOb2RlVmVyc2lvbilcbn1cblxuZnVuY3Rpb24gdG9FbmdpbmVSZXF1aXJlbWVudCh2ZXJzaW9uczogTm9kZVZlcnNpb25bXSk6IHN0cmluZyB7XG4gIGNvbnN0IHJlcXVpcmVtZW50czogc3RyaW5nW10gPSBbXVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgbGV0IHJlcSA9ICcnXG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIGNvbnN0IGxhc3RWZXJzaW9uID0gdmVyc2lvbnNbaSAtIDFdXG4gICAgICByZXEgKz0gYDwgJHtsYXN0VmVyc2lvbi5tYWpvciArIDF9YFxuICAgIH1cblxuICAgIHJlcSArPSBgJHtpID09PSAwID8gJycgOiAnIHx8ICd9Pj0gJHt2Lm1ham9yfS4ke3YubWlub3J9LiR7di5wYXRjaH1gXG4gICAgcmVxdWlyZW1lbnRzLnB1c2gocmVxKVxuICB9KVxuXG4gIHJldHVybiByZXF1aXJlbWVudHMuam9pbignICcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXBpRW5naW5lUmVxdWlyZW1lbnQobmFwaVZlcnNpb246IE5hcGlWZXJzaW9uKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRvRW5naW5lUmVxdWlyZW1lbnQocmVxdWlyZWROb2RlVmVyc2lvbnMobmFwaVZlcnNpb24pKVxufVxuIiwiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcydcblxuZXhwb3J0IHR5cGUgQ3JhdGVUYXJnZXRLaW5kID1cbiAgfCAnYmluJ1xuICB8ICdleGFtcGxlJ1xuICB8ICd0ZXN0J1xuICB8ICdiZW5jaCdcbiAgfCAnbGliJ1xuICB8ICdybGliJ1xuICB8ICdjZHlsaWInXG4gIHwgJ2N1c3RvbS1idWlsZCdcblxuZXhwb3J0IGludGVyZmFjZSBDcmF0ZVRhcmdldCB7XG4gIG5hbWU6IHN0cmluZ1xuICBraW5kOiBDcmF0ZVRhcmdldEtpbmRbXVxuICBjcmF0ZV90eXBlczogQ3JhdGVUYXJnZXRLaW5kW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmF0ZSB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHNyY19wYXRoOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIGVkaXRpb246IHN0cmluZ1xuICB0YXJnZXRzOiBDcmF0ZVRhcmdldFtdXG4gIGZlYXR1cmVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT5cbiAgbWFuaWZlc3RfcGF0aDogc3RyaW5nXG4gIGRlcGVuZGVuY2llczogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHNvdXJjZTogc3RyaW5nXG4gICAgcmVxOiBzdHJpbmdcbiAgICBraW5kOiBzdHJpbmcgfCBudWxsXG4gICAgcmVuYW1lOiBzdHJpbmcgfCBudWxsXG4gICAgb3B0aW9uYWw6IGJvb2xlYW5cbiAgICB1c2VzX2RlZmF1bHRfZmVhdHVyZXM6IGJvb2xlYW5cbiAgICBmZWF0dXJlczogc3RyaW5nW11cbiAgICB0YXJnZXQ6IHN0cmluZyB8IG51bGxcbiAgICByZWdpc3RyeTogc3RyaW5nIHwgbnVsbFxuICB9PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhcmdvV29ya3NwYWNlTWV0YWRhdGEge1xuICB2ZXJzaW9uOiBudW1iZXJcbiAgcGFja2FnZXM6IENyYXRlW11cbiAgd29ya3NwYWNlX21lbWJlcnM6IHN0cmluZ1tdXG4gIHRhcmdldF9kaXJlY3Rvcnk6IHN0cmluZ1xuICB3b3Jrc3BhY2Vfcm9vdDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZU1ldGFkYXRhKG1hbmlmZXN0UGF0aDogc3RyaW5nKSB7XG4gIGlmICghZnMuZXhpc3RzU3luYyhtYW5pZmVzdFBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBjcmF0ZSBmb3VuZCBpbiBtYW5pZmVzdDogJHttYW5pZmVzdFBhdGh9YClcbiAgfVxuXG4gIGNvbnN0IGNoaWxkUHJvY2VzcyA9IHNwYXduKFxuICAgICdjYXJnbycsXG4gICAgWydtZXRhZGF0YScsICctLW1hbmlmZXN0LXBhdGgnLCBtYW5pZmVzdFBhdGgsICctLWZvcm1hdC12ZXJzaW9uJywgJzEnXSxcbiAgICB7IHN0ZGlvOiAncGlwZScgfSxcbiAgKVxuXG4gIGxldCBzdGRvdXQgPSAnJ1xuICBsZXQgc3RkZXJyID0gJydcbiAgbGV0IHN0YXR1cyA9IDBcbiAgbGV0IGVycm9yID0gbnVsbFxuXG4gIGNoaWxkUHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgIHN0ZG91dCArPSBkYXRhXG4gIH0pXG5cbiAgY2hpbGRQcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgc3RkZXJyICs9IGRhdGFcbiAgfSlcblxuICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIGNoaWxkUHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgc3RhdHVzID0gY29kZSA/PyAwXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FyZ28gbWV0YWRhdGEgZmFpbGVkIHRvIHJ1bicsIHsgY2F1c2U6IGVycm9yIH0pXG4gIH1cbiAgaWYgKHN0YXR1cyAhPT0gMCkge1xuICAgIGNvbnN0IHNpbXBsZU1lc3NhZ2UgPSBgY2FyZ28gbWV0YWRhdGEgZXhpdGVkIHdpdGggY29kZSAke3N0YXR1c31gXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpbXBsZU1lc3NhZ2V9IGFuZCBlcnJvciBtZXNzYWdlOlxcblxcbiR7c3RkZXJyfWAsIHtcbiAgICAgIGNhdXNlOiBuZXcgRXJyb3Ioc2ltcGxlTWVzc2FnZSksXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3Rkb3V0KSBhcyBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBjYXJnbyBtZXRhZGF0YSBKU09OJywgeyBjYXVzZTogZSB9KVxuICB9XG59XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTeW1ib2w7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlkZW50aXR5O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBXZWFrTWFwO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBseTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0T3V0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUHJvcGVydHk7XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSAnLi9jb25zdGFudC5qcyc7XG5pbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNldFRvU3RyaW5nO1xuIiwiaW1wb3J0IGJhc2VTZXRUb1N0cmluZyBmcm9tICcuL19iYXNlU2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHNob3J0T3V0IGZyb20gJy4vX3Nob3J0T3V0LmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RWFjaDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weU9iamVjdDtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJSZXN0O1xuIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IG92ZXJSZXN0IGZyb20gJy4vX292ZXJSZXN0LmpzJztcbmltcG9ydCBzZXRUb1N0cmluZyBmcm9tICcuL19zZXRUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmVzdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0l0ZXJhdGVlQ2FsbDtcbiIsImltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuIiwiaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzIGZyb20gJy4vX25hdGl2ZUtleXMuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzSW47XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXNJbiBmcm9tICcuL19uYXRpdmVLZXlzSW4uanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5c0luO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXNJbiBmcm9tICcuL19iYXNlS2V5c0luLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXNJbjtcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXk7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUNyZWF0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEdldDtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoSGFzO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcbiIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IG1lbW9pemUgZnJvbSAnLi9tZW1vaXplLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplQ2FwcGVkO1xuIiwiaW1wb3J0IG1lbW9pemVDYXBwZWQgZnJvbSAnLi9fbWVtb2l6ZUNhcHBlZC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nVG9QYXRoO1xuIiwiaW1wb3J0IGJhc2VUb1N0cmluZyBmcm9tICcuL19iYXNlVG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU3RyaW5nO1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgc3RyaW5nVG9QYXRoIGZyb20gJy4vX3N0cmluZ1RvUGF0aC5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RQYXRoO1xuIiwiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9LZXk7XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldDtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlQdXNoO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRmxhdHRlbmFibGU7XG4iLCJpbXBvcnQgYXJyYXlQdXNoIGZyb20gJy4vX2FycmF5UHVzaC5qcyc7XG5pbXBvcnQgaXNGbGF0dGVuYWJsZSBmcm9tICcuL19pc0ZsYXR0ZW5hYmxlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGbGF0dGVuO1xuIiwiaW1wb3J0IGJhc2VGbGF0dGVuIGZyb20gJy4vX2Jhc2VGbGF0dGVuLmpzJztcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZsYXR0ZW47XG4iLCJpbXBvcnQgZmxhdHRlbiBmcm9tICcuL2ZsYXR0ZW4uanMnO1xuaW1wb3J0IG92ZXJSZXN0IGZyb20gJy4vX292ZXJSZXN0LmpzJztcbmltcG9ydCBzZXRUb1N0cmluZyBmcm9tICcuL19zZXRUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmxhdFJlc3Q7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNsaWNlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0hhcztcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcbmltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja1NldDtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBzdGFja0NsZWFyIGZyb20gJy4vX3N0YWNrQ2xlYXIuanMnO1xuaW1wb3J0IHN0YWNrRGVsZXRlIGZyb20gJy4vX3N0YWNrRGVsZXRlLmpzJztcbmltcG9ydCBzdGFja0dldCBmcm9tICcuL19zdGFja0dldC5qcyc7XG5pbXBvcnQgc3RhY2tIYXMgZnJvbSAnLi9fc3RhY2tIYXMuanMnO1xuaW1wb3J0IHN0YWNrU2V0IGZyb20gJy4vX3N0YWNrU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBTdGFjaztcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduSW47XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVCdWZmZXI7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkFycmF5O1xuIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBzdHViQXJyYXkgZnJvbSAnLi9zdHViQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHM7XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlTeW1ib2xzO1xuIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3ltYm9sc0luO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9sc0luIGZyb20gJy4vX2dldFN5bWJvbHNJbi5qcyc7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weVN5bWJvbHNJbjtcbiIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldEFsbEtleXM7XG4iLCJpbXBvcnQgYmFzZUdldEFsbEtleXMgZnJvbSAnLi9fYmFzZUdldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzSW4gZnJvbSAnLi9fZ2V0U3ltYm9sc0luLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzSW47XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhVmlldztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9taXNlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5leHBvcnQgZGVmYXVsdCBTZXQ7XG4iLCJpbXBvcnQgRGF0YVZpZXcgZnJvbSAnLi9fRGF0YVZpZXcuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9fUHJvbWlzZS5qcyc7XG5pbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgV2Vha01hcCBmcm9tICcuL19XZWFrTWFwLmpzJztcbmltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQXJyYXk7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgVWludDhBcnJheTtcbiIsImltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lUmVnRXhwO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lU3ltYm9sO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lVHlwZWRBcnJheTtcbiIsImltcG9ydCBjbG9uZUFycmF5QnVmZmVyIGZyb20gJy4vX2Nsb25lQXJyYXlCdWZmZXIuanMnO1xuaW1wb3J0IGNsb25lRGF0YVZpZXcgZnJvbSAnLi9fY2xvbmVEYXRhVmlldy5qcyc7XG5pbXBvcnQgY2xvbmVSZWdFeHAgZnJvbSAnLi9fY2xvbmVSZWdFeHAuanMnO1xuaW1wb3J0IGNsb25lU3ltYm9sIGZyb20gJy4vX2Nsb25lU3ltYm9sLmpzJztcbmltcG9ydCBjbG9uZVR5cGVkQXJyYXkgZnJvbSAnLi9fY2xvbmVUeXBlZEFycmF5LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRDbG9uZUJ5VGFnO1xuIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRDbG9uZU9iamVjdDtcbiIsImltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTWFwO1xuIiwiaW1wb3J0IGJhc2VJc01hcCBmcm9tICcuL19iYXNlSXNNYXAuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuZXhwb3J0IGRlZmF1bHQgaXNNYXA7XG4iLCJpbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1NldDtcbiIsImltcG9ydCBiYXNlSXNTZXQgZnJvbSAnLi9fYmFzZUlzU2V0LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IGlzU2V0O1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhcnJheUVhY2ggZnJvbSAnLi9fYXJyYXlFYWNoLmpzJztcbmltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnbiBmcm9tICcuL19iYXNlQXNzaWduLmpzJztcbmltcG9ydCBiYXNlQXNzaWduSW4gZnJvbSAnLi9fYmFzZUFzc2lnbkluLmpzJztcbmltcG9ydCBjbG9uZUJ1ZmZlciBmcm9tICcuL19jbG9uZUJ1ZmZlci5qcyc7XG5pbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgY29weVN5bWJvbHMgZnJvbSAnLi9fY29weVN5bWJvbHMuanMnO1xuaW1wb3J0IGNvcHlTeW1ib2xzSW4gZnJvbSAnLi9fY29weVN5bWJvbHNJbi5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5cyBmcm9tICcuL19nZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRBbGxLZXlzSW4gZnJvbSAnLi9fZ2V0QWxsS2V5c0luLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpbml0Q2xvbmVBcnJheSBmcm9tICcuL19pbml0Q2xvbmVBcnJheS5qcyc7XG5pbXBvcnQgaW5pdENsb25lQnlUYWcgZnJvbSAnLi9faW5pdENsb25lQnlUYWcuanMnO1xuaW1wb3J0IGluaXRDbG9uZU9iamVjdCBmcm9tICcuL19pbml0Q2xvbmVPYmplY3QuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc01hcCBmcm9tICcuL2lzTWFwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1NldCBmcm9tICcuL2lzU2V0LmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VDbG9uZTtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuaW1wb3J0IHNldENhY2hlQWRkIGZyb20gJy4vX3NldENhY2hlQWRkLmpzJztcbmltcG9ydCBzZXRDYWNoZUhhcyBmcm9tICcuL19zZXRDYWNoZUhhcy5qcyc7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNvbWU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FjaGVIYXM7XG4iLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5U29tZSBmcm9tICcuL19hcnJheVNvbWUuanMnO1xuaW1wb3J0IGNhY2hlSGFzIGZyb20gJy4vX2NhY2hlSGFzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEFycmF5cztcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRUb0FycmF5O1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgZXF1YWxBcnJheXMgZnJvbSAnLi9fZXF1YWxBcnJheXMuanMnO1xuaW1wb3J0IG1hcFRvQXJyYXkgZnJvbSAnLi9fbWFwVG9BcnJheS5qcyc7XG5pbXBvcnQgc2V0VG9BcnJheSBmcm9tICcuL19zZXRUb0FycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxCeVRhZztcbiIsImltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxPYmplY3RzO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgZXF1YWxCeVRhZyBmcm9tICcuL19lcXVhbEJ5VGFnLmpzJztcbmltcG9ydCBlcXVhbE9iamVjdHMgZnJvbSAnLi9fZXF1YWxPYmplY3RzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsRGVlcDtcbiIsImltcG9ydCBiYXNlSXNFcXVhbERlZXAgZnJvbSAnLi9fYmFzZUlzRXF1YWxEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWw7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hdGNoO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGJhc2VJc01hdGNoIGZyb20gJy4vX2Jhc2VJc01hdGNoLmpzJztcbmltcG9ydCBnZXRNYXRjaERhdGEgZnJvbSAnLi9fZ2V0TWF0Y2hEYXRhLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSGFzSW47XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc1BhdGg7XG4iLCJpbXBvcnQgYmFzZUhhc0luIGZyb20gJy4vX2Jhc2VIYXNJbi5qcyc7XG5pbXBvcnQgaGFzUGF0aCBmcm9tICcuL19oYXNQYXRoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNJbjtcbiIsImltcG9ydCBiYXNlSXNFcXVhbCBmcm9tICcuL19iYXNlSXNFcXVhbC5qcyc7XG5pbXBvcnQgZ2V0IGZyb20gJy4vZ2V0LmpzJztcbmltcG9ydCBoYXNJbiBmcm9tICcuL2hhc0luLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgaXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHlEZWVwO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eSBmcm9tICcuL19iYXNlUHJvcGVydHkuanMnO1xuaW1wb3J0IGJhc2VQcm9wZXJ0eURlZXAgZnJvbSAnLi9fYmFzZVByb3BlcnR5RGVlcC5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcm9wZXJ0eTtcbiIsImltcG9ydCBiYXNlTWF0Y2hlcyBmcm9tICcuL19iYXNlTWF0Y2hlcy5qcyc7XG5pbXBvcnQgYmFzZU1hdGNoZXNQcm9wZXJ0eSBmcm9tICcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgcHJvcGVydHkgZnJvbSAnLi9wcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJdGVyYXRlZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCYXNlRm9yO1xuIiwiaW1wb3J0IGNyZWF0ZUJhc2VGb3IgZnJvbSAnLi9fY3JlYXRlQmFzZUZvci5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZvcjtcbiIsImltcG9ydCBiYXNlRm9yIGZyb20gJy4vX2Jhc2VGb3IuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yT3duO1xuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCYXNlRWFjaDtcbiIsImltcG9ydCBiYXNlRm9yT3duIGZyb20gJy4vX2Jhc2VGb3JPd24uanMnO1xuaW1wb3J0IGNyZWF0ZUJhc2VFYWNoIGZyb20gJy4vX2NyZWF0ZUJhc2VFYWNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VFYWNoO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25NZXJnZVZhbHVlO1xuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2VPYmplY3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2FmZUdldDtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9QbGFpbk9iamVjdDtcbiIsImltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGNsb25lQnVmZmVyIGZyb20gJy4vX2Nsb25lQnVmZmVyLmpzJztcbmltcG9ydCBjbG9uZVR5cGVkQXJyYXkgZnJvbSAnLi9fY2xvbmVUeXBlZEFycmF5LmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBpbml0Q2xvbmVPYmplY3QgZnJvbSAnLi9faW5pdENsb25lT2JqZWN0LmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2VPYmplY3QgZnJvbSAnLi9pc0FycmF5TGlrZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5pbXBvcnQgdG9QbGFpbk9iamVjdCBmcm9tICcuL3RvUGxhaW5PYmplY3QuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2VEZWVwO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQgYmFzZU1lcmdlRGVlcCBmcm9tICcuL19iYXNlTWVyZ2VEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1lcmdlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxhc3Q7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWFwO1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5pbXBvcnQgYmFzZVNsaWNlIGZyb20gJy4vX2Jhc2VTbGljZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyZW50O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmlsKG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOaWwodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmlsKE5hTik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNOaWw7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCIvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH1cbiAqXG4gKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICogLy8gPT4gWzEsIDMsIDVdXG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmVnYXRlO1xuIiwiaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcbmltcG9ydCBsYXN0IGZyb20gJy4vbGFzdC5qcyc7XG5pbXBvcnQgcGFyZW50IGZyb20gJy4vX3BhcmVudC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbnNldDtcbiIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAqIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICovXG5mdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbU9taXRDbG9uZTtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgYmFzZUNsb25lIGZyb20gJy4vX2Jhc2VDbG9uZS5qcyc7XG5pbXBvcnQgYmFzZVVuc2V0IGZyb20gJy4vX2Jhc2VVbnNldC5qcyc7XG5pbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgY3VzdG9tT21pdENsb25lIGZyb20gJy4vX2N1c3RvbU9taXRDbG9uZS5qcyc7XG5pbXBvcnQgZmxhdFJlc3QgZnJvbSAnLi9fZmxhdFJlc3QuanMnO1xuaW1wb3J0IGdldEFsbEtleXNJbiBmcm9tICcuL19nZXRBbGxLZXlzSW4uanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2InOiAnMicgfVxuICovXG52YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSk7XG4gIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG9taXQ7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTZXQ7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcbmltcG9ydCBiYXNlU2V0IGZyb20gJy4vX2Jhc2VTZXQuanMnO1xuaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQaWNrQnk7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VQaWNrQnkgZnJvbSAnLi9fYmFzZVBpY2tCeS5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5c0luIGZyb20gJy4vX2dldEFsbEtleXNJbi5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBbcHJvcF07XG4gIH0pO1xuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBpY2tCeTtcbiIsImltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBuZWdhdGUgZnJvbSAnLi9uZWdhdGUuanMnO1xuaW1wb3J0IHBpY2tCeSBmcm9tICcuL3BpY2tCeS5qcyc7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xuZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb21pdEJ5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNvcnRCeTtcbiIsImltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJlQXNjZW5kaW5nO1xuIiwiaW1wb3J0IGNvbXBhcmVBc2NlbmRpbmcgZnJvbSAnLi9fY29tcGFyZUFzY2VuZGluZy5qcyc7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBhcmVNdWx0aXBsZTtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlTWFwIGZyb20gJy4vX2Jhc2VNYXAuanMnO1xuaW1wb3J0IGJhc2VTb3J0QnkgZnJvbSAnLi9fYmFzZVNvcnRCeS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgY29tcGFyZU11bHRpcGxlIGZyb20gJy4vX2NvbXBhcmVNdWx0aXBsZS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyYXRlZXMgPSBbaWRlbnRpdHldO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlT3JkZXJCeTtcbiIsImltcG9ydCBiYXNlUGlja0J5IGZyb20gJy4vX2Jhc2VQaWNrQnkuanMnO1xuaW1wb3J0IGhhc0luIGZyb20gJy4vaGFzSW4uanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQaWNrO1xuIiwiaW1wb3J0IGJhc2VQaWNrIGZyb20gJy4vX2Jhc2VQaWNrLmpzJztcbmltcG9ydCBmbGF0UmVzdCBmcm9tICcuL19mbGF0UmVzdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGljaztcbiIsImltcG9ydCBiYXNlRmxhdHRlbiBmcm9tICcuL19iYXNlRmxhdHRlbi5qcyc7XG5pbXBvcnQgYmFzZU9yZGVyQnkgZnJvbSAnLi9fYmFzZU9yZGVyQnkuanMnO1xuaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICogXTtcbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAqL1xudmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbXTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb3J0Qnk7XG4iLCJpbXBvcnQgeyB1bmRlcmxpbmUsIHllbGxvdyB9IGZyb20gJ2NvbG9yZXR0ZSdcbmltcG9ydCB7IG1lcmdlLCBvbWl0IH0gZnJvbSAnbG9kYXNoLWVzJ1xuXG5pbXBvcnQgeyBmaWxlRXhpc3RzLCByZWFkRmlsZUFzeW5jIH0gZnJvbSAnLi9taXNjLmpzJ1xuaW1wb3J0IHsgREVGQVVMVF9UQVJHRVRTLCBwYXJzZVRyaXBsZSwgVGFyZ2V0IH0gZnJvbSAnLi90YXJnZXQuanMnXG5cbmV4cG9ydCB0eXBlIFZhbHVlT2ZDb25zdEFycmF5PFQ+ID0gVFtFeGNsdWRlPGtleW9mIFQsIGtleW9mIEFycmF5PGFueT4+XVxuXG5leHBvcnQgY29uc3QgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJzID0gWyd5YXJuJywgJ3BucG0nXSBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IFN1cHBvcnRlZFRlc3RGcmFtZXdvcmtzID0gWydhdmEnXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlciA9IFZhbHVlT2ZDb25zdEFycmF5PFxuICB0eXBlb2YgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJzXG4+XG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUZXN0RnJhbWV3b3JrID0gVmFsdWVPZkNvbnN0QXJyYXk8XG4gIHR5cGVvZiBTdXBwb3J0ZWRUZXN0RnJhbWV3b3Jrc1xuPlxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJOYXBpQ29uZmlnIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGJpbmFyeSB0byBiZSBnZW5lcmF0ZWQsIGRlZmF1bHQgdG8gYGluZGV4YFxuICAgKi9cbiAgYmluYXJ5TmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgbnBtIHBhY2thZ2UsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2Ygcm9vdCBwYWNrYWdlLmpzb24gbmFtZVxuICAgKlxuICAgKiBBbHdheXMgZ2l2ZW4gYEBzY29wZS9wa2dgIGFuZCBhcmNoIHN1ZmZpeCB3aWxsIGJlIGFwcGVuZGVkIGxpa2UgYEBzY29wZS9wa2ctbGludXgtZ251LXg2NGBcbiAgICovXG4gIHBhY2thZ2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBbGwgdGFyZ2V0cyB0aGUgY3JhdGUgd2lsbCBiZSBjb21waWxlZCBmb3JcbiAgICovXG4gIHRhcmdldHM/OiBzdHJpbmdbXVxuXG4gIC8qKlxuICAgKiBUaGUgbnBtIGNsaWVudCBwcm9qZWN0IHVzZXMuXG4gICAqL1xuICBucG1DbGllbnQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogV2hldGhlciBnZW5lcmF0ZSBjb25zdCBlbnVtIGZvciB0eXBlc2NyaXB0IGJpbmRpbmdzXG4gICAqL1xuICBjb25zdEVudW0/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIGR0cyBoZWFkZXIgcHJlcGVuZCB0byB0aGUgZ2VuZXJhdGVkIGR0cyBmaWxlXG4gICAqL1xuICBkdHNIZWFkZXI/OiBzdHJpbmdcblxuICAvKipcbiAgICogZHRzIGhlYWRlciBmaWxlIHBhdGggdG8gYmUgcHJlcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgZHRzIGZpbGVcbiAgICogaWYgYm90aCBkdHNIZWFkZXIgYW5kIGR0c0hlYWRlckZpbGUgYXJlIHByb3ZpZGVkLCBkdHNIZWFkZXJGaWxlIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgZHRzSGVhZGVyRmlsZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiB3YXNtIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAgICovXG4gIHdhc20/OiB7XG4gICAgLyoqXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWJBc3NlbWJseS9KYXZhU2NyaXB0X2ludGVyZmFjZS9NZW1vcnlcbiAgICAgKiBAZGVmYXVsdCA0MDAwIHBhZ2VzICgyNTZNaUIpXG4gICAgICovXG4gICAgaW5pdGlhbE1lbW9yeT86IG51bWJlclxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDY1NTM2IHBhZ2VzICg0R2lCKVxuICAgICAqL1xuICAgIG1heGltdW1NZW1vcnk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIEJyb3dzZXIgd2FzbSBiaW5kaW5nIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBicm93c2VyOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gdXNlIGZzIG1vZHVsZSBpbiBicm93c2VyXG4gICAgICAgKi9cbiAgICAgIGZzPzogYm9vbGVhblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGluaXRpYWxpemUgd2FzbSBhc3luY2hyb25vdXNseVxuICAgICAgICovXG4gICAgICBhc3luY0luaXQ/OiBib29sZWFuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gaW5qZWN0IGBidWZmZXJgIHRvIGVtbmFwaSBjb250ZXh0XG4gICAgICAgKi9cbiAgICAgIGJ1ZmZlcj86IGJvb2xlYW5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYmluYXJ5TmFtZSBpbnN0ZWFkXG4gICAqL1xuICBuYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgcGFja2FnZU5hbWUgaW5zdGVhZFxuICAgKi9cbiAgcGFja2FnZT86IHtcbiAgICBuYW1lPzogc3RyaW5nXG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0YXJnZXRzIGluc3RlYWRcbiAgICovXG4gIHRyaXBsZXM/OiB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzXG4gICAgICovXG4gICAgZGVmYXVsdHM6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIHRhcmdldHMgdG8gYmUgY29tcGlsZWQgZm9yXG4gICAgICovXG4gICAgYWRkaXRpb25hbD86IHN0cmluZ1tdXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21tb25QYWNrYWdlSnNvbkZpZWxkcyB7XG4gIG5hbWU6IHN0cmluZ1xuICB2ZXJzaW9uOiBzdHJpbmdcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAga2V5d29yZHM/OiBzdHJpbmdbXVxuICBhdXRob3I/OiBzdHJpbmdcbiAgYXV0aG9ycz86IHN0cmluZ1tdXG4gIGxpY2Vuc2U/OiBzdHJpbmdcbiAgY3B1Pzogc3RyaW5nW11cbiAgb3M/OiBzdHJpbmdbXVxuICBsaWJjPzogc3RyaW5nW11cbiAgZmlsZXM/OiBzdHJpbmdbXVxuICByZXBvc2l0b3J5PzogYW55XG4gIGhvbWVwYWdlPzogYW55XG4gIGVuZ2luZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHB1Ymxpc2hDb25maWc/OiBhbnlcbiAgYnVncz86IGFueVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgbmFwaT86IFVzZXJOYXBpQ29uZmlnXG4gIHR5cGU/OiAnbW9kdWxlJyB8ICdjb21tb25qcydcbiAgc2NyaXB0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICAvLyBtb2R1bGVzXG4gIG1haW4/OiBzdHJpbmdcbiAgbW9kdWxlPzogc3RyaW5nXG4gIHR5cGVzPzogc3RyaW5nXG4gIGJyb3dzZXI/OiBzdHJpbmdcbiAgZXhwb3J0cz86IGFueVxuXG4gIGRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZGV2RGVwZW5kZW5jaWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXG4gIGF2YT86IHtcbiAgICB0aW1lb3V0Pzogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTmFwaUNvbmZpZyA9IFJlcXVpcmVkPFxuICBQaWNrPFVzZXJOYXBpQ29uZmlnLCAnYmluYXJ5TmFtZScgfCAncGFja2FnZU5hbWUnIHwgJ25wbUNsaWVudCc+XG4+ICZcbiAgUGljazxVc2VyTmFwaUNvbmZpZywgJ3dhc20nIHwgJ2R0c0hlYWRlcicgfCAnZHRzSGVhZGVyRmlsZScgfCAnY29uc3RFbnVtJz4gJiB7XG4gICAgdGFyZ2V0czogVGFyZ2V0W11cbiAgICBwYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHNcbiAgfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZE5hcGlDb25maWcoXG4gIHBhdGg6IHN0cmluZyxcbiAgY29uZmlnUGF0aD86IHN0cmluZyxcbik6IFByb21pc2U8TmFwaUNvbmZpZz4ge1xuICBpZiAoY29uZmlnUGF0aCAmJiAhKGF3YWl0IGZpbGVFeGlzdHMoY29uZmlnUGF0aCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOQVBJLVJTIGNvbmZpZyBub3QgZm91bmQgYXQgJHtjb25maWdQYXRofWApXG4gIH1cbiAgaWYgKCEoYXdhaXQgZmlsZUV4aXN0cyhwYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2thZ2UuanNvbiBub3QgZm91bmQgYXQgJHtwYXRofWApXG4gIH1cbiAgLy8gTWF5IHN1cHBvcnQgbXVsdGlwbGUgY29uZmlnIHNvdXJjZXMgbGF0ZXIgb24uXG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKHBhdGgsICd1dGY4JylcbiAgbGV0IHBrZ0pzb25cbiAgdHJ5IHtcbiAgICBwa2dKc29uID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyBDb21tb25QYWNrYWdlSnNvbkZpZWxkc1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgcGFja2FnZS5qc29uIGF0ICR7cGF0aH1gLCB7XG4gICAgICBjYXVzZTogZSxcbiAgICB9KVxuICB9XG5cbiAgbGV0IHNlcGFyYXRlZENvbmZpZzogVXNlck5hcGlDb25maWcgfCB1bmRlZmluZWRcbiAgaWYgKGNvbmZpZ1BhdGgpIHtcbiAgICBjb25zdCBjb25maWdDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjb25maWdQYXRoLCAndXRmOCcpXG4gICAgdHJ5IHtcbiAgICAgIHNlcGFyYXRlZENvbmZpZyA9IEpTT04ucGFyc2UoY29uZmlnQ29udGVudCkgYXMgVXNlck5hcGlDb25maWdcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBOQVBJLVJTIGNvbmZpZyBhdCAke2NvbmZpZ1BhdGh9YCwge1xuICAgICAgICBjYXVzZTogZSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXNlck5hcGlDb25maWcgPSBwa2dKc29uLm5hcGkgPz8ge31cbiAgaWYgKHBrZ0pzb24ubmFwaSAmJiBzZXBhcmF0ZWRDb25maWcpIHtcbiAgICBjb25zdCBwa2dKc29uUGF0aCA9IHVuZGVybGluZShwYXRoKVxuICAgIGNvbnN0IGNvbmZpZ1BhdGhVbmRlcmxpbmUgPSB1bmRlcmxpbmUoY29uZmlnUGF0aCEpXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgeWVsbG93KFxuICAgICAgICBgQm90aCBuYXBpIGZpZWxkIGluICR7cGtnSnNvblBhdGh9IGFuZCBbTkFQSS1SUyBjb25maWddKCR7Y29uZmlnUGF0aFVuZGVybGluZX0pIGZpbGUgYXJlIGZvdW5kLCB0aGUgTkFQSS1SUyBjb25maWcgZmlsZSB3aWxsIGJlIHVzZWQuYCxcbiAgICAgICksXG4gICAgKVxuICAgIE9iamVjdC5hc3NpZ24odXNlck5hcGlDb25maWcsIHNlcGFyYXRlZENvbmZpZylcbiAgfVxuICBjb25zdCBuYXBpQ29uZmlnOiBOYXBpQ29uZmlnID0gbWVyZ2UoXG4gICAge1xuICAgICAgYmluYXJ5TmFtZTogJ2luZGV4JyxcbiAgICAgIHBhY2thZ2VOYW1lOiBwa2dKc29uLm5hbWUsXG4gICAgICB0YXJnZXRzOiBbXSxcbiAgICAgIHBhY2thZ2VKc29uOiBwa2dKc29uLFxuICAgICAgbnBtQ2xpZW50OiAnbnBtJyxcbiAgICB9LFxuICAgIG9taXQodXNlck5hcGlDb25maWcsICd0YXJnZXRzJyksXG4gIClcblxuICBsZXQgdGFyZ2V0czogc3RyaW5nW10gPSB1c2VyTmFwaUNvbmZpZy50YXJnZXRzID8/IFtdXG5cbiAgLy8gY29tcGF0aWJsZSB3aXRoIG9sZCBjb25maWdcbiAgaWYgKHVzZXJOYXBpQ29uZmlnPy5uYW1lKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgeWVsbG93KFxuICAgICAgICBgW0RFUFJFQ0FURURdIG5hcGkubmFtZSBpcyBkZXByZWNhdGVkLCB1c2UgbmFwaS5iaW5hcnlOYW1lIGluc3RlYWQuYCxcbiAgICAgICksXG4gICAgKVxuICAgIG5hcGlDb25maWcuYmluYXJ5TmFtZSA9IHVzZXJOYXBpQ29uZmlnLm5hbWVcbiAgfVxuXG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICBsZXQgZGVwcmVjYXRlZFdhcm5lZCA9IGZhbHNlXG4gICAgY29uc3Qgd2FybmluZyA9IHllbGxvdyhcbiAgICAgIGBbREVQUkVDQVRFRF0gbmFwaS50cmlwbGVzIGlzIGRlcHJlY2F0ZWQsIHVzZSBuYXBpLnRhcmdldHMgaW5zdGVhZC5gLFxuICAgIClcbiAgICBpZiAodXNlck5hcGlDb25maWcudHJpcGxlcz8uZGVmYXVsdHMpIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuZWQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4od2FybmluZylcbiAgICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChERUZBVUxUX1RBUkdFVFMpXG4gICAgfVxuXG4gICAgaWYgKHVzZXJOYXBpQ29uZmlnLnRyaXBsZXM/LmFkZGl0aW9uYWw/Lmxlbmd0aCkge1xuICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KHVzZXJOYXBpQ29uZmlnLnRyaXBsZXMuYWRkaXRpb25hbClcbiAgICAgIGlmICghZGVwcmVjYXRlZFdhcm5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4od2FybmluZylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGR1cGxpY2F0ZSB0YXJnZXRzXG4gIGNvbnN0IHVuaXF1ZVRhcmdldHMgPSBuZXcgU2V0KHRhcmdldHMpXG4gIGlmICh1bmlxdWVUYXJnZXRzLnNpemUgIT09IHRhcmdldHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZHVwbGljYXRlVGFyZ2V0ID0gdGFyZ2V0cy5maW5kKFxuICAgICAgKHRhcmdldCwgaW5kZXgpID0+IHRhcmdldHMuaW5kZXhPZih0YXJnZXQpICE9PSBpbmRleCxcbiAgICApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdGFyZ2V0cyBhcmUgbm90IGFsbG93ZWQ6ICR7ZHVwbGljYXRlVGFyZ2V0fWApXG4gIH1cblxuICBuYXBpQ29uZmlnLnRhcmdldHMgPSB0YXJnZXRzLm1hcChwYXJzZVRyaXBsZSlcblxuICByZXR1cm4gbmFwaUNvbmZpZ1xufVxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5cbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9sb2cuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkobmFtZTogc3RyaW5nLCBiaW46IHN0cmluZykge1xuICBpZiAoZGV0ZWN0Q2FyZ29CaW5hcnkoYmluKSkge1xuICAgIGRlYnVnKCdDYXJnbyBiaW5hcnkgYWxyZWFkeSBpbnN0YWxsZWQ6ICVzJywgbmFtZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVidWcoJ0luc3RhbGxpbmcgY2FyZ28gYmluYXJ5OiAlcycsIG5hbWUpXG4gICAgZXhlY1N5bmMoYGNhcmdvIGluc3RhbGwgJHtuYW1lfWAsIHtcbiAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluc3RhbGwgY2FyZ28gYmluYXJ5OiAke25hbWV9YCwge1xuICAgICAgY2F1c2U6IGUsXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlY3RDYXJnb0JpbmFyeShiaW46IHN0cmluZykge1xuICBkZWJ1ZygnRGV0ZWN0aW5nIGNhcmdvIGJpbmFyeTogJXMnLCBiaW4pXG4gIHRyeSB7XG4gICAgZXhlY1N5bmMoYGNhcmdvIGhlbHAgJHtiaW59YCwge1xuICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgIH0pXG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBkZXRlY3RlZDogJXMnLCBiaW4pXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCB7XG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBub3QgZGV0ZWN0ZWQ6ICVzJywgYmluKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCJpbXBvcnQgeyBzb3J0QnkgfSBmcm9tICdsb2Rhc2gtZXMnXG5cbmltcG9ydCB7IHJlYWRGaWxlQXN5bmMgfSBmcm9tICcuL21pc2MuanMnXG5cbmNvbnN0IFRPUF9MRVZFTF9OQU1FU1BBQ0UgPSAnX19UT1BfTEVWRUxfTU9EVUxFX18nXG5leHBvcnQgY29uc3QgREVGQVVMVF9UWVBFX0RFRl9IRUFERVIgPSBgLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmBcblxuZW51bSBUeXBlRGVmS2luZCB7XG4gIENvbnN0ID0gJ2NvbnN0JyxcbiAgRW51bSA9ICdlbnVtJyxcbiAgU3RyaW5nRW51bSA9ICdzdHJpbmdfZW51bScsXG4gIEludGVyZmFjZSA9ICdpbnRlcmZhY2UnLFxuICBUeXBlID0gJ3R5cGUnLFxuICBGbiA9ICdmbicsXG4gIFN0cnVjdCA9ICdzdHJ1Y3QnLFxuICBJbXBsID0gJ2ltcGwnLFxufVxuXG5pbnRlcmZhY2UgVHlwZURlZkxpbmUge1xuICBraW5kOiBUeXBlRGVmS2luZFxuICBuYW1lOiBzdHJpbmdcbiAgb3JpZ2luYWxfbmFtZT86IHN0cmluZ1xuICBkZWY6IHN0cmluZ1xuICBqc19kb2M/OiBzdHJpbmdcbiAganNfbW9kPzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHByZXR0eVByaW50KFxuICBsaW5lOiBUeXBlRGVmTGluZSxcbiAgY29uc3RFbnVtOiBib29sZWFuLFxuICBpZGVudDogbnVtYmVyLFxuICBhbWJpZW50ID0gZmFsc2UsXG4pOiBzdHJpbmcge1xuICBsZXQgcyA9IGxpbmUuanNfZG9jID8/ICcnXG4gIHN3aXRjaCAobGluZS5raW5kKSB7XG4gICAgY2FzZSBUeXBlRGVmS2luZC5JbnRlcmZhY2U6XG4gICAgICBzICs9IGBleHBvcnQgaW50ZXJmYWNlICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuVHlwZTpcbiAgICAgIHMgKz0gYGV4cG9ydCB0eXBlICR7bGluZS5uYW1lfSA9IFxcbiR7bGluZS5kZWZ9YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuRW51bTpcbiAgICAgIGNvbnN0IGVudW1OYW1lID0gY29uc3RFbnVtID8gJ2NvbnN0IGVudW0nIDogJ2VudW0nXG4gICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9ICR7ZW51bU5hbWV9ICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuU3RyaW5nRW51bTpcbiAgICAgIGlmIChjb25zdEVudW0pIHtcbiAgICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSBjb25zdCBlbnVtICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyArPSBgZXhwb3J0IHR5cGUgJHtsaW5lLm5hbWV9ID0gJHtsaW5lLmRlZi5yZXBsYWNlQWxsKC8uKj0vZywgJycpLnJlcGxhY2VBbGwoJywnLCAnfCcpfTtgXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5TdHJ1Y3Q6XG4gICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9IGNsYXNzICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgaWYgKGxpbmUub3JpZ2luYWxfbmFtZSAmJiBsaW5lLm9yaWdpbmFsX25hbWUgIT09IGxpbmUubmFtZSkge1xuICAgICAgICBzICs9IGBcXG5leHBvcnQgdHlwZSAke2xpbmUub3JpZ2luYWxfbmFtZX0gPSAke2xpbmUubmFtZX1gXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5GbjpcbiAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gJHtsaW5lLmRlZn1gXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHMgKz0gbGluZS5kZWZcbiAgfVxuXG4gIHJldHVybiBjb3JyZWN0U3RyaW5nSWRlbnQocywgaWRlbnQpXG59XG5cbmZ1bmN0aW9uIGV4cG9ydERlY2xhcmUoYW1iaWVudDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChhbWJpZW50KSB7XG4gICAgcmV0dXJuICdleHBvcnQnXG4gIH1cblxuICByZXR1cm4gJ2V4cG9ydCBkZWNsYXJlJ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1R5cGVEZWYoXG4gIGludGVybWVkaWF0ZVR5cGVGaWxlOiBzdHJpbmcsXG4gIGNvbnN0RW51bTogYm9vbGVhbixcbikge1xuICBjb25zdCBleHBvcnRzOiBzdHJpbmdbXSA9IFtdXG4gIGNvbnN0IGRlZnMgPSBhd2FpdCByZWFkSW50ZXJtZWRpYXRlVHlwZUZpbGUoaW50ZXJtZWRpYXRlVHlwZUZpbGUpXG4gIGNvbnN0IGdyb3VwZWREZWZzID0gcHJlcHJvY2Vzc1R5cGVEZWYoZGVmcylcblxuICBjb25zdCBkdHMgPVxuICAgIHNvcnRCeShBcnJheS5mcm9tKGdyb3VwZWREZWZzKSwgKFtuYW1lc3BhY2VdKSA9PiBuYW1lc3BhY2UpXG4gICAgICAubWFwKChbbmFtZXNwYWNlLCBkZWZzXSkgPT4ge1xuICAgICAgICBpZiAobmFtZXNwYWNlID09PSBUT1BfTEVWRUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZnNcbiAgICAgICAgICAgIC5tYXAoKGRlZikgPT4ge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGRlZi5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5Db25zdDpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLkVudW06XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5TdHJpbmdFbnVtOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuRm46XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5TdHJ1Y3Q6IHtcbiAgICAgICAgICAgICAgICAgIGV4cG9ydHMucHVzaChkZWYubmFtZSlcbiAgICAgICAgICAgICAgICAgIGlmIChkZWYub3JpZ2luYWxfbmFtZSAmJiBkZWYub3JpZ2luYWxfbmFtZSAhPT0gZGVmLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5wdXNoKGRlZi5vcmlnaW5hbF9uYW1lKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHByZXR0eVByaW50KGRlZiwgY29uc3RFbnVtLCAwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG5cXG4nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydHMucHVzaChuYW1lc3BhY2UpXG4gICAgICAgICAgbGV0IGRlY2xhcmF0aW9uID0gJydcbiAgICAgICAgICBkZWNsYXJhdGlvbiArPSBgZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlICR7bmFtZXNwYWNlfSB7XFxuYFxuICAgICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uICs9IHByZXR0eVByaW50KGRlZiwgY29uc3RFbnVtLCAyLCB0cnVlKSArICdcXG4nXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlY2xhcmF0aW9uICs9ICd9J1xuICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvblxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJ1xcblxcbicpICsgJ1xcbidcblxuICByZXR1cm4ge1xuICAgIGR0cyxcbiAgICBleHBvcnRzLFxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRJbnRlcm1lZGlhdGVUeXBlRmlsZShmaWxlOiBzdHJpbmcpIHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoZmlsZSwgJ3V0ZjgnKVxuXG4gIGNvbnN0IGRlZnMgPSBjb250ZW50XG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICBsaW5lID0gbGluZS50cmltKClcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UobGluZSkgYXMgVHlwZURlZkxpbmVcbiAgICAgIC8vIENvbnZlcnQgZXNjYXBlZCBuZXdsaW5lcyBiYWNrIHRvIGFjdHVhbCBuZXdsaW5lcyBpbiBqc19kb2MgZmllbGRzXG4gICAgICBpZiAocGFyc2VkLmpzX2RvYykge1xuICAgICAgICBwYXJzZWQuanNfZG9jID0gcGFyc2VkLmpzX2RvYy5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIH1cbiAgICAgIC8vIENvbnZlcnQgZXNjYXBlZCBuZXdsaW5lcyB0byBhY3R1YWwgbmV3bGluZXMgaW4gZGVmIGZpZWxkcyBmb3Igc3RydWN0L2NsYXNzL2ludGVyZmFjZS90eXBlIHR5cGVzXG4gICAgICAvLyB3aGVyZSBcXG4gcmVwcmVzZW50cyBtZXRob2QvZmllbGQgc2VwYXJhdG9ycyB0aGF0IHNob3VsZCBiZSBhY3R1YWwgbmV3bGluZXNcbiAgICAgIGlmIChwYXJzZWQuZGVmKSB7XG4gICAgICAgIHBhcnNlZC5kZWYgPSBwYXJzZWQuZGVmLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZFxuICAgIH0pXG5cbiAgLy8gbW92ZSBhbGwgYHN0cnVjdGAgZGVmIHRvIHRoZSB2ZXJ5IHRvcFxuICAvLyBhbmQgb3JkZXIgdGhlIHJlc3QgYWxwaGFiZXRpY2FsbHkuXG4gIHJldHVybiBkZWZzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgIGlmIChiLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmIChiLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NUeXBlRGVmKGRlZnM6IFR5cGVEZWZMaW5lW10pOiBNYXA8c3RyaW5nLCBUeXBlRGVmTGluZVtdPiB7XG4gIGNvbnN0IG5hbWVzcGFjZUdyb3VwZWQgPSBuZXcgTWFwPHN0cmluZywgVHlwZURlZkxpbmVbXT4oKVxuICBjb25zdCBjbGFzc0RlZnMgPSBuZXcgTWFwPHN0cmluZywgVHlwZURlZkxpbmU+KClcblxuICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gZGVmLmpzX21vZCA/PyBUT1BfTEVWRUxfTkFNRVNQQUNFXG4gICAgaWYgKCFuYW1lc3BhY2VHcm91cGVkLmhhcyhuYW1lc3BhY2UpKSB7XG4gICAgICBuYW1lc3BhY2VHcm91cGVkLnNldChuYW1lc3BhY2UsIFtdKVxuICAgIH1cblxuICAgIGNvbnN0IGdyb3VwID0gbmFtZXNwYWNlR3JvdXBlZC5nZXQobmFtZXNwYWNlKSFcblxuICAgIGlmIChkZWYua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICBncm91cC5wdXNoKGRlZilcbiAgICAgIGNsYXNzRGVmcy5zZXQoZGVmLm5hbWUsIGRlZilcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBUeXBlRGVmS2luZC5JbXBsKSB7XG4gICAgICAvLyBtZXJnZSBgaW1wbGAgaW50byBjbGFzcyBkZWZpbml0aW9uXG4gICAgICBjb25zdCBjbGFzc0RlZiA9IGNsYXNzRGVmcy5nZXQoZGVmLm5hbWUpXG4gICAgICBpZiAoY2xhc3NEZWYpIHtcbiAgICAgICAgaWYgKGNsYXNzRGVmLmRlZikge1xuICAgICAgICAgIGNsYXNzRGVmLmRlZiArPSAnXFxuJ1xuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3NEZWYuZGVmICs9IGRlZi5kZWZcbiAgICAgICAgLy8gQ29udmVydCBhbnkgcmVtYWluaW5nIFxcbiBzZXF1ZW5jZXMgaW4gdGhlIG1lcmdlZCBkZWYgdG8gYWN0dWFsIG5ld2xpbmVzXG4gICAgICAgIGlmIChjbGFzc0RlZi5kZWYpIHtcbiAgICAgICAgICBjbGFzc0RlZi5kZWYgPSBjbGFzc0RlZi5kZWYucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAucHVzaChkZWYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWVzcGFjZUdyb3VwZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcnJlY3RTdHJpbmdJZGVudChzcmM6IHN0cmluZywgaWRlbnQ6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCBicmFja2V0RGVwdGggPSAwXG4gIGNvbnN0IHJlc3VsdCA9IHNyY1xuICAgIC5zcGxpdCgnXFxuJylcbiAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICBsaW5lID0gbGluZS50cmltKClcbiAgICAgIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNJbk11bHRpbGluZUNvbW1lbnQgPSBsaW5lLnN0YXJ0c1dpdGgoJyonKVxuICAgICAgY29uc3QgaXNDbG9zaW5nQnJhY2tldCA9IGxpbmUuZW5kc1dpdGgoJ30nKVxuICAgICAgY29uc3QgaXNPcGVuaW5nQnJhY2tldCA9IGxpbmUuZW5kc1dpdGgoJ3snKVxuICAgICAgY29uc3QgaXNUeXBlRGVjbGFyYXRpb24gPSBsaW5lLmVuZHNXaXRoKCc9JylcbiAgICAgIGNvbnN0IGlzVHlwZVZhcmlhbnQgPSBsaW5lLnN0YXJ0c1dpdGgoJ3wnKVxuXG4gICAgICBsZXQgcmlnaHRJbmRlbnQgPSBpZGVudFxuICAgICAgaWYgKChpc09wZW5pbmdCcmFja2V0IHx8IGlzVHlwZURlY2xhcmF0aW9uKSAmJiAhaXNJbk11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgICAgYnJhY2tldERlcHRoICs9IDFcbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gKGJyYWNrZXREZXB0aCAtIDEpICogMlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzQ2xvc2luZ0JyYWNrZXQgJiZcbiAgICAgICAgICBicmFja2V0RGVwdGggPiAwICYmXG4gICAgICAgICAgIWlzSW5NdWx0aWxpbmVDb21tZW50ICYmXG4gICAgICAgICAgIWlzVHlwZVZhcmlhbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgYnJhY2tldERlcHRoIC09IDFcbiAgICAgICAgfVxuICAgICAgICByaWdodEluZGVudCArPSBicmFja2V0RGVwdGggKiAyXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0luTXVsdGlsaW5lQ29tbWVudCkge1xuICAgICAgICByaWdodEluZGVudCArPSAxXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHMgPSBgJHsnICcucmVwZWF0KHJpZ2h0SW5kZW50KX0ke2xpbmV9YFxuXG4gICAgICByZXR1cm4gc1xuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiaW1wb3J0IHsgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcmVhZE5hcGlDb25maWcgfSBmcm9tICcuL2NvbmZpZy5qcydcblxuaW50ZXJmYWNlIE1pbmltYWxOYXBpT3B0aW9ucyB7XG4gIGN3ZDogc3RyaW5nXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQ29uZmlnKG9wdGlvbnM6IE1pbmltYWxOYXBpT3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlUGF0aCA9ICguLi5wYXRoczogc3RyaW5nW10pID0+IHJlc29sdmUob3B0aW9ucy5jd2QsIC4uLnBhdGhzKVxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICByZXNvbHZlUGF0aChcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/PyBvcHRpb25zLnBhY2thZ2VKc29uUGF0aCA/PyAncGFja2FnZS5qc29uJyxcbiAgICApLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmVQYXRoKG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcbiAgcmV0dXJuIGNvbmZpZ1xufVxuIiwiaW1wb3J0IHsgam9pbiwgcGFyc2UgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcmV0dGUnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnMsXG4gIEFydGlmYWN0c09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9hcnRpZmFjdHMuanMnXG5pbXBvcnQge1xuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICByZWFkRmlsZUFzeW5jLFxuICB3cml0ZUZpbGVBc3luYyxcbiAgVW5pQXJjaHNCeVBsYXRmb3JtLFxuICByZWFkZGlyQXN5bmMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnYXJ0aWZhY3RzJylcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RBcnRpZmFjdHModXNlck9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IHsgdGFyZ2V0cywgYmluYXJ5TmFtZSwgcGFja2FnZU5hbWUgfSA9XG4gICAgYXdhaXQgcmVhZE5hcGlDb25maWcocGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IGRpc3REaXJzID0gdGFyZ2V0cy5tYXAoKHBsYXRmb3JtKSA9PlxuICAgIGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMubnBtRGlyLCBwbGF0Zm9ybS5wbGF0Zm9ybUFyY2hBQkkpLFxuICApXG5cbiAgY29uc3QgdW5pdmVyc2FsU291cmNlQmlucyA9IG5ldyBTZXQoXG4gICAgdGFyZ2V0c1xuICAgICAgLmZpbHRlcigocGxhdGZvcm0pID0+IHBsYXRmb3JtLmFyY2ggPT09ICd1bml2ZXJzYWwnKVxuICAgICAgLmZsYXRNYXAoKHApID0+XG4gICAgICAgIFVuaUFyY2hzQnlQbGF0Zm9ybVtwLnBsYXRmb3JtXT8ubWFwKChhKSA9PiBgJHtwLnBsYXRmb3JtfS0ke2F9YCksXG4gICAgICApXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIHN0cmluZ1tdLFxuICApXG5cbiAgYXdhaXQgY29sbGVjdE5vZGVCaW5hcmllcyhqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLm91dHB1dERpcikpLnRoZW4oXG4gICAgKG91dHB1dCkgPT5cbiAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICBvdXRwdXQubWFwKGFzeW5jIChmaWxlUGF0aCkgPT4ge1xuICAgICAgICAgIGRlYnVnLmluZm8oYFJlYWQgWyR7Y29sb3JzLnllbGxvd0JyaWdodChmaWxlUGF0aCl9XWApXG4gICAgICAgICAgY29uc3Qgc291cmNlQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoZmlsZVBhdGgpXG4gICAgICAgICAgY29uc3QgcGFyc2VkTmFtZSA9IHBhcnNlKGZpbGVQYXRoKVxuICAgICAgICAgIGNvbnN0IHRlcm1zID0gcGFyc2VkTmFtZS5uYW1lLnNwbGl0KCcuJylcbiAgICAgICAgICBjb25zdCBwbGF0Zm9ybUFyY2hBQkkgPSB0ZXJtcy5wb3AoKSFcbiAgICAgICAgICBjb25zdCBfYmluYXJ5TmFtZSA9IHRlcm1zLmpvaW4oJy4nKVxuXG4gICAgICAgICAgaWYgKF9iaW5hcnlOYW1lICE9PSBiaW5hcnlOYW1lKSB7XG4gICAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgICBgWyR7X2JpbmFyeU5hbWV9XSBpcyBub3QgbWF0Y2hlZCB3aXRoIFske2JpbmFyeU5hbWV9XSwgc2tpcGAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGlyID0gZGlzdERpcnMuZmluZCgoZGlyKSA9PiBkaXIuaW5jbHVkZXMocGxhdGZvcm1BcmNoQUJJKSlcbiAgICAgICAgICBpZiAoIWRpciAmJiB1bml2ZXJzYWxTb3VyY2VCaW5zLmhhcyhwbGF0Zm9ybUFyY2hBQkkpKSB7XG4gICAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgICBgWyR7cGxhdGZvcm1BcmNoQUJJfV0gaGFzIG5vIGRpc3QgZGlyIGJ1dCBpdCBpcyBzb3VyY2UgYmluIGZvciB1bml2ZXJzYWwgYXJjaCwgc2tpcGAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGlzdCBkaXIgZm91bmQgZm9yICR7ZmlsZVBhdGh9YClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkaXN0RmlsZVBhdGggPSBqb2luKGRpciwgcGFyc2VkTmFtZS5iYXNlKVxuICAgICAgICAgIGRlYnVnLmluZm8oXG4gICAgICAgICAgICBgV3JpdGUgZmlsZSBjb250ZW50IHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoZGlzdEZpbGVQYXRoKX1dYCxcbiAgICAgICAgICApXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGlzdEZpbGVQYXRoLCBzb3VyY2VDb250ZW50KVxuICAgICAgICAgIGNvbnN0IGRpc3RGaWxlUGF0aExvY2FsID0gam9pbihcbiAgICAgICAgICAgIHBhcnNlKHBhY2thZ2VKc29uUGF0aCkuZGlyLFxuICAgICAgICAgICAgcGFyc2VkTmFtZS5iYXNlLFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1Zy5pbmZvKFxuICAgICAgICAgICAgYFdyaXRlIGZpbGUgY29udGVudCB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KGRpc3RGaWxlUGF0aExvY2FsKX1dYCxcbiAgICAgICAgICApXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGlzdEZpbGVQYXRoTG9jYWwsIHNvdXJjZUNvbnRlbnQpXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgKVxuXG4gIGNvbnN0IHdhc2lUYXJnZXQgPSB0YXJnZXRzLmZpbmQoKHQpID0+IHQucGxhdGZvcm0gPT09ICd3YXNpJylcbiAgaWYgKHdhc2lUYXJnZXQpIHtcbiAgICBjb25zdCB3YXNpRGlyID0gam9pbihcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5ucG1EaXIsXG4gICAgICB3YXNpVGFyZ2V0LnBsYXRmb3JtQXJjaEFCSSxcbiAgICApXG4gICAgY29uc3QgY2pzRmlsZSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYCR7YmluYXJ5TmFtZX0ud2FzaS5janNgLFxuICAgIClcbiAgICBjb25zdCB3b3JrZXJGaWxlID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgd2FzaS13b3JrZXIubWpzYCxcbiAgICApXG4gICAgY29uc3QgYnJvd3NlckVudHJ5ID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgJHtiaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgIClcbiAgICBjb25zdCBicm93c2VyV29ya2VyRmlsZSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgYmluZGluZyBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGNqc0ZpbGUsXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYCksXG4gICAgICBhd2FpdCByZWFkRmlsZUFzeW5jKGNqc0ZpbGUpLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSB3b3JrZXIgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICB3b3JrZXJGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgd2FzaS13b3JrZXIubWpzYCksXG4gICAgICBhd2FpdCByZWFkRmlsZUFzeW5jKHdvcmtlckZpbGUpLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSBicm93c2VyIGVudHJ5IGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgYnJvd3NlckVudHJ5LFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgJHtiaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgKSxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvODQyN1xuICAgICAgKGF3YWl0IHJlYWRGaWxlQXN5bmMoYnJvd3NlckVudHJ5LCAndXRmOCcpKS5yZXBsYWNlKFxuICAgICAgICBgbmV3IFVSTCgnLi93YXNpLXdvcmtlci1icm93c2VyLm1qcycsIGltcG9ydC5tZXRhLnVybClgLFxuICAgICAgICBgbmV3IFVSTCgnJHtwYWNrYWdlTmFtZX0td2FzbTMyLXdhc2kvd2FzaS13b3JrZXItYnJvd3Nlci5tanMnLCBpbXBvcnQubWV0YS51cmwpYCxcbiAgICAgICksXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIGJyb3dzZXIgd29ya2VyIGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgYnJvd3NlcldvcmtlckZpbGUsXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGB3YXNpLXdvcmtlci1icm93c2VyLm1qc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyhicm93c2VyV29ya2VyRmlsZSksXG4gICAgKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3ROb2RlQmluYXJpZXMocm9vdDogc3RyaW5nKSB7XG4gIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHJvb3QsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuICBjb25zdCBub2RlQmluYXJpZXMgPSBmaWxlc1xuICAgIC5maWx0ZXIoXG4gICAgICAoZmlsZSkgPT5cbiAgICAgICAgZmlsZS5pc0ZpbGUoKSAmJlxuICAgICAgICAoZmlsZS5uYW1lLmVuZHNXaXRoKCcubm9kZScpIHx8IGZpbGUubmFtZS5lbmRzV2l0aCgnLndhc20nKSksXG4gICAgKVxuICAgIC5tYXAoKGZpbGUpID0+IGpvaW4ocm9vdCwgZmlsZS5uYW1lKSlcblxuICBjb25zdCBkaXJzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiBmaWxlLmlzRGlyZWN0b3J5KCkpXG4gIGZvciAoY29uc3QgZGlyIG9mIGRpcnMpIHtcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdub2RlX21vZHVsZXMnKSB7XG4gICAgICBub2RlQmluYXJpZXMucHVzaCguLi4oYXdhaXQgY29sbGVjdE5vZGVCaW5hcmllcyhqb2luKHJvb3QsIGRpci5uYW1lKSkpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZUJpbmFyaWVzXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2pzQmluZGluZyhcbiAgbG9jYWxOYW1lOiBzdHJpbmcsXG4gIHBrZ05hbWU6IHN0cmluZyxcbiAgaWRlbnRzOiBzdHJpbmdbXSxcbik6IHN0cmluZyB7XG4gIHJldHVybiBgJHtiaW5kaW5nSGVhZGVyfVxuY29uc3QgeyBjcmVhdGVSZXF1aXJlIH0gPSByZXF1aXJlKCdub2RlOm1vZHVsZScpXG5yZXF1aXJlID0gY3JlYXRlUmVxdWlyZShfX2ZpbGVuYW1lKVxuXG4ke2NyZWF0ZUNvbW1vbkJpbmRpbmcobG9jYWxOYW1lLCBwa2dOYW1lKX1cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQmluZGluZ1xuJHtpZGVudHNcbiAgLm1hcCgoaWRlbnQpID0+IGBtb2R1bGUuZXhwb3J0cy4ke2lkZW50fSA9IG5hdGl2ZUJpbmRpbmcuJHtpZGVudH1gKVxuICAuam9pbignXFxuJyl9XG5gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFc21CaW5kaW5nKFxuICBsb2NhbE5hbWU6IHN0cmluZyxcbiAgcGtnTmFtZTogc3RyaW5nLFxuICBpZGVudHM6IHN0cmluZ1tdLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2JpbmRpbmdIZWFkZXJ9XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbm9kZTptb2R1bGUnXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpXG5jb25zdCBfX2Rpcm5hbWUgPSBuZXcgVVJMKCcuJywgaW1wb3J0Lm1ldGEudXJsKS5wYXRobmFtZVxuXG4ke2NyZWF0ZUNvbW1vbkJpbmRpbmcobG9jYWxOYW1lLCBwa2dOYW1lKX1cbmNvbnN0IHsgJHtpZGVudHMuam9pbignLCAnKX0gfSA9IG5hdGl2ZUJpbmRpbmdcbiR7aWRlbnRzLm1hcCgoaWRlbnQpID0+IGBleHBvcnQgeyAke2lkZW50fSB9YCkuam9pbignXFxuJyl9XG5gXG59XG5cbmNvbnN0IGJpbmRpbmdIZWFkZXIgPSBgLy8gcHJldHRpZXItaWdub3JlXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbi8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cbmBcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uQmluZGluZyhsb2NhbE5hbWU6IHN0cmluZywgcGtnTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgZnVuY3Rpb24gcmVxdWlyZVR1cGxlKHR1cGxlOiBzdHJpbmcsIGlkZW50U2l6ZSA9IDgpIHtcbiAgICBjb25zdCBpZGVudExvdyA9ICcgJy5yZXBlYXQoaWRlbnRTaXplIC0gMilcbiAgICBjb25zdCBpZGVudCA9ICcgJy5yZXBlYXQoaWRlbnRTaXplKVxuICAgIHJldHVybiBgdHJ5IHtcbiR7aWRlbnR9cmV0dXJuIHJlcXVpcmUoJy4vJHtsb2NhbE5hbWV9LiR7dHVwbGV9Lm5vZGUnKVxuJHtpZGVudExvd319IGNhdGNoIChlKSB7XG4ke2lkZW50fWxvYWRFcnJvcnMucHVzaChlKVxuJHtpZGVudExvd319XG4ke2lkZW50TG93fXRyeSB7XG4ke2lkZW50fXJldHVybiByZXF1aXJlKCcke3BrZ05hbWV9LSR7dHVwbGV9JylcbiR7aWRlbnRMb3d9fSBjYXRjaCAoZSkge1xuJHtpZGVudH1sb2FkRXJyb3JzLnB1c2goZSlcbiR7aWRlbnRMb3d9fWBcbiAgfVxuXG4gIHJldHVybiBgY29uc3QgeyByZWFkRmlsZVN5bmMgfSA9IHJlcXVpcmUoJ25vZGU6ZnMnKVxubGV0IG5hdGl2ZUJpbmRpbmcgPSBudWxsXG5jb25zdCBsb2FkRXJyb3JzID0gW11cblxuY29uc3QgaXNNdXNsID0gKCkgPT4ge1xuICBsZXQgbXVzbCA9IGZhbHNlXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgbXVzbCA9IGlzTXVzbEZyb21GaWxlc3lzdGVtKClcbiAgICBpZiAobXVzbCA9PT0gbnVsbCkge1xuICAgICAgbXVzbCA9IGlzTXVzbEZyb21SZXBvcnQoKVxuICAgIH1cbiAgICBpZiAobXVzbCA9PT0gbnVsbCkge1xuICAgICAgbXVzbCA9IGlzTXVzbEZyb21DaGlsZFByb2Nlc3MoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbXVzbFxufVxuXG5jb25zdCBpc0ZpbGVNdXNsID0gKGYpID0+IGYuaW5jbHVkZXMoJ2xpYmMubXVzbC0nKSB8fCBmLmluY2x1ZGVzKCdsZC1tdXNsLScpXG5cbmNvbnN0IGlzTXVzbEZyb21GaWxlc3lzdGVtID0gKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiByZWFkRmlsZVN5bmMoJy91c3IvYmluL2xkZCcsICd1dGYtOCcpLmluY2x1ZGVzKCdtdXNsJylcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jb25zdCBpc011c2xGcm9tUmVwb3J0ID0gKCkgPT4ge1xuICBsZXQgcmVwb3J0ID0gbnVsbFxuICBpZiAodHlwZW9mIHByb2Nlc3MucmVwb3J0Py5nZXRSZXBvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLnJlcG9ydC5leGNsdWRlTmV0d29yayA9IHRydWVcbiAgICByZXBvcnQgPSBwcm9jZXNzLnJlcG9ydC5nZXRSZXBvcnQoKVxuICB9XG4gIGlmICghcmVwb3J0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAocmVwb3J0LmhlYWRlciAmJiByZXBvcnQuaGVhZGVyLmdsaWJjVmVyc2lvblJ1bnRpbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXBvcnQuc2hhcmVkT2JqZWN0cykpIHtcbiAgICBpZiAocmVwb3J0LnNoYXJlZE9iamVjdHMuc29tZShpc0ZpbGVNdXNsKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IGlzTXVzbEZyb21DaGlsZFByb2Nlc3MgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYygnbGRkIC0tdmVyc2lvbicsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KS5pbmNsdWRlcygnbXVzbCcpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZiB3ZSByZWFjaCB0aGlzIGNhc2UsIHdlIGRvbid0IGtub3cgaWYgdGhlIHN5c3RlbSBpcyBtdXNsIG9yIG5vdCwgc28gaXMgYmV0dGVyIHRvIGp1c3QgZmFsbGJhY2sgdG8gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1aXJlTmF0aXZlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19OQVRJVkVfTElCUkFSWV9QQVRIKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5hdGl2ZUJpbmRpbmcgPSByZXF1aXJlKHByb2Nlc3MuZW52Lk5BUElfUlNfTkFUSVZFX0xJQlJBUllfUEFUSCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2goZXJyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnYW5kcm9pZC1hcm02NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2FuZHJvaWQtYXJtLWVhYmknKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gQW5kcm9pZCBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ3dpbjMyLXg2NC1tc3ZjJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ3dpbjMyLWlhMzItbXN2YycpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzItYXJtNjQtbXN2YycpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBXaW5kb3dzOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgJHtyZXF1aXJlVHVwbGUoJ2Rhcndpbi11bml2ZXJzYWwnLCA2KX1cbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2Rhcndpbi14NjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2Rhcndpbi1hcm02NCcpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBtYWNPUzogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZnJlZWJzZCcpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2ZyZWVic2QteDY0Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdmcmVlYnNkLWFybTY0Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIEZyZWVCU0Q6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXg2NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXg2NC1nbnUnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtNjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm02NC1nbnUnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybS1tdXNsZWFiaWhmJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybS1nbnVlYWJpaGYnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdyaXNjdjY0Jykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1yaXNjdjY0LW11c2wnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtcmlzY3Y2NC1nbnUnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdwcGM2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1wcGM2NC1nbnUnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3MzOTB4Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXMzOTB4LWdudScpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBMaW51eDogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnb3Blbmhhcm1vbnknKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybTY0LW9ob3MnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC14NjQtb2hvcycpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybS1vaG9zJyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIE9wZW5IYXJtb255OiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgT1M6IFxcJHtwcm9jZXNzLnBsYXRmb3JtfSwgYXJjaGl0ZWN0dXJlOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gIH1cbn1cblxubmF0aXZlQmluZGluZyA9IHJlcXVpcmVOYXRpdmUoKVxuXG5pZiAoIW5hdGl2ZUJpbmRpbmcgfHwgcHJvY2Vzcy5lbnYuTkFQSV9SU19GT1JDRV9XQVNJKSB7XG4gIHRyeSB7XG4gICAgbmF0aXZlQmluZGluZyA9IHJlcXVpcmUoJy4vJHtsb2NhbE5hbWV9Lndhc2kuY2pzJylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKGVycilcbiAgICB9XG4gIH1cbiAgaWYgKCFuYXRpdmVCaW5kaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5hdGl2ZUJpbmRpbmcgPSByZXF1aXJlKCcke3BrZ05hbWV9LXdhc20zMi13YXNpJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OQVBJX1JTX0ZPUkNFX1dBU0kpIHtcbiAgICAgICAgbG9hZEVycm9ycy5wdXNoKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKCFuYXRpdmVCaW5kaW5nKSB7XG4gIGlmIChsb2FkRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcXGBDYW5ub3QgZmluZCBuYXRpdmUgYmluZGluZy4gXFxgICtcbiAgICAgICAgXFxgbnBtIGhhcyBhIGJ1ZyByZWxhdGVkIHRvIG9wdGlvbmFsIGRlcGVuZGVuY2llcyAoaHR0cHM6Ly9naXRodWIuY29tL25wbS9jbGkvaXNzdWVzLzQ4MjgpLiBcXGAgK1xuICAgICAgICAnUGxlYXNlIHRyeSBcXGBucG0gaVxcYCBhZ2FpbiBhZnRlciByZW1vdmluZyBib3RoIHBhY2thZ2UtbG9jay5qc29uIGFuZCBub2RlX21vZHVsZXMgZGlyZWN0b3J5LicsXG4gICAgICB7IGNhdXNlOiBsb2FkRXJyb3JzIH1cbiAgICApXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxcYEZhaWxlZCB0byBsb2FkIG5hdGl2ZSBiaW5kaW5nXFxgKVxufVxuYFxufVxuIiwiZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyA9IChcbiAgd2FzaUZpbGVuYW1lOiBzdHJpbmcsXG4gIGluaXRpYWxNZW1vcnkgPSA0MDAwLFxuICBtYXhpbXVtTWVtb3J5ID0gNjU1MzYsXG4gIGZzID0gZmFsc2UsXG4gIGFzeW5jSW5pdCA9IGZhbHNlLFxuICBidWZmZXIgPSBmYWxzZSxcbikgPT4ge1xuICBjb25zdCBmc0ltcG9ydCA9IGZzXG4gICAgPyBidWZmZXJcbiAgICAgID8gYGltcG9ydCB7IG1lbWZzLCBCdWZmZXIgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUvZnMnYFxuICAgICAgOiBgaW1wb3J0IHsgbWVtZnMgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUvZnMnYFxuICAgIDogJydcbiAgY29uc3QgYnVmZmVySW1wb3J0ID0gYnVmZmVyICYmICFmcyA/IGBpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInYCA6ICcnXG4gIGNvbnN0IHdhc2lDcmVhdGlvbiA9IGZzXG4gICAgPyBgXG5leHBvcnQgY29uc3QgeyBmczogX19mcywgdm9sOiBfX3ZvbHVtZSB9ID0gbWVtZnMoKVxuXG5jb25zdCBfX3dhc2kgPSBuZXcgX19XQVNJKHtcbiAgdmVyc2lvbjogJ3ByZXZpZXcxJyxcbiAgZnM6IF9fZnMsXG4gIHByZW9wZW5zOiB7XG4gICAgJy8nOiAnLycsXG4gIH0sXG59KWBcbiAgICA6IGBcbmNvbnN0IF9fd2FzaSA9IG5ldyBfX1dBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxufSlgXG5cbiAgY29uc3Qgd29ya2VyRnNIYW5kbGVyID0gZnNcbiAgICA/IGAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5KF9fZnMpKVxcbmBcbiAgICA6ICcnXG5cbiAgY29uc3QgZW1uYXBpSW5qZWN0QnVmZmVyID0gYnVmZmVyXG4gICAgPyAnX19lbW5hcGlDb250ZXh0LmZlYXR1cmUuQnVmZmVyID0gQnVmZmVyJ1xuICAgIDogJydcbiAgY29uc3QgZW1uYXBpSW5zdGFudGlhdGVJbXBvcnQgPSBhc3luY0luaXRcbiAgICA/IGBpbnN0YW50aWF0ZU5hcGlNb2R1bGUgYXMgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVgXG4gICAgOiBgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyBhcyBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmNgXG4gIGNvbnN0IGVtbmFwaUluc3RhbnRpYXRlQ2FsbCA9IGFzeW5jSW5pdFxuICAgID8gYGF3YWl0IF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlYFxuICAgIDogYF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luY2BcblxuICByZXR1cm4gYGltcG9ydCB7XG4gIGNyZWF0ZU9uTWVzc2FnZSBhcyBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5LFxuICBnZXREZWZhdWx0Q29udGV4dCBhcyBfX2VtbmFwaUdldERlZmF1bHRDb250ZXh0LFxuICAke2VtbmFwaUluc3RhbnRpYXRlSW1wb3J0fSxcbiAgV0FTSSBhcyBfX1dBU0ksXG59IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdcbiR7ZnNJbXBvcnR9XG4ke2J1ZmZlckltcG9ydH1cbiR7d2FzaUNyZWF0aW9ufVxuXG5jb25zdCBfX3dhc21VcmwgPSBuZXcgVVJMKCcuLyR7d2FzaUZpbGVuYW1lfS53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmXG5jb25zdCBfX2VtbmFwaUNvbnRleHQgPSBfX2VtbmFwaUdldERlZmF1bHRDb250ZXh0KClcbiR7ZW1uYXBpSW5qZWN0QnVmZmVyfVxuXG5jb25zdCBfX3NoYXJlZE1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICBpbml0aWFsOiAke2luaXRpYWxNZW1vcnl9LFxuICBtYXhpbXVtOiAke21heGltdW1NZW1vcnl9LFxuICBzaGFyZWQ6IHRydWUsXG59KVxuXG5jb25zdCBfX3dhc21GaWxlID0gYXdhaXQgZmV0Y2goX193YXNtVXJsKS50aGVuKChyZXMpID0+IHJlcy5hcnJheUJ1ZmZlcigpKVxuXG5jb25zdCB7XG4gIGluc3RhbmNlOiBfX25hcGlJbnN0YW5jZSxcbiAgbW9kdWxlOiBfX3dhc2lNb2R1bGUsXG4gIG5hcGlNb2R1bGU6IF9fbmFwaU1vZHVsZSxcbn0gPSAke2VtbmFwaUluc3RhbnRpYXRlQ2FsbH0oX193YXNtRmlsZSwge1xuICBjb250ZXh0OiBfX2VtbmFwaUNvbnRleHQsXG4gIGFzeW5jV29ya1Bvb2xTaXplOiA0LFxuICB3YXNpOiBfX3dhc2ksXG4gIG9uQ3JlYXRlV29ya2VyKCkge1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTCgnLi93YXNpLXdvcmtlci1icm93c2VyLm1qcycsIGltcG9ydC5tZXRhLnVybCksIHtcbiAgICAgIHR5cGU6ICdtb2R1bGUnLFxuICAgIH0pXG4ke3dvcmtlckZzSGFuZGxlcn1cbiAgICByZXR1cm4gd29ya2VyXG4gIH0sXG4gIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICBtZW1vcnk6IF9fc2hhcmVkTWVtb3J5LFxuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0T2JqZWN0XG4gIH0sXG4gIGJlZm9yZUluaXQoeyBpbnN0YW5jZSB9KSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfX25hcGlfcmVnaXN0ZXJfXycpKSB7XG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbbmFtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pXG5gXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVXYXNpQmluZGluZyA9IChcbiAgd2FzbUZpbGVOYW1lOiBzdHJpbmcsXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gIGluaXRpYWxNZW1vcnkgPSA0MDAwLFxuICBtYXhpbXVtTWVtb3J5ID0gNjU1MzYsXG4pID0+IGAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyogcHJldHRpZXItaWdub3JlICovXG5cbi8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cblxuY29uc3QgX19ub2RlRnMgPSByZXF1aXJlKCdub2RlOmZzJylcbmNvbnN0IF9fbm9kZVBhdGggPSByZXF1aXJlKCdub2RlOnBhdGgnKVxuY29uc3QgeyBXQVNJOiBfX25vZGVXQVNJIH0gPSByZXF1aXJlKCdub2RlOndhc2knKVxuY29uc3QgeyBXb3JrZXIgfSA9IHJlcXVpcmUoJ25vZGU6d29ya2VyX3RocmVhZHMnKVxuXG5jb25zdCB7XG4gIGNyZWF0ZU9uTWVzc2FnZTogX193YXNtQ3JlYXRlT25NZXNzYWdlRm9yRnNQcm94eSxcbiAgZ2V0RGVmYXVsdENvbnRleHQ6IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQsXG4gIGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmM6IF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyxcbn0gPSByZXF1aXJlKCdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnKVxuXG5jb25zdCBfX3Jvb3REaXIgPSBfX25vZGVQYXRoLnBhcnNlKHByb2Nlc3MuY3dkKCkpLnJvb3RcblxuY29uc3QgX193YXNpID0gbmV3IF9fbm9kZVdBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICBlbnY6IHByb2Nlc3MuZW52LFxuICBwcmVvcGVuczoge1xuICAgIFtfX3Jvb3REaXJdOiBfX3Jvb3REaXIsXG4gIH1cbn0pXG5cbmNvbnN0IF9fZW1uYXBpQ29udGV4dCA9IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQoKVxuXG5jb25zdCBfX3NoYXJlZE1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICBpbml0aWFsOiAke2luaXRpYWxNZW1vcnl9LFxuICBtYXhpbXVtOiAke21heGltdW1NZW1vcnl9LFxuICBzaGFyZWQ6IHRydWUsXG59KVxuXG5sZXQgX193YXNtRmlsZVBhdGggPSBfX25vZGVQYXRoLmpvaW4oX19kaXJuYW1lLCAnJHt3YXNtRmlsZU5hbWV9Lndhc20nKVxuY29uc3QgX193YXNtRGVidWdGaWxlUGF0aCA9IF9fbm9kZVBhdGguam9pbihfX2Rpcm5hbWUsICcke3dhc21GaWxlTmFtZX0uZGVidWcud2FzbScpXG5cbmlmIChfX25vZGVGcy5leGlzdHNTeW5jKF9fd2FzbURlYnVnRmlsZVBhdGgpKSB7XG4gIF9fd2FzbUZpbGVQYXRoID0gX193YXNtRGVidWdGaWxlUGF0aFxufSBlbHNlIGlmICghX19ub2RlRnMuZXhpc3RzU3luYyhfX3dhc21GaWxlUGF0aCkpIHtcbiAgdHJ5IHtcbiAgICBfX3dhc21GaWxlUGF0aCA9IF9fbm9kZVBhdGgucmVzb2x2ZSgnJHtwYWNrYWdlTmFtZX0td2FzbTMyLXdhc2knKVxuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kICR7d2FzbUZpbGVOYW1lfS53YXNtIGZpbGUsIGFuZCAke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaSBwYWNrYWdlIGlzIG5vdCBpbnN0YWxsZWQuJylcbiAgfVxufVxuXG5jb25zdCB7IGluc3RhbmNlOiBfX25hcGlJbnN0YW5jZSwgbW9kdWxlOiBfX3dhc2lNb2R1bGUsIG5hcGlNb2R1bGU6IF9fbmFwaU1vZHVsZSB9ID0gX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jKF9fbm9kZUZzLnJlYWRGaWxlU3luYyhfX3dhc21GaWxlUGF0aCksIHtcbiAgY29udGV4dDogX19lbW5hcGlDb250ZXh0LFxuICBhc3luY1dvcmtQb29sU2l6ZTogKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHRocmVhZHNTaXplRnJvbUVudiA9IE51bWJlcihwcm9jZXNzLmVudi5OQVBJX1JTX0FTWU5DX1dPUktfUE9PTF9TSVpFID8/IHByb2Nlc3MuZW52LlVWX1RIUkVBRFBPT0xfU0laRSlcbiAgICAvLyBOYU4gPiAwIGlzIGZhbHNlXG4gICAgaWYgKHRocmVhZHNTaXplRnJvbUVudiA+IDApIHtcbiAgICAgIHJldHVybiB0aHJlYWRzU2l6ZUZyb21FbnZcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDRcbiAgICB9XG4gIH0pKCksXG4gIHJldXNlV29ya2VyOiB0cnVlLFxuICB3YXNpOiBfX3dhc2ksXG4gIG9uQ3JlYXRlV29ya2VyKCkge1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoX19ub2RlUGF0aC5qb2luKF9fZGlybmFtZSwgJ3dhc2ktd29ya2VyLm1qcycpLCB7XG4gICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgIH0pXG4gICAgd29ya2VyLm9ubWVzc2FnZSA9ICh7IGRhdGEgfSkgPT4ge1xuICAgICAgX193YXNtQ3JlYXRlT25NZXNzYWdlRm9yRnNQcm94eShfX25vZGVGcykoZGF0YSlcbiAgICB9XG5cbiAgICAvLyBUaGUgbWFpbiB0aHJlYWQgb2YgTm9kZS5qcyB3YWl0cyBmb3IgYWxsIHRoZSBhY3RpdmUgaGFuZGxlcyBiZWZvcmUgZXhpdGluZy5cbiAgICAvLyBCdXQgUnVzdCB0aHJlYWRzIGFyZSBuZXZlciB3YWl0ZWQgd2l0aG91dCBcXGB0aHJlYWQ6OmpvaW5cXGAuXG4gICAgLy8gU28gaGVyZSB3ZSBoYWNrIHRoZSBjb2RlIG9mIE5vZGUuanMgdG8gcHJldmVudCB0aGUgd29ya2VycyBmcm9tIGJlaW5nIHJlZmVyZW5jZWQgKGFjdGl2ZSkuXG4gICAgLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzE5ZTBkNDcyNzI4Yzc5ZDQxOGI3NGJkZGZmNTg4YmVhNzBhNDAzZDAvbGliL2ludGVybmFsL3dvcmtlci5qcyNMNDE1LFxuICAgIC8vIGEgd29ya2VyIGlzIGNvbnNpc3Qgb2YgdHdvIGhhbmRsZXM6IGtQdWJsaWNQb3J0IGFuZCBrSGFuZGxlLlxuICAgIHtcbiAgICAgIGNvbnN0IGtQdWJsaWNQb3J0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh3b3JrZXIpLmZpbmQocyA9PlxuICAgICAgICBzLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJrUHVibGljUG9ydFwiKVxuICAgICAgKTtcbiAgICAgIGlmIChrUHVibGljUG9ydCkge1xuICAgICAgICB3b3JrZXJba1B1YmxpY1BvcnRdLnJlZiA9ICgpID0+IHt9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrSGFuZGxlID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh3b3JrZXIpLmZpbmQocyA9PlxuICAgICAgICBzLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJrSGFuZGxlXCIpXG4gICAgICApO1xuICAgICAgaWYgKGtIYW5kbGUpIHtcbiAgICAgICAgd29ya2VyW2tIYW5kbGVdLnJlZiA9ICgpID0+IHt9O1xuICAgICAgfVxuXG4gICAgICB3b3JrZXIudW5yZWYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlclxuICB9LFxuICBvdmVyd3JpdGVJbXBvcnRzKGltcG9ydE9iamVjdCkge1xuICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAuLi5pbXBvcnRPYmplY3QuZW52LFxuICAgICAgLi4uaW1wb3J0T2JqZWN0Lm5hcGksXG4gICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgbWVtb3J5OiBfX3NoYXJlZE1lbW9yeSxcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydE9iamVjdFxuICB9LFxuICBiZWZvcmVJbml0KHsgaW5zdGFuY2UgfSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhpbnN0YW5jZS5leHBvcnRzKSkge1xuICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnX19uYXBpX3JlZ2lzdGVyX18nKSkge1xuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW25hbWVdKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59KVxuYFxuIiwiZXhwb3J0IGNvbnN0IFdBU0lfV09SS0VSX1RFTVBMQVRFID0gYGltcG9ydCBmcyBmcm9tIFwibm9kZTpmc1wiO1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gXCJub2RlOm1vZHVsZVwiO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQgeyBXQVNJIH0gZnJvbSBcIm5vZGU6d2FzaVwiO1xuaW1wb3J0IHsgcGFyZW50UG9ydCwgV29ya2VyIH0gZnJvbSBcIm5vZGU6d29ya2VyX3RocmVhZHNcIjtcblxuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcblxuY29uc3QgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgZ2V0RGVmYXVsdENvbnRleHQgfSA9IHJlcXVpcmUoXCJAbmFwaS1ycy93YXNtLXJ1bnRpbWVcIik7XG5cbmlmIChwYXJlbnRQb3J0KSB7XG4gIHBhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsIChkYXRhKSA9PiB7XG4gICAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UoeyBkYXRhIH0pO1xuICB9KTtcbn1cblxuT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gIHNlbGY6IGdsb2JhbFRoaXMsXG4gIHJlcXVpcmUsXG4gIFdvcmtlcixcbiAgaW1wb3J0U2NyaXB0czogZnVuY3Rpb24gKGYpIHtcbiAgICA7KDAsIGV2YWwpKGZzLnJlYWRGaWxlU3luYyhmLCBcInV0ZjhcIikgKyBcIi8vIyBzb3VyY2VVUkw9XCIgKyBmKTtcbiAgfSxcbiAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBpZiAocGFyZW50UG9ydCkge1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5jb25zdCBlbW5hcGlDb250ZXh0ID0gZ2V0RGVmYXVsdENvbnRleHQoKTtcblxuY29uc3QgX19yb290RGlyID0gcGFyc2UocHJvY2Vzcy5jd2QoKSkucm9vdDtcblxuY29uc3QgaGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcih7XG4gIG9uTG9hZCh7IHdhc21Nb2R1bGUsIHdhc21NZW1vcnkgfSkge1xuICAgIGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgIHByZW9wZW5zOiB7XG4gICAgICAgIFtfX3Jvb3REaXJdOiBfX3Jvb3REaXIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMod2FzbU1vZHVsZSwge1xuICAgICAgY2hpbGRUaHJlYWQ6IHRydWUsXG4gICAgICB3YXNpLFxuICAgICAgY29udGV4dDogZW1uYXBpQ29udGV4dCxcbiAgICAgIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbn0pO1xuXG5nbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gIGhhbmRsZXIuaGFuZGxlKGUpO1xufTtcbmBcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCcm93c2VyV29ya2VyQmluZGluZyA9IChmczogYm9vbGVhbikgPT4ge1xuICBjb25zdCBmc0ltcG9ydCA9IGZzXG4gICAgPyBgaW1wb3J0IHsgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYywgTWVzc2FnZUhhbmRsZXIsIFdBU0ksIGNyZWF0ZUZzUHJveHkgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnXG5pbXBvcnQgeyBtZW1mc0V4cG9ydGVkIGFzIF9fbWVtZnNFeHBvcnRlZCB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydcblxuY29uc3QgZnMgPSBjcmVhdGVGc1Byb3h5KF9fbWVtZnNFeHBvcnRlZClgXG4gICAgOiBgaW1wb3J0IHsgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYywgTWVzc2FnZUhhbmRsZXIsIFdBU0kgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnYFxuICBjb25zdCB3YXNpQ3JlYXRpb24gPSBmc1xuICAgID8gYGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBmcyxcbiAgICAgIHByZW9wZW5zOiB7XG4gICAgICAgICcvJzogJy8nLFxuICAgICAgfSxcbiAgICAgIHByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIH0sXG4gICAgICBwcmludEVycjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICB9KWBcbiAgICA6IGBjb25zdCB3YXNpID0gbmV3IFdBU0koe1xuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICAgIHByaW50RXJyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgIH0pYFxuICByZXR1cm4gYCR7ZnNJbXBvcnR9XG5cbmNvbnN0IGhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoe1xuICBvbkxvYWQoeyB3YXNtTW9kdWxlLCB3YXNtTWVtb3J5IH0pIHtcbiAgICAke3dhc2lDcmVhdGlvbn1cbiAgICByZXR1cm4gaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyh3YXNtTW9kdWxlLCB7XG4gICAgICBjaGlsZFRocmVhZDogdHJ1ZSxcbiAgICAgIHdhc2ksXG4gICAgICBvdmVyd3JpdGVJbXBvcnRzKGltcG9ydE9iamVjdCkge1xuICAgICAgICBpbXBvcnRPYmplY3QuZW52ID0ge1xuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0Lm5hcGksXG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVtbmFwaSxcbiAgICAgICAgICBtZW1vcnk6IHdhc21NZW1vcnksXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSlcbiAgfSxcbn0pXG5cbmdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgaGFuZGxlci5oYW5kbGUoZSlcbn1cbmBcbn1cbiIsImltcG9ydCB7IHNwYXduIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ25vZGU6Y3J5cHRvJ1xuaW1wb3J0IHsgZXhpc3RzU3luYywgbWtkaXJTeW5jLCBybVN5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ25vZGU6bW9kdWxlJ1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ25vZGU6b3MnXG5pbXBvcnQgeyBwYXJzZSwgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9yZXR0ZSdcblxuaW1wb3J0IHsgQnVpbGRPcHRpb25zIGFzIFJhd0J1aWxkT3B0aW9ucyB9IGZyb20gJy4uL2RlZi9idWlsZC5qcydcbmltcG9ydCB7XG4gIENMSV9WRVJTSU9OLFxuICBjb3B5RmlsZUFzeW5jLFxuICBDcmF0ZSxcbiAgZGVidWdGYWN0b3J5LFxuICBERUZBVUxUX1RZUEVfREVGX0hFQURFUixcbiAgZmlsZUV4aXN0cyxcbiAgZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCxcbiAgZ2V0VGFyZ2V0TGlua2VyLFxuICBta2RpckFzeW5jLFxuICBOYXBpQ29uZmlnLFxuICBwYXJzZU1ldGFkYXRhLFxuICBwYXJzZVRyaXBsZSxcbiAgcHJvY2Vzc1R5cGVEZWYsXG4gIHJlYWRGaWxlQXN5bmMsXG4gIHJlYWROYXBpQ29uZmlnLFxuICBUYXJnZXQsXG4gIHRhcmdldFRvRW52VmFyLFxuICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnksXG4gIHVubGlua0FzeW5jLFxuICB3cml0ZUZpbGVBc3luYyxcbiAgZGlyRXhpc3RzQXN5bmMsXG4gIHJlYWRkaXJBc3luYyxcbiAgQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSxcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmltcG9ydCB7IGNyZWF0ZUNqc0JpbmRpbmcsIGNyZWF0ZUVzbUJpbmRpbmcgfSBmcm9tICcuL3RlbXBsYXRlcy9pbmRleC5qcydcbmltcG9ydCB7XG4gIGNyZWF0ZVdhc2lCaW5kaW5nLFxuICBjcmVhdGVXYXNpQnJvd3NlckJpbmRpbmcsXG59IGZyb20gJy4vdGVtcGxhdGVzL2xvYWQtd2FzaS10ZW1wbGF0ZS5qcydcbmltcG9ydCB7XG4gIGNyZWF0ZVdhc2lCcm93c2VyV29ya2VyQmluZGluZyxcbiAgV0FTSV9XT1JLRVJfVEVNUExBVEUsXG59IGZyb20gJy4vdGVtcGxhdGVzL3dhc2ktd29ya2VyLXRlbXBsYXRlLmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnYnVpbGQnKVxuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKVxuXG50eXBlIE91dHB1dEtpbmQgPSAnanMnIHwgJ2R0cycgfCAnbm9kZScgfCAnZXhlJyB8ICd3YXNtJ1xudHlwZSBPdXRwdXQgPSB7IGtpbmQ6IE91dHB1dEtpbmQ7IHBhdGg6IHN0cmluZyB9XG5cbnR5cGUgQnVpbGRPcHRpb25zID0gUmF3QnVpbGRPcHRpb25zICYgeyBjYXJnb09wdGlvbnM/OiBzdHJpbmdbXSB9XG50eXBlIFBhcnNlZEJ1aWxkT3B0aW9ucyA9IE9taXQ8QnVpbGRPcHRpb25zLCAnY3dkJz4gJiB7IGN3ZDogc3RyaW5nIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkUHJvamVjdChyYXdPcHRpb25zOiBCdWlsZE9wdGlvbnMpIHtcbiAgZGVidWcoJ25hcGkgYnVpbGQgY29tbWFuZCByZWNlaXZlIG9wdGlvbnM6ICVPJywgcmF3T3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMgPSB7XG4gICAgZHRzQ2FjaGU6IHRydWUsXG4gICAgLi4ucmF3T3B0aW9ucyxcbiAgICBjd2Q6IHJhd09wdGlvbnMuY3dkID8/IHByb2Nlc3MuY3dkKCksXG4gIH1cblxuICBjb25zdCByZXNvbHZlUGF0aCA9ICguLi5wYXRoczogc3RyaW5nW10pID0+IHJlc29sdmUob3B0aW9ucy5jd2QsIC4uLnBhdGhzKVxuXG4gIGNvbnN0IG1hbmlmZXN0UGF0aCA9IHJlc29sdmVQYXRoKG9wdGlvbnMubWFuaWZlc3RQYXRoID8/ICdDYXJnby50b21sJylcbiAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBwYXJzZU1ldGFkYXRhKG1hbmlmZXN0UGF0aClcblxuICBjb25zdCBjcmF0ZSA9IG1ldGFkYXRhLnBhY2thZ2VzLmZpbmQoKHApID0+IHtcbiAgICAvLyBwYWNrYWdlIHdpdGggZ2l2ZW4gbmFtZVxuICAgIGlmIChvcHRpb25zLnBhY2thZ2UpIHtcbiAgICAgIHJldHVybiBwLm5hbWUgPT09IG9wdGlvbnMucGFja2FnZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcC5tYW5pZmVzdF9wYXRoID09PSBtYW5pZmVzdFBhdGhcbiAgICB9XG4gIH0pXG5cbiAgaWYgKCFjcmF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdVbmFibGUgdG8gZmluZCBjcmF0ZSB0byBidWlsZC4gSXQgc2VlbXMgeW91IGFyZSB0cnlpbmcgdG8gYnVpbGQgYSBjcmF0ZSBpbiBhIHdvcmtzcGFjZSwgdHJ5IHVzaW5nIGAtLXBhY2thZ2VgIG9wdGlvbiB0byBzcGVjaWZ5IHRoZSBwYWNrYWdlIHRvIGJ1aWxkLicsXG4gICAgKVxuICB9XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHJlc29sdmVQYXRoKFxuICAgICAgb3B0aW9ucy5jb25maWdQYXRoID8/IG9wdGlvbnMucGFja2FnZUpzb25QYXRoID8/ICdwYWNrYWdlLmpzb24nLFxuICAgICksXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZVBhdGgob3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQnVpbGRlcihtZXRhZGF0YSwgY3JhdGUsIGNvbmZpZywgb3B0aW9ucylcblxuICByZXR1cm4gYnVpbGRlci5idWlsZCgpXG59XG5cbmNsYXNzIEJ1aWxkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGFyZ3M6IHN0cmluZ1tdID0gW11cbiAgcHJpdmF0ZSByZWFkb25seSBlbnZzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXRzOiBPdXRwdXRbXSA9IFtdXG5cbiAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXQ6IFRhcmdldFxuICBwcml2YXRlIHJlYWRvbmx5IGNyYXRlRGlyOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXREaXI6IHN0cmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IHRhcmdldERpcjogc3RyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgZW5hYmxlVHlwZURlZjogYm9vbGVhbiA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNyYXRlOiBDcmF0ZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogTmFwaUNvbmZpZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFBhcnNlZEJ1aWxkT3B0aW9ucyxcbiAgKSB7XG4gICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldFxuICAgICAgPyBwYXJzZVRyaXBsZShvcHRpb25zLnRhcmdldClcbiAgICAgIDogcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUXG4gICAgICAgID8gcGFyc2VUcmlwbGUocHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUKVxuICAgICAgICA6IGdldFN5c3RlbURlZmF1bHRUYXJnZXQoKVxuICAgIHRoaXMuY3JhdGVEaXIgPSBwYXJzZShjcmF0ZS5tYW5pZmVzdF9wYXRoKS5kaXJcbiAgICB0aGlzLm91dHB1dERpciA9IHJlc29sdmUoXG4gICAgICB0aGlzLm9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5vdXRwdXREaXIgPz8gdGhpcy5jcmF0ZURpcixcbiAgICApXG4gICAgdGhpcy50YXJnZXREaXIgPVxuICAgICAgb3B0aW9ucy50YXJnZXREaXIgPz9cbiAgICAgIHByb2Nlc3MuZW52LkNBUkdPX0JVSUxEX1RBUkdFVF9ESVIgPz9cbiAgICAgIG1ldGFkYXRhLnRhcmdldF9kaXJlY3RvcnlcbiAgICB0aGlzLmVuYWJsZVR5cGVEZWYgPSB0aGlzLmNyYXRlLmRlcGVuZGVuY2llcy5zb21lKFxuICAgICAgKGRlcCkgPT5cbiAgICAgICAgZGVwLm5hbWUgPT09ICduYXBpLWRlcml2ZScgJiZcbiAgICAgICAgKGRlcC51c2VzX2RlZmF1bHRfZmVhdHVyZXMgfHwgZGVwLmZlYXR1cmVzLmluY2x1ZGVzKCd0eXBlLWRlZicpKSxcbiAgICApXG5cbiAgICBpZiAoIXRoaXMuZW5hYmxlVHlwZURlZikge1xuICAgICAgY29uc3QgcmVxdWlyZW1lbnRXYXJuaW5nID1cbiAgICAgICAgJ2BuYXBpLWRlcml2ZWAgY3JhdGUgaXMgbm90IHVzZWQgb3IgYHR5cGUtZGVmYCBmZWF0dXJlIGlzIG5vdCBlbmFibGVkIGZvciBgbmFwaS1kZXJpdmVgIGNyYXRlJ1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7cmVxdWlyZW1lbnRXYXJuaW5nfS4gV2lsbCBza2lwIGJpbmRpbmcgZ2VuZXJhdGlvbiBmb3IgXFxgLm5vZGVcXGAsIFxcYC53YXNpXFxgIGFuZCBcXGAuZC50c1xcYCBmaWxlcy5gLFxuICAgICAgKVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMub3B0aW9ucy5kdHMgfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmR0c0hlYWRlciB8fFxuICAgICAgICB0aGlzLmNvbmZpZy5kdHNIZWFkZXIgfHxcbiAgICAgICAgdGhpcy5jb25maWcuZHRzSGVhZGVyRmlsZVxuICAgICAgKSB7XG4gICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgYCR7cmVxdWlyZW1lbnRXYXJuaW5nfS4gXFxgZHRzXFxgIHJlbGF0ZWQgb3B0aW9ucyBhcmUgZW5hYmxlZCBidXQgd2lsbCBiZSBpZ25vcmVkLmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgY2R5TGliTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmF0ZS50YXJnZXRzLmZpbmQoKHQpID0+IHQuY3JhdGVfdHlwZXMuaW5jbHVkZXMoJ2NkeWxpYicpKVxuICAgICAgPy5uYW1lXG4gIH1cblxuICBnZXQgYmluTmFtZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5vcHRpb25zLmJpbiA/P1xuICAgICAgLy8gb25seSBhdmFpbGFibGUgaWYgbm90IGNkeWxpYiBvciBiaW4gbmFtZSBzcGVjaWZpZWRcbiAgICAgICh0aGlzLmNkeUxpYk5hbWVcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogdGhpcy5jcmF0ZS50YXJnZXRzLmZpbmQoKHQpID0+IHQuY3JhdGVfdHlwZXMuaW5jbHVkZXMoJ2JpbicpKT8ubmFtZSlcbiAgICApXG4gIH1cblxuICBidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3Qgd2FybmluZyA9XG4gICAgICAgICdNaXNzaW5nIGBjcmF0ZS10eXBlID0gW1wiY2R5bGliXCJdYCBpbiBbbGliXSBjb25maWcuIFRoZSBidWlsZCByZXN1bHQgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGFzIG5vZGUgYWRkb24uJ1xuXG4gICAgICBpZiAodGhpcy5iaW5OYW1lKSB7XG4gICAgICAgIGRlYnVnLndhcm4od2FybmluZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3YXJuaW5nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBpY2tCaW5hcnkoKVxuICAgICAgLnNldFBhY2thZ2UoKVxuICAgICAgLnNldEZlYXR1cmVzKClcbiAgICAgIC5zZXRUYXJnZXQoKVxuICAgICAgLnBpY2tDcm9zc1Rvb2xjaGFpbigpXG4gICAgICAuc2V0RW52cygpXG4gICAgICAuc2V0QnlwYXNzQXJncygpXG4gICAgICAuZXhlYygpXG4gIH1cblxuICBwcml2YXRlIHBpY2tDcm9zc1Rvb2xjaGFpbigpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VOYXBpQ3Jvc3MpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQ3Jvc3MpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYm90aCBgLS1jcm9zc2AgYW5kIGAtLXVzZS1uYXBpLWNyb3NzYCBvcHRpb25zLCBgLS11c2UtY3Jvc3NgIHdpbGwgYmUgaWdub3JlZC4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gdXNlIGJvdGggYC0tY3Jvc3MtY29tcGlsZWAgYW5kIGAtLXVzZS1uYXBpLWNyb3NzYCBvcHRpb25zLCBgLS1jcm9zcy1jb21waWxlYCB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2ZXJzaW9uLCBkb3dubG9hZCB9ID0gcmVxdWlyZSgnQG5hcGktcnMvY3Jvc3MtdG9vbGNoYWluJylcblxuICAgICAgY29uc3QgYWxpYXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICdzMzkweC11bmtub3duLWxpbnV4LWdudSc6ICdzMzkweC1pYm0tbGludXgtZ251JyxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9vbGNoYWluUGF0aCA9IGpvaW4oXG4gICAgICAgIGhvbWVkaXIoKSxcbiAgICAgICAgJy5uYXBpLXJzJyxcbiAgICAgICAgJ2Nyb3NzLXRvb2xjaGFpbicsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHRoaXMudGFyZ2V0LnRyaXBsZSxcbiAgICAgIClcbiAgICAgIG1rZGlyU3luYyh0b29sY2hhaW5QYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICAgICAgaWYgKGV4aXN0c1N5bmMoam9pbih0b29sY2hhaW5QYXRoLCAncGFja2FnZS5qc29uJykpKSB7XG4gICAgICAgIGRlYnVnKGBUb29sY2hhaW4gJHt0b29sY2hhaW5QYXRofSBleGlzdHMsIHNraXAgZXh0cmFjdGluZ2ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJBcmNoaXZlID0gZG93bmxvYWQocHJvY2Vzcy5hcmNoLCB0aGlzLnRhcmdldC50cmlwbGUpXG4gICAgICAgIHRhckFyY2hpdmUudW5wYWNrKHRvb2xjaGFpblBhdGgpXG4gICAgICB9XG4gICAgICBjb25zdCB1cHBlckNhc2VUYXJnZXQgPSB0YXJnZXRUb0VudlZhcih0aGlzLnRhcmdldC50cmlwbGUpXG4gICAgICBjb25zdCBjcm9zc1RhcmdldE5hbWUgPSBhbGlhc1t0aGlzLnRhcmdldC50cmlwbGVdID8/IHRoaXMudGFyZ2V0LnRyaXBsZVxuICAgICAgY29uc3QgbGlua2VyRW52ID0gYENBUkdPX1RBUkdFVF8ke3VwcGVyQ2FzZVRhcmdldH1fTElOS0VSYFxuICAgICAgdGhpcy5lbnZzW2xpbmtlckVudl0gPSBqb2luKFxuICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAnYmluJyxcbiAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nY2NgLFxuICAgICAgKVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfU1lTUk9PVCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9TWVNST09UYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgY3Jvc3NUYXJnZXROYW1lLFxuICAgICAgICAgICdzeXNyb290JyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfQVIpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQVJgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWFyYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfUkFOTElCKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1JBTkxJQmBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgICdiaW4nLFxuICAgICAgICAgIGAke2Nyb3NzVGFyZ2V0TmFtZX0tcmFubGliYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfUkVBREVMRikge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9SRUFERUxGYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1yZWFkZWxmYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfQ19JTkNMVURFX1BBVEgpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQ19JTkNMVURFX1BBVEhgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICBjcm9zc1RhcmdldE5hbWUsXG4gICAgICAgICAgJ3N5c3Jvb3QnLFxuICAgICAgICAgICd1c3InLFxuICAgICAgICAgICdpbmNsdWRlLycsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghcHJvY2Vzcy5lbnYuVEFSR0VUX0NDKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX0NDYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nY2NgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9DWFgpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQ1hYYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nKytgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52LlRBUkdFVF9DQz8uc3RhcnRzV2l0aCgnY2xhbmcnKSB8fFxuICAgICAgICAocHJvY2Vzcy5lbnYuQ0M/LnN0YXJ0c1dpdGgoJ2NsYW5nJykgJiYgIXByb2Nlc3MuZW52LlRBUkdFVF9DQylcbiAgICAgICkge1xuICAgICAgICBjb25zdCBUQVJHRVRfQ0ZMQUdTID0gcHJvY2Vzcy5lbnYuVEFSR0VUX0NGTEFHUyA/PyAnJ1xuICAgICAgICB0aGlzLmVudnMuVEFSR0VUX0NGTEFHUyA9IGAtLXN5c3Jvb3Q9JHt0aGlzLmVudnMuVEFSR0VUX1NZU1JPT1R9IC0tZ2NjLXRvb2xjaGFpbj0ke3Rvb2xjaGFpblBhdGh9ICR7VEFSR0VUX0NGTEFHU31gXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChwcm9jZXNzLmVudi5DWFg/LnN0YXJ0c1dpdGgoJ2NsYW5nKysnKSAmJiAhcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWCkgfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWD8uc3RhcnRzV2l0aCgnY2xhbmcrKycpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgVEFSR0VUX0NYWEZMQUdTID0gcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWEZMQUdTID8/ICcnXG4gICAgICAgIHRoaXMuZW52cy5UQVJHRVRfQ1hYRkxBR1MgPSBgLS1zeXNyb290PSR7dGhpcy5lbnZzLlRBUkdFVF9TWVNST09UfSAtLWdjYy10b29sY2hhaW49JHt0b29sY2hhaW5QYXRofSAke1RBUkdFVF9DWFhGTEFHU31gXG4gICAgICB9XG4gICAgICB0aGlzLmVudnMuUEFUSCA9IHRoaXMuZW52cy5QQVRIXG4gICAgICAgID8gYCR7dG9vbGNoYWluUGF0aH0vYmluOiR7dGhpcy5lbnZzLlBBVEh9OiR7cHJvY2Vzcy5lbnYuUEFUSH1gXG4gICAgICAgIDogYCR7dG9vbGNoYWluUGF0aH0vYmluOiR7cHJvY2Vzcy5lbnYuUEFUSH1gXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcud2FybignUGljayBjcm9zcyB0b29sY2hhaW4gZmFpbGVkJywgZSBhcyBFcnJvcilcbiAgICAgIC8vIGlnbm9yZSwgZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBleGVjKCkge1xuICAgIGRlYnVnKGBTdGFydCBidWlsZGluZyBjcmF0ZTogJHt0aGlzLmNyYXRlLm5hbWV9YClcbiAgICBkZWJ1ZygnICAlaScsIGBjYXJnbyAke3RoaXMuYXJncy5qb2luKCcgJyl9YClcblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAgIGNvbnN0IHdhdGNoID0gdGhpcy5vcHRpb25zLndhdGNoXG4gICAgY29uc3QgYnVpbGRUYXNrID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VDcm9zcyAmJiB0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnYC0tdXNlLWNyb3NzYCBhbmQgYC0tY3Jvc3MtY29tcGlsZWAgY2FuIG5vdCBiZSB1c2VkIHRvZ2V0aGVyJyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgY29uc3QgY29tbWFuZCA9XG4gICAgICAgIHByb2Nlc3MuZW52LkNBUkdPID8/ICh0aGlzLm9wdGlvbnMudXNlQ3Jvc3MgPyAnY3Jvc3MnIDogJ2NhcmdvJylcbiAgICAgIGNvbnN0IGJ1aWxkUHJvY2VzcyA9IHNwYXduKGNvbW1hbmQsIHRoaXMuYXJncywge1xuICAgICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLnRoaXMuZW52cyB9LFxuICAgICAgICBzdGRpbzogd2F0Y2ggPyBbJ2luaGVyaXQnLCAnaW5oZXJpdCcsICdwaXBlJ10gOiAnaW5oZXJpdCcsXG4gICAgICAgIGN3ZDogdGhpcy5vcHRpb25zLmN3ZCxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pXG5cbiAgICAgIGJ1aWxkUHJvY2Vzcy5vbmNlKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICBkZWJ1ZygnJWknLCBgQnVpbGQgY3JhdGUgJHt0aGlzLmNyYXRlLm5hbWV9IHN1Y2Nlc3NmdWxseSFgKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEJ1aWxkIGZhaWxlZCB3aXRoIGV4aXQgY29kZSAke2NvZGV9YCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGJ1aWxkUHJvY2Vzcy5vbmNlKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEJ1aWxkIGZhaWxlZCB3aXRoIGVycm9yOiAke2UubWVzc2FnZX1gLCB7IGNhdXNlOiBlIH0pKVxuICAgICAgfSlcblxuICAgICAgLy8gd2F0Y2ggbW9kZSBvbmx5LCB0aGV5IGFyZSBwaXBlZCB0aHJvdWdoIHN0ZGVyclxuICAgICAgYnVpbGRQcm9jZXNzLnN0ZGVycj8ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBkYXRhLnRvU3RyaW5nKClcbiAgICAgICAgY29uc29sZS5lcnJvcihvdXRwdXQpXG4gICAgICAgIGlmICgvRmluaXNoZWRcXHMoYGRldmB8YHJlbGVhc2VgKS8udGVzdChvdXRwdXQpKSB7XG4gICAgICAgICAgdGhpcy5wb3N0QnVpbGQoKS5jYXRjaCgoKSA9PiB7fSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhc2s6IGJ1aWxkVGFzay50aGVuKCgpID0+IHRoaXMucG9zdEJ1aWxkKCkpLFxuICAgICAgYWJvcnQ6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBpY2tCaW5hcnkoKSB7XG4gICAgbGV0IHNldCA9IGZhbHNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy53YXRjaCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkNJKSB7XG4gICAgICAgIGRlYnVnLndhcm4oJ1dhdGNoIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiBDSSBlbnZpcm9ubWVudCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXdhdGNoJylcbiAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby13YXRjaCcsICd3YXRjaCcpXG4gICAgICAgIC8vIHlhcm4gbmFwaSB3YXRjaCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnUgWy0tY3Jvc3MtY29tcGlsZV1cbiAgICAgICAgLy8gPT09PlxuICAgICAgICAvLyBjYXJnbyB3YXRjaCBbLi4uXSAtLSBidWlsZCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnVcbiAgICAgICAgLy8gY2FyZ28gd2F0Y2ggWy4uLl0gLS0gemlnYnVpbGQgLS10YXJnZXQgeDg2XzY0LXVua25vd24tbGludXgtZ251XG4gICAgICAgIHRoaXMuYXJncy5wdXNoKFxuICAgICAgICAgICd3YXRjaCcsXG4gICAgICAgICAgJy0td2h5JyxcbiAgICAgICAgICAnLWknLFxuICAgICAgICAgICcqLntqcyx0cyxub2RlfScsXG4gICAgICAgICAgJy13JyxcbiAgICAgICAgICB0aGlzLmNyYXRlRGlyLFxuICAgICAgICAgICctLScsXG4gICAgICAgICAgJ2NhcmdvJyxcbiAgICAgICAgICAnYnVpbGQnLFxuICAgICAgICApXG4gICAgICAgIHNldCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNyb3NzQ29tcGlsZSkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byBjcm9zcyBjb21waWxlIHRvIHdpbjMyIHBsYXRmb3JtIG9uIHdpbjMyIHBsYXRmb3JtIHdoaWNoIGlzIHVubmVjZXNzYXJ5LicsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBjYXJnby14d2luIHRvIGNyb3NzIGNvbXBpbGUgdG8gd2luMzIgcGxhdGZvcm1cbiAgICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXh3aW4nKVxuICAgICAgICAgIHRyeUluc3RhbGxDYXJnb0JpbmFyeSgnY2FyZ28teHdpbicsICd4d2luJylcbiAgICAgICAgICB0aGlzLmFyZ3MucHVzaCgneHdpbicsICdidWlsZCcpXG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0LmFyY2ggPT09ICdpYTMyJykge1xuICAgICAgICAgICAgdGhpcy5lbnZzLlhXSU5fQVJDSCA9ICd4ODYnXG4gICAgICAgICAgfVxuICAgICAgICAgIHNldCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnbGludXgnICYmXG4gICAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJlxuICAgICAgICAgIHRoaXMudGFyZ2V0LmFyY2ggPT09IHByb2Nlc3MuYXJjaCAmJlxuICAgICAgICAgIChmdW5jdGlvbiAoYWJpOiBzdHJpbmcgfCBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBnbGliY1ZlcnNpb25SdW50aW1lID1cbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICBwcm9jZXNzLnJlcG9ydD8uZ2V0UmVwb3J0KCk/LmhlYWRlcj8uZ2xpYmNWZXJzaW9uUnVudGltZVxuICAgICAgICAgICAgY29uc3QgbGliYyA9IGdsaWJjVmVyc2lvblJ1bnRpbWUgPyAnZ251JyA6ICdtdXNsJ1xuICAgICAgICAgICAgcmV0dXJuIGFiaSA9PT0gbGliY1xuICAgICAgICAgIH0pKHRoaXMudGFyZ2V0LmFiaSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byBjcm9zcyBjb21waWxlIHRvIGxpbnV4IHRhcmdldCBvbiBsaW51eCBwbGF0Zm9ybSB3aGljaCBpcyB1bm5lY2Vzc2FyeS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgJiZcbiAgICAgICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICApIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gZGFyd2luIHRhcmdldCBvbiBkYXJ3aW4gcGxhdGZvcm0gd2hpY2ggaXMgdW5uZWNlc3NhcnkuJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGNhcmdvLXppZ2J1aWxkIHRvIGNyb3NzIGNvbXBpbGUgdG8gb3RoZXIgcGxhdGZvcm1zXG4gICAgICAgICAgZGVidWcoJ1VzZSAlaScsICdjYXJnby16aWdidWlsZCcpXG4gICAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby16aWdidWlsZCcsICd6aWdidWlsZCcpXG4gICAgICAgICAgdGhpcy5hcmdzLnB1c2goJ3ppZ2J1aWxkJylcbiAgICAgICAgICBzZXQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNldCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJ2J1aWxkJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0UGFja2FnZSgpIHtcbiAgICBjb25zdCBhcmdzID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFja2FnZSkge1xuICAgICAgYXJncy5wdXNoKCctLXBhY2thZ2UnLCB0aGlzLm9wdGlvbnMucGFja2FnZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaW5OYW1lKSB7XG4gICAgICBhcmdzLnB1c2goJy0tYmluJywgdGhpcy5iaW5OYW1lKVxuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgZGVidWcoJ1NldCBwYWNrYWdlIGZsYWdzOiAnKVxuICAgICAgZGVidWcoJyAgJU8nLCBhcmdzKVxuICAgICAgdGhpcy5hcmdzLnB1c2goLi4uYXJncylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRUYXJnZXQoKSB7XG4gICAgZGVidWcoJ1NldCBjb21waWxpbmcgdGFyZ2V0IHRvOiAnKVxuICAgIGRlYnVnKCcgICVpJywgdGhpcy50YXJnZXQudHJpcGxlKVxuXG4gICAgdGhpcy5hcmdzLnB1c2goJy0tdGFyZ2V0JywgdGhpcy50YXJnZXQudHJpcGxlKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0RW52cygpIHtcbiAgICAvLyBUWVBFIERFRlxuICAgIGlmICh0aGlzLmVuYWJsZVR5cGVEZWYpIHtcbiAgICAgIHRoaXMuZW52cy5OQVBJX1RZUEVfREVGX1RNUF9GT0xERVIgPVxuICAgICAgICB0aGlzLmdlbmVyYXRlSW50ZXJtZWRpYXRlVHlwZURlZkZvbGRlcigpXG4gICAgICB0aGlzLnNldEZvcmNlQnVpbGRFbnZzKHRoaXMuZW52cy5OQVBJX1RZUEVfREVGX1RNUF9GT0xERVIpXG4gICAgfVxuXG4gICAgLy8gUlVTVEZMQUdTXG4gICAgbGV0IHJ1c3RmbGFncyA9XG4gICAgICBwcm9jZXNzLmVudi5SVVNURkxBR1MgPz8gcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfUlVTVEZMQUdTID8/ICcnXG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRhcmdldC5hYmk/LmluY2x1ZGVzKCdtdXNsJykgJiZcbiAgICAgICFydXN0ZmxhZ3MuaW5jbHVkZXMoJ3RhcmdldC1mZWF0dXJlPS1jcnQtc3RhdGljJylcbiAgICApIHtcbiAgICAgIHJ1c3RmbGFncyArPSAnIC1DIHRhcmdldC1mZWF0dXJlPS1jcnQtc3RhdGljJ1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaXAgJiYgIXJ1c3RmbGFncy5pbmNsdWRlcygnbGluay1hcmc9LXMnKSkge1xuICAgICAgcnVzdGZsYWdzICs9ICcgLUMgbGluay1hcmc9LXMnXG4gICAgfVxuXG4gICAgaWYgKHJ1c3RmbGFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZW52cy5SVVNURkxBR1MgPSBydXN0ZmxhZ3NcbiAgICB9XG4gICAgLy8gRU5EIFJVU1RGTEFHU1xuXG4gICAgLy8gTElOS0VSXG4gICAgY29uc3QgbGlua2VyID0gdGhpcy5vcHRpb25zLmNyb3NzQ29tcGlsZVxuICAgICAgPyB2b2lkIDBcbiAgICAgIDogZ2V0VGFyZ2V0TGlua2VyKHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAvLyBUT0RPOlxuICAgIC8vICAgZGlyZWN0bHkgc2V0IENBUkdPX1RBUkdFVF88dGFyZ2V0Pl9MSU5LRVIgd2lsbCBjb3ZlciAuY2FyZ28vY29uZmlnLnRvbWxcbiAgICAvLyAgIHdpbGwgZGV0ZWN0IGJ5IGNhcmdvIGNvbmZpZyB3aGVuIGl0IGJlY29tZXMgc3RhYmxlXG4gICAgLy8gICBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvY2FyZ28vaXNzdWVzLzkzMDFcbiAgICBjb25zdCBsaW5rZXJFbnYgPSBgQ0FSR09fVEFSR0VUXyR7dGFyZ2V0VG9FbnZWYXIoXG4gICAgICB0aGlzLnRhcmdldC50cmlwbGUsXG4gICAgKX1fTElOS0VSYFxuICAgIGlmIChsaW5rZXIgJiYgIXByb2Nlc3MuZW52W2xpbmtlckVudl0gJiYgIXRoaXMuZW52c1tsaW5rZXJFbnZdKSB7XG4gICAgICB0aGlzLmVudnNbbGlua2VyRW52XSA9IGxpbmtlclxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICB0aGlzLnNldEFuZHJvaWRFbnYoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knKSB7XG4gICAgICB0aGlzLnNldFdhc2lFbnYoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ29wZW5oYXJtb255Jykge1xuICAgICAgdGhpcy5zZXRPcGVuSGFybW9ueUVudigpXG4gICAgfVxuXG4gICAgZGVidWcoJ1NldCBlbnZzOiAnKVxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW52cykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICBkZWJ1ZygnICAlaScsIGAke2t9PSR7dn1gKVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRGb3JjZUJ1aWxkRW52cyh0eXBlRGVmVG1wRm9sZGVyOiBzdHJpbmcpIHtcbiAgICAvLyBkeW5hbWljYWxseSBjaGVjayBhbGwgbmFwaS1ycyBkZXBzIGFuZCBzZXQgYE5BUElfRk9SQ0VfQlVJTERfe3VwcGVyY2FzZShzbmFrZV9jYXNlKG5hbWUpKX0gPSB0aW1lc3RhbXBgXG4gICAgdGhpcy5tZXRhZGF0YS5wYWNrYWdlcy5mb3JFYWNoKChjcmF0ZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBjcmF0ZS5kZXBlbmRlbmNpZXMuc29tZSgoZCkgPT4gZC5uYW1lID09PSAnbmFwaS1kZXJpdmUnKSAmJlxuICAgICAgICAhZXhpc3RzU3luYyhqb2luKHR5cGVEZWZUbXBGb2xkZXIsIGNyYXRlLm5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZW52c1tcbiAgICAgICAgICBgTkFQSV9GT1JDRV9CVUlMRF8ke2NyYXRlLm5hbWUucmVwbGFjZSgvLS9nLCAnXycpLnRvVXBwZXJDYXNlKCl9YFxuICAgICAgICBdID0gRGF0ZS5ub3coKS50b1N0cmluZygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgc2V0QW5kcm9pZEVudigpIHtcbiAgICBjb25zdCB7IEFORFJPSURfTkRLX0xBVEVTVF9IT01FIH0gPSBwcm9jZXNzLmVudlxuICAgIGlmICghQU5EUk9JRF9OREtfTEFURVNUX0hPTUUpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgIGAke2NvbG9ycy5yZWQoXG4gICAgICAgICAgJ0FORFJPSURfTkRLX0xBVEVTVF9IT01FJyxcbiAgICAgICAgKX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZ2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gc2tpcCBjcm9zcyBjb21waWxlIHNldHVwIGlmIGhvc3QgaXMgYW5kcm9pZFxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldEFyY2ggPSB0aGlzLnRhcmdldC5hcmNoID09PSAnYXJtJyA/ICdhcm12N2EnIDogJ2FhcmNoNjQnXG4gICAgY29uc3QgdGFyZ2V0UGxhdGZvcm0gPVxuICAgICAgdGhpcy50YXJnZXQuYXJjaCA9PT0gJ2FybScgPyAnYW5kcm9pZGVhYmkyNCcgOiAnYW5kcm9pZDI0J1xuICAgIGNvbnN0IGhvc3RQbGF0Zm9ybSA9XG4gICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICA/ICdkYXJ3aW4nXG4gICAgICAgIDogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICAgICAgICAgID8gJ3dpbmRvd3MnXG4gICAgICAgICAgOiAnbGludXgnXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmVudnMsIHtcbiAgICAgIENBUkdPX1RBUkdFVF9BQVJDSDY0X0xJTlVYX0FORFJPSURfTElOS0VSOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtYW5kcm9pZDI0LWNsYW5nYCxcbiAgICAgIENBUkdPX1RBUkdFVF9BUk1WN19MSU5VWF9BTkRST0lERUFCSV9MSU5LRVI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC1hbmRyb2lkZWFiaTI0LWNsYW5nYCxcbiAgICAgIFRBUkdFVF9DQzogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LSR7dGFyZ2V0UGxhdGZvcm19LWNsYW5nYCxcbiAgICAgIFRBUkdFVF9DWFg6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC0ke3RhcmdldFBsYXRmb3JtfS1jbGFuZysrYCxcbiAgICAgIFRBUkdFVF9BUjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi9sbHZtLWFyYCxcbiAgICAgIFRBUkdFVF9SQU5MSUI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vbGx2bS1yYW5saWJgLFxuICAgICAgQU5EUk9JRF9OREs6IEFORFJPSURfTkRLX0xBVEVTVF9IT01FLFxuICAgICAgUEFUSDogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2JpbiR7cHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6J30ke3Byb2Nlc3MuZW52LlBBVEh9YCxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRXYXNpRW52KCkge1xuICAgIGNvbnN0IGVtbmFwaSA9IGpvaW4oXG4gICAgICByZXF1aXJlLnJlc29sdmUoJ2VtbmFwaScpLFxuICAgICAgJy4uJyxcbiAgICAgICdsaWInLFxuICAgICAgJ3dhc20zMi13YXNpLXRocmVhZHMnLFxuICAgIClcbiAgICB0aGlzLmVudnMuRU1OQVBJX0xJTktfRElSID0gZW1uYXBpXG4gICAgY29uc3QgeyBXQVNJX1NES19QQVRIIH0gPSBwcm9jZXNzLmVudlxuXG4gICAgaWYgKFdBU0lfU0RLX1BBVEggJiYgZXhpc3RzU3luYyhXQVNJX1NES19QQVRIKSkge1xuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSV9QUkVWSUVXMV9USFJFQURTX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDFfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lQMV9USFJFQURTX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDJfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9DQycsIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdjbGFuZycpKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DWFgnLFxuICAgICAgICBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAnY2xhbmcrKycpLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0FSJywgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ2FyJykpXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX1JBTkxJQicsXG4gICAgICAgIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdyYW5saWInKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ0ZMQUdTJyxcbiAgICAgICAgYC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHMgLS1zeXNyb290PSR7V0FTSV9TREtfUEFUSH0vc2hhcmUvd2FzaS1zeXNyb290IC1wdGhyZWFkIC1tbGx2bSAtd2FzbS1lbmFibGUtc2psamAsXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NYWEZMQUdTJyxcbiAgICAgICAgYC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHMgLS1zeXNyb290PSR7V0FTSV9TREtfUEFUSH0vc2hhcmUvd2FzaS1zeXNyb290IC1wdGhyZWFkIC1tbGx2bSAtd2FzbS1lbmFibGUtc2psamAsXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICBgVEFSR0VUX0xERkxBR1NgLFxuICAgICAgICBgLWZ1c2UtbGQ9JHtXQVNJX1NES19QQVRIfS9iaW4vd2FzbS1sZCAtLXRhcmdldD13YXNtMzItd2FzaS10aHJlYWRzYCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldE9wZW5IYXJtb255RW52KCkge1xuICAgIGNvbnN0IHsgT0hPU19TREtfUEFUSCwgT0hPU19TREtfTkFUSVZFIH0gPSBwcm9jZXNzLmVudlxuICAgIGNvbnN0IG5ka1BhdGggPSBPSE9TX1NES19QQVRIXG4gICAgICA/IGAke09IT1NfU0RLX05BVElWRX0vbmF0aXZlYFxuICAgICAgOiBPSE9TX1NES19OQVRJVkVcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKCFuZGtQYXRoICYmIHByb2Nlc3MucGxhdGZvcm0gIT09ICdvcGVuaGFybW9ueScpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgIGAke2NvbG9ycy5yZWQoJ09IT1NfU0RLX1BBVEgnKX0gb3IgJHtjb2xvcnMucmVkKCdPSE9TX1NES19OQVRJVkUnKX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZ2AsXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgbGlua2VyTmFtZSA9IGBDQVJHT19UQVJHRVRfJHt0aGlzLnRhcmdldC50cmlwbGUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJyl9X0xJTktFUmBcbiAgICBjb25zdCByYW5QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1yYW5saWJgXG4gICAgY29uc3QgYXJQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1hcmBcbiAgICBjb25zdCBjY1BhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi8ke3RoaXMudGFyZ2V0LnRyaXBsZX0tY2xhbmdgXG4gICAgY29uc3QgY3h4UGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluLyR7dGhpcy50YXJnZXQudHJpcGxlfS1jbGFuZysrYFxuICAgIGNvbnN0IGFzUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tYXNgXG4gICAgY29uc3QgbGRQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGQubGxkYFxuICAgIGNvbnN0IHN0cmlwUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tc3RyaXBgXG4gICAgY29uc3Qgb2JqRHVtcFBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW9iamR1bXBgXG4gICAgY29uc3Qgb2JqQ29weVBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW9iamNvcHlgXG4gICAgY29uc3Qgbm1QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1ubWBcbiAgICBjb25zdCBiaW5QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW5gXG4gICAgY29uc3QgbGliUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vbGliYFxuXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnTElCQ0xBTkdfUEFUSCcsIGxpYlBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnREVQX0FUT01JQycsICdjbGFuZ19ydC5idWlsdGlucycpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhsaW5rZXJOYW1lLCBjY1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NDJywgY2NQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9DWFgnLCBjeHhQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUicsIGFyUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfUkFOTElCJywgcmFuUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQVMnLCBhc1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0xEJywgbGRQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9TVFJJUCcsIHN0cmlwUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfT0JKRFVNUCcsIG9iakR1bXBQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9PQkpDT1BZJywgb2JqQ29weVBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX05NJywgbm1QYXRoKVxuICAgIHRoaXMuZW52cy5QQVRIID0gYCR7YmluUGF0aH0ke3Byb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnOycgOiAnOid9JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgfVxuXG4gIHByaXZhdGUgc2V0RmVhdHVyZXMoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbGxGZWF0dXJlcyAmJiB0aGlzLm9wdGlvbnMubm9EZWZhdWx0RmVhdHVyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBzcGVjaWZ5IC0tYWxsLWZlYXR1cmVzIGFuZCAtLW5vLWRlZmF1bHQtZmVhdHVyZXMgdG9nZXRoZXInLFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbEZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tYWxsLWZlYXR1cmVzJylcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5ub0RlZmF1bHRGZWF0dXJlcykge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWRlZmF1bHQtZmVhdHVyZXMnKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tZmVhdHVyZXMnLCAuLi50aGlzLm9wdGlvbnMuZmVhdHVyZXMpXG4gICAgfVxuXG4gICAgZGVidWcoJ1NldCBmZWF0dXJlcyBmbGFnczogJylcbiAgICBkZWJ1ZygnICAlTycsIGFyZ3MpXG4gICAgdGhpcy5hcmdzLnB1c2goLi4uYXJncylcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldEJ5cGFzc0FyZ3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWxlYXNlKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS1yZWxlYXNlJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXZlcmJvc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0RGlyKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS10YXJnZXQtZGlyJywgdGhpcy5vcHRpb25zLnRhcmdldERpcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByb2ZpbGUpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXByb2ZpbGUnLCB0aGlzLm9wdGlvbnMucHJvZmlsZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tbWFuaWZlc3QtcGF0aCcsIHRoaXMub3B0aW9ucy5tYW5pZmVzdFBhdGgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jYXJnb09wdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goLi4udGhpcy5vcHRpb25zLmNhcmdvT3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUludGVybWVkaWF0ZVR5cGVEZWZGb2xkZXIoKSB7XG4gICAgbGV0IGZvbGRlciA9IGpvaW4oXG4gICAgICB0aGlzLnRhcmdldERpcixcbiAgICAgICduYXBpLXJzJyxcbiAgICAgIGAke3RoaXMuY3JhdGUubmFtZX0tJHtjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKHRoaXMuY3JhdGUubWFuaWZlc3RfcGF0aClcbiAgICAgICAgLnVwZGF0ZShDTElfVkVSU0lPTilcbiAgICAgICAgLmRpZ2VzdCgnaGV4JylcbiAgICAgICAgLnN1YnN0cmluZygwLCA4KX1gLFxuICAgIClcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmR0c0NhY2hlKSB7XG4gICAgICBybVN5bmMoZm9sZGVyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSlcbiAgICAgIGZvbGRlciArPSBgXyR7RGF0ZS5ub3coKX1gXG4gICAgfVxuXG4gICAgbWtkaXJBc3luYyhmb2xkZXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG5cbiAgICByZXR1cm4gZm9sZGVyXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBvc3RCdWlsZCgpIHtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYFRyeSB0byBjcmVhdGUgb3V0cHV0IGRpcmVjdG9yeTpgKVxuICAgICAgZGVidWcoJyAgJWknLCB0aGlzLm91dHB1dERpcilcbiAgICAgIGF3YWl0IG1rZGlyQXN5bmModGhpcy5vdXRwdXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICBkZWJ1ZyhgT3V0cHV0IGRpcmVjdG9yeSBjcmVhdGVkYClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgb3V0cHV0IGRpcmVjdG9yeSAke3RoaXMub3V0cHV0RGlyfWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHdhc21CaW5hcnlOYW1lID0gYXdhaXQgdGhpcy5jb3B5QXJ0aWZhY3QoKVxuXG4gICAgLy8gb25seSBmb3IgY2R5bGliXG4gICAgaWYgKHRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3QgaWRlbnRzID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVR5cGVEZWYoKVxuICAgICAgY29uc3QganNPdXRwdXQgPSBhd2FpdCB0aGlzLndyaXRlSnNCaW5kaW5nKGlkZW50cylcbiAgICAgIGNvbnN0IHdhc21CaW5kaW5nc091dHB1dCA9IGF3YWl0IHRoaXMud3JpdGVXYXNpQmluZGluZyhcbiAgICAgICAgd2FzbUJpbmFyeU5hbWUsXG4gICAgICAgIGlkZW50cyxcbiAgICAgIClcbiAgICAgIGlmIChqc091dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaChqc091dHB1dClcbiAgICAgIH1cbiAgICAgIGlmICh3YXNtQmluZGluZ3NPdXRwdXQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goLi4ud2FzbUJpbmRpbmdzT3V0cHV0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm91dHB1dHNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY29weUFydGlmYWN0KCkge1xuICAgIGNvbnN0IFtzcmNOYW1lLCBkZXN0TmFtZSwgd2FzbUJpbmFyeU5hbWVdID0gdGhpcy5nZXRBcnRpZmFjdE5hbWVzKClcbiAgICBpZiAoIXNyY05hbWUgfHwgIWRlc3ROYW1lKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcm9maWxlID1cbiAgICAgIHRoaXMub3B0aW9ucy5wcm9maWxlID8/ICh0aGlzLm9wdGlvbnMucmVsZWFzZSA/ICdyZWxlYXNlJyA6ICdkZWJ1ZycpXG4gICAgY29uc3Qgc3JjID0gam9pbih0aGlzLnRhcmdldERpciwgdGhpcy50YXJnZXQudHJpcGxlLCBwcm9maWxlLCBzcmNOYW1lKVxuICAgIGRlYnVnKGBDb3B5IGFydGlmYWN0IGZyb206IFske3NyY31dYClcbiAgICBjb25zdCBkZXN0ID0gam9pbih0aGlzLm91dHB1dERpciwgZGVzdE5hbWUpXG4gICAgY29uc3QgaXNXYXNtID0gZGVzdC5lbmRzV2l0aCgnLndhc20nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKGRlc3QpKSB7XG4gICAgICAgIGRlYnVnKCdPbGQgYXJ0aWZhY3QgZm91bmQsIHJlbW92ZSBpdCBmaXJzdCcpXG4gICAgICAgIGF3YWl0IHVubGlua0FzeW5jKGRlc3QpXG4gICAgICB9XG4gICAgICBkZWJ1ZygnQ29weSBhcnRpZmFjdCB0bzonKVxuICAgICAgZGVidWcoJyAgJWknLCBkZXN0KVxuICAgICAgaWYgKGlzV2FzbSkge1xuICAgICAgICBjb25zdCB7IE1vZHVsZUNvbmZpZyB9ID0gYXdhaXQgaW1wb3J0KCdAbmFwaS1ycy93YXNtLXRvb2xzJylcbiAgICAgICAgZGVidWcoJ0dlbmVyYXRlIGRlYnVnIHdhc20gbW9kdWxlJylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWJ1Z1dhc21Nb2R1bGUgPSBuZXcgTW9kdWxlQ29uZmlnKClcbiAgICAgICAgICAgIC5nZW5lcmF0ZUR3YXJmKHRydWUpXG4gICAgICAgICAgICAuZ2VuZXJhdGVOYW1lU2VjdGlvbih0cnVlKVxuICAgICAgICAgICAgLmdlbmVyYXRlUHJvZHVjZXJzU2VjdGlvbih0cnVlKVxuICAgICAgICAgICAgLnByZXNlcnZlQ29kZVRyYW5zZm9ybSh0cnVlKVxuICAgICAgICAgICAgLnN0cmljdFZhbGlkYXRlKGZhbHNlKVxuICAgICAgICAgICAgLnBhcnNlKGF3YWl0IHJlYWRGaWxlQXN5bmMoc3JjKSlcbiAgICAgICAgICBjb25zdCBkZWJ1Z1dhc21CaW5hcnkgPSBkZWJ1Z1dhc21Nb2R1bGUuZW1pdFdhc20odHJ1ZSlcbiAgICAgICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgICAgIGRlc3QucmVwbGFjZSgvXFwud2FzbSQvLCAnLmRlYnVnLndhc20nKSxcbiAgICAgICAgICAgIGRlYnVnV2FzbUJpbmFyeSxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcoJ0dlbmVyYXRlIHJlbGVhc2Ugd2FzbSBtb2R1bGUnKVxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VXYXNtTW9kdWxlID0gbmV3IE1vZHVsZUNvbmZpZygpXG4gICAgICAgICAgICAuZ2VuZXJhdGVEd2FyZihmYWxzZSlcbiAgICAgICAgICAgIC5nZW5lcmF0ZU5hbWVTZWN0aW9uKGZhbHNlKVxuICAgICAgICAgICAgLmdlbmVyYXRlUHJvZHVjZXJzU2VjdGlvbihmYWxzZSlcbiAgICAgICAgICAgIC5wcmVzZXJ2ZUNvZGVUcmFuc2Zvcm0oZmFsc2UpXG4gICAgICAgICAgICAuc3RyaWN0VmFsaWRhdGUoZmFsc2UpXG4gICAgICAgICAgICAub25seVN0YWJsZUZlYXR1cmVzKGZhbHNlKVxuICAgICAgICAgICAgLnBhcnNlKGRlYnVnV2FzbUJpbmFyeSlcbiAgICAgICAgICBjb25zdCByZWxlYXNlV2FzbUJpbmFyeSA9IHJlbGVhc2VXYXNtTW9kdWxlLmVtaXRXYXNtKGZhbHNlKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIHJlbGVhc2VXYXNtQmluYXJ5KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUgZGVidWcgd2FzbSBtb2R1bGU6ICR7KGUgYXMgYW55KS5tZXNzYWdlID8/IGV9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgYXdhaXQgY29weUZpbGVBc3luYyhzcmMsIGRlc3QpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGNvcHlGaWxlQXN5bmMoc3JjLCBkZXN0KVxuICAgICAgfVxuICAgICAgdGhpcy5vdXRwdXRzLnB1c2goe1xuICAgICAgICBraW5kOiBkZXN0LmVuZHNXaXRoKCcubm9kZScpID8gJ25vZGUnIDogaXNXYXNtID8gJ3dhc20nIDogJ2V4ZScsXG4gICAgICAgIHBhdGg6IGRlc3QsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHdhc21CaW5hcnlOYW1lID8gam9pbih0aGlzLm91dHB1dERpciwgd2FzbUJpbmFyeU5hbWUpIDogbnVsbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvcHkgYXJ0aWZhY3QnLCB7IGNhdXNlOiBlIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcnRpZmFjdE5hbWVzKCkge1xuICAgIGlmICh0aGlzLmNkeUxpYk5hbWUpIHtcbiAgICAgIGNvbnN0IGNkeUxpYiA9IHRoaXMuY2R5TGliTmFtZS5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgIGNvbnN0IHdhc2lUYXJnZXQgPSB0aGlzLmNvbmZpZy50YXJnZXRzLmZpbmQoKHQpID0+IHQucGxhdGZvcm0gPT09ICd3YXNpJylcblxuICAgICAgY29uc3Qgc3JjTmFtZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICAgID8gYGxpYiR7Y2R5TGlifS5keWxpYmBcbiAgICAgICAgICA6IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICAgICAgICA/IGAke2NkeUxpYn0uZGxsYFxuICAgICAgICAgICAgOiB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knIHx8IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzbSdcbiAgICAgICAgICAgICAgPyBgJHtjZHlMaWJ9Lndhc21gXG4gICAgICAgICAgICAgIDogYGxpYiR7Y2R5TGlifS5zb2BcblxuICAgICAgbGV0IGRlc3ROYW1lID0gdGhpcy5jb25maWcuYmluYXJ5TmFtZVxuICAgICAgLy8gYWRkIHBsYXRmb3JtIHN1ZmZpeCB0byBiaW5hcnkgbmFtZVxuICAgICAgLy8gaW5kZXhbLmxpbnV4LXg2NC1nbnVdLm5vZGVcbiAgICAgIC8vICAgICAgIF5eXl5eXl5eXl5eXl5eXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBsYXRmb3JtKSB7XG4gICAgICAgIGRlc3ROYW1lICs9IGAuJHt0aGlzLnRhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YFxuICAgICAgfVxuICAgICAgaWYgKHNyY05hbWUuZW5kc1dpdGgoJy53YXNtJykpIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gJy53YXNtJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gJy5ub2RlJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzcmNOYW1lLFxuICAgICAgICBkZXN0TmFtZSxcbiAgICAgICAgd2FzaVRhcmdldFxuICAgICAgICAgID8gYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0uJHt3YXNpVGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgICA6IG51bGwsXG4gICAgICBdXG4gICAgfSBlbHNlIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgIGNvbnN0IHNyY05hbWUgPVxuICAgICAgICB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IGAke3RoaXMuYmluTmFtZX0uZXhlYCA6IHRoaXMuYmluTmFtZVxuXG4gICAgICByZXR1cm4gW3NyY05hbWUsIHNyY05hbWVdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVHlwZURlZigpIHtcbiAgICBjb25zdCB0eXBlRGVmRGlyID0gdGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUlxuICAgIGlmICghdGhpcy5lbmFibGVUeXBlRGVmIHx8ICEoYXdhaXQgZGlyRXhpc3RzQXN5bmModHlwZURlZkRpcikpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBjb25zdCBkZXN0ID0gam9pbih0aGlzLm91dHB1dERpciwgdGhpcy5vcHRpb25zLmR0cyA/PyAnaW5kZXguZC50cycpXG5cbiAgICBsZXQgaGVhZGVyID0gJydcbiAgICBsZXQgZHRzID0gJydcbiAgICBsZXQgZXhwb3J0czogc3RyaW5nW10gPSBbXVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubm9EdHNIZWFkZXIpIHtcbiAgICAgIGNvbnN0IGR0c0hlYWRlciA9IHRoaXMub3B0aW9ucy5kdHNIZWFkZXIgPz8gdGhpcy5jb25maWcuZHRzSGVhZGVyXG4gICAgICAvLyBgZHRzSGVhZGVyRmlsZWAgaW4gY29uZmlnID4gYGR0c0hlYWRlcmAgaW4gY2xpIGZsYWcgPiBgZHRzSGVhZGVyYCBpbiBjb25maWdcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVyID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgICAgIGpvaW4odGhpcy5vcHRpb25zLmN3ZCwgdGhpcy5jb25maWcuZHRzSGVhZGVyRmlsZSksXG4gICAgICAgICAgICAndXRmLTgnLFxuICAgICAgICAgIClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlYWQgZHRzIGhlYWRlciBmaWxlICR7dGhpcy5jb25maWcuZHRzSGVhZGVyRmlsZX1gLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZHRzSGVhZGVyKSB7XG4gICAgICAgIGhlYWRlciA9IGR0c0hlYWRlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyID0gREVGQVVMVF9UWVBFX0RFRl9IRUFERVJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHJlYWRkaXJBc3luYyh0eXBlRGVmRGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcblxuICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnTm8gdHlwZSBkZWYgZmlsZXMgZm91bmQuIFNraXAgZ2VuZXJhdGluZyBkdHMgZmlsZS4nKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoIWZpbGUuaXNGaWxlKCkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkdHM6IGZpbGVEdHMsIGV4cG9ydHM6IGZpbGVFeHBvcnRzIH0gPSBhd2FpdCBwcm9jZXNzVHlwZURlZihcbiAgICAgICAgam9pbih0eXBlRGVmRGlyLCBmaWxlLm5hbWUpLFxuICAgICAgICB0aGlzLm9wdGlvbnMuY29uc3RFbnVtID8/IHRoaXMuY29uZmlnLmNvbnN0RW51bSA/PyB0cnVlLFxuICAgICAgKVxuXG4gICAgICBkdHMgKz0gZmlsZUR0c1xuICAgICAgZXhwb3J0cy5wdXNoKC4uLmZpbGVFeHBvcnRzKVxuICAgIH1cblxuICAgIGlmIChkdHMuaW5kZXhPZignRXh0ZXJuYWxPYmplY3Q8JykgPiAtMSkge1xuICAgICAgaGVhZGVyICs9IGBcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEV4dGVybmFsT2JqZWN0PFQ+IHtcbiAgcmVhZG9ubHkgJyc6IHtcbiAgICByZWFkb25seSAnJzogdW5pcXVlIHN5bWJvbFxuICAgIFtLOiBzeW1ib2xdOiBUXG4gIH1cbn1cbmBcbiAgICB9XG5cbiAgICBpZiAoZHRzLmluZGV4T2YoJ1R5cGVkQXJyYXknKSA+IC0xKSB7XG4gICAgICBoZWFkZXIgKz0gYFxuZXhwb3J0IHR5cGUgVHlwZWRBcnJheSA9IEludDhBcnJheSB8IFVpbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXkgfCBVaW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheSB8IEJpZ0ludDY0QXJyYXkgfCBCaWdVaW50NjRBcnJheVxuYFxuICAgIH1cblxuICAgIGR0cyA9IGhlYWRlciArIGR0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKCdXcml0aW5nIHR5cGUgZGVmIHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkZXN0LCBkdHMsICd1dGYtOCcpXG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7IGtpbmQ6ICdkdHMnLCBwYXRoOiBkZXN0IH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcuZXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSB0eXBlIGRlZiBmaWxlJylcbiAgICAgIGRlYnVnLmVycm9yKGUgYXMgRXJyb3IpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd3JpdGVKc0JpbmRpbmcoaWRlbnRzOiBzdHJpbmdbXSkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLm9wdGlvbnMucGxhdGZvcm0gfHxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgdGhpcy5vcHRpb25zLm5vSnNCaW5kaW5nIHx8XG4gICAgICBpZGVudHMubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gdGhpcy5vcHRpb25zLmpzQmluZGluZyA/PyAnaW5kZXguanMnXG5cbiAgICBjb25zdCBjcmVhdGVCaW5kaW5nID0gdGhpcy5vcHRpb25zLmVzbSA/IGNyZWF0ZUVzbUJpbmRpbmcgOiBjcmVhdGVDanNCaW5kaW5nXG4gICAgY29uc3QgYmluZGluZyA9IGNyZWF0ZUJpbmRpbmcoXG4gICAgICB0aGlzLmNvbmZpZy5iaW5hcnlOYW1lLFxuICAgICAgdGhpcy5jb25maWcucGFja2FnZU5hbWUsXG4gICAgICBpZGVudHMsXG4gICAgKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCBuYW1lKVxuICAgICAgZGVidWcoJ1dyaXRpbmcganMgYmluZGluZyB0bzonKVxuICAgICAgZGVidWcoJyAgJWknLCBkZXN0KVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGVzdCwgYmluZGluZywgJ3V0Zi04JylcbiAgICAgIHJldHVybiB7IGtpbmQ6ICdqcycsIHBhdGg6IGRlc3QgfSBzYXRpc2ZpZXMgT3V0cHV0XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gd3JpdGUganMgYmluZGluZyBmaWxlJywgeyBjYXVzZTogZSB9KVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd3JpdGVXYXNpQmluZGluZyhcbiAgICBkaXN0RmlsZU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgaWRlbnRzOiBzdHJpbmdbXSxcbiAgKSB7XG4gICAgaWYgKGRpc3RGaWxlTmFtZSkge1xuICAgICAgY29uc3QgeyBuYW1lLCBkaXIgfSA9IHBhcnNlKGRpc3RGaWxlTmFtZSlcbiAgICAgIGNvbnN0IGJpbmRpbmdQYXRoID0gam9pbihkaXIsIGAke3RoaXMuY29uZmlnLmJpbmFyeU5hbWV9Lndhc2kuY2pzYClcbiAgICAgIGNvbnN0IGJyb3dzZXJCaW5kaW5nUGF0aCA9IGpvaW4oXG4gICAgICAgIGRpcixcbiAgICAgICAgYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICAgIClcbiAgICAgIGNvbnN0IHdvcmtlclBhdGggPSBqb2luKGRpciwgJ3dhc2ktd29ya2VyLm1qcycpXG4gICAgICBjb25zdCBicm93c2VyV29ya2VyUGF0aCA9IGpvaW4oZGlyLCAnd2FzaS13b3JrZXItYnJvd3Nlci5tanMnKVxuICAgICAgY29uc3QgYnJvd3NlckVudHJ5UGF0aCA9IGpvaW4oZGlyLCAnYnJvd3Nlci5qcycpXG4gICAgICBjb25zdCBleHBvcnRzQ29kZSA9XG4gICAgICAgIGBtb2R1bGUuZXhwb3J0cyA9IF9fbmFwaU1vZHVsZS5leHBvcnRzXFxuYCArXG4gICAgICAgIGlkZW50c1xuICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAoaWRlbnQpID0+XG4gICAgICAgICAgICAgIGBtb2R1bGUuZXhwb3J0cy4ke2lkZW50fSA9IF9fbmFwaU1vZHVsZS5leHBvcnRzLiR7aWRlbnR9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYmluZGluZ1BhdGgsXG4gICAgICAgIGNyZWF0ZVdhc2lCaW5kaW5nKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcucGFja2FnZU5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uaW5pdGlhbE1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5tYXhpbXVtTWVtb3J5LFxuICAgICAgICApICtcbiAgICAgICAgICBleHBvcnRzQ29kZSArXG4gICAgICAgICAgJ1xcbicsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBicm93c2VyQmluZGluZ1BhdGgsXG4gICAgICAgIGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyhcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmluaXRpYWxNZW1vcnksXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8ubWF4aW11bU1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5mcyxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5hc3luY0luaXQsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uYnVmZmVyLFxuICAgICAgICApICtcbiAgICAgICAgICBgZXhwb3J0IGRlZmF1bHQgX19uYXBpTW9kdWxlLmV4cG9ydHNcXG5gICtcbiAgICAgICAgICBpZGVudHNcbiAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgIChpZGVudCkgPT5cbiAgICAgICAgICAgICAgICBgZXhwb3J0IGNvbnN0ICR7aWRlbnR9ID0gX19uYXBpTW9kdWxlLmV4cG9ydHMuJHtpZGVudH1gLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpICtcbiAgICAgICAgICAnXFxuJyxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMod29ya2VyUGF0aCwgV0FTSV9XT1JLRVJfVEVNUExBVEUsICd1dGY4JylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBicm93c2VyV29ya2VyUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nKHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmZzID8/IGZhbHNlKSxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJFbnRyeVBhdGgsXG4gICAgICAgIGBleHBvcnQgKiBmcm9tICcke3RoaXMuY29uZmlnLnBhY2thZ2VOYW1lfS13YXNtMzItd2FzaSdcXG5gLFxuICAgICAgKVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBiaW5kaW5nUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJCaW5kaW5nUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IHdvcmtlclBhdGggfSxcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBicm93c2VyV29ya2VyUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJFbnRyeVBhdGggfSxcbiAgICAgIF0gc2F0aXNmaWVzIE91dHB1dFtdXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRFbnZJZk5vdEV4aXN0cyhlbnY6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIGlmICghcHJvY2Vzcy5lbnZbZW52XSkge1xuICAgICAgdGhpcy5lbnZzW2Vudl0gPSB2YWx1ZVxuICAgIH1cbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDcmVhdGVOcG1EaXJzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydjcmVhdGUtbnBtLWRpcnMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBucG0gcGFja2FnZSBkaXJzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgbnBtIHBhY2thZ2UgZGlycyBmb3IgZGlmZmVyZW50IHBsYXRmb3Jtc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU5wbURpcnNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIERyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0Q3JlYXRlTnBtRGlyc09wdGlvbnMoXG4gIG9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zLFxuKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnc2VtdmVyJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyxcbiAgQ3JlYXRlTnBtRGlyc09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQge1xuICBkZWJ1Z0ZhY3RvcnksXG4gIHJlYWROYXBpQ29uZmlnLFxuICBta2RpckFzeW5jIGFzIHJhd01rZGlyQXN5bmMsXG4gIHBpY2ssXG4gIHdyaXRlRmlsZUFzeW5jIGFzIHJhd1dyaXRlRmlsZUFzeW5jLFxuICBUYXJnZXQsXG4gIHR5cGUgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnY3JlYXRlLW5wbS1kaXJzJylcblxuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlTWV0YSB7XG4gICdkaXN0LXRhZ3MnOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5wbURpcnModXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBhc3luYyBmdW5jdGlvbiBta2RpckFzeW5jKGRpcjogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1RyeSB0byBjcmVhdGUgZGlyOiAlaScsIGRpcilcbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGF3YWl0IHJhd01rZGlyQXN5bmMoZGlyLCB7XG4gICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUFzeW5jKGZpbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1dyaXRpbmcgZmlsZSAlaScsIGZpbGUpXG5cbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIGRlYnVnKGNvbnRlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCByYXdXcml0ZUZpbGVBc3luYyhmaWxlLCBjb250ZW50KVxuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IG5wbVBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpcilcblxuICBkZWJ1ZyhgUmVhZCBjb250ZW50IGZyb20gWyR7b3B0aW9ucy5jb25maWdQYXRoID8/IHBhY2thZ2VKc29uUGF0aH1dYClcblxuICBjb25zdCB7IHRhcmdldHMsIGJpbmFyeU5hbWUsIHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbiB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gICAgKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBqb2luKG5wbVBhdGgsIGAke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YClcbiAgICBhd2FpdCBta2RpckFzeW5jKHRhcmdldERpcilcblxuICAgIGNvbnN0IGJpbmFyeUZpbGVOYW1lID1cbiAgICAgIHRhcmdldC5hcmNoID09PSAnd2FzbTMyJ1xuICAgICAgICA/IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgOiBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9Lm5vZGVgXG4gICAgY29uc3Qgc2NvcGVkUGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzID0ge1xuICAgICAgbmFtZTogYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgICAgdmVyc2lvbjogcGFja2FnZUpzb24udmVyc2lvbixcbiAgICAgIGNwdTogdGFyZ2V0LmFyY2ggIT09ICd1bml2ZXJzYWwnID8gW3RhcmdldC5hcmNoXSA6IHVuZGVmaW5lZCxcbiAgICAgIG1haW46IGJpbmFyeUZpbGVOYW1lLFxuICAgICAgZmlsZXM6IFtiaW5hcnlGaWxlTmFtZV0sXG4gICAgICAuLi5waWNrKFxuICAgICAgICBwYWNrYWdlSnNvbixcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ2tleXdvcmRzJyxcbiAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICdhdXRob3JzJyxcbiAgICAgICAgJ2hvbWVwYWdlJyxcbiAgICAgICAgJ2xpY2Vuc2UnLFxuICAgICAgICAnZW5naW5lcycsXG4gICAgICAgICdyZXBvc2l0b3J5JyxcbiAgICAgICAgJ2J1Z3MnLFxuICAgICAgKSxcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcgPSBwaWNrKFxuICAgICAgICBwYWNrYWdlSnNvbi5wdWJsaXNoQ29uZmlnLFxuICAgICAgICAncmVnaXN0cnknLFxuICAgICAgICAnYWNjZXNzJyxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHRhcmdldC5hcmNoICE9PSAnd2FzbTMyJykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ub3MgPSBbdGFyZ2V0LnBsYXRmb3JtXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24ubWFpbiA9IGVudHJ5XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyID0gYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24uZmlsZXM/LnB1c2goXG4gICAgICAgIGVudHJ5LFxuICAgICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyLFxuICAgICAgICBgd2FzaS13b3JrZXIubWpzYCxcbiAgICAgICAgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCxcbiAgICAgIClcbiAgICAgIGxldCBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IHRydWVcbiAgICAgIGlmIChzY29wZWRQYWNrYWdlSnNvbi5lbmdpbmVzPy5ub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBtYWpvciB9ID0gcGFyc2Uoc2NvcGVkUGFja2FnZUpzb24uZW5naW5lcy5ub2RlKSA/PyB7XG4gICAgICAgICAgICBtYWpvcjogMCxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ham9yID49IDE0KSB7XG4gICAgICAgICAgICBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRSZXN0cmljdE5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmVuZ2luZXMgPSB7XG4gICAgICAgICAgbm9kZTogJz49MTQuMC4wJyxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2FzbVJ1bnRpbWUgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL0BuYXBpLXJzL3dhc20tcnVudGltZWAsXG4gICAgICApLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSBhcyBQcm9taXNlPFBhY2thZ2VNZXRhPilcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgJ0BuYXBpLXJzL3dhc20tcnVudGltZSc6IGBeJHt3YXNtUnVudGltZVsnZGlzdC10YWdzJ10ubGF0ZXN0fWAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5hYmkgPT09ICdnbnUnKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5saWJjID0gWydnbGliYyddXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYWJpID09PSAnbXVzbCcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmxpYmMgPSBbJ211c2wnXVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFBhY2thZ2VKc29uID0gam9pbih0YXJnZXREaXIsICdwYWNrYWdlLmpzb24nKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgdGFyZ2V0UGFja2FnZUpzb24sXG4gICAgICBKU09OLnN0cmluZ2lmeShzY29wZWRQYWNrYWdlSnNvbiwgbnVsbCwgMikgKyAnXFxuJyxcbiAgICApXG4gICAgY29uc3QgdGFyZ2V0UmVhZG1lID0gam9pbih0YXJnZXREaXIsICdSRUFETUUubWQnKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHRhcmdldFJlYWRtZSwgcmVhZG1lKHBhY2thZ2VOYW1lLCB0YXJnZXQpKVxuXG4gICAgZGVidWcuaW5mbyhgJHtwYWNrYWdlTmFtZX0gLSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0gY3JlYXRlZGApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZG1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHRhcmdldDogVGFyZ2V0KSB7XG4gIHJldHVybiBgIyBcXGAke3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9XFxgXG5cblRoaXMgaXMgdGhlICoqJHt0YXJnZXQudHJpcGxlfSoqIGJpbmFyeSBmb3IgXFxgJHtwYWNrYWdlTmFtZX1cXGBcbmBcbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5pbXBvcnQgKiBhcyB0eXBhbmlvbiBmcm9tICd0eXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VOZXdDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ25ldyddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRlIGEgbmV3IHByb2plY3Qgd2l0aCBwcmUtY29uZmlndXJlZCBib2lsZXJwbGF0ZScsXG4gIH0pXG5cbiAgJCRwYXRoID0gT3B0aW9uLlN0cmluZyh7IHJlcXVpcmVkOiBmYWxzZSB9KVxuXG4gICQkbmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbmFtZSwtbicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5IGlmIG5vdCBwcm92aWRlZCcsXG4gIH0pXG5cbiAgbWluTm9kZUFwaVZlcnNpb24gPSBPcHRpb24uU3RyaW5nKCctLW1pbi1ub2RlLWFwaSwtdicsICc0Jywge1xuICAgIHZhbGlkYXRvcjogdHlwYW5pb24uaXNOdW1iZXIoKSxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBtaW5pbXVtIE5vZGUtQVBJIHZlcnNpb24gdG8gc3VwcG9ydCcsXG4gIH0pXG5cbiAgcGFja2FnZU1hbmFnZXIgPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtbWFuYWdlcicsICd5YXJuJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UuIE9ubHkgc3VwcG9ydCB5YXJuIDQueCBmb3Igbm93LicsXG4gIH0pXG5cbiAgbGljZW5zZSA9IE9wdGlvbi5TdHJpbmcoJy0tbGljZW5zZSwtbCcsICdNSVQnLCB7XG4gICAgZGVzY3JpcHRpb246ICdMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdCcsXG4gIH0pXG5cbiAgdGFyZ2V0cyA9IE9wdGlvbi5BcnJheSgnLS10YXJnZXRzLC10JywgW10sIHtcbiAgICBkZXNjcmlwdGlvbjogJ0FsbCB0YXJnZXRzIHRoZSBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIGZvci4nLFxuICB9KVxuXG4gIGVuYWJsZURlZmF1bHRUYXJnZXRzID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWRlZmF1bHQtdGFyZ2V0cycsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZW5hYmxlIGRlZmF1bHQgdGFyZ2V0cycsXG4gIH0pXG5cbiAgZW5hYmxlQWxsVGFyZ2V0cyA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS1hbGwtdGFyZ2V0cycsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGVuYWJsZSBhbGwgdGFyZ2V0cycsXG4gIH0pXG5cbiAgZW5hYmxlVHlwZURlZiA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS10eXBlLWRlZicsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIGVuYWJsZSB0aGUgYHR5cGUtZGVmYCBmZWF0dXJlIGZvciB0eXBlc2NyaXB0IGRlZmluaXRpb25zIGF1dG8tZ2VuZXJhdGlvbicsXG4gIH0pXG5cbiAgZW5hYmxlR2l0aHViQWN0aW9ucyA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS1naXRodWItYWN0aW9ucycsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZ2VuZXJhdGUgcHJlY29uZmlndXJlZCBHaXRIdWIgQWN0aW9ucyB3b3JrZmxvdycsXG4gIH0pXG5cbiAgdGVzdEZyYW1ld29yayA9IE9wdGlvbi5TdHJpbmcoJy0tdGVzdC1mcmFtZXdvcmsnLCAnYXZhJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSBKYXZhU2NyaXB0IHRlc3QgZnJhbWV3b3JrIHRvIHVzZSwgb25seSBzdXBwb3J0IGBhdmFgIGZvciBub3cnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciB0byBydW4gdGhlIGNvbW1hbmQgaW4gZHJ5LXJ1biBtb2RlJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB0aGlzLiQkcGF0aCxcbiAgICAgIG5hbWU6IHRoaXMuJCRuYW1lLFxuICAgICAgbWluTm9kZUFwaVZlcnNpb246IHRoaXMubWluTm9kZUFwaVZlcnNpb24sXG4gICAgICBwYWNrYWdlTWFuYWdlcjogdGhpcy5wYWNrYWdlTWFuYWdlcixcbiAgICAgIGxpY2Vuc2U6IHRoaXMubGljZW5zZSxcbiAgICAgIHRhcmdldHM6IHRoaXMudGFyZ2V0cyxcbiAgICAgIGVuYWJsZURlZmF1bHRUYXJnZXRzOiB0aGlzLmVuYWJsZURlZmF1bHRUYXJnZXRzLFxuICAgICAgZW5hYmxlQWxsVGFyZ2V0czogdGhpcy5lbmFibGVBbGxUYXJnZXRzLFxuICAgICAgZW5hYmxlVHlwZURlZjogdGhpcy5lbmFibGVUeXBlRGVmLFxuICAgICAgZW5hYmxlR2l0aHViQWN0aW9uczogdGhpcy5lbmFibGVHaXRodWJBY3Rpb25zLFxuICAgICAgdGVzdEZyYW1ld29yazogdGhpcy50ZXN0RnJhbWV3b3JrLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcHJvamVjdCB3aXRoIHByZS1jb25maWd1cmVkIGJvaWxlcnBsYXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV3T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB3aGVyZSB0aGUgTkFQSS1SUyBwcm9qZWN0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaWYgbm90IHByb3ZpZGVkXG4gICAqL1xuICBuYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBOb2RlLUFQSSB2ZXJzaW9uIHRvIHN1cHBvcnRcbiAgICpcbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgbWluTm9kZUFwaVZlcnNpb24/OiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSBwYWNrYWdlIG1hbmFnZXIgdG8gdXNlLiBPbmx5IHN1cHBvcnQgeWFybiA0LnggZm9yIG5vdy5cbiAgICpcbiAgICogQGRlZmF1bHQgJ3lhcm4nXG4gICAqL1xuICBwYWNrYWdlTWFuYWdlcj86IHN0cmluZ1xuICAvKipcbiAgICogTGljZW5zZSBmb3Igb3Blbi1zb3VyY2VkIHByb2plY3RcbiAgICpcbiAgICogQGRlZmF1bHQgJ01JVCdcbiAgICovXG4gIGxpY2Vuc2U/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFsbCB0YXJnZXRzIHRoZSBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIGZvci5cbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHRhcmdldHM/OiBzdHJpbmdbXVxuICAvKipcbiAgICogV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZURlZmF1bHRUYXJnZXRzPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciBlbmFibGUgYWxsIHRhcmdldHNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVuYWJsZUFsbFRhcmdldHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSB0aGUgYHR5cGUtZGVmYCBmZWF0dXJlIGZvciB0eXBlc2NyaXB0IGRlZmluaXRpb25zIGF1dG8tZ2VuZXJhdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBlbmFibGVUeXBlRGVmPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciBnZW5lcmF0ZSBwcmVjb25maWd1cmVkIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93XG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZUdpdGh1YkFjdGlvbnM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgSmF2YVNjcmlwdCB0ZXN0IGZyYW1ld29yayB0byB1c2UsIG9ubHkgc3VwcG9ydCBgYXZhYCBmb3Igbm93XG4gICAqXG4gICAqIEBkZWZhdWx0ICdhdmEnXG4gICAqL1xuICB0ZXN0RnJhbWV3b3JrPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJ1biB0aGUgY29tbWFuZCBpbiBkcnktcnVuIG1vZGVcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyeVJ1bj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMob3B0aW9uczogTmV3T3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIG1pbk5vZGVBcGlWZXJzaW9uOiA0LFxuICAgIHBhY2thZ2VNYW5hZ2VyOiAneWFybicsXG4gICAgbGljZW5zZTogJ01JVCcsXG4gICAgdGFyZ2V0czogW10sXG4gICAgZW5hYmxlRGVmYXVsdFRhcmdldHM6IHRydWUsXG4gICAgZW5hYmxlQWxsVGFyZ2V0czogZmFsc2UsXG4gICAgZW5hYmxlVHlwZURlZjogdHJ1ZSxcbiAgICBlbmFibGVHaXRodWJBY3Rpb25zOiB0cnVlLFxuICAgIHRlc3RGcmFtZXdvcms6ICdhdmEnLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbi8vIEJhcmUga2V5cyBtYXkgb25seSBjb250YWluIEFTQ0lJIGxldHRlcnMsXG4vLyBBU0NJSSBkaWdpdHMsIHVuZGVyc2NvcmVzLCBhbmQgZGFzaGVzIChBLVphLXowLTlfLSkuXG5mdW5jdGlvbiBqb2luS2V5cyhrZXlzKSB7XG4gIC8vIERvdHRlZCBrZXlzIGFyZSBhIHNlcXVlbmNlIG9mIGJhcmUgb3IgcXVvdGVkIGtleXMgam9pbmVkIHdpdGggYSBkb3QuXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBncm91cGluZyBzaW1pbGFyIHByb3BlcnRpZXMgdG9nZXRoZXI6XG4gIHJldHVybiBrZXlzLm1hcCgoc3RyKT0+e1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAwIHx8IHN0ci5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/IEpTT04uc3RyaW5naWZ5KHN0cikgOiBzdHI7XG4gIH0pLmpvaW4oXCIuXCIpO1xufVxuY2xhc3MgRHVtcGVyIHtcbiAgbWF4UGFkID0gMDtcbiAgc3JjT2JqZWN0O1xuICBvdXRwdXQgPSBbXTtcbiAgI2FycmF5VHlwZUNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihzcmNPYmpjKXtcbiAgICB0aGlzLnNyY09iamVjdCA9IHNyY09iamM7XG4gIH1cbiAgZHVtcChmbXRPcHRpb25zID0ge30pIHtcbiAgICAvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgIHRoaXMub3V0cHV0ID0gdGhpcy4jcHJpbnRPYmplY3QodGhpcy5zcmNPYmplY3QpO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy4jZm9ybWF0KGZtdE9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLm91dHB1dDtcbiAgfVxuICAjcHJpbnRPYmplY3Qob2JqLCBrZXlzID0gW10pIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgY29uc3QgaW5saW5lUHJvcHMgPSBbXTtcbiAgICBjb25zdCBtdWx0aWxpbmVQcm9wcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcyl7XG4gICAgICBpZiAodGhpcy4jaXNTaW1wbHlTZXJpYWxpemFibGUob2JqW3Byb3BdKSkge1xuICAgICAgICBpbmxpbmVQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlsaW5lUHJvcHMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc29ydGVkUHJvcHMgPSBpbmxpbmVQcm9wcy5jb25jYXQobXVsdGlsaW5lUHJvcHMpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBzb3J0ZWRQcm9wcyl7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jZGF0ZURlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNzdHJEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNudW1iZXJEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI2Jvb2xEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFycmF5VHlwZSA9IHRoaXMuI2dldFR5cGVPZkFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKGFycmF5VHlwZSA9PT0gXCJPTkxZX1BSSU1JVElWRVwiKSB7XG4gICAgICAgICAgb3V0LnB1c2godGhpcy4jYXJyYXlEZWNsYXJhdGlvbihbXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnJheVR5cGUgPT09IFwiT05MWV9PQkpFQ1RfRVhDTFVESU5HX0FSUkFZXCIpIHtcbiAgICAgICAgICAvLyBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIG91dC5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgb3V0LnB1c2godGhpcy4jaGVhZGVyR3JvdXAoW1xuICAgICAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICBvdXQucHVzaCguLi50aGlzLiNwcmludE9iamVjdCh2YWx1ZVtpXSwgW1xuICAgICAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBjb21wbGV4IGFycmF5LCB1c2UgdGhlIGlubGluZSBmb3JtYXQuXG4gICAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUubWFwKCh4KT0+dGhpcy4jcHJpbnRBc0lubGluZVZhbHVlKHgpKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICBvdXQucHVzaChgJHt0aGlzLiNkZWNsYXJhdGlvbihbXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgXSl9WyR7c3RyfV1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3V0LnB1c2goXCJcIik7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI2hlYWRlcihbXG4gICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0pKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgdG9QYXJzZSA9IHZhbHVlO1xuICAgICAgICAgIG91dC5wdXNoKC4uLnRoaXMuI3ByaW50T2JqZWN0KHRvUGFyc2UsIFtcbiAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgXSkpO1xuICAgICAgICB9XG4gICAgICAvLyBvdXQucHVzaCguLi50aGlzLl9wYXJzZSh2YWx1ZSwgYCR7cGF0aH0ke3Byb3B9LmApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0LnB1c2goXCJcIik7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAjaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IFtcbiAgICAgIFwic3RyaW5nXCIsXG4gICAgICBcIm51bWJlclwiLFxuICAgICAgXCJib29sZWFuXCJcbiAgICBdLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSk7XG4gIH1cbiAgI2dldFR5cGVPZkFycmF5KGFycikge1xuICAgIGlmICh0aGlzLiNhcnJheVR5cGVDYWNoZS5oYXMoYXJyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2FycmF5VHlwZUNhY2hlLmdldChhcnIpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy4jZG9HZXRUeXBlT2ZBcnJheShhcnIpO1xuICAgIHRoaXMuI2FycmF5VHlwZUNhY2hlLnNldChhcnIsIHR5cGUpO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gICNkb0dldFR5cGVPZkFycmF5KGFycikge1xuICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgLy8gYW55IHR5cGUgc2hvdWxkIGJlIGZpbmVcbiAgICAgIHJldHVybiBcIk9OTFlfUFJJTUlUSVZFXCI7XG4gICAgfVxuICAgIGNvbnN0IG9ubHlQcmltaXRpdmUgPSB0aGlzLiNpc1ByaW1pdGl2ZShhcnJbMF0pO1xuICAgIGlmIChhcnJbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIFwiTUlYRURcIjtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG4gICAgICBpZiAob25seVByaW1pdGl2ZSAhPT0gdGhpcy4jaXNQcmltaXRpdmUoYXJyW2ldKSB8fCBhcnJbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gXCJNSVhFRFwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb25seVByaW1pdGl2ZSA/IFwiT05MWV9QUklNSVRJVkVcIiA6IFwiT05MWV9PQkpFQ1RfRVhDTFVESU5HX0FSUkFZXCI7XG4gIH1cbiAgI3ByaW50QXNJbmxpbmVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBgXCIke3RoaXMuI3ByaW50RGF0ZSh2YWx1ZSl9XCJgO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgY29uc3Qgc3RyID0gdmFsdWUubWFwKCh4KT0+dGhpcy4jcHJpbnRBc0lubGluZVZhbHVlKHgpKS5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBgWyR7c3RyfV1gO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciByZWFjaFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0ciA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGtleSk9PntcbiAgICAgICAgcmV0dXJuIGAke2pvaW5LZXlzKFtcbiAgICAgICAgICBrZXlcbiAgICAgICAgXSl9ID0gJHsvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLiNwcmludEFzSW5saW5lVmFsdWUodmFsdWVba2V5XSl9YDtcbiAgICAgIH0pLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGB7JHtzdHJ9fWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciByZWFjaFwiKTtcbiAgfVxuICAjaXNTaW1wbHlTZXJpYWxpemFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRoaXMuI2dldFR5cGVPZkFycmF5KHZhbHVlKSAhPT0gXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIjtcbiAgfVxuICAjaGVhZGVyKGtleXMpIHtcbiAgICByZXR1cm4gYFske2pvaW5LZXlzKGtleXMpfV1gO1xuICB9XG4gICNoZWFkZXJHcm91cChrZXlzKSB7XG4gICAgcmV0dXJuIGBbWyR7am9pbktleXMoa2V5cyl9XV1gO1xuICB9XG4gICNkZWNsYXJhdGlvbihrZXlzKSB7XG4gICAgY29uc3QgdGl0bGUgPSBqb2luS2V5cyhrZXlzKTtcbiAgICBpZiAodGl0bGUubGVuZ3RoID4gdGhpcy5tYXhQYWQpIHtcbiAgICAgIHRoaXMubWF4UGFkID0gdGl0bGUubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGl0bGV9ID0gYDtcbiAgfVxuICAjYXJyYXlEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICB9XG4gICNzdHJEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICB9XG4gICNudW1iZXJEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9bmFuYDtcbiAgICB9XG4gICAgc3dpdGNoKHZhbHVlKXtcbiAgICAgIGNhc2UgSW5maW5pdHk6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX1pbmZgO1xuICAgICAgY2FzZSAtSW5maW5pdHk6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0taW5mYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke3ZhbHVlfWA7XG4gICAgfVxuICB9XG4gICNib29sRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHt2YWx1ZX1gO1xuICB9XG4gICNwcmludERhdGUodmFsdWUpIHtcbiAgICBmdW5jdGlvbiBkdFBhZCh2LCBsUGFkID0gMikge1xuICAgICAgcmV0dXJuIHYucGFkU3RhcnQobFBhZCwgXCIwXCIpO1xuICAgIH1cbiAgICBjb25zdCBtID0gZHRQYWQoKHZhbHVlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBkID0gZHRQYWQodmFsdWUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IGggPSBkdFBhZCh2YWx1ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IG1pbiA9IGR0UGFkKHZhbHVlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBzID0gZHRQYWQodmFsdWUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IG1zID0gZHRQYWQodmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKSwgMyk7XG4gICAgLy8gZm9ybWF0dGVkIGRhdGVcbiAgICBjb25zdCBmRGF0YSA9IGAke3ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCl9LSR7bX0tJHtkfVQke2h9OiR7bWlufToke3N9LiR7bXN9YDtcbiAgICByZXR1cm4gZkRhdGE7XG4gIH1cbiAgI2RhdGVEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke3RoaXMuI3ByaW50RGF0ZSh2YWx1ZSl9YDtcbiAgfVxuICAjZm9ybWF0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsga2V5QWxpZ25tZW50ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgckRlY2xhcmF0aW9uID0gL14oXFxcIi4qXFxcInxbXj1dKilcXHM9LztcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXQubGVuZ3RoOyBpKyspe1xuICAgICAgY29uc3QgbCA9IHRoaXMub3V0cHV0W2ldO1xuICAgICAgLy8gd2Uga2VlcCBlbXB0eSBlbnRyeSBmb3IgYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgaWYgKGxbMF0gPT09IFwiW1wiICYmIGxbMV0gIT09IFwiW1wiKSB7XG4gICAgICAgIC8vIG5vbi1lbXB0eSBvYmplY3Qgd2l0aCBvbmx5IHN1Ym9iamVjdHMgYXMgcHJvcGVydGllc1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRbaSArIDFdID09PSBcIlwiICYmIHRoaXMub3V0cHV0W2kgKyAyXT8uc2xpY2UoMCwgbC5sZW5ndGgpID09PSBsLnNsaWNlKDAsIC0xKSArIFwiLlwiKSB7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtleUFsaWdubWVudCkge1xuICAgICAgICAgIGNvbnN0IG0gPSByRGVjbGFyYXRpb24uZXhlYyhsKTtcbiAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICBvdXQucHVzaChsLnJlcGxhY2UobVsxXSwgbVsxXS5wYWRFbmQodGhpcy5tYXhQYWQpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQucHVzaChsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGVhbmluZyBtdWx0aXBsZSBzcGFjZXNcbiAgICBjb25zdCBjbGVhbmVkT3V0cHV0ID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKyl7XG4gICAgICBjb25zdCBsID0gb3V0W2ldO1xuICAgICAgaWYgKCEobCA9PT0gXCJcIiAmJiBvdXRbaSArIDFdID09PSBcIlwiKSkge1xuICAgICAgICBjbGVhbmVkT3V0cHV0LnB1c2gobCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGVhbmVkT3V0cHV0O1xuICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCB0byBhIHtAbGluayBodHRwczovL3RvbWwuaW8gfCBUT01MfSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGUgVXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tIFwiQHN0ZC90b21sL3N0cmluZ2lmeVwiO1xuICogaW1wb3J0IHsgYXNzZXJ0RXF1YWxzIH0gZnJvbSBcIkBzdGQvYXNzZXJ0XCI7XG4gKlxuICogY29uc3Qgb2JqID0ge1xuICogICB0aXRsZTogXCJUT01MIEV4YW1wbGVcIixcbiAqICAgb3duZXI6IHtcbiAqICAgICBuYW1lOiBcIkJvYlwiLFxuICogICAgIGJpbzogXCJCb2IgaXMgYSBjb29sIGd1eVwiLFxuICogIH1cbiAqIH07XG4gKiBjb25zdCB0b21sU3RyaW5nID0gc3RyaW5naWZ5KG9iaik7XG4gKiBhc3NlcnRFcXVhbHModG9tbFN0cmluZywgYHRpdGxlID0gXCJUT01MIEV4YW1wbGVcIlxcblxcbltvd25lcl1cXG5uYW1lID0gXCJCb2JcIlxcbmJpbyA9IFwiQm9iIGlzIGEgY29vbCBndXlcIlxcbmApO1xuICogYGBgXG4gKiBAcGFyYW0gb2JqIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHN0cmluZ2lmeWluZy5cbiAqIEByZXR1cm5zIFRPTUwgc3RyaW5nXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBEdW1wZXIob2JqKS5kdW1wKG9wdGlvbnMpLmpvaW4oXCJcXG5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbi8qKlxuICogRmlsdGVycyB0aGUgZ2l2ZW4gYXJyYXksIHJlbW92aW5nIGFsbCBlbGVtZW50cyB0aGF0IGRvIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlXG4gKiAqKmluIHBsYWNlLiBUaGlzIG1lYW5zIGBhcnJheWAgd2lsbCBiZSBtb2RpZmllZCEqKi5cbiAqLyBleHBvcnQgZnVuY3Rpb24gZmlsdGVySW5QbGFjZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIGxldCBvdXRwdXRJbmRleCA9IDA7XG4gIGZvciAoY29uc3QgY3VyIG9mIGFycmF5KXtcbiAgICBpZiAoIXByZWRpY2F0ZShjdXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYXJyYXlbb3V0cHV0SW5kZXhdID0gY3VyO1xuICAgIG91dHB1dEluZGV4ICs9IDE7XG4gIH1cbiAgYXJyYXkuc3BsaWNlKG91dHB1dEluZGV4KTtcbiAgcmV0dXJuIGFycmF5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3V0aWxzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBmaWx0ZXJJblBsYWNlIH0gZnJvbSBcIi4vX3V0aWxzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVlcE1lcmdlKHJlY29yZCwgb3RoZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlZXBNZXJnZUludGVybmFsKHJlY29yZCwgb3RoZXIsIG5ldyBTZXQoKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkZWVwTWVyZ2VJbnRlcm5hbChyZWNvcmQsIG90aGVyLCBzZWVuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBrZXlzID0gbmV3IFNldChbXG4gICAgLi4uZ2V0S2V5cyhyZWNvcmQpLFxuICAgIC4uLmdldEtleXMob3RoZXIpXG4gIF0pO1xuICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBrZXkgb2Ygb3RoZXIgb2JqZWN0IGFuZCB1c2UgY29ycmVjdCBtZXJnaW5nIHN0cmF0ZWd5XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpe1xuICAgIC8vIFNraXAgdG8gcHJldmVudCBPYmplY3QucHJvdG90eXBlLl9fcHJvdG9fXyBhY2Nlc3NvciBwcm9wZXJ0eSBjYWxscyBvbiBub24tRGVubyBwbGF0Zm9ybXNcbiAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHJlY29yZFtrZXldO1xuICAgIGlmICghT2JqZWN0Lmhhc093bihvdGhlciwga2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBhO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGIgPSBvdGhlcltrZXldO1xuICAgIGlmIChpc05vbk51bGxPYmplY3QoYSkgJiYgaXNOb25OdWxsT2JqZWN0KGIpICYmICFzZWVuLmhhcyhhKSAmJiAhc2Vlbi5oYXMoYikpIHtcbiAgICAgIHNlZW4uYWRkKGEpO1xuICAgICAgc2Vlbi5hZGQoYik7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlT2JqZWN0cyhhLCBiLCBzZWVuLCBvcHRpb25zKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBPdmVycmlkZSB2YWx1ZVxuICAgIHJlc3VsdFtrZXldID0gYjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKGxlZnQsIHJpZ2h0LCBzZWVuLCBvcHRpb25zID0ge1xuICBhcnJheXM6IFwibWVyZ2VcIixcbiAgc2V0czogXCJtZXJnZVwiLFxuICBtYXBzOiBcIm1lcmdlXCJcbn0pIHtcbiAgLy8gUmVjdXJzaXZlbHkgbWVyZ2UgbWVyZ2VhYmxlIG9iamVjdHNcbiAgaWYgKGlzTWVyZ2VhYmxlKGxlZnQpICYmIGlzTWVyZ2VhYmxlKHJpZ2h0KSkge1xuICAgIHJldHVybiBkZWVwTWVyZ2VJbnRlcm5hbChsZWZ0LCByaWdodCwgc2Vlbiwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzSXRlcmFibGUobGVmdCkgJiYgaXNJdGVyYWJsZShyaWdodCkpIHtcbiAgICAvLyBIYW5kbGUgYXJyYXlzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBtYXBzXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBNYXAgJiYgcmlnaHQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGlmIChvcHRpb25zLm1hcHMgPT09IFwibWVyZ2VcIikge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChbXG4gICAgICAgICAgLi4ubGVmdCxcbiAgICAgICAgICAuLi5yaWdodFxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHNldHNcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFNldCAmJiByaWdodCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgaWYgKG9wdGlvbnMuc2V0cyA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KFtcbiAgICAgICAgICAuLi5sZWZ0LFxuICAgICAgICAgIC4uLnJpZ2h0XG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmlnaHQ7XG59XG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIG1lcmdlYWJsZSBvciBub3RcbiAqIEJ1aWx0aW5zIHRoYXQgbG9vayBsaWtlIG9iamVjdHMsIG51bGwgYW5kIHVzZXIgZGVmaW5lZCBjbGFzc2VzXG4gKiBhcmUgbm90IGNvbnNpZGVyZWQgbWVyZ2VhYmxlIChpdCBtZWFucyB0aGF0IHJlZmVyZW5jZSB3aWxsIGJlIGNvcGllZClcbiAqLyBmdW5jdGlvbiBpc01lcmdlYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGdldEtleXMocmVjb3JkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocmVjb3JkKTtcbiAgZmlsdGVySW5QbGFjZShyZXN1bHQsIChrZXkpPT5PYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocmVjb3JkLCBrZXkpKTtcbiAgcmVzdWx0LnB1c2goLi4uT2JqZWN0LmtleXMocmVjb3JkKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWVwX21lcmdlLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBkZWVwTWVyZ2UgfSBmcm9tIFwiQGpzci9zdGRfX2NvbGxlY3Rpb25zL2RlZXAtbWVyZ2VcIjtcbi8qKlxuICogQ29weSBvZiBgaW1wb3J0IHsgaXNMZWFwIH0gZnJvbSBcIkBzdGQvZGF0ZXRpbWVcIjtgIGJlY2F1c2UgaXQgY2Fubm90IGJlIGltcG90ZWQgYXMgbG9uZyBhcyBpdCBpcyB1bnN0YWJsZS5cbiAqLyBmdW5jdGlvbiBpc0xlYXAoeWVhck51bWJlcikge1xuICByZXR1cm4geWVhck51bWJlciAlIDQgPT09IDAgJiYgeWVhck51bWJlciAlIDEwMCAhPT0gMCB8fCB5ZWFyTnVtYmVyICUgNDAwID09PSAwO1xufVxuZXhwb3J0IGNsYXNzIFNjYW5uZXIge1xuICAjd2hpdGVzcGFjZSA9IC9bIFxcdF0vO1xuICAjcG9zaXRpb24gPSAwO1xuICAjc291cmNlO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2Upe1xuICAgIHRoaXMuI3NvdXJjZSA9IHNvdXJjZTtcbiAgfVxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uO1xuICB9XG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBpbmRleCAtIHJlbGF0aXZlIGluZGV4IGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKi8gY2hhcihpbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlW3RoaXMuI3Bvc2l0aW9uICsgaW5kZXhdID8/IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzbGljZWQgc3RyaW5nXG4gICAqIEBwYXJhbSBzdGFydCAtIHN0YXJ0IHBvc2l0aW9uIHJlbGF0aXZlIGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKiBAcGFyYW0gZW5kIC0gZW5kIHBvc2l0aW9uIHJlbGF0aXZlIGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKi8gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2Uuc2xpY2UodGhpcy4jcG9zaXRpb24gKyBzdGFydCwgdGhpcy4jcG9zaXRpb24gKyBlbmQpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIHBvc2l0aW9uIHRvIG5leHRcbiAgICovIG5leHQoY291bnQgPSAxKSB7XG4gICAgdGhpcy4jcG9zaXRpb24gKz0gY291bnQ7XG4gIH1cbiAgc2tpcFdoaXRlc3BhY2VzKCkge1xuICAgIHdoaWxlKHRoaXMuI3doaXRlc3BhY2UudGVzdCh0aGlzLmNoYXIoKSkgJiYgIXRoaXMuZW9mKCkpe1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIC8vIEludmFsaWQgaWYgY3VycmVudCBjaGFyIGlzIG90aGVyIGtpbmRzIG9mIHdoaXRlc3BhY2VcbiAgICBpZiAoIXRoaXMuaXNDdXJyZW50Q2hhckVPTCgpICYmIC9cXHMvLnRlc3QodGhpcy5jaGFyKCkpKSB7XG4gICAgICBjb25zdCBlc2NhcGVkID0gXCJcXFxcdVwiICsgdGhpcy5jaGFyKCkuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuI3Bvc2l0aW9uO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBDYW5ub3QgcGFyc2UgdGhlIFRPTUw6IEl0IGNvbnRhaW5zIGludmFsaWQgd2hpdGVzcGFjZSBhdCBwb3NpdGlvbiAnJHtwb3NpdGlvbn0nOiBcXGAke2VzY2FwZWR9XFxgYCk7XG4gICAgfVxuICB9XG4gIG5leHRVbnRpbENoYXIob3B0aW9ucyA9IHtcbiAgICBza2lwQ29tbWVudHM6IHRydWVcbiAgfSkge1xuICAgIHdoaWxlKCF0aGlzLmVvZigpKXtcbiAgICAgIGNvbnN0IGNoYXIgPSB0aGlzLmNoYXIoKTtcbiAgICAgIGlmICh0aGlzLiN3aGl0ZXNwYWNlLnRlc3QoY2hhcikgfHwgdGhpcy5pc0N1cnJlbnRDaGFyRU9MKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2tpcENvbW1lbnRzICYmIHRoaXMuY2hhcigpID09PSBcIiNcIikge1xuICAgICAgICAvLyBlbnRlcmluZyBjb21tZW50XG4gICAgICAgIHdoaWxlKCF0aGlzLmlzQ3VycmVudENoYXJFT0woKSAmJiAhdGhpcy5lb2YoKSl7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUG9zaXRpb24gcmVhY2hlZCBFT0Ygb3Igbm90XG4gICAqLyBlb2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uID49IHRoaXMuI3NvdXJjZS5sZW5ndGg7XG4gIH1cbiAgaXNDdXJyZW50Q2hhckVPTCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFyKCkgPT09IFwiXFxuXCIgfHwgdGhpcy5zdGFydHNXaXRoKFwiXFxyXFxuXCIpO1xuICB9XG4gIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZywgdGhpcy4jcG9zaXRpb24pO1xuICB9XG4gIG1hdGNoKHJlZ0V4cCkge1xuICAgIGlmICghcmVnRXhwLnN0aWNreSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdFeHAgJHtyZWdFeHB9IGRvZXMgbm90IGhhdmUgYSBzdGlja3kgJ3knIGZsYWdgKTtcbiAgICB9XG4gICAgcmVnRXhwLmxhc3RJbmRleCA9IHRoaXMuI3Bvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2UubWF0Y2gocmVnRXhwKTtcbiAgfVxufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN1Y2Nlc3MoYm9keSkge1xuICByZXR1cm4ge1xuICAgIG9rOiB0cnVlLFxuICAgIGJvZHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGZhaWx1cmUoKSB7XG4gIHJldHVybiB7XG4gICAgb2s6IGZhbHNlXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhlIGtleXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBlLmcuIGB1bmZsYXQoW1wiYVwiLCBcImJcIiwgXCJjXCJdLCAxKWAgcmV0dXJucyBgeyBhOiB7IGI6IHsgYzogMSB9IH0gfWBcbiAqLyBleHBvcnQgZnVuY3Rpb24gdW5mbGF0KGtleXMsIHZhbHVlcyA9IHt9KSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZVJpZ2h0KChhY2MsIGtleSk9Pih7XG4gICAgICBba2V5XTogYWNjXG4gICAgfSksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKSB7XG4gIGNvbnN0IGtleSA9IGtleXNbMF07XG4gIGlmICgha2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIHRoZSBUT01MOiBrZXkgbGVuZ3RoIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0W2tleV07XG59XG5mdW5jdGlvbiBkZWVwQXNzaWduVGFibGUodGFyZ2V0LCB0YWJsZSkge1xuICBjb25zdCB7IGtleXMsIHR5cGUsIHZhbHVlIH0gPSB0YWJsZTtcbiAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB1bmZsYXQoa2V5cywgdmFsdWUpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgY29uc3QgbGFzdCA9IGN1cnJlbnRWYWx1ZS5hdCgtMSk7XG4gICAgZGVlcEFzc2lnbihsYXN0LCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNPYmplY3QoY3VycmVudFZhbHVlKSkge1xuICAgIGRlZXBBc3NpZ24oY3VycmVudFZhbHVlLCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGFzc2lnblwiKTtcbn1cbmZ1bmN0aW9uIGRlZXBBc3NpZ25UYWJsZUFycmF5KHRhcmdldCwgdGFibGUpIHtcbiAgY29uc3QgeyB0eXBlLCBrZXlzLCB2YWx1ZSB9ID0gdGFibGU7XG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGdldFRhcmdldFZhbHVlKHRhcmdldCwga2V5cyk7XG4gIGlmIChjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgdW5mbGF0KGtleXMsIFtcbiAgICAgIHZhbHVlXG4gICAgXSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBjdXJyZW50VmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNPYmplY3QoY3VycmVudFZhbHVlKSkge1xuICAgIGRlZXBBc3NpZ24oY3VycmVudFZhbHVlLCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGFzc2lnblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCwgYm9keSkge1xuICBzd2l0Y2goYm9keS50eXBlKXtcbiAgICBjYXNlIFwiQmxvY2tcIjpcbiAgICAgIHJldHVybiBkZWVwTWVyZ2UodGFyZ2V0LCBib2R5LnZhbHVlKTtcbiAgICBjYXNlIFwiVGFibGVcIjpcbiAgICAgIHJldHVybiBkZWVwQXNzaWduVGFibGUodGFyZ2V0LCBib2R5KTtcbiAgICBjYXNlIFwiVGFibGVBcnJheVwiOlxuICAgICAgcmV0dXJuIGRlZXBBc3NpZ25UYWJsZUFycmF5KHRhcmdldCwgYm9keSk7XG4gIH1cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2VyIGNvbWJpbmF0b3JzIGFuZCBnZW5lcmF0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBvcihwYXJzZXJzKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBmb3IgKGNvbnN0IHBhcnNlIG9mIHBhcnNlcnMpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2Uoc2Nhbm5lcik7XG4gICAgICBpZiAocmVzdWx0Lm9rKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZmFpbHVyZSgpO1xuICB9O1xufVxuLyoqIEpvaW4gdGhlIHBhcnNlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIHBhcnNlciBpbnRvIGFuIGFycmF5LlxuICpcbiAqIElmIHRoZSBwYXJzZXIgZmFpbHMgYXQgdGhlIGZpcnN0IGF0dGVtcHQsIGl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICovIGZ1bmN0aW9uIGpvaW4ocGFyc2VyLCBzZXBhcmF0b3IpIHtcbiAgY29uc3QgU2VwYXJhdG9yID0gY2hhcmFjdGVyKHNlcGFyYXRvcik7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBjb25zdCBmaXJzdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIWZpcnN0Lm9rKSByZXR1cm4gc3VjY2VzcyhvdXQpO1xuICAgIG91dC5wdXNoKGZpcnN0LmJvZHkpO1xuICAgIHdoaWxlKCFzY2FubmVyLmVvZigpKXtcbiAgICAgIGlmICghU2VwYXJhdG9yKHNjYW5uZXIpLm9rKSBicmVhaztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCB0b2tlbiBhZnRlciBcIiR7c2VwYXJhdG9yfVwiYCk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChyZXN1bHQuYm9keSk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKG91dCk7XG4gIH07XG59XG4vKiogSm9pbiB0aGUgcGFyc2UgcmVzdWx0cyBvZiB0aGUgZ2l2ZW4gcGFyc2VyIGludG8gYW4gYXJyYXkuXG4gKlxuICogVGhpcyByZXF1aXJlcyB0aGUgcGFyc2VyIHRvIHN1Y2NlZWQgYXQgbGVhc3Qgb25jZS5cbiAqLyBmdW5jdGlvbiBqb2luMShwYXJzZXIsIHNlcGFyYXRvcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghZmlyc3Qub2spIHJldHVybiBmYWlsdXJlKCk7XG4gICAgY29uc3Qgb3V0ID0gW1xuICAgICAgZmlyc3QuYm9keVxuICAgIF07XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgaWYgKCFTZXBhcmF0b3Ioc2Nhbm5lcikub2spIGJyZWFrO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3Mob3V0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGt2KGtleVBhcnNlciwgc2VwYXJhdG9yLCB2YWx1ZVBhcnNlcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IHBvc2l0aW9uID0gc2Nhbm5lci5wb3NpdGlvbjtcbiAgICBjb25zdCBrZXkgPSBrZXlQYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFrZXkub2spIHJldHVybiBmYWlsdXJlKCk7XG4gICAgY29uc3Qgc2VwID0gU2VwYXJhdG9yKHNjYW5uZXIpO1xuICAgIGlmICghc2VwLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYGtleS92YWx1ZSBwYWlyIGRvZXNuJ3QgaGF2ZSBcIiR7c2VwYXJhdG9yfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVQYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCF2YWx1ZS5vaykge1xuICAgICAgY29uc3QgbGluZUVuZEluZGV4ID0gc2Nhbm5lci5zb3VyY2UuaW5kZXhPZihcIlxcblwiLCBzY2FubmVyLnBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gbGluZUVuZEluZGV4ID4gMCA/IGxpbmVFbmRJbmRleCA6IHNjYW5uZXIuc291cmNlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGxpbmUgPSBzY2FubmVyLnNvdXJjZS5zbGljZShwb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBDYW5ub3QgcGFyc2UgdmFsdWUgb24gbGluZSAnJHtsaW5lfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3ModW5mbGF0KGtleS5ib2R5LCB2YWx1ZS5ib2R5KSk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZShwYXJzZXIpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXJlc3VsdC5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBsZXQgYm9keSA9IHt9O1xuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlc3VsdC5ib2R5KXtcbiAgICAgIGlmICh0eXBlb2YgcmVjb3JkID09PSBcIm9iamVjdFwiICYmIHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gZGVlcE1lcmdlKGJvZHksIHJlY29yZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKGJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVwZWF0KHBhcnNlcikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlKCFzY2FubmVyLmVvZigpKXtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSBicmVhaztcbiAgICAgIGJvZHkucHVzaChyZXN1bHQuYm9keSk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgICB9XG4gICAgaWYgKGJvZHkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIHJldHVybiBzdWNjZXNzKGJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gc3Vycm91bmQobGVmdCwgcGFyc2VyLCByaWdodCkge1xuICBjb25zdCBMZWZ0ID0gY2hhcmFjdGVyKGxlZnQpO1xuICBjb25zdCBSaWdodCA9IGNoYXJhY3RlcihyaWdodCk7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBpZiAoIUxlZnQoc2Nhbm5lcikub2spIHtcbiAgICAgIHJldHVybiBmYWlsdXJlKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtsZWZ0fVwiYCk7XG4gICAgfVxuICAgIGlmICghUmlnaHQoc2Nhbm5lcikub2spIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm90IGNsb3NlZCBieSBcIiR7cmlnaHR9XCIgYWZ0ZXIgc3RhcnRlZCB3aXRoIFwiJHtsZWZ0fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKHJlc3VsdC5ib2R5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoYXJhY3RlcihzdHIpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gICAgaWYgKCFzY2FubmVyLnN0YXJ0c1dpdGgoc3RyKSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBzY2FubmVyLm5leHQoc3RyLmxlbmd0aCk7XG4gICAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgICByZXR1cm4gc3VjY2Vzcyh1bmRlZmluZWQpO1xuICB9O1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhcnNlciBjb21wb25lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQkFSRV9LRVlfUkVHRVhQID0gL1tBLVphLXowLTlfLV0rL3k7XG5leHBvcnQgZnVuY3Rpb24gYmFyZUtleShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IGtleSA9IHNjYW5uZXIubWF0Y2goQkFSRV9LRVlfUkVHRVhQKT8uWzBdO1xuICBpZiAoIWtleSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KGtleS5sZW5ndGgpO1xuICByZXR1cm4gc3VjY2VzcyhrZXkpO1xufVxuZnVuY3Rpb24gZXNjYXBlU2VxdWVuY2Uoc2Nhbm5lcikge1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiXFxcXFwiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgLy8gU2VlIGh0dHBzOi8vdG9tbC5pby9lbi92MS4wLjAtcmMuMyNzdHJpbmdcbiAgc3dpdGNoKHNjYW5uZXIuY2hhcigpKXtcbiAgICBjYXNlIFwiYlwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcYlwiKTtcbiAgICBjYXNlIFwidFwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcdFwiKTtcbiAgICBjYXNlIFwiblwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcblwiKTtcbiAgICBjYXNlIFwiZlwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcZlwiKTtcbiAgICBjYXNlIFwiclwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcclwiKTtcbiAgICBjYXNlIFwidVwiOlxuICAgIGNhc2UgXCJVXCI6XG4gICAgICB7XG4gICAgICAgIC8vIFVuaWNvZGUgY2hhcmFjdGVyXG4gICAgICAgIGNvbnN0IGNvZGVQb2ludExlbiA9IHNjYW5uZXIuY2hhcigpID09PSBcInVcIiA/IDQgOiA2O1xuICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBwYXJzZUludChcIjB4XCIgKyBzY2FubmVyLnNsaWNlKDEsIDEgKyBjb2RlUG9pbnRMZW4pLCAxNik7XG4gICAgICAgIGNvbnN0IHN0ciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgIHNjYW5uZXIubmV4dChjb2RlUG9pbnRMZW4gKyAxKTtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moc3RyKTtcbiAgICAgIH1cbiAgICBjYXNlICdcIic6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKCdcIicpO1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxcXFwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogXFxcXCR7c2Nhbm5lci5jaGFyKCl9YCk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBiYXNpY1N0cmluZyhzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gJ1wiJykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KCk7XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZShzY2FubmVyLmNoYXIoKSAhPT0gJ1wiJyAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJTaW5nbGUtbGluZSBzdHJpbmcgY2Fubm90IGNvbnRhaW4gRU9MXCIpO1xuICAgIH1cbiAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVNlcXVlbmNlKHNjYW5uZXIpO1xuICAgIGlmIChlc2NhcGVkQ2hhci5vaykge1xuICAgICAgYWNjLnB1c2goZXNjYXBlZENoYXIuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5wdXNoKHNjYW5uZXIuY2hhcigpKTtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoc2Nhbm5lci5lb2YoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgU2luZ2xlLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICBzY2FubmVyLm5leHQoKTsgLy8gc2tpcCBsYXN0ICdcIlwiXG4gIHJldHVybiBzdWNjZXNzKGFjYy5qb2luKFwiXCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSBcIidcIikgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KCk7XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZShzY2FubmVyLmNoYXIoKSAhPT0gXCInXCIgJiYgIXNjYW5uZXIuZW9mKCkpe1xuICAgIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiU2luZ2xlLWxpbmUgc3RyaW5nIGNhbm5vdCBjb250YWluIEVPTFwiKTtcbiAgICB9XG4gICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBTaW5nbGUtbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIHNjYW5uZXIubmV4dCgpOyAvLyBza2lwIGxhc3QgXCInXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpbGluZUJhc2ljU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKCFzY2FubmVyLnN0YXJ0c1dpdGgoJ1wiXCJcIicpKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoMyk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcclxcblwiKSkge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChDUkxGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICB9XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5zdGFydHNXaXRoKCdcIlwiXCInKSAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgLy8gbGluZSBlbmRpbmcgYmFja3NsYXNoXG4gICAgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcXFxcXG5cIikpIHtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKHtcbiAgICAgICAgc2tpcENvbW1lbnRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcXFxcXHJcXG5cIikpIHtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKHtcbiAgICAgICAgc2tpcENvbW1lbnRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZXNjYXBlZENoYXIgPSBlc2NhcGVTZXF1ZW5jZShzY2FubmVyKTtcbiAgICBpZiAoZXNjYXBlZENoYXIub2spIHtcbiAgICAgIGFjYy5wdXNoKGVzY2FwZWRDaGFyLmJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE11bHRpLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICAvLyBpZiBlbmRzIHdpdGggNCBgXCJgLCBwdXNoIHRoZSBmaXN0IGBcImAgdG8gc3RyaW5nXG4gIGlmIChzY2FubmVyLmNoYXIoMykgPT09ICdcIicpIHtcbiAgICBhY2MucHVzaCgnXCInKTtcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfVxuICBzY2FubmVyLm5leHQoMyk7IC8vIHNraXAgbGFzdCAnXCJcIlwiXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpbGluZUxpdGVyYWxTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aChcIicnJ1wiKSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KDMpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgPT09IFwiXFxuXCIpIHtcbiAgICAvLyBUaGUgZmlyc3QgbmV3bGluZSAoTEYpIGlzIHRyaW1tZWRcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfSBlbHNlIGlmIChzY2FubmVyLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIikpIHtcbiAgICAvLyBUaGUgZmlyc3QgbmV3bGluZSAoQ1JMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgyKTtcbiAgfVxuICBjb25zdCBhY2MgPSBbXTtcbiAgd2hpbGUoIXNjYW5uZXIuc3RhcnRzV2l0aChcIicnJ1wiKSAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBNdWx0aS1saW5lIHN0cmluZyBpcyBub3QgY2xvc2VkOlxcbiR7YWNjLmpvaW4oXCJcIil9YCk7XG4gIH1cbiAgLy8gaWYgZW5kcyB3aXRoIDQgYCdgLCBwdXNoIHRoZSBmaXN0IGAnYCB0byBzdHJpbmdcbiAgaWYgKHNjYW5uZXIuY2hhcigzKSA9PT0gXCInXCIpIHtcbiAgICBhY2MucHVzaChcIidcIik7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0KDMpOyAvLyBza2lwIGxhc3QgXCInJydcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5jb25zdCBCT09MRUFOX1JFR0VYUCA9IC8oPzp0cnVlfGZhbHNlKVxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGJvb2xlYW4oc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goQk9PTEVBTl9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IHN0cmluZyA9PT0gXCJ0cnVlXCI7XG4gIHJldHVybiBzdWNjZXNzKHZhbHVlKTtcbn1cbmNvbnN0IElORklOSVRZX01BUCA9IG5ldyBNYXAoW1xuICBbXG4gICAgXCJpbmZcIixcbiAgICBJbmZpbml0eVxuICBdLFxuICBbXG4gICAgXCIraW5mXCIsXG4gICAgSW5maW5pdHlcbiAgXSxcbiAgW1xuICAgIFwiLWluZlwiLFxuICAgIC1JbmZpbml0eVxuICBdXG5dKTtcbmNvbnN0IElORklOSVRZX1JFR0VYUCA9IC9bKy1dP2luZlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGluZmluaXR5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKElORklOSVRZX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gSU5GSU5JVFlfTUFQLmdldChzdHJpbmcpO1xuICByZXR1cm4gc3VjY2Vzcyh2YWx1ZSk7XG59XG5jb25zdCBOQU5fUkVHRVhQID0gL1srLV0/bmFuXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gbmFuKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKE5BTl9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IE5hTjtcbiAgcmV0dXJuIHN1Y2Nlc3ModmFsdWUpO1xufVxuZXhwb3J0IGNvbnN0IGRvdHRlZEtleSA9IGpvaW4xKG9yKFtcbiAgYmFyZUtleSxcbiAgYmFzaWNTdHJpbmcsXG4gIGxpdGVyYWxTdHJpbmdcbl0pLCBcIi5cIik7XG5jb25zdCBCSU5BUllfUkVHRVhQID0gLzBiWzAxXSsoPzpfWzAxXSspKlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChCSU5BUllfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDIpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IE9DVEFMX1JFR0VYUCA9IC8wb1swLTddKyg/Ol9bMC03XSspKlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIG9jdGFsKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKE9DVEFMX1JFR0VYUCk/LlswXTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KG1hdGNoLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gbWF0Y2guc2xpY2UoMikucmVwbGFjZUFsbChcIl9cIiwgXCJcIik7XG4gIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWlsdXJlKCkgOiBzdWNjZXNzKG51bWJlcik7XG59XG5jb25zdCBIRVhfUkVHRVhQID0gLzB4WzAtOWEtZl0rKD86X1swLTlhLWZdKykqXFxiL3lpO1xuZXhwb3J0IGZ1bmN0aW9uIGhleChzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChIRVhfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWlsdXJlKCkgOiBzdWNjZXNzKG51bWJlcik7XG59XG5jb25zdCBJTlRFR0VSX1JFR0VYUCA9IC9bKy1dPyg/OjB8WzEtOV1bMC05XSooPzpfWzAtOV0rKSopXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlcihzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChJTlRFR0VSX1JFR0VYUCk/LlswXTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KG1hdGNoLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gbWF0Y2gucmVwbGFjZUFsbChcIl9cIiwgXCJcIik7XG4gIGNvbnN0IGludCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIHJldHVybiBzdWNjZXNzKGludCk7XG59XG5jb25zdCBGTE9BVF9SRUdFWFAgPSAvWystXT8oPzowfFsxLTldWzAtOV0qKD86X1swLTldKykqKSg/OlxcLlswLTldKyg/Ol9bMC05XSspKik/KD86ZVsrLV0/WzAtOV0rKD86X1swLTldKykqKT9cXGIveWk7XG5leHBvcnQgZnVuY3Rpb24gZmxvYXQoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goRkxPQVRfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgZmxvYXQgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgaWYgKGlzTmFOKGZsb2F0KSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoZmxvYXQpO1xufVxuY29uc3QgREFURV9USU1FX1JFR0VYUCA9IC8oPzx5ZWFyPlxcZHs0fSktKD88bW9udGg+XFxkezJ9KS0oPzxkYXk+XFxkezJ9KSg/OlsgMC05VFouOistXSspP1xcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUaW1lKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKERBVEVfVElNRV9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCBncm91cHMgPSBtYXRjaC5ncm91cHM7XG4gIC8vIHNwZWNpYWwgY2FzZSBpZiBtb250aCBpcyBGZWJydWFyeVxuICBpZiAoZ3JvdXBzLm1vbnRoID09IFwiMDJcIikge1xuICAgIGNvbnN0IGRheXMgPSBwYXJzZUludChncm91cHMuZGF5KTtcbiAgICBpZiAoZGF5cyA+IDI5KSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChncm91cHMueWVhcik7XG4gICAgaWYgKGRheXMgPiAyOCAmJiAhaXNMZWFwKHllYXIpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcudHJpbSgpKTtcbiAgLy8gaW52YWxpZCBkYXRlXG4gIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gIH1cbiAgcmV0dXJuIHN1Y2Nlc3MoZGF0ZSk7XG59XG5jb25zdCBMT0NBTF9USU1FX1JFR0VYUCA9IC8oXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KSg/OlxcLlswLTldKyk/XFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gbG9jYWxUaW1lKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKExPQ0FMX1RJTUVfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MobWF0Y2gpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VmFsdWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiW1wiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSBicmVhaztcbiAgICBhcnJheS5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICAgIC8vIG1heSBoYXZlIGEgbmV4dCBpdGVtLCBidXQgdHJhaWxpbmcgY29tbWEgaXMgYWxsb3dlZCBhdCBhcnJheVxuICAgIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiXVwiKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBcnJheSBpcyBub3QgY2xvc2VkXCIpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoYXJyYXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlubGluZVRhYmxlKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoMSkgPT09IFwifVwiKSB7XG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICAgIHJldHVybiBzdWNjZXNzKHt9KTtcbiAgfVxuICBjb25zdCBwYWlycyA9IHN1cnJvdW5kKFwie1wiLCBqb2luKHBhaXIsIFwiLFwiKSwgXCJ9XCIpKHNjYW5uZXIpO1xuICBpZiAoIXBhaXJzLm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICBsZXQgdGFibGUgPSB7fTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzLmJvZHkpe1xuICAgIHRhYmxlID0gZGVlcE1lcmdlKHRhYmxlLCBwYWlyKTtcbiAgfVxuICByZXR1cm4gc3VjY2Vzcyh0YWJsZSk7XG59XG5leHBvcnQgY29uc3QgdmFsdWUgPSBvcihbXG4gIG11bHRpbGluZUJhc2ljU3RyaW5nLFxuICBtdWx0aWxpbmVMaXRlcmFsU3RyaW5nLFxuICBiYXNpY1N0cmluZyxcbiAgbGl0ZXJhbFN0cmluZyxcbiAgYm9vbGVhbixcbiAgaW5maW5pdHksXG4gIG5hbixcbiAgZGF0ZVRpbWUsXG4gIGxvY2FsVGltZSxcbiAgYmluYXJ5LFxuICBvY3RhbCxcbiAgaGV4LFxuICBmbG9hdCxcbiAgaW50ZWdlcixcbiAgYXJyYXlWYWx1ZSxcbiAgaW5saW5lVGFibGVcbl0pO1xuZXhwb3J0IGNvbnN0IHBhaXIgPSBrdihkb3R0ZWRLZXksIFwiPVwiLCB2YWx1ZSk7XG5leHBvcnQgZnVuY3Rpb24gYmxvY2soc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgcmVzdWx0ID0gbWVyZ2UocmVwZWF0KHBhaXIpKShzY2FubmVyKTtcbiAgaWYgKHJlc3VsdC5vaykgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIHR5cGU6IFwiQmxvY2tcIixcbiAgICB2YWx1ZTogcmVzdWx0LmJvZHlcbiAgfSk7XG4gIHJldHVybiBmYWlsdXJlKCk7XG59XG5leHBvcnQgY29uc3QgdGFibGVIZWFkZXIgPSBzdXJyb3VuZChcIltcIiwgZG90dGVkS2V5LCBcIl1cIik7XG5leHBvcnQgZnVuY3Rpb24gdGFibGUoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgaGVhZGVyID0gdGFibGVIZWFkZXIoc2Nhbm5lcik7XG4gIGlmICghaGVhZGVyLm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgYiA9IGJsb2NrKHNjYW5uZXIpO1xuICByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJUYWJsZVwiLFxuICAgIGtleXM6IGhlYWRlci5ib2R5LFxuICAgIHZhbHVlOiBiLm9rID8gYi5ib2R5LnZhbHVlIDoge31cbiAgfSk7XG59XG5leHBvcnQgY29uc3QgdGFibGVBcnJheUhlYWRlciA9IHN1cnJvdW5kKFwiW1tcIiwgZG90dGVkS2V5LCBcIl1dXCIpO1xuZXhwb3J0IGZ1bmN0aW9uIHRhYmxlQXJyYXkoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgaGVhZGVyID0gdGFibGVBcnJheUhlYWRlcihzY2FubmVyKTtcbiAgaWYgKCFoZWFkZXIub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBiID0gYmxvY2soc2Nhbm5lcik7XG4gIHJldHVybiBzdWNjZXNzKHtcbiAgICB0eXBlOiBcIlRhYmxlQXJyYXlcIixcbiAgICBrZXlzOiBoZWFkZXIuYm9keSxcbiAgICB2YWx1ZTogYi5vayA/IGIuYm9keS52YWx1ZSA6IHt9XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvbWwoc2Nhbm5lcikge1xuICBjb25zdCBibG9ja3MgPSByZXBlYXQob3IoW1xuICAgIGJsb2NrLFxuICAgIHRhYmxlQXJyYXksXG4gICAgdGFibGVcbiAgXSkpKHNjYW5uZXIpO1xuICBpZiAoIWJsb2Nrcy5vaykgcmV0dXJuIHN1Y2Nlc3Moe30pO1xuICBjb25zdCBib2R5ID0gYmxvY2tzLmJvZHkucmVkdWNlKGRlZXBBc3NpZ24sIHt9KTtcbiAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHN0cmluZyA9IHNjYW5uZXIuc291cmNlLnNsaWNlKDAsIHNjYW5uZXIucG9zaXRpb24pO1xuICBjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgY29uc3Qgcm93ID0gbGluZXMubGVuZ3RoO1xuICBjb25zdCBjb2x1bW4gPSBsaW5lcy5hdCgtMSk/Lmxlbmd0aCA/PyAwO1xuICByZXR1cm4gYFBhcnNlIGVycm9yIG9uIGxpbmUgJHtyb3d9LCBjb2x1bW4gJHtjb2x1bW59OiAke21lc3NhZ2V9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGYWN0b3J5KHBhcnNlcikge1xuICByZXR1cm4gKHRvbWxTdHJpbmcpPT57XG4gICAgY29uc3Qgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRvbWxTdHJpbmcpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgICBpZiAocmVzdWx0Lm9rICYmIHNjYW5uZXIuZW9mKCkpIHJldHVybiByZXN1bHQuYm9keTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiJHtzY2FubmVyLmNoYXIoKX1cImA7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgbWVzc2FnZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBlcnJvciB0eXBlIGNhdWdodFwiO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGNyZWF0ZVBhcnNlRXJyb3JNZXNzYWdlKHNjYW5uZXIsIG1lc3NhZ2UpKTtcbiAgICB9XG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcGFyc2VyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBwYXJzZXJGYWN0b3J5LCB0b21sIH0gZnJvbSBcIi4vX3BhcnNlci5qc1wiO1xuLyoqXG4gKiBQYXJzZXMgYSB7QGxpbmsgaHR0cHM6Ly90b21sLmlvIHwgVE9NTH0gc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlIFVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiQHN0ZC90b21sL3BhcnNlXCI7XG4gKiBpbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tIFwiQHN0ZC9hc3NlcnRcIjtcbiAqXG4gKiBjb25zdCB0b21sU3RyaW5nID0gYHRpdGxlID0gXCJUT01MIEV4YW1wbGVcIlxuICogW293bmVyXVxuICogbmFtZSA9IFwiQWxpY2VcIlxuICogYmlvID0gXCJBbGljZSBpcyBhIHByb2dyYW1tZXIuXCJgO1xuICpcbiAqIGNvbnN0IG9iaiA9IHBhcnNlKHRvbWxTdHJpbmcpO1xuICogYXNzZXJ0RXF1YWxzKG9iaiwgeyB0aXRsZTogXCJUT01MIEV4YW1wbGVcIiwgb3duZXI6IHsgbmFtZTogXCJBbGljZVwiLCBiaW86IFwiQWxpY2UgaXMgYSBwcm9ncmFtbWVyLlwiIH0gfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB0b21sU3RyaW5nIFRPTUwgc3RyaW5nIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgSlMgb2JqZWN0LlxuICovIGV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0b21sU3RyaW5nKSB7XG4gIHJldHVybiBwYXJzZXJGYWN0b3J5KHRvbWwpKHRvbWxTdHJpbmcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VSZW5hbWVDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3JlbmFtZSddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnUmVuYW1lIHRoZSBOQVBJLVJTIHByb2plY3QnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpcicsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gICQkbmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbmFtZSwtbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgbmFtZSBvZiB0aGUgcHJvamVjdCcsXG4gIH0pXG5cbiAgYmluYXJ5TmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYmluYXJ5LW5hbWUsLWInLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IGJpbmFyeSBuYW1lICoubm9kZSBmaWxlcycsXG4gIH0pXG5cbiAgcGFja2FnZU5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtbmFtZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgcGFja2FnZSBuYW1lIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBtYW5pZmVzdFBhdGggPSBPcHRpb24uU3RyaW5nKCctLW1hbmlmZXN0LXBhdGgnLCAnQ2FyZ28udG9tbCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYENhcmdvLnRvbWxgJyxcbiAgfSlcblxuICByZXBvc2l0b3J5Pzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1yZXBvc2l0b3J5Jywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyByZXBvc2l0b3J5IG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBkZXNjcmlwdGlvbj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZGVzY3JpcHRpb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICBuYW1lOiB0aGlzLiQkbmFtZSxcbiAgICAgIGJpbmFyeU5hbWU6IHRoaXMuYmluYXJ5TmFtZSxcbiAgICAgIHBhY2thZ2VOYW1lOiB0aGlzLnBhY2thZ2VOYW1lLFxuICAgICAgbWFuaWZlc3RQYXRoOiB0aGlzLm1hbmlmZXN0UGF0aCxcbiAgICAgIHJlcG9zaXRvcnk6IHRoaXMucmVwb3NpdG9yeSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbmFtZSB0aGUgTkFQSS1SUyBwcm9qZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVuYW1lT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IG5hbWUgb2YgdGhlIHByb2plY3RcbiAgICovXG4gIG5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgYmluYXJ5IG5hbWUgKi5ub2RlIGZpbGVzXG4gICAqL1xuICBiaW5hcnlOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IHBhY2thZ2UgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgcGFja2FnZU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYENhcmdvLnRvbWxgXG4gICAqXG4gICAqIEBkZWZhdWx0ICdDYXJnby50b21sJ1xuICAgKi9cbiAgbWFuaWZlc3RQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IHJlcG9zaXRvcnkgb2YgdGhlIHByb2plY3RcbiAgICovXG4gIHJlcG9zaXRvcnk/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3RcbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zKG9wdGlvbnM6IFJlbmFtZU9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIG1hbmlmZXN0UGF0aDogJ0NhcmdvLnRvbWwnLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgcmVuYW1lIH0gZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcbmltcG9ydCB7IHJlc29sdmUsIGpvaW4gfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlVG9tbCwgc3RyaW5naWZ5IGFzIHN0cmluZ2lmeVRvbWwgfSBmcm9tICdAc3RkL3RvbWwnXG5pbXBvcnQgeyBsb2FkIGFzIHlhbWxQYXJzZSwgZHVtcCBhcyB5YW1sU3RyaW5naWZ5IH0gZnJvbSAnanMteWFtbCdcbmltcG9ydCB7IGlzTmlsLCBtZXJnZSwgb21pdEJ5LCBwaWNrIH0gZnJvbSAnbG9kYXNoLWVzJ1xuaW1wb3J0IHsgZmluZFVwIH0gZnJvbSAnZmluZC11cCdcblxuaW1wb3J0IHsgYXBwbHlEZWZhdWx0UmVuYW1lT3B0aW9ucywgUmVuYW1lT3B0aW9ucyB9IGZyb20gJy4uL2RlZi9yZW5hbWUuanMnXG5pbXBvcnQgeyByZWFkQ29uZmlnLCByZWFkRmlsZUFzeW5jLCB3cml0ZUZpbGVBc3luYyB9IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuYW1lUHJvamVjdCh1c2VyT3B0aW9uczogUmVuYW1lT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0UmVuYW1lT3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgY29uc3QgbmFwaUNvbmZpZyA9IGF3YWl0IHJlYWRDb25maWcob3B0aW9ucylcbiAgY29uc3Qgb2xkTmFtZSA9IG5hcGlDb25maWcuYmluYXJ5TmFtZVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuICBjb25zdCBjYXJnb1RvbWxQYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5tYW5pZmVzdFBhdGgpXG5cbiAgY29uc3QgcGFja2FnZUpzb25Db250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhwYWNrYWdlSnNvblBhdGgsICd1dGY4JylcbiAgY29uc3QgcGFja2FnZUpzb25EYXRhID0gSlNPTi5wYXJzZShwYWNrYWdlSnNvbkNvbnRlbnQpXG5cbiAgbWVyZ2UoXG4gICAgcGFja2FnZUpzb25EYXRhLFxuICAgIG9taXRCeShwaWNrKG9wdGlvbnMsIFsnbmFtZScsICdkZXNjcmlwdGlvbicsICdhdXRob3InLCAnbGljZW5zZSddKSwgaXNOaWwpLFxuICAgIHtcbiAgICAgIG5hcGk6IG9taXRCeShcbiAgICAgICAge1xuICAgICAgICAgIGJpbmFyeU5hbWU6IG9wdGlvbnMuYmluYXJ5TmFtZSxcbiAgICAgICAgICBwYWNrYWdlTmFtZTogb3B0aW9ucy5wYWNrYWdlTmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNOaWwsXG4gICAgICApLFxuICAgIH0sXG4gIClcblxuICBpZiAob3B0aW9ucy5jb25maWdQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aClcbiAgICBjb25zdCBjb25maWdDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjb25maWdQYXRoLCAndXRmOCcpXG4gICAgY29uc3QgY29uZmlnRGF0YSA9IEpTT04ucGFyc2UoY29uZmlnQ29udGVudClcbiAgICBjb25maWdEYXRhLmJpbmFyeU5hbWUgPSBvcHRpb25zLmJpbmFyeU5hbWVcbiAgICBjb25maWdEYXRhLnBhY2thZ2VOYW1lID0gb3B0aW9ucy5wYWNrYWdlTmFtZVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGNvbmZpZ1BhdGgsIEpTT04uc3RyaW5naWZ5KGNvbmZpZ0RhdGEsIG51bGwsIDIpKVxuICB9XG5cbiAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uRGF0YSwgbnVsbCwgMiksXG4gIClcblxuICBjb25zdCB0b21sQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoY2FyZ29Ub21sUGF0aCwgJ3V0ZjgnKVxuICBjb25zdCBjYXJnb1RvbWwgPSBwYXJzZVRvbWwodG9tbENvbnRlbnQpIGFzIGFueVxuXG4gIC8vIFVwZGF0ZSB0aGUgcGFja2FnZSBuYW1lXG4gIGlmIChjYXJnb1RvbWwucGFja2FnZSAmJiBvcHRpb25zLmJpbmFyeU5hbWUpIHtcbiAgICAvLyBTYW5pdGl6ZSB0aGUgYmluYXJ5IG5hbWUgZm9yIFJ1c3QgcGFja2FnZSBuYW1pbmcgY29udmVudGlvbnNcbiAgICBjb25zdCBzYW5pdGl6ZWROYW1lID0gb3B0aW9ucy5iaW5hcnlOYW1lXG4gICAgICAucmVwbGFjZSgnQCcsICcnKVxuICAgICAgLnJlcGxhY2UoJy8nLCAnXycpXG4gICAgICAucmVwbGFjZSgvLS9nLCAnXycpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgIGNhcmdvVG9tbC5wYWNrYWdlLm5hbWUgPSBzYW5pdGl6ZWROYW1lXG4gIH1cblxuICAvLyBTdHJpbmdpZnkgdGhlIHVwZGF0ZWQgVE9NTFxuICBjb25zdCB1cGRhdGVkVG9tbENvbnRlbnQgPSBzdHJpbmdpZnlUb21sKGNhcmdvVG9tbClcblxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhjYXJnb1RvbWxQYXRoLCB1cGRhdGVkVG9tbENvbnRlbnQpXG4gIGlmIChvbGROYW1lICE9PSBvcHRpb25zLmJpbmFyeU5hbWUpIHtcbiAgICBjb25zdCBnaXRodWJBY3Rpb25zUGF0aCA9IGF3YWl0IGZpbmRVcCgnLmdpdGh1YicsIHtcbiAgICAgIGN3ZDogb3B0aW9ucy5jd2QsXG4gICAgICB0eXBlOiAnZGlyZWN0b3J5JyxcbiAgICB9KVxuICAgIGlmIChnaXRodWJBY3Rpb25zUGF0aCkge1xuICAgICAgY29uc3QgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCA9IGpvaW4oXG4gICAgICAgIGdpdGh1YkFjdGlvbnNQYXRoLFxuICAgICAgICAnd29ya2Zsb3dzJyxcbiAgICAgICAgJ0NJLnltbCcsXG4gICAgICApXG4gICAgICBpZiAoZXhpc3RzU3luYyhnaXRodWJBY3Rpb25zQ0lZbWxQYXRoKSkge1xuICAgICAgICBjb25zdCBnaXRodWJBY3Rpb25zQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoXG4gICAgICAgICAgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCxcbiAgICAgICAgICAndXRmOCcsXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgZ2l0aHViQWN0aW9uc0RhdGEgPSB5YW1sUGFyc2UoZ2l0aHViQWN0aW9uc0NvbnRlbnQpIGFzIGFueVxuICAgICAgICBpZiAoZ2l0aHViQWN0aW9uc0RhdGEuZW52Py5BUFBfTkFNRSkge1xuICAgICAgICAgIGdpdGh1YkFjdGlvbnNEYXRhLmVudi5BUFBfTkFNRSA9IG9wdGlvbnMuYmluYXJ5TmFtZVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICAgICAgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCxcbiAgICAgICAgICAgIHlhbWxTdHJpbmdpZnkoZ2l0aHViQWN0aW9uc0RhdGEsIHtcbiAgICAgICAgICAgICAgbGluZVdpZHRoOiAtMSxcbiAgICAgICAgICAgICAgbm9SZWZzOiB0cnVlLFxuICAgICAgICAgICAgICBzb3J0S2V5czogZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCA9IGpvaW4oXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIGAke29sZE5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgKVxuICAgIGlmIChleGlzdHNTeW5jKG9sZFdhc2lCcm93c2VyQmluZGluZ1BhdGgpKSB7XG4gICAgICBhd2FpdCByZW5hbWUoXG4gICAgICAgIG9sZFdhc2lCcm93c2VyQmluZGluZ1BhdGgsXG4gICAgICAgIGpvaW4ob3B0aW9ucy5jd2QsIGAke29wdGlvbnMuYmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCksXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IG9sZFdhc2lCaW5kaW5nUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsIGAke29sZE5hbWV9Lndhc2kuY2pzYClcbiAgICBpZiAoZXhpc3RzU3luYyhvbGRXYXNpQmluZGluZ1BhdGgpKSB7XG4gICAgICBhd2FpdCByZW5hbWUoXG4gICAgICAgIG9sZFdhc2lCaW5kaW5nUGF0aCxcbiAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLmNqc2ApLFxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBnaXRBdHRyaWJ1dGVzUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsICcuZ2l0YXR0cmlidXRlcycpXG4gICAgaWYgKGV4aXN0c1N5bmMoZ2l0QXR0cmlidXRlc1BhdGgpKSB7XG4gICAgICBjb25zdCBnaXRBdHRyaWJ1dGVzQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoXG4gICAgICAgIGdpdEF0dHJpYnV0ZXNQYXRoLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBjb25zdCBnaXRBdHRyaWJ1dGVzRGF0YSA9IGdpdEF0dHJpYnV0ZXNDb250ZW50XG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBsaW5lXG4gICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgYCR7b2xkTmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICAgICAgICAgICAgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnJlcGxhY2UoYCR7b2xkTmFtZX0ud2FzaS5janNgLCBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2kuY2pzYClcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhnaXRBdHRyaWJ1dGVzUGF0aCwgZ2l0QXR0cmlidXRlc0RhdGEpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBleGVjLCBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ25vZGU6b3MnXG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnXG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ25vZGU6ZnMnXG5cbmltcG9ydCB7IGxvYWQgYXMgeWFtbExvYWQsIGR1bXAgYXMgeWFtbER1bXAgfSBmcm9tICdqcy15YW1sJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHROZXdPcHRpb25zLFxuICBOZXdPcHRpb25zIGFzIFJhd05ld09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9uZXcuanMnXG5pbXBvcnQge1xuICBBVkFJTEFCTEVfVEFSR0VUUyxcbiAgZGVidWdGYWN0b3J5LFxuICBERUZBVUxUX1RBUkdFVFMsXG4gIG1rZGlyQXN5bmMsXG4gIHJlYWRkaXJBc3luYyxcbiAgc3RhdEFzeW5jLFxuICBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5pbXBvcnQgeyBuYXBpRW5naW5lUmVxdWlyZW1lbnQgfSBmcm9tICcuLi91dGlscy92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgcmVuYW1lUHJvamVjdCB9IGZyb20gJy4vcmVuYW1lLmpzJ1xuXG4vLyBUZW1wbGF0ZSBpbXBvcnRzIHJlbW92ZWQgYXMgd2UncmUgbm93IHVzaW5nIGV4dGVybmFsIHRlbXBsYXRlc1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnbmV3JylcblxudHlwZSBOZXdPcHRpb25zID0gUmVxdWlyZWQ8UmF3TmV3T3B0aW9ucz5cblxuY29uc3QgVEVNUExBVEVfUkVQT1MgPSB7XG4gIHlhcm46ICdodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9wYWNrYWdlLXRlbXBsYXRlJyxcbiAgcG5wbTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL3BhY2thZ2UtdGVtcGxhdGUtcG5wbScsXG59IGFzIGNvbnN0XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrR2l0Q29tbWFuZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY3AgPSBleGVjKCdnaXQgLS12ZXJzaW9uJylcbiAgICAgIGNwLm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgIH0pXG4gICAgICBjcC5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVDYWNoZURpcihcbiAgcGFja2FnZU1hbmFnZXI6IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgY2FjaGVEaXIgPSBwYXRoLmpvaW4oaG9tZWRpcigpLCAnLm5hcGktcnMnLCAndGVtcGxhdGUnLCBwYWNrYWdlTWFuYWdlcilcbiAgYXdhaXQgbWtkaXJBc3luYyhjYWNoZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgcmV0dXJuIGNhY2hlRGlyXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkVGVtcGxhdGUoXG4gIHBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcixcbiAgY2FjaGVEaXI6IHN0cmluZyxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXBvVXJsID0gVEVNUExBVEVfUkVQT1NbcGFja2FnZU1hbmFnZXJdXG4gIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihjYWNoZURpciwgJ3JlcG8nKVxuXG4gIGlmIChleGlzdHNTeW5jKHRlbXBsYXRlUGF0aCkpIHtcbiAgICBkZWJ1ZyhgVGVtcGxhdGUgY2FjaGUgZm91bmQgYXQgJHt0ZW1wbGF0ZVBhdGh9LCB1cGRhdGluZy4uLmApXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIGxhdGVzdCBjaGFuZ2VzIGFuZCByZXNldCB0byByZW1vdGVcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY3AgPSBleGVjKCdnaXQgZmV0Y2ggb3JpZ2luJywgeyBjd2Q6IHRlbXBsYXRlUGF0aCB9KVxuICAgICAgICBjcC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIGNwLm9uKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggbGF0ZXN0IGNoYW5nZXMsIGdpdCBwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGV4ZWNTeW5jKCdnaXQgcmVzZXQgLS1oYXJkIG9yaWdpbi9tYWluJywge1xuICAgICAgICBjd2Q6IHRlbXBsYXRlUGF0aCxcbiAgICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgICAgfSlcbiAgICAgIGRlYnVnKCdUZW1wbGF0ZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnKGBGYWlsZWQgdG8gdXBkYXRlIHRlbXBsYXRlOiAke2Vycm9yfWApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9OiAke2Vycm9yfWApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKGBDbG9uaW5nIHRlbXBsYXRlIGZyb20gJHtyZXBvVXJsfS4uLmApXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKGBnaXQgY2xvbmUgJHtyZXBvVXJsfSByZXBvYCwgeyBjd2Q6IGNhY2hlRGlyLCBzdGRpbzogJ2luaGVyaXQnIH0pXG4gICAgICBkZWJ1ZygnVGVtcGxhdGUgY2xvbmVkIHN1Y2Nlc3NmdWxseScpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNsb25lIHRlbXBsYXRlIGZyb20gJHtyZXBvVXJsfTogJHtlcnJvcn1gKVxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5RGlyZWN0b3J5KFxuICBzcmM6IHN0cmluZyxcbiAgZGVzdDogc3RyaW5nLFxuICBpbmNsdWRlV2FzaUJpbmRpbmdzOiBib29sZWFuLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IG1rZGlyQXN5bmMoZGVzdCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgY29uc3QgZW50cmllcyA9IGF3YWl0IGZzLnJlYWRkaXIoc3JjLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcblxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBzcmNQYXRoID0gcGF0aC5qb2luKHNyYywgZW50cnkubmFtZSlcbiAgICBjb25zdCBkZXN0UGF0aCA9IHBhdGguam9pbihkZXN0LCBlbnRyeS5uYW1lKVxuXG4gICAgLy8gU2tpcCAuZ2l0IGRpcmVjdG9yeVxuICAgIGlmIChlbnRyeS5uYW1lID09PSAnLmdpdCcpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGF3YWl0IGNvcHlEaXJlY3Rvcnkoc3JjUGF0aCwgZGVzdFBhdGgsIGluY2x1ZGVXYXNpQmluZGluZ3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWluY2x1ZGVXYXNpQmluZGluZ3MgJiZcbiAgICAgICAgKGVudHJ5Lm5hbWUuZW5kc1dpdGgoJy53YXNpLWJyb3dzZXIuanMnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJy53YXNpLmNqcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnd2FzaS13b3JrZXIuYnJvd3Nlci5tanMgJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCd3YXNpLXdvcmtlci5tanMnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJ2Jyb3dzZXIuanMnKSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgYXdhaXQgZnMuY29weUZpbGUoc3JjUGF0aCwgZGVzdFBhdGgpXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbHRlclRhcmdldHNJblBhY2thZ2VKc29uKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBlbmFibGVkVGFyZ2V0czogc3RyaW5nW10sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKVxuICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudClcblxuICAvLyBGaWx0ZXIgbmFwaS50YXJnZXRzXG4gIGlmIChwYWNrYWdlSnNvbi5uYXBpPy50YXJnZXRzKSB7XG4gICAgcGFja2FnZUpzb24ubmFwaS50YXJnZXRzID0gcGFja2FnZUpzb24ubmFwaS50YXJnZXRzLmZpbHRlcihcbiAgICAgICh0YXJnZXQ6IHN0cmluZykgPT4gZW5hYmxlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSxcbiAgICApXG4gIH1cblxuICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uLCBudWxsLCAyKSArICdcXG4nKVxufVxuXG5hc3luYyBmdW5jdGlvbiBmaWx0ZXJUYXJnZXRzSW5HaXRodWJBY3Rpb25zKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBlbmFibGVkVGFyZ2V0czogc3RyaW5nW10sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKVxuICBjb25zdCB5YW1sID0geWFtbExvYWQoY29udGVudCkgYXMgYW55XG5cbiAgY29uc3QgbWFjT1NBbmRXaW5kb3dzVGFyZ2V0cyA9IG5ldyBTZXQoW1xuICAgICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgICAnYWFyY2g2NC1wYy13aW5kb3dzLW1zdmMnLFxuICAgICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgXSlcblxuICBjb25zdCBsaW51eFRhcmdldHMgPSBuZXcgU2V0KFtcbiAgICAneDg2XzY0LXVua25vd24tbGludXgtZ251JyxcbiAgICAneDg2XzY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICAgJ2FybXY3LXVua25vd24tbGludXgtZ251ZWFiaWhmJyxcbiAgICAnYXJtdjctdW5rbm93bi1saW51eC1tdXNsZWFiaWhmJyxcbiAgICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JyxcbiAgICAncG93ZXJwYzY0bGUtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdzMzkweC11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ2FhcmNoNjQtbGludXgtYW5kcm9pZCcsXG4gICAgJ2FybXY3LWxpbnV4LWFuZHJvaWRlYWJpJyxcbiAgXSlcblxuICAvLyBDaGVjayBpZiBhbnkgTGludXggdGFyZ2V0cyBhcmUgZW5hYmxlZFxuICBjb25zdCBoYXNMaW51eFRhcmdldHMgPSBlbmFibGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+XG4gICAgbGludXhUYXJnZXRzLmhhcyh0YXJnZXQpLFxuICApXG5cbiAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIGJ1aWxkIGpvYlxuICBpZiAoeWFtbD8uam9icz8uYnVpbGQ/LnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzKSB7XG4gICAgeWFtbC5qb2JzLmJ1aWxkLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5ncyA9XG4gICAgICB5YW1sLmpvYnMuYnVpbGQuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzLmZpbHRlcigoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgIGlmIChzZXR0aW5nLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyhzZXR0aW5nLnRhcmdldClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgfVxuXG4gIGNvbnN0IGpvYnNUb1JlbW92ZTogc3RyaW5nW10gPSBbXVxuXG4gIGlmIChlbmFibGVkVGFyZ2V0cy5ldmVyeSgodGFyZ2V0KSA9PiAhbWFjT1NBbmRXaW5kb3dzVGFyZ2V0cy5oYXModGFyZ2V0KSkpIHtcbiAgICBqb2JzVG9SZW1vdmUucHVzaCgndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbHRlciB0aGUgbWF0cml4IGNvbmZpZ3VyYXRpb25zIGluIHRoZSB0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZyBqb2JcbiAgICBpZiAoXG4gICAgICB5YW1sPy5qb2JzPy5bJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10/LnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzXG4gICAgKSB7XG4gICAgICB5YW1sLmpvYnNbJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzID1cbiAgICAgICAgeWFtbC5qb2JzWyd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZyddLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5ncy5maWx0ZXIoXG4gICAgICAgICAgKHNldHRpbmc6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmcudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyhzZXR0aW5nLnRhcmdldClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIExpbnV4IHRhcmdldHMgYXJlIGVuYWJsZWQsIHJlbW92ZSBMaW51eC1zcGVjaWZpYyBqb2JzXG4gIGlmICghaGFzTGludXhUYXJnZXRzKSB7XG4gICAgLy8gUmVtb3ZlIHRlc3QtbGludXgtYmluZGluZyBqb2JcbiAgICBpZiAoeWFtbD8uam9icz8uWyd0ZXN0LWxpbnV4LWJpbmRpbmcnXSkge1xuICAgICAgam9ic1RvUmVtb3ZlLnB1c2goJ3Rlc3QtbGludXgtYmluZGluZycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbHRlciB0aGUgbWF0cml4IGNvbmZpZ3VyYXRpb25zIGluIHRoZSB0ZXN0LWxpbnV4LXg2NC1nbnUtYmluZGluZyBqb2JcbiAgICBpZiAoeWFtbD8uam9icz8uWyd0ZXN0LWxpbnV4LWJpbmRpbmcnXT8uc3RyYXRlZ3k/Lm1hdHJpeD8udGFyZ2V0KSB7XG4gICAgICB5YW1sLmpvYnNbJ3Rlc3QtbGludXgtYmluZGluZyddLnN0cmF0ZWd5Lm1hdHJpeC50YXJnZXQgPSB5YW1sLmpvYnNbXG4gICAgICAgICd0ZXN0LWxpbnV4LWJpbmRpbmcnXG4gICAgICBdLnN0cmF0ZWd5Lm1hdHJpeC50YXJnZXQuZmlsdGVyKCh0YXJnZXQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSkge1xuICAgIGpvYnNUb1JlbW92ZS5wdXNoKCd0ZXN0LXdhc2knKVxuICB9XG5cbiAgaWYgKCFlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcygneDg2XzY0LXVua25vd24tZnJlZWJzZCcpKSB7XG4gICAgam9ic1RvUmVtb3ZlLnB1c2goJ2J1aWxkLWZyZWVic2QnKVxuICB9XG5cbiAgLy8gRmlsdGVyIG90aGVyIHRlc3Qgam9icyBiYXNlZCBvbiB0YXJnZXRcbiAgZm9yIChjb25zdCBbam9iTmFtZSwgam9iQ29uZmlnXSBvZiBPYmplY3QuZW50cmllcyh5YW1sLmpvYnMgfHwge30pKSB7XG4gICAgaWYgKFxuICAgICAgam9iTmFtZS5zdGFydHNXaXRoKCd0ZXN0LScpICYmXG4gICAgICBqb2JOYW1lICE9PSAndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnICYmXG4gICAgICBqb2JOYW1lICE9PSAndGVzdC1saW51eC14NjQtZ251LWJpbmRpbmcnXG4gICAgKSB7XG4gICAgICAvLyBFeHRyYWN0IHRhcmdldCBmcm9tIGpvYiBuYW1lIG9yIGNvbmZpZ1xuICAgICAgY29uc3Qgam9iID0gam9iQ29uZmlnIGFzIGFueVxuICAgICAgaWYgKGpvYi5zdHJhdGVneT8ubWF0cml4Py5zZXR0aW5ncz8uWzBdPy50YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gam9iLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5nc1swXS50YXJnZXRcbiAgICAgICAgaWYgKCFlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgam9ic1RvUmVtb3ZlLnB1c2goam9iTmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBqb2JzIGZvciBkaXNhYmxlZCB0YXJnZXRzXG4gIGZvciAoY29uc3Qgam9iTmFtZSBvZiBqb2JzVG9SZW1vdmUpIHtcbiAgICBkZWxldGUgeWFtbC5qb2JzW2pvYk5hbWVdXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh5YW1sLmpvYnM/LnB1Ymxpc2g/Lm5lZWRzKSkge1xuICAgIHlhbWwuam9icy5wdWJsaXNoLm5lZWRzID0geWFtbC5qb2JzLnB1Ymxpc2gubmVlZHMuZmlsdGVyKFxuICAgICAgKG5lZWQ6IHN0cmluZykgPT4gIWpvYnNUb1JlbW92ZS5pbmNsdWRlcyhuZWVkKSxcbiAgICApXG4gIH1cblxuICAvLyBXcml0ZSBiYWNrIHRoZSBmaWx0ZXJlZCBZQU1MXG4gIGNvbnN0IHVwZGF0ZWRZYW1sID0geWFtbER1bXAoeWFtbCwge1xuICAgIGxpbmVXaWR0aDogLTEsXG4gICAgbm9SZWZzOiB0cnVlLFxuICAgIHNvcnRLZXlzOiBmYWxzZSxcbiAgfSlcbiAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGVQYXRoLCB1cGRhdGVkWWFtbClcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0aW9uczogUmF3TmV3T3B0aW9ucykge1xuICBkZWJ1ZygnUHJvY2Vzc2luZyBvcHRpb25zLi4uJylcbiAgaWYgKCFvcHRpb25zLnBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIHRoZSBwYXRoIGFzIHRoZSBhcmd1bWVudCcpXG4gIH1cbiAgb3B0aW9ucy5wYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIG9wdGlvbnMucGF0aClcbiAgZGVidWcoYFJlc29sdmVkIHRhcmdldCBwYXRoIHRvOiAke29wdGlvbnMucGF0aH1gKVxuXG4gIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgb3B0aW9ucy5uYW1lID0gcGF0aC5wYXJzZShvcHRpb25zLnBhdGgpLmJhc2VcbiAgICBkZWJ1ZyhgTm8gcHJvamVjdCBuYW1lIHByb3ZpZGVkLCBmaXggaXQgdG8gZGlyIG5hbWU6ICR7b3B0aW9ucy5uYW1lfWApXG4gIH1cblxuICBpZiAoIW9wdGlvbnMudGFyZ2V0cz8ubGVuZ3RoKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQWxsVGFyZ2V0cykge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gQVZBSUxBQkxFX1RBUkdFVFMuY29uY2F0KClcbiAgICAgIGRlYnVnKCdFbmFibGUgYWxsIHRhcmdldHMnKVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lbmFibGVEZWZhdWx0VGFyZ2V0cykge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gREVGQVVMVF9UQVJHRVRTLmNvbmNhdCgpXG4gICAgICBkZWJ1ZygnRW5hYmxlIGRlZmF1bHQgdGFyZ2V0cycpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIHRhcmdldCBtdXN0IGJlIGVuYWJsZWQnKVxuICAgIH1cbiAgfVxuICBpZiAoXG4gICAgb3B0aW9ucy50YXJnZXRzLnNvbWUoKHRhcmdldCkgPT4gdGFyZ2V0ID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcycpXG4gICkge1xuICAgIGNvbnN0IG91dCA9IGV4ZWNTeW5jKGBydXN0dXAgdGFyZ2V0IGxpc3RgLCB7XG4gICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIH0pXG4gICAgaWYgKG91dC5pbmNsdWRlcygnd2FzbTMyLXdhc2lwMS10aHJlYWRzJykpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0cyA9IG9wdGlvbnMudGFyZ2V0cy5tYXAoKHRhcmdldCkgPT5cbiAgICAgICAgdGFyZ2V0ID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcydcbiAgICAgICAgICA/ICd3YXNtMzItd2FzaXAxLXRocmVhZHMnXG4gICAgICAgICAgOiB0YXJnZXQsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMob3B0aW9ucykgYXMgTmV3T3B0aW9uc1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmV3UHJvamVjdCh1c2VyT3B0aW9uczogUmF3TmV3T3B0aW9ucykge1xuICBkZWJ1ZygnV2lsbCBjcmVhdGUgbmFwaS1ycyBwcm9qZWN0IHdpdGggZ2l2ZW4gb3B0aW9uczonKVxuICBkZWJ1Zyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zID0gcHJvY2Vzc09wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgZGVidWcoJ1RhcmdldHMgdG8gYmUgZW5hYmxlZDonKVxuICBkZWJ1ZyhvcHRpb25zLnRhcmdldHMpXG5cbiAgLy8gQ2hlY2sgaWYgZ2l0IGlzIGF2YWlsYWJsZVxuICBpZiAoIShhd2FpdCBjaGVja0dpdENvbW1hbmQoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnR2l0IGlzIG5vdCBpbnN0YWxsZWQgb3Igbm90IGF2YWlsYWJsZSBpbiBQQVRILiBQbGVhc2UgaW5zdGFsbCBHaXQgdG8gY29udGludWUuJyxcbiAgICApXG4gIH1cblxuICBjb25zdCBwYWNrYWdlTWFuYWdlciA9IG9wdGlvbnMucGFja2FnZU1hbmFnZXIgYXMgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJcblxuICAvLyBFbnN1cmUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGVtcHR5XG4gIGF3YWl0IGVuc3VyZVBhdGgob3B0aW9ucy5wYXRoLCBvcHRpb25zLmRyeVJ1bilcblxuICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERvd25sb2FkIG9yIHVwZGF0ZSB0ZW1wbGF0ZVxuICAgICAgY29uc3QgY2FjaGVEaXIgPSBhd2FpdCBlbnN1cmVDYWNoZURpcihwYWNrYWdlTWFuYWdlcilcbiAgICAgIGF3YWl0IGRvd25sb2FkVGVtcGxhdGUocGFja2FnZU1hbmFnZXIsIGNhY2hlRGlyKVxuXG4gICAgICAvLyBDb3B5IHRlbXBsYXRlIGZpbGVzIHRvIHRhcmdldCBkaXJlY3RvcnlcbiAgICAgIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihjYWNoZURpciwgJ3JlcG8nKVxuICAgICAgYXdhaXQgY29weURpcmVjdG9yeShcbiAgICAgICAgdGVtcGxhdGVQYXRoLFxuICAgICAgICBvcHRpb25zLnBhdGgsXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0cy5pbmNsdWRlcygnd2FzbTMyLXdhc2lwMS10aHJlYWRzJyksXG4gICAgICApXG5cbiAgICAgIC8vIFJlbmFtZSBwcm9qZWN0IHVzaW5nIHRoZSByZW5hbWUgQVBJXG4gICAgICBhd2FpdCByZW5hbWVQcm9qZWN0KHtcbiAgICAgICAgY3dkOiBvcHRpb25zLnBhdGgsXG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgYmluYXJ5TmFtZTogZ2V0QmluYXJ5TmFtZShvcHRpb25zLm5hbWUpLFxuICAgICAgfSlcblxuICAgICAgLy8gRmlsdGVyIHRhcmdldHMgaW4gcGFja2FnZS5qc29uXG4gICAgICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAncGFja2FnZS5qc29uJylcbiAgICAgIGlmIChleGlzdHNTeW5jKHBhY2thZ2VKc29uUGF0aCkpIHtcbiAgICAgICAgYXdhaXQgZmlsdGVyVGFyZ2V0c0luUGFja2FnZUpzb24ocGFja2FnZUpzb25QYXRoLCBvcHRpb25zLnRhcmdldHMpXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRlciB0YXJnZXRzIGluIEdpdEh1YiBBY3Rpb25zIENJXG4gICAgICBjb25zdCBjaVBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicsICd3b3JrZmxvd3MnLCAnQ0kueW1sJylcbiAgICAgIGlmIChleGlzdHNTeW5jKGNpUGF0aCkgJiYgb3B0aW9ucy5lbmFibGVHaXRodWJBY3Rpb25zKSB7XG4gICAgICAgIGF3YWl0IGZpbHRlclRhcmdldHNJbkdpdGh1YkFjdGlvbnMoY2lQYXRoLCBvcHRpb25zLnRhcmdldHMpXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAhb3B0aW9ucy5lbmFibGVHaXRodWJBY3Rpb25zICYmXG4gICAgICAgIGV4aXN0c1N5bmMocGF0aC5qb2luKG9wdGlvbnMucGF0aCwgJy5naXRodWInKSlcbiAgICAgICkge1xuICAgICAgICAvLyBSZW1vdmUgLmdpdGh1YiBkaXJlY3RvcnkgaWYgR2l0SHViIEFjdGlvbnMgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgYXdhaXQgZnMucm0ocGF0aC5qb2luKG9wdGlvbnMucGF0aCwgJy5naXRodWInKSwge1xuICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHBhY2thZ2UuanNvbiB3aXRoIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbnNcbiAgICAgIGNvbnN0IHBrZ0pzb25Db250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUocGFja2FnZUpzb25QYXRoLCAndXRmLTgnKVxuICAgICAgY29uc3QgcGtnSnNvbiA9IEpTT04ucGFyc2UocGtnSnNvbkNvbnRlbnQpXG5cbiAgICAgIC8vIFVwZGF0ZSBlbmdpbmUgcmVxdWlyZW1lbnRcbiAgICAgIGlmICghcGtnSnNvbi5lbmdpbmVzKSB7XG4gICAgICAgIHBrZ0pzb24uZW5naW5lcyA9IHt9XG4gICAgICB9XG4gICAgICBwa2dKc29uLmVuZ2luZXMubm9kZSA9IG5hcGlFbmdpbmVSZXF1aXJlbWVudChvcHRpb25zLm1pbk5vZGVBcGlWZXJzaW9uKVxuXG4gICAgICAvLyBVcGRhdGUgbGljZW5zZSBpZiBkaWZmZXJlbnQgZnJvbSB0ZW1wbGF0ZVxuICAgICAgaWYgKG9wdGlvbnMubGljZW5zZSAmJiBwa2dKc29uLmxpY2Vuc2UgIT09IG9wdGlvbnMubGljZW5zZSkge1xuICAgICAgICBwa2dKc29uLmxpY2Vuc2UgPSBvcHRpb25zLmxpY2Vuc2VcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRlc3QgZnJhbWV3b3JrIGlmIG5lZWRlZFxuICAgICAgaWYgKG9wdGlvbnMudGVzdEZyYW1ld29yayAhPT0gJ2F2YScpIHtcbiAgICAgICAgLy8gVGhpcyB3b3VsZCByZXF1aXJlIG1vcmUgY29tcGxleCBsb2dpYyB0byB1cGRhdGUgdGVzdCBzY3JpcHRzIGFuZCBkZXBlbmRlbmNpZXNcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgYFRlc3QgZnJhbWV3b3JrICR7b3B0aW9ucy50ZXN0RnJhbWV3b3JrfSByZXF1ZXN0ZWQgYnV0IG5vdCB5ZXQgaW1wbGVtZW50ZWRgLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShcbiAgICAgICAgcGFja2FnZUpzb25QYXRoLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShwa2dKc29uLCBudWxsLCAyKSArICdcXG4nLFxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcHJvamVjdDogJHtlcnJvcn1gKVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKGBQcm9qZWN0IGNyZWF0ZWQgYXQ6ICR7b3B0aW9ucy5wYXRofWApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZVBhdGgocGF0aDogc3RyaW5nLCBkcnlSdW4gPSBmYWxzZSkge1xuICBjb25zdCBzdGF0ID0gYXdhaXQgc3RhdEFzeW5jKHBhdGgsIHt9KS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpXG5cbiAgLy8gZmlsZSBkZXNjcmlwdG9yIGV4aXN0c1xuICBpZiAoc3RhdCkge1xuICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQYXRoICR7cGF0aH0gZm9yIGNyZWF0aW5nIG5ldyBuYXBpLXJzIHByb2plY3QgYWxyZWFkeSBleGlzdHMgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LmAsXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHBhdGgpXG4gICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUGF0aCAke3BhdGh9IGZvciBjcmVhdGluZyBuZXcgbmFwaS1ycyBwcm9qZWN0IGFscmVhZHkgZXhpc3RzIGFuZCBpdCdzIG5vdCBlbXB0eS5gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFkcnlSdW4pIHtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYFRyeSB0byBjcmVhdGUgdGFyZ2V0IGRpcmVjdG9yeTogJHtwYXRofWApXG4gICAgICBpZiAoIWRyeVJ1bikge1xuICAgICAgICBhd2FpdCBta2RpckFzeW5jKHBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHRhcmdldCBkaXJlY3Rvcnk6ICR7cGF0aH1gLCB7XG4gICAgICAgIGNhdXNlOiBlLFxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbmFtZS5zcGxpdCgnLycpLnBvcCgpIVxufVxuXG5leHBvcnQgeyBOZXdPcHRpb25zIH1cbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtcbiAgICAgIHByb2Nlc3MuYXJjaFxuICAgIH0pYDtcbiAgfVxuXG4gIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG4iLCIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHN0YXRlLCBuYW1lLCBtZXRob2QsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCBmb3IgYmVmb3JlIGhvb2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZS5yZXZlcnNlKCkucmVkdWNlKChjYWxsYmFjaywgbmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyLmJpbmQobnVsbCwgc3RhdGUsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LCBtZXRob2QpKCk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5yZWdpc3RyeVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG1ldGhvZChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUucmVnaXN0cnlbbmFtZV0ucmVkdWNlKChtZXRob2QsIHJlZ2lzdGVyZWQpID0+IHtcbiAgICAgIHJldHVybiByZWdpc3RlcmVkLmhvb2suYmluZChudWxsLCBtZXRob2QsIG9wdGlvbnMpO1xuICAgIH0sIG1ldGhvZCkoKTtcbiAgfSk7XG59XG4iLCIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhvb2soc3RhdGUsIGtpbmQsIG5hbWUsIGhvb2spIHtcbiAgY29uc3Qgb3JpZyA9IGhvb2s7XG4gIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICBzdGF0ZS5yZWdpc3RyeVtuYW1lXSA9IFtdO1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiYmVmb3JlXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG9yaWcuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJhZnRlclwiKSB7XG4gICAgaG9vayA9IChtZXRob2QsIG9wdGlvbnMpID0+IHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKChyZXN1bHRfKSA9PiB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0XztcbiAgICAgICAgICByZXR1cm4gb3JpZyhyZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImVycm9yXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9yaWcoZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGUucmVnaXN0cnlbbmFtZV0ucHVzaCh7XG4gICAgaG9vazogaG9vayxcbiAgICBvcmlnOiBvcmlnLFxuICB9KTtcbn1cbiIsIi8vIEB0cy1jaGVja1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSG9vayhzdGF0ZSwgbmFtZSwgbWV0aG9kKSB7XG4gIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpbmRleCA9IHN0YXRlLnJlZ2lzdHJ5W25hbWVdXG4gICAgLm1hcCgocmVnaXN0ZXJlZCkgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQub3JpZztcbiAgICB9KVxuICAgIC5pbmRleE9mKG1ldGhvZCk7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLnJlZ2lzdHJ5W25hbWVdLnNwbGljZShpbmRleCwgMSk7XG59XG4iLCIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tIFwiLi9saWIvcmVnaXN0ZXIuanNcIjtcbmltcG9ydCB7IGFkZEhvb2sgfSBmcm9tIFwiLi9saWIvYWRkLmpzXCI7XG5pbXBvcnQgeyByZW1vdmVIb29rIH0gZnJvbSBcIi4vbGliL3JlbW92ZS5qc1wiO1xuXG4vLyBiaW5kIHdpdGggYXJyYXkgb2YgYXJndW1lbnRzOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjE3OTI5MTNcbmNvbnN0IGJpbmQgPSBGdW5jdGlvbi5iaW5kO1xuY29uc3QgYmluZGFibGUgPSBiaW5kLmJpbmQoYmluZCk7XG5cbmZ1bmN0aW9uIGJpbmRBcGkoaG9vaywgc3RhdGUsIG5hbWUpIHtcbiAgY29uc3QgcmVtb3ZlSG9va1JlZiA9IGJpbmRhYmxlKHJlbW92ZUhvb2ssIG51bGwpLmFwcGx5KFxuICAgIG51bGwsXG4gICAgbmFtZSA/IFtzdGF0ZSwgbmFtZV0gOiBbc3RhdGVdXG4gICk7XG4gIGhvb2suYXBpID0geyByZW1vdmU6IHJlbW92ZUhvb2tSZWYgfTtcbiAgaG9vay5yZW1vdmUgPSByZW1vdmVIb29rUmVmO1xuICBbXCJiZWZvcmVcIiwgXCJlcnJvclwiLCBcImFmdGVyXCIsIFwid3JhcFwiXS5mb3JFYWNoKChraW5kKSA9PiB7XG4gICAgY29uc3QgYXJncyA9IG5hbWUgPyBbc3RhdGUsIGtpbmQsIG5hbWVdIDogW3N0YXRlLCBraW5kXTtcbiAgICBob29rW2tpbmRdID0gaG9vay5hcGlba2luZF0gPSBiaW5kYWJsZShhZGRIb29rLCBudWxsKS5hcHBseShudWxsLCBhcmdzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIFNpbmd1bGFyKCkge1xuICBjb25zdCBzaW5ndWxhckhvb2tOYW1lID0gU3ltYm9sKFwiU2luZ3VsYXJcIik7XG4gIGNvbnN0IHNpbmd1bGFySG9va1N0YXRlID0ge1xuICAgIHJlZ2lzdHJ5OiB7fSxcbiAgfTtcbiAgY29uc3Qgc2luZ3VsYXJIb29rID0gcmVnaXN0ZXIuYmluZChudWxsLCBzaW5ndWxhckhvb2tTdGF0ZSwgc2luZ3VsYXJIb29rTmFtZSk7XG4gIGJpbmRBcGkoc2luZ3VsYXJIb29rLCBzaW5ndWxhckhvb2tTdGF0ZSwgc2luZ3VsYXJIb29rTmFtZSk7XG4gIHJldHVybiBzaW5ndWxhckhvb2s7XG59XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24oKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHJlZ2lzdHJ5OiB7fSxcbiAgfTtcblxuICBjb25zdCBob29rID0gcmVnaXN0ZXIuYmluZChudWxsLCBzdGF0ZSk7XG4gIGJpbmRBcGkoaG9vaywgc3RhdGUpO1xuXG4gIHJldHVybiBob29rO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IFNpbmd1bGFyLCBDb2xsZWN0aW9uIH07XG4iLCIvLyBwa2cvZGlzdC1zcmMvZGVmYXVsdHMuanNcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9kZWZhdWx0cy5qc1xudmFyIHVzZXJBZ2VudCA9IGBvY3Rva2l0LWVuZHBvaW50LmpzLyR7VkVSU0lPTn0gJHtnZXRVc2VyQWdlbnQoKX1gO1xudmFyIERFRkFVTFRTID0ge1xuICBtZXRob2Q6IFwiR0VUXCIsXG4gIGJhc2VVcmw6IFwiaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbVwiLFxuICBoZWFkZXJzOiB7XG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMranNvblwiLFxuICAgIFwidXNlci1hZ2VudFwiOiB1c2VyQWdlbnRcbiAgfSxcbiAgbWVkaWFUeXBlOiB7XG4gICAgZm9ybWF0OiBcIlwiXG4gIH1cbn07XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL2xvd2VyY2FzZS1rZXlzLmpzXG5mdW5jdGlvbiBsb3dlcmNhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5yZWR1Y2UoKG5ld09iaiwga2V5KSA9PiB7XG4gICAgbmV3T2JqW2tleS50b0xvd2VyQ2FzZSgpXSA9IG9iamVjdFtrZXldO1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH0sIHt9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvaXMtcGxhaW4tb2JqZWN0LmpzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHJldHVybiB0cnVlO1xuICBjb25zdCBDdG9yID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbChDdG9yKSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwodmFsdWUpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9tZXJnZS1kZWVwLmpzXG5mdW5jdGlvbiBtZXJnZURlZXAoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zW2tleV0pKSB7XG4gICAgICBpZiAoIShrZXkgaW4gZGVmYXVsdHMpKSBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBba2V5XTogb3B0aW9uc1trZXldIH0pO1xuICAgICAgZWxzZSByZXN1bHRba2V5XSA9IG1lcmdlRGVlcChkZWZhdWx0c1trZXldLCBvcHRpb25zW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBba2V5XTogb3B0aW9uc1trZXldIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL3JlbW92ZS11bmRlZmluZWQtcHJvcGVydGllcy5qc1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL21lcmdlLmpzXG5mdW5jdGlvbiBtZXJnZShkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiByb3V0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxldCBbbWV0aG9kLCB1cmxdID0gcm91dGUuc3BsaXQoXCIgXCIpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHVybCA/IHsgbWV0aG9kLCB1cmwgfSA6IHsgdXJsOiBtZXRob2QgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlKTtcbiAgfVxuICBvcHRpb25zLmhlYWRlcnMgPSBsb3dlcmNhc2VLZXlzKG9wdGlvbnMuaGVhZGVycyk7XG4gIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob3B0aW9ucyk7XG4gIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IG1lcmdlRGVlcChkZWZhdWx0cyB8fCB7fSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLnVybCA9PT0gXCIvZ3JhcGhxbFwiKSB7XG4gICAgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLm1lZGlhVHlwZS5wcmV2aWV3cz8ubGVuZ3RoKSB7XG4gICAgICBtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyA9IGRlZmF1bHRzLm1lZGlhVHlwZS5wcmV2aWV3cy5maWx0ZXIoXG4gICAgICAgIChwcmV2aWV3KSA9PiAhbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MuaW5jbHVkZXMocHJldmlldylcbiAgICAgICkuY29uY2F0KG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzKTtcbiAgICB9XG4gICAgbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MgPSAobWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MgfHwgW10pLm1hcCgocHJldmlldykgPT4gcHJldmlldy5yZXBsYWNlKC8tcHJldmlldy8sIFwiXCIpKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkT3B0aW9ucztcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvYWRkLXF1ZXJ5LXBhcmFtZXRlcnMuanNcbmZ1bmN0aW9uIGFkZFF1ZXJ5UGFyYW1ldGVycyh1cmwsIHBhcmFtZXRlcnMpIHtcbiAgY29uc3Qgc2VwYXJhdG9yID0gL1xcPy8udGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIjtcbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKTtcbiAgaWYgKG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgcmV0dXJuIHVybCArIHNlcGFyYXRvciArIG5hbWVzLm1hcCgobmFtZSkgPT4ge1xuICAgIGlmIChuYW1lID09PSBcInFcIikge1xuICAgICAgcmV0dXJuIFwicT1cIiArIHBhcmFtZXRlcnMucS5zcGxpdChcIitcIikubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbihcIitcIik7XG4gICAgfVxuICAgIHJldHVybiBgJHtuYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJzW25hbWVdKX1gO1xuICB9KS5qb2luKFwiJlwiKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvZXh0cmFjdC11cmwtdmFyaWFibGUtbmFtZXMuanNcbnZhciB1cmxWYXJpYWJsZVJlZ2V4ID0gL1xce1tee319XStcXH0vZztcbmZ1bmN0aW9uIHJlbW92ZU5vbkNoYXJzKHZhcmlhYmxlTmFtZSkge1xuICByZXR1cm4gdmFyaWFibGVOYW1lLnJlcGxhY2UoLyg/Ol5cXFcrKXwoPzooPzwhXFxXKVxcVyskKS9nLCBcIlwiKS5zcGxpdCgvLC8pO1xufVxuZnVuY3Rpb24gZXh0cmFjdFVybFZhcmlhYmxlTmFtZXModXJsKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSB1cmwubWF0Y2godXJsVmFyaWFibGVSZWdleCk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5tYXAocmVtb3ZlTm9uQ2hhcnMpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvb21pdC5qc1xuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXNUb09taXQpIHtcbiAgY29uc3QgcmVzdWx0ID0geyBfX3Byb3RvX186IG51bGwgfTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqZWN0KSkge1xuICAgIGlmIChrZXlzVG9PbWl0LmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL3VybC10ZW1wbGF0ZS5qc1xuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoLyglWzAtOUEtRmEtZl17Mn0pL2cpLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgaWYgKCEvJVswLTlBLUZhLWZdLy50ZXN0KHBhcnQpKSB7XG4gICAgICBwYXJ0ID0gZW5jb2RlVVJJKHBhcnQpLnJlcGxhY2UoLyU1Qi9nLCBcIltcIikucmVwbGFjZSgvJTVEL2csIFwiXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnQ7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBlbmNvZGVVbnJlc2VydmVkKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqXS9nLCBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiJVwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwga2V5KSB7XG4gIHZhbHVlID0gb3BlcmF0b3IgPT09IFwiK1wiIHx8IG9wZXJhdG9yID09PSBcIiNcIiA/IGVuY29kZVJlc2VydmVkKHZhbHVlKSA6IGVuY29kZVVucmVzZXJ2ZWQodmFsdWUpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIGVuY29kZVVucmVzZXJ2ZWQoa2V5KSArIFwiPVwiICsgdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCI7XCIgfHwgb3BlcmF0b3IgPT09IFwiJlwiIHx8IG9wZXJhdG9yID09PSBcIj9cIjtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwga2V5LCBtb2RpZmllcikge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0W2tleV0sIHJlc3VsdCA9IFtdO1xuICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtb2RpZmllciAmJiBtb2RpZmllciAhPT0gXCIqXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgcGFyc2VJbnQobW9kaWZpZXIsIDEwKSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IFwiXCIpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlMiwgaXNLZXlPcGVyYXRvcihvcGVyYXRvcikgPyBrZXkgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10sIGspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdG1wID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICB0bXAucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVW5yZXNlcnZlZChrKSk7XG4gICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIgKyB0bXAuam9pbihcIixcIikpO1xuICAgICAgICB9IGVsc2UgaWYgKHRtcC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChvcGVyYXRvciA9PT0gXCI7XCIpIHtcbiAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoa2V5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcIiAmJiAob3BlcmF0b3IgPT09IFwiJlwiIHx8IG9wZXJhdG9yID09PSBcIj9cIikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoa2V5KSArIFwiPVwiKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICByZXN1bHQucHVzaChcIlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVXJsKHRlbXBsYXRlKSB7XG4gIHJldHVybiB7XG4gICAgZXhwYW5kOiBleHBhbmQuYmluZChudWxsLCB0ZW1wbGF0ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cGFuZCh0ZW1wbGF0ZSwgY29udGV4dCkge1xuICB2YXIgb3BlcmF0b3JzID0gW1wiK1wiLCBcIiNcIiwgXCIuXCIsIFwiL1wiLCBcIjtcIiwgXCI/XCIsIFwiJlwiXTtcbiAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKFxuICAgIC9cXHsoW15cXHtcXH1dKylcXH18KFteXFx7XFx9XSspL2csXG4gICAgZnVuY3Rpb24oXywgZXhwcmVzc2lvbiwgbGl0ZXJhbCkge1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgbGV0IG9wZXJhdG9yID0gXCJcIjtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihleHByZXNzaW9uLmNoYXJBdCgwKSkgIT09IC0xKSB7XG4gICAgICAgICAgb3BlcmF0b3IgPSBleHByZXNzaW9uLmNoYXJBdCgwKTtcbiAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwcmVzc2lvbi5zcGxpdCgvLC9nKS5mb3JFYWNoKGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IC8oW146XFwqXSopKD86OihcXGQrKXwoXFwqKSk/Ly5leGVjKHZhcmlhYmxlKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIHRtcFsxXSwgdG1wWzJdIHx8IHRtcFszXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wZXJhdG9yICYmIG9wZXJhdG9yICE9PSBcIitcIikge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBcIixcIjtcbiAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBcIiZcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSBcIiNcIikge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAodmFsdWVzLmxlbmd0aCAhPT0gMCA/IG9wZXJhdG9yIDogXCJcIikgKyB2YWx1ZXMuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXMuam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVSZXNlcnZlZChsaXRlcmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmICh0ZW1wbGF0ZSA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxufVxuXG4vLyBwa2cvZGlzdC1zcmMvcGFyc2UuanNcbmZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMpIHtcbiAgbGV0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIGxldCB1cmwgPSAob3B0aW9ucy51cmwgfHwgXCIvXCIpLnJlcGxhY2UoLzooW2Etel1cXHcrKS9nLCBcInskMX1cIik7XG4gIGxldCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgbGV0IGJvZHk7XG4gIGxldCBwYXJhbWV0ZXJzID0gb21pdChvcHRpb25zLCBbXG4gICAgXCJtZXRob2RcIixcbiAgICBcImJhc2VVcmxcIixcbiAgICBcInVybFwiLFxuICAgIFwiaGVhZGVyc1wiLFxuICAgIFwicmVxdWVzdFwiLFxuICAgIFwibWVkaWFUeXBlXCJcbiAgXSk7XG4gIGNvbnN0IHVybFZhcmlhYmxlTmFtZXMgPSBleHRyYWN0VXJsVmFyaWFibGVOYW1lcyh1cmwpO1xuICB1cmwgPSBwYXJzZVVybCh1cmwpLmV4cGFuZChwYXJhbWV0ZXJzKTtcbiAgaWYgKCEvXmh0dHAvLnRlc3QodXJsKSkge1xuICAgIHVybCA9IG9wdGlvbnMuYmFzZVVybCArIHVybDtcbiAgfVxuICBjb25zdCBvbWl0dGVkUGFyYW1ldGVycyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigob3B0aW9uKSA9PiB1cmxWYXJpYWJsZU5hbWVzLmluY2x1ZGVzKG9wdGlvbikpLmNvbmNhdChcImJhc2VVcmxcIik7XG4gIGNvbnN0IHJlbWFpbmluZ1BhcmFtZXRlcnMgPSBvbWl0KHBhcmFtZXRlcnMsIG9taXR0ZWRQYXJhbWV0ZXJzKTtcbiAgY29uc3QgaXNCaW5hcnlSZXF1ZXN0ID0gL2FwcGxpY2F0aW9uXFwvb2N0ZXQtc3RyZWFtL2kudGVzdChoZWFkZXJzLmFjY2VwdCk7XG4gIGlmICghaXNCaW5hcnlSZXF1ZXN0KSB7XG4gICAgaWYgKG9wdGlvbnMubWVkaWFUeXBlLmZvcm1hdCkge1xuICAgICAgaGVhZGVycy5hY2NlcHQgPSBoZWFkZXJzLmFjY2VwdC5zcGxpdCgvLC8pLm1hcChcbiAgICAgICAgKGZvcm1hdCkgPT4gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgL2FwcGxpY2F0aW9uXFwvdm5kKFxcLlxcdyspKFxcLnYzKT8oXFwuXFx3Kyk/KFxcK2pzb24pPyQvLFxuICAgICAgICAgIGBhcHBsaWNhdGlvbi92bmQkMSQyLiR7b3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0fWBcbiAgICAgICAgKVxuICAgICAgKS5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgaWYgKHVybC5lbmRzV2l0aChcIi9ncmFwaHFsXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3M/Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwcmV2aWV3c0Zyb21BY2NlcHRIZWFkZXIgPSBoZWFkZXJzLmFjY2VwdC5tYXRjaCgvKD88IVtcXHctXSlbXFx3LV0rKD89LXByZXZpZXcpL2cpIHx8IFtdO1xuICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlci5jb25jYXQob3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpLm1hcCgocHJldmlldykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMubWVkaWFUeXBlLmZvcm1hdCA/IGAuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YCA6IFwiK2pzb25cIjtcbiAgICAgICAgICByZXR1cm4gYGFwcGxpY2F0aW9uL3ZuZC5naXRodWIuJHtwcmV2aWV3fS1wcmV2aWV3JHtmb3JtYXR9YDtcbiAgICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChbXCJHRVRcIiwgXCJIRUFEXCJdLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICB1cmwgPSBhZGRRdWVyeVBhcmFtZXRlcnModXJsLCByZW1haW5pbmdQYXJhbWV0ZXJzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXCJkYXRhXCIgaW4gcmVtYWluaW5nUGFyYW1ldGVycykge1xuICAgICAgYm9keSA9IHJlbWFpbmluZ1BhcmFtZXRlcnMuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHJlbWFpbmluZ1BhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgICAgICBib2R5ID0gcmVtYWluaW5nUGFyYW1ldGVycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFoZWFkZXJzW1wiY29udGVudC10eXBlXCJdICYmIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiO1xuICB9XG4gIGlmIChbXCJQQVRDSFwiLCBcIlBVVFwiXS5pbmNsdWRlcyhtZXRob2QpICYmIHR5cGVvZiBib2R5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYm9keSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgeyBtZXRob2QsIHVybCwgaGVhZGVycyB9LFxuICAgIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiID8geyBib2R5IH0gOiBudWxsLFxuICAgIG9wdGlvbnMucmVxdWVzdCA/IHsgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0IH0gOiBudWxsXG4gICk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9lbmRwb2ludC13aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiBlbmRwb2ludFdpdGhEZWZhdWx0cyhkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBhcnNlKG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZERlZmF1bHRzLCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBERUZBVUxUUzIgPSBtZXJnZShvbGREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICBjb25zdCBlbmRwb2ludDIgPSBlbmRwb2ludFdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGVuZHBvaW50Miwge1xuICAgIERFRkFVTFRTOiBERUZBVUxUUzIsXG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMiksXG4gICAgbWVyZ2U6IG1lcmdlLmJpbmQobnVsbCwgREVGQVVMVFMyKSxcbiAgICBwYXJzZVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgZW5kcG9pbnQgPSB3aXRoRGVmYXVsdHMobnVsbCwgREVGQVVMVFMpO1xuZXhwb3J0IHtcbiAgZW5kcG9pbnRcbn07XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgTnVsbE9iamVjdCA9IGZ1bmN0aW9uIE51bGxPYmplY3QgKCkgeyB9XG5OdWxsT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggKiggXCI7XCIgcGFyYW1ldGVyICkgaW4gUkZDIDcyMzEgc2VjIDMuMS4xLjFcbiAqXG4gKiBwYXJhbWV0ZXIgICAgID0gdG9rZW4gXCI9XCIgKCB0b2tlbiAvIHF1b3RlZC1zdHJpbmcgKVxuICogdG9rZW4gICAgICAgICA9IDEqdGNoYXJcbiAqIHRjaGFyICAgICAgICAgPSBcIiFcIiAvIFwiI1wiIC8gXCIkXCIgLyBcIiVcIiAvIFwiJlwiIC8gXCInXCIgLyBcIipcIlxuICogICAgICAgICAgICAgICAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiAvIFwiXlwiIC8gXCJfXCIgLyBcImBcIiAvIFwifFwiIC8gXCJ+XCJcbiAqICAgICAgICAgICAgICAgLyBESUdJVCAvIEFMUEhBXG4gKiAgICAgICAgICAgICAgIDsgYW55IFZDSEFSLCBleGNlcHQgZGVsaW1pdGVyc1xuICogcXVvdGVkLXN0cmluZyA9IERRVU9URSAqKCBxZHRleHQgLyBxdW90ZWQtcGFpciApIERRVU9URVxuICogcWR0ZXh0ICAgICAgICA9IEhUQUIgLyBTUCAvICV4MjEgLyAleDIzLTVCIC8gJXg1RC03RSAvIG9icy10ZXh0XG4gKiBvYnMtdGV4dCAgICAgID0gJXg4MC1GRlxuICogcXVvdGVkLXBhaXIgICA9IFwiXFxcIiAoIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVxuICovXG5jb25zdCBwYXJhbVJFID0gLzsgKihbISMkJSYnKisuXlxcd2B8fi1dKyk9KFwiKD86W1xcdlxcdTAwMjBcXHUwMDIxXFx1MDAyMy1cXHUwMDViXFx1MDA1ZC1cXHUwMDdlXFx1MDA4MC1cXHUwMGZmXXxcXFxcW1xcdlxcdTAwMjAtXFx1MDBmZl0pKlwifFshIyQlJicqKy5eXFx3YHx+LV0rKSAqL2d1XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHF1b3RlZC1wYWlyIGluIFJGQyA3MjMwIHNlYyAzLjIuNlxuICpcbiAqIHF1b3RlZC1wYWlyID0gXCJcXFwiICggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gKiBvYnMtdGV4dCAgICA9ICV4ODAtRkZcbiAqL1xuY29uc3QgcXVvdGVkUGFpclJFID0gL1xcXFwoW1xcdlxcdTAwMjAtXFx1MDBmZl0pL2d1XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHR5cGUgaW4gUkZDIDcyMzEgc2VjIDMuMS4xLjFcbiAqXG4gKiBtZWRpYS10eXBlID0gdHlwZSBcIi9cIiBzdWJ0eXBlXG4gKiB0eXBlICAgICAgID0gdG9rZW5cbiAqIHN1YnR5cGUgICAgPSB0b2tlblxuICovXG5jb25zdCBtZWRpYVR5cGVSRSA9IC9eWyEjJCUmJyorLl5cXHd8fi1dK1xcL1shIyQlJicqKy5eXFx3fH4tXSskL3VcblxuLy8gZGVmYXVsdCBDb250ZW50VHlwZSB0byBwcmV2ZW50IHJlcGVhdGVkIG9iamVjdCBjcmVhdGlvblxuY29uc3QgZGVmYXVsdENvbnRlbnRUeXBlID0geyB0eXBlOiAnJywgcGFyYW1ldGVyczogbmV3IE51bGxPYmplY3QoKSB9XG5PYmplY3QuZnJlZXplKGRlZmF1bHRDb250ZW50VHlwZS5wYXJhbWV0ZXJzKVxuT2JqZWN0LmZyZWV6ZShkZWZhdWx0Q29udGVudFR5cGUpXG5cbi8qKlxuICogUGFyc2UgbWVkaWEgdHlwZSB0byBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZSAoaGVhZGVyKSB7XG4gIGlmICh0eXBlb2YgaGVhZGVyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGhlYWRlciBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycpXG4gIH1cblxuICBsZXQgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOycpXG4gIGNvbnN0IHR5cGUgPSBpbmRleCAhPT0gLTFcbiAgICA/IGhlYWRlci5zbGljZSgwLCBpbmRleCkudHJpbSgpXG4gICAgOiBoZWFkZXIudHJpbSgpXG5cbiAgaWYgKG1lZGlhVHlwZVJFLnRlc3QodHlwZSkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBtZWRpYSB0eXBlJylcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0eXBlOiB0eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgcGFyYW1ldGVyczogbmV3IE51bGxPYmplY3QoKVxuICB9XG5cbiAgLy8gcGFyc2UgcGFyYW1ldGVyc1xuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbGV0IGtleVxuICBsZXQgbWF0Y2hcbiAgbGV0IHZhbHVlXG5cbiAgcGFyYW1SRS5sYXN0SW5kZXggPSBpbmRleFxuXG4gIHdoaWxlICgobWF0Y2ggPSBwYXJhbVJFLmV4ZWMoaGVhZGVyKSkpIHtcbiAgICBpZiAobWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBmb3JtYXQnKVxuICAgIH1cblxuICAgIGluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aFxuICAgIGtleSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKClcbiAgICB2YWx1ZSA9IG1hdGNoWzJdXG5cbiAgICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICAgIC8vIHJlbW92ZSBxdW90ZXMgYW5kIGVzY2FwZXNcbiAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgLnNsaWNlKDEsIHZhbHVlLmxlbmd0aCAtIDEpXG5cbiAgICAgIHF1b3RlZFBhaXJSRS50ZXN0KHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHF1b3RlZFBhaXJSRSwgJyQxJykpXG4gICAgfVxuXG4gICAgcmVzdWx0LnBhcmFtZXRlcnNba2V5XSA9IHZhbHVlXG4gIH1cblxuICBpZiAoaW5kZXggIT09IGhlYWRlci5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBmb3JtYXQnKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBzYWZlUGFyc2UgKGhlYWRlcikge1xuICBpZiAodHlwZW9mIGhlYWRlciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVmYXVsdENvbnRlbnRUeXBlXG4gIH1cblxuICBsZXQgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOycpXG4gIGNvbnN0IHR5cGUgPSBpbmRleCAhPT0gLTFcbiAgICA/IGhlYWRlci5zbGljZSgwLCBpbmRleCkudHJpbSgpXG4gICAgOiBoZWFkZXIudHJpbSgpXG5cbiAgaWYgKG1lZGlhVHlwZVJFLnRlc3QodHlwZSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDb250ZW50VHlwZVxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHR5cGU6IHR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICBwYXJhbWV0ZXJzOiBuZXcgTnVsbE9iamVjdCgpXG4gIH1cblxuICAvLyBwYXJzZSBwYXJhbWV0ZXJzXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBsZXQga2V5XG4gIGxldCBtYXRjaFxuICBsZXQgdmFsdWVcblxuICBwYXJhbVJFLmxhc3RJbmRleCA9IGluZGV4XG5cbiAgd2hpbGUgKChtYXRjaCA9IHBhcmFtUkUuZXhlYyhoZWFkZXIpKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Q29udGVudFR5cGVcbiAgICB9XG5cbiAgICBpbmRleCArPSBtYXRjaFswXS5sZW5ndGhcbiAgICBrZXkgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG4gICAgdmFsdWUgPSBtYXRjaFsyXVxuXG4gICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICAvLyByZW1vdmUgcXVvdGVzIGFuZCBlc2NhcGVzXG4gICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgIC5zbGljZSgxLCB2YWx1ZS5sZW5ndGggLSAxKVxuXG4gICAgICBxdW90ZWRQYWlyUkUudGVzdCh2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUucmVwbGFjZShxdW90ZWRQYWlyUkUsICckMScpKVxuICAgIH1cblxuICAgIHJlc3VsdC5wYXJhbWV0ZXJzW2tleV0gPSB2YWx1ZVxuICB9XG5cbiAgaWYgKGluZGV4ICE9PSBoZWFkZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDb250ZW50VHlwZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0geyBwYXJzZSwgc2FmZVBhcnNlIH1cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLnNhZmVQYXJzZSA9IHNhZmVQYXJzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdENvbnRlbnRUeXBlID0gZGVmYXVsdENvbnRlbnRUeXBlXG4iLCJjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIC8qKlxuICAgKiBodHRwIHN0YXR1cyBjb2RlXG4gICAqL1xuICBzdGF0dXM7XG4gIC8qKlxuICAgKiBSZXF1ZXN0IG9wdGlvbnMgdGhhdCBsZWFkIHRvIHRoZSBlcnJvci5cbiAgICovXG4gIHJlcXVlc3Q7XG4gIC8qKlxuICAgKiBSZXNwb25zZSBvYmplY3QgaWYgYSByZXNwb25zZSB3YXMgcmVjZWl2ZWRcbiAgICovXG4gIHJlc3BvbnNlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJIdHRwRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IE51bWJlci5wYXJzZUludChzdGF0dXNDb2RlKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRoaXMuc3RhdHVzKSkge1xuICAgICAgdGhpcy5zdGF0dXMgPSAwO1xuICAgIH1cbiAgICBpZiAoXCJyZXNwb25zZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdCk7XG4gICAgaWYgKG9wdGlvbnMucmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIHJlcXVlc3RDb3B5LmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QuaGVhZGVycywge1xuICAgICAgICBhdXRob3JpemF0aW9uOiBvcHRpb25zLnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uLnJlcGxhY2UoXG4gICAgICAgICAgLyg/PCEgKSAuKiQvLFxuICAgICAgICAgIFwiIFtSRURBQ1RFRF1cIlxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdENvcHkudXJsID0gcmVxdWVzdENvcHkudXJsLnJlcGxhY2UoL1xcYmNsaWVudF9zZWNyZXQ9XFx3Ky9nLCBcImNsaWVudF9zZWNyZXQ9W1JFREFDVEVEXVwiKS5yZXBsYWNlKC9cXGJhY2Nlc3NfdG9rZW49XFx3Ky9nLCBcImFjY2Vzc190b2tlbj1bUkVEQUNURURdXCIpO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RDb3B5O1xuICB9XG59XG5leHBvcnQge1xuICBSZXF1ZXN0RXJyb3Jcbn07XG4iLCIvLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbmltcG9ydCB7IGVuZHBvaW50IH0gZnJvbSBcIkBvY3Rva2l0L2VuZHBvaW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9kZWZhdWx0cy5qc1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSBcInVuaXZlcnNhbC11c2VyLWFnZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTiA9IFwiMTAuMC4zXCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9kZWZhdWx0cy5qc1xudmFyIGRlZmF1bHRzX2RlZmF1bHQgPSB7XG4gIGhlYWRlcnM6IHtcbiAgICBcInVzZXItYWdlbnRcIjogYG9jdG9raXQtcmVxdWVzdC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YFxuICB9XG59O1xuXG4vLyBwa2cvZGlzdC1zcmMvZmV0Y2gtd3JhcHBlci5qc1xuaW1wb3J0IHsgc2FmZVBhcnNlIH0gZnJvbSBcImZhc3QtY29udGVudC10eXBlLXBhcnNlXCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9pcy1wbGFpbi1vYmplY3QuanNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKEN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9mZXRjaC13cmFwcGVyLmpzXG5pbXBvcnQgeyBSZXF1ZXN0RXJyb3IgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdC1lcnJvclwiO1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXcmFwcGVyKHJlcXVlc3RPcHRpb25zKSB7XG4gIGNvbnN0IGZldGNoID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8uZmV0Y2ggfHwgZ2xvYmFsVGhpcy5mZXRjaDtcbiAgaWYgKCFmZXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiZmV0Y2ggaXMgbm90IHNldC4gUGxlYXNlIHBhc3MgYSBmZXRjaCBpbXBsZW1lbnRhdGlvbiBhcyBuZXcgT2N0b2tpdCh7IHJlcXVlc3Q6IHsgZmV0Y2ggfX0pLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3Rva2l0L29jdG9raXQuanMvI2ZldGNoLW1pc3NpbmdcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgbG9nID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8ubG9nIHx8IGNvbnNvbGU7XG4gIGNvbnN0IHBhcnNlU3VjY2Vzc1Jlc3BvbnNlQm9keSA9IHJlcXVlc3RPcHRpb25zLnJlcXVlc3Q/LnBhcnNlU3VjY2Vzc1Jlc3BvbnNlQm9keSAhPT0gZmFsc2U7XG4gIGNvbnN0IGJvZHkgPSBpc1BsYWluT2JqZWN0KHJlcXVlc3RPcHRpb25zLmJvZHkpIHx8IEFycmF5LmlzQXJyYXkocmVxdWVzdE9wdGlvbnMuYm9keSkgPyBKU09OLnN0cmluZ2lmeShyZXF1ZXN0T3B0aW9ucy5ib2R5KSA6IHJlcXVlc3RPcHRpb25zLmJvZHk7XG4gIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RPcHRpb25zLmhlYWRlcnMpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW1xuICAgICAgbmFtZSxcbiAgICAgIFN0cmluZyh2YWx1ZSlcbiAgICBdKVxuICApO1xuICBsZXQgZmV0Y2hSZXNwb25zZTtcbiAgdHJ5IHtcbiAgICBmZXRjaFJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdE9wdGlvbnMudXJsLCB7XG4gICAgICBtZXRob2Q6IHJlcXVlc3RPcHRpb25zLm1ldGhvZCxcbiAgICAgIGJvZHksXG4gICAgICByZWRpcmVjdDogcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8ucmVkaXJlY3QsXG4gICAgICBoZWFkZXJzOiByZXF1ZXN0SGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8uc2lnbmFsLFxuICAgICAgLy8gZHVwbGV4IG11c3QgYmUgc2V0IGlmIHJlcXVlc3QuYm9keSBpcyBSZWFkYWJsZVN0cmVhbSBvciBBc3luYyBJdGVyYWJsZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0aW5pdC1kdXBsZXguXG4gICAgICAuLi5yZXF1ZXN0T3B0aW9ucy5ib2R5ICYmIHsgZHVwbGV4OiBcImhhbGZcIiB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBcIlVua25vd24gRXJyb3JcIjtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIGVycm9yLnN0YXR1cyA9IDUwMDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIlR5cGVFcnJvclwiICYmIFwiY2F1c2VcIiBpbiBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZS5tZXNzYWdlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvci5jYXVzZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0RXJyb3IgPSBuZXcgUmVxdWVzdEVycm9yKG1lc3NhZ2UsIDUwMCwge1xuICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICB9KTtcbiAgICByZXF1ZXN0RXJyb3IuY2F1c2UgPSBlcnJvcjtcbiAgICB0aHJvdyByZXF1ZXN0RXJyb3I7XG4gIH1cbiAgY29uc3Qgc3RhdHVzID0gZmV0Y2hSZXNwb25zZS5zdGF0dXM7XG4gIGNvbnN0IHVybCA9IGZldGNoUmVzcG9uc2UudXJsO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZmV0Y2hSZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgcmVzcG9uc2VIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBjb25zdCBvY3Rva2l0UmVzcG9uc2UgPSB7XG4gICAgdXJsLFxuICAgIHN0YXR1cyxcbiAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgZGF0YTogXCJcIlxuICB9O1xuICBpZiAoXCJkZXByZWNhdGlvblwiIGluIHJlc3BvbnNlSGVhZGVycykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSByZXNwb25zZUhlYWRlcnMubGluayAmJiByZXNwb25zZUhlYWRlcnMubGluay5tYXRjaCgvPChbXjw+XSspPjsgcmVsPVwiZGVwcmVjYXRpb25cIi8pO1xuICAgIGNvbnN0IGRlcHJlY2F0aW9uTGluayA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5wb3AoKTtcbiAgICBsb2cud2FybihcbiAgICAgIGBbQG9jdG9raXQvcmVxdWVzdF0gXCIke3JlcXVlc3RPcHRpb25zLm1ldGhvZH0gJHtyZXF1ZXN0T3B0aW9ucy51cmx9XCIgaXMgZGVwcmVjYXRlZC4gSXQgaXMgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgb24gJHtyZXNwb25zZUhlYWRlcnMuc3Vuc2V0fSR7ZGVwcmVjYXRpb25MaW5rID8gYC4gU2VlICR7ZGVwcmVjYXRpb25MaW5rfWAgOiBcIlwifWBcbiAgICApO1xuICB9XG4gIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzdGF0dXMgPT09IDIwNSkge1xuICAgIHJldHVybiBvY3Rva2l0UmVzcG9uc2U7XG4gIH1cbiAgaWYgKHJlcXVlc3RPcHRpb25zLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICBpZiAoc3RhdHVzIDwgNDAwKSB7XG4gICAgICByZXR1cm4gb2N0b2tpdFJlc3BvbnNlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKGZldGNoUmVzcG9uc2Uuc3RhdHVzVGV4dCwgc3RhdHVzLCB7XG4gICAgICByZXNwb25zZTogb2N0b2tpdFJlc3BvbnNlLFxuICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBpZiAoc3RhdHVzID09PSAzMDQpIHtcbiAgICBvY3Rva2l0UmVzcG9uc2UuZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShmZXRjaFJlc3BvbnNlKTtcbiAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKFwiTm90IG1vZGlmaWVkXCIsIHN0YXR1cywge1xuICAgICAgcmVzcG9uc2U6IG9jdG9raXRSZXNwb25zZSxcbiAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgaWYgKHN0YXR1cyA+PSA0MDApIHtcbiAgICBvY3Rva2l0UmVzcG9uc2UuZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShmZXRjaFJlc3BvbnNlKTtcbiAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKHRvRXJyb3JNZXNzYWdlKG9jdG9raXRSZXNwb25zZS5kYXRhKSwgc3RhdHVzLCB7XG4gICAgICByZXNwb25zZTogb2N0b2tpdFJlc3BvbnNlLFxuICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBvY3Rva2l0UmVzcG9uc2UuZGF0YSA9IHBhcnNlU3VjY2Vzc1Jlc3BvbnNlQm9keSA/IGF3YWl0IGdldFJlc3BvbnNlRGF0YShmZXRjaFJlc3BvbnNlKSA6IGZldGNoUmVzcG9uc2UuYm9keTtcbiAgcmV0dXJuIG9jdG9raXRSZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBcIlwiKTtcbiAgfVxuICBjb25zdCBtaW1ldHlwZSA9IHNhZmVQYXJzZShjb250ZW50VHlwZSk7XG4gIGlmIChpc0pTT05SZXNwb25zZShtaW1ldHlwZSkpIHtcbiAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtaW1ldHlwZS50eXBlLnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSB8fCBtaW1ldHlwZS5wYXJhbWV0ZXJzLmNoYXJzZXQ/LnRvTG93ZXJDYXNlKCkgPT09IFwidXRmLThcIikge1xuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gXCJcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkuY2F0Y2goKCkgPT4gbmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNKU09OUmVzcG9uc2UobWltZXR5cGUpIHtcbiAgcmV0dXJuIG1pbWV0eXBlLnR5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiIHx8IG1pbWV0eXBlLnR5cGUgPT09IFwiYXBwbGljYXRpb24vc2NpbStqc29uXCI7XG59XG5mdW5jdGlvbiB0b0Vycm9yTWVzc2FnZShkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gXCJVbmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKFwibWVzc2FnZVwiIGluIGRhdGEpIHtcbiAgICBjb25zdCBzdWZmaXggPSBcImRvY3VtZW50YXRpb25fdXJsXCIgaW4gZGF0YSA/IGAgLSAke2RhdGEuZG9jdW1lbnRhdGlvbl91cmx9YCA6IFwiXCI7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YS5lcnJvcnMpID8gYCR7ZGF0YS5tZXNzYWdlfTogJHtkYXRhLmVycm9ycy5tYXAoKHYpID0+IEpTT04uc3RyaW5naWZ5KHYpKS5qb2luKFwiLCBcIil9JHtzdWZmaXh9YCA6IGAke2RhdGEubWVzc2FnZX0ke3N1ZmZpeH1gO1xuICB9XG4gIHJldHVybiBgVW5rbm93biBlcnJvcjogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZEVuZHBvaW50LCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBlbmRwb2ludDIgPSBvbGRFbmRwb2ludC5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IG5ld0FwaSA9IGZ1bmN0aW9uKHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgZW5kcG9pbnRPcHRpb25zID0gZW5kcG9pbnQyLm1lcmdlKHJvdXRlLCBwYXJhbWV0ZXJzKTtcbiAgICBpZiAoIWVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0IHx8ICFlbmRwb2ludE9wdGlvbnMucmVxdWVzdC5ob29rKSB7XG4gICAgICByZXR1cm4gZmV0Y2hXcmFwcGVyKGVuZHBvaW50Mi5wYXJzZShlbmRwb2ludE9wdGlvbnMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdDIgPSAocm91dGUyLCBwYXJhbWV0ZXJzMikgPT4ge1xuICAgICAgcmV0dXJuIGZldGNoV3JhcHBlcihcbiAgICAgICAgZW5kcG9pbnQyLnBhcnNlKGVuZHBvaW50Mi5tZXJnZShyb3V0ZTIsIHBhcmFtZXRlcnMyKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHJlcXVlc3QyLCB7XG4gICAgICBlbmRwb2ludDogZW5kcG9pbnQyLFxuICAgICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIGVuZHBvaW50MilcbiAgICB9KTtcbiAgICByZXR1cm4gZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QuaG9vayhyZXF1ZXN0MiwgZW5kcG9pbnRPcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgZW5kcG9pbnQ6IGVuZHBvaW50MixcbiAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgZW5kcG9pbnQyKVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgcmVxdWVzdCA9IHdpdGhEZWZhdWx0cyhlbmRwb2ludCwgZGVmYXVsdHNfZGVmYXVsdCk7XG5leHBvcnQge1xuICByZXF1ZXN0XG59O1xuIiwiLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5pbXBvcnQgeyByZXF1ZXN0IGFzIFJlcXVlc3QyIH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbmltcG9ydCB7IHJlcXVlc3QgYXMgUmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9lcnJvci5qc1xuZnVuY3Rpb24gX2J1aWxkTWVzc2FnZUZvclJlc3BvbnNlRXJyb3JzKGRhdGEpIHtcbiAgcmV0dXJuIGBSZXF1ZXN0IGZhaWxlZCBkdWUgdG8gZm9sbG93aW5nIHJlc3BvbnNlIGVycm9yczpcbmAgKyBkYXRhLmVycm9ycy5tYXAoKGUpID0+IGAgLSAke2UubWVzc2FnZX1gKS5qb2luKFwiXFxuXCIpO1xufVxudmFyIEdyYXBocWxSZXNwb25zZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QyLCBoZWFkZXJzLCByZXNwb25zZSkge1xuICAgIHN1cGVyKF9idWlsZE1lc3NhZ2VGb3JSZXNwb25zZUVycm9ycyhyZXNwb25zZSkpO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3QyO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZXJyb3JzID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgbmFtZSA9IFwiR3JhcGhxbFJlc3BvbnNlRXJyb3JcIjtcbiAgZXJyb3JzO1xuICBkYXRhO1xufTtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbnZhciBOT05fVkFSSUFCTEVfT1BUSU9OUyA9IFtcbiAgXCJtZXRob2RcIixcbiAgXCJiYXNlVXJsXCIsXG4gIFwidXJsXCIsXG4gIFwiaGVhZGVyc1wiLFxuICBcInJlcXVlc3RcIixcbiAgXCJxdWVyeVwiLFxuICBcIm1lZGlhVHlwZVwiLFxuICBcIm9wZXJhdGlvbk5hbWVcIlxuXTtcbnZhciBGT1JCSURERU5fVkFSSUFCTEVfT1BUSU9OUyA9IFtcInF1ZXJ5XCIsIFwibWV0aG9kXCIsIFwidXJsXCJdO1xudmFyIEdIRVNfVjNfU1VGRklYX1JFR0VYID0gL1xcL2FwaVxcL3YzXFwvPyQvO1xuZnVuY3Rpb24gZ3JhcGhxbChyZXF1ZXN0MiwgcXVlcnksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIFwicXVlcnlcIiBpbiBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihgW0BvY3Rva2l0L2dyYXBocWxdIFwicXVlcnlcIiBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZSBuYW1lYClcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghRk9SQklEREVOX1ZBUklBQkxFX09QVElPTlMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICBgW0BvY3Rva2l0L2dyYXBocWxdIFwiJHtrZXl9XCIgY2Fubm90IGJlIHVzZWQgYXMgdmFyaWFibGUgbmFtZWBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IHR5cGVvZiBxdWVyeSA9PT0gXCJzdHJpbmdcIiA/IE9iamVjdC5hc3NpZ24oeyBxdWVyeSB9LCBvcHRpb25zKSA6IHF1ZXJ5O1xuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5rZXlzKFxuICAgIHBhcnNlZE9wdGlvbnNcbiAgKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgaWYgKE5PTl9WQVJJQUJMRV9PUFRJT05TLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcGFyc2VkT3B0aW9uc1trZXldO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQudmFyaWFibGVzKSB7XG4gICAgICByZXN1bHQudmFyaWFibGVzID0ge307XG4gICAgfVxuICAgIHJlc3VsdC52YXJpYWJsZXNba2V5XSA9IHBhcnNlZE9wdGlvbnNba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG4gIGNvbnN0IGJhc2VVcmwgPSBwYXJzZWRPcHRpb25zLmJhc2VVcmwgfHwgcmVxdWVzdDIuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybDtcbiAgaWYgKEdIRVNfVjNfU1VGRklYX1JFR0VYLnRlc3QoYmFzZVVybCkpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy51cmwgPSBiYXNlVXJsLnJlcGxhY2UoR0hFU19WM19TVUZGSVhfUkVHRVgsIFwiL2FwaS9ncmFwaHFsXCIpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0MihyZXF1ZXN0T3B0aW9ucykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICBpZiAocmVzcG9uc2UuZGF0YS5lcnJvcnMpIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IHJlc3BvbnNlLmhlYWRlcnNba2V5XTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBHcmFwaHFsUmVzcG9uc2VFcnJvcihcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlLmRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmRhdGE7XG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHJlcXVlc3QyLCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBuZXdSZXF1ZXN0ID0gcmVxdWVzdDIuZGVmYXVsdHMobmV3RGVmYXVsdHMpO1xuICBjb25zdCBuZXdBcGkgPSAocXVlcnksIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gZ3JhcGhxbChuZXdSZXF1ZXN0LCBxdWVyeSwgb3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0FwaSwge1xuICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBuZXdSZXF1ZXN0KSxcbiAgICBlbmRwb2ludDogbmV3UmVxdWVzdC5lbmRwb2ludFxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgZ3JhcGhxbDIgPSB3aXRoRGVmYXVsdHMocmVxdWVzdCwge1xuICBoZWFkZXJzOiB7XG4gICAgXCJ1c2VyLWFnZW50XCI6IGBvY3Rva2l0LWdyYXBocWwuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWBcbiAgfSxcbiAgbWV0aG9kOiBcIlBPU1RcIixcbiAgdXJsOiBcIi9ncmFwaHFsXCJcbn0pO1xuZnVuY3Rpb24gd2l0aEN1c3RvbVJlcXVlc3QoY3VzdG9tUmVxdWVzdCkge1xuICByZXR1cm4gd2l0aERlZmF1bHRzKGN1c3RvbVJlcXVlc3QsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogXCIvZ3JhcGhxbFwiXG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgR3JhcGhxbFJlc3BvbnNlRXJyb3IsXG4gIGdyYXBocWwyIGFzIGdyYXBocWwsXG4gIHdpdGhDdXN0b21SZXF1ZXN0XG59O1xuIiwiLy8gcGtnL2Rpc3Qtc3JjL2lzLWp3dC5qc1xudmFyIGI2NHVybCA9IFwiKD86W2EtekEtWjAtOV8tXSspXCI7XG52YXIgc2VwID0gXCJcXFxcLlwiO1xudmFyIGp3dFJFID0gbmV3IFJlZ0V4cChgXiR7YjY0dXJsfSR7c2VwfSR7YjY0dXJsfSR7c2VwfSR7YjY0dXJsfSRgKTtcbnZhciBpc0pXVCA9IGp3dFJFLnRlc3QuYmluZChqd3RSRSk7XG5cbi8vIHBrZy9kaXN0LXNyYy9hdXRoLmpzXG5hc3luYyBmdW5jdGlvbiBhdXRoKHRva2VuKSB7XG4gIGNvbnN0IGlzQXBwID0gaXNKV1QodG9rZW4pO1xuICBjb25zdCBpc0luc3RhbGxhdGlvbiA9IHRva2VuLnN0YXJ0c1dpdGgoXCJ2MS5cIikgfHwgdG9rZW4uc3RhcnRzV2l0aChcImdoc19cIik7XG4gIGNvbnN0IGlzVXNlclRvU2VydmVyID0gdG9rZW4uc3RhcnRzV2l0aChcImdodV9cIik7XG4gIGNvbnN0IHRva2VuVHlwZSA9IGlzQXBwID8gXCJhcHBcIiA6IGlzSW5zdGFsbGF0aW9uID8gXCJpbnN0YWxsYXRpb25cIiA6IGlzVXNlclRvU2VydmVyID8gXCJ1c2VyLXRvLXNlcnZlclwiIDogXCJvYXV0aFwiO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9rZW5cIixcbiAgICB0b2tlbixcbiAgICB0b2tlblR5cGVcbiAgfTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3dpdGgtYXV0aG9yaXphdGlvbi1wcmVmaXguanNcbmZ1bmN0aW9uIHdpdGhBdXRob3JpemF0aW9uUHJlZml4KHRva2VuKSB7XG4gIGlmICh0b2tlbi5zcGxpdCgvXFwuLykubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGBiZWFyZXIgJHt0b2tlbn1gO1xuICB9XG4gIHJldHVybiBgdG9rZW4gJHt0b2tlbn1gO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaG9vay5qc1xuYXN5bmMgZnVuY3Rpb24gaG9vayh0b2tlbiwgcmVxdWVzdCwgcm91dGUsIHBhcmFtZXRlcnMpIHtcbiAgY29uc3QgZW5kcG9pbnQgPSByZXF1ZXN0LmVuZHBvaW50Lm1lcmdlKFxuICAgIHJvdXRlLFxuICAgIHBhcmFtZXRlcnNcbiAgKTtcbiAgZW5kcG9pbnQuaGVhZGVycy5hdXRob3JpemF0aW9uID0gd2l0aEF1dGhvcml6YXRpb25QcmVmaXgodG9rZW4pO1xuICByZXR1cm4gcmVxdWVzdChlbmRwb2ludCk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xudmFyIGNyZWF0ZVRva2VuQXV0aCA9IGZ1bmN0aW9uIGNyZWF0ZVRva2VuQXV0aDIodG9rZW4pIHtcbiAgaWYgKCF0b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltAb2N0b2tpdC9hdXRoLXRva2VuXSBObyB0b2tlbiBwYXNzZWQgdG8gY3JlYXRlVG9rZW5BdXRoXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgdG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIltAb2N0b2tpdC9hdXRoLXRva2VuXSBUb2tlbiBwYXNzZWQgdG8gY3JlYXRlVG9rZW5BdXRoIGlzIG5vdCBhIHN0cmluZ1wiXG4gICAgKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoL14odG9rZW58YmVhcmVyKSArL2ksIFwiXCIpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihhdXRoLmJpbmQobnVsbCwgdG9rZW4pLCB7XG4gICAgaG9vazogaG9vay5iaW5kKG51bGwsIHRva2VuKVxuICB9KTtcbn07XG5leHBvcnQge1xuICBjcmVhdGVUb2tlbkF1dGhcbn07XG4iLCJjb25zdCBWRVJTSU9OID0gXCI3LjAuM1wiO1xuZXhwb3J0IHtcbiAgVkVSU0lPTlxufTtcbiIsImltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuaW1wb3J0IEhvb2sgZnJvbSBcImJlZm9yZS1hZnRlci1ob29rXCI7XG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcbmltcG9ydCB7IHdpdGhDdXN0b21SZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L2dyYXBocWxcIjtcbmltcG9ydCB7IGNyZWF0ZVRva2VuQXV0aCB9IGZyb20gXCJAb2N0b2tpdC9hdXRoLXRva2VuXCI7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn07XG5jb25zdCBjb25zb2xlV2FybiA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuY29uc3QgY29uc29sZUVycm9yID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKGxvZ2dlciA9IHt9KSB7XG4gIGlmICh0eXBlb2YgbG9nZ2VyLmRlYnVnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsb2dnZXIuZGVidWcgPSBub29wO1xuICB9XG4gIGlmICh0eXBlb2YgbG9nZ2VyLmluZm8gIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxvZ2dlci5pbmZvID0gbm9vcDtcbiAgfVxuICBpZiAodHlwZW9mIGxvZ2dlci53YXJuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsb2dnZXIud2FybiA9IGNvbnNvbGVXYXJuO1xuICB9XG4gIGlmICh0eXBlb2YgbG9nZ2VyLmVycm9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsb2dnZXIuZXJyb3IgPSBjb25zb2xlRXJyb3I7XG4gIH1cbiAgcmV0dXJuIGxvZ2dlcjtcbn1cbmNvbnN0IHVzZXJBZ2VudFRyYWlsID0gYG9jdG9raXQtY29yZS5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YDtcbmNsYXNzIE9jdG9raXQge1xuICBzdGF0aWMgVkVSU0lPTiA9IFZFUlNJT047XG4gIHN0YXRpYyBkZWZhdWx0cyhkZWZhdWx0cykge1xuICAgIGNvbnN0IE9jdG9raXRXaXRoRGVmYXVsdHMgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1swXSB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgc3VwZXIoZGVmYXVsdHMob3B0aW9ucykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zLnVzZXJBZ2VudCAmJiBkZWZhdWx0cy51c2VyQWdlbnQgPyB7XG4gICAgICAgICAgICAgIHVzZXJBZ2VudDogYCR7b3B0aW9ucy51c2VyQWdlbnR9ICR7ZGVmYXVsdHMudXNlckFnZW50fWBcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9jdG9raXRXaXRoRGVmYXVsdHM7XG4gIH1cbiAgc3RhdGljIHBsdWdpbnMgPSBbXTtcbiAgLyoqXG4gICAqIEF0dGFjaCBhIHBsdWdpbiAob3IgbWFueSkgdG8geW91ciBPY3Rva2l0IGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBBUEkgPSBPY3Rva2l0LnBsdWdpbihwbHVnaW4xLCBwbHVnaW4yLCBwbHVnaW4zLCAuLi4pXG4gICAqL1xuICBzdGF0aWMgcGx1Z2luKC4uLm5ld1BsdWdpbnMpIHtcbiAgICBjb25zdCBjdXJyZW50UGx1Z2lucyA9IHRoaXMucGx1Z2lucztcbiAgICBjb25zdCBOZXdPY3Rva2l0ID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICAgIHN0YXRpYyBwbHVnaW5zID0gY3VycmVudFBsdWdpbnMuY29uY2F0KFxuICAgICAgICBuZXdQbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiAhY3VycmVudFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV3T2N0b2tpdDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBob29rID0gbmV3IEhvb2suQ29sbGVjdGlvbigpO1xuICAgIGNvbnN0IHJlcXVlc3REZWZhdWx0cyA9IHtcbiAgICAgIGJhc2VVcmw6IHJlcXVlc3QuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgcmVxdWVzdDogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdXNhZ2Ugb25seSwgbm8gbmVlZCB0byB0eXBlXG4gICAgICAgIGhvb2s6IGhvb2suYmluZChudWxsLCBcInJlcXVlc3RcIilcbiAgICAgIH0pLFxuICAgICAgbWVkaWFUeXBlOiB7XG4gICAgICAgIHByZXZpZXdzOiBbXSxcbiAgICAgICAgZm9ybWF0OiBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0RGVmYXVsdHMuaGVhZGVyc1tcInVzZXItYWdlbnRcIl0gPSBvcHRpb25zLnVzZXJBZ2VudCA/IGAke29wdGlvbnMudXNlckFnZW50fSAke3VzZXJBZ2VudFRyYWlsfWAgOiB1c2VyQWdlbnRUcmFpbDtcbiAgICBpZiAob3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgICByZXF1ZXN0RGVmYXVsdHMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJldmlld3MpIHtcbiAgICAgIHJlcXVlc3REZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3MgPSBvcHRpb25zLnByZXZpZXdzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgcmVxdWVzdERlZmF1bHRzLmhlYWRlcnNbXCJ0aW1lLXpvbmVcIl0gPSBvcHRpb25zLnRpbWVab25lO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0LmRlZmF1bHRzKHJlcXVlc3REZWZhdWx0cyk7XG4gICAgdGhpcy5ncmFwaHFsID0gd2l0aEN1c3RvbVJlcXVlc3QodGhpcy5yZXF1ZXN0KS5kZWZhdWx0cyhyZXF1ZXN0RGVmYXVsdHMpO1xuICAgIHRoaXMubG9nID0gY3JlYXRlTG9nZ2VyKG9wdGlvbnMubG9nKTtcbiAgICB0aGlzLmhvb2sgPSBob29rO1xuICAgIGlmICghb3B0aW9ucy5hdXRoU3RyYXRlZ3kpIHtcbiAgICAgIGlmICghb3B0aW9ucy5hdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aCA9IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ1bmF1dGhlbnRpY2F0ZWRcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBjcmVhdGVUb2tlbkF1dGgob3B0aW9ucy5hdXRoKTtcbiAgICAgICAgaG9vay53cmFwKFwicmVxdWVzdFwiLCBhdXRoLmhvb2spO1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGF1dGhTdHJhdGVneSwgLi4ub3RoZXJPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgYXV0aCA9IGF1dGhTdHJhdGVneShcbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICBsb2c6IHRoaXMubG9nLFxuICAgICAgICAgICAgLy8gd2UgcGFzcyB0aGUgY3VycmVudCBvY3Rva2l0IGluc3RhbmNlIGFzIHdlbGwgYXMgaXRzIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgICAgICAgIC8vIHRvIGFsbG93IGZvciBhdXRoZW50aWNhdGlvbiBzdHJhdGVnaWVzIHRoYXQgcmV0dXJuIGEgbmV3IG9jdG9raXQgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIHRoYXQgc2hhcmVzIHRoZSBzYW1lIGludGVybmFsIHN0YXRlIGFzIHRoZSBjdXJyZW50IG9uZS4gVGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyByZXF1aXJlbWVudCBmb3IgdGhpcyB3YXMgdGhlIFwiZXZlbnQtb2N0b2tpdFwiIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5XG4gICAgICAgICAgICAvLyBvZiBodHRwczovL2dpdGh1Yi5jb20vcHJvYm90L29jdG9raXQtYXV0aC1wcm9ib3QuXG4gICAgICAgICAgICBvY3Rva2l0OiB0aGlzLFxuICAgICAgICAgICAgb2N0b2tpdE9wdGlvbnM6IG90aGVyT3B0aW9uc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3B0aW9ucy5hdXRoXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBob29rLndyYXAoXCJyZXF1ZXN0XCIsIGF1dGguaG9vayk7XG4gICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc0NvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzQ29uc3RydWN0b3IucGx1Z2lucy5sZW5ndGg7ICsraSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjbGFzc0NvbnN0cnVjdG9yLnBsdWdpbnNbaV0odGhpcywgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICAvLyBhc3NpZ25lZCBkdXJpbmcgY29uc3RydWN0b3JcbiAgcmVxdWVzdDtcbiAgZ3JhcGhxbDtcbiAgbG9nO1xuICBob29rO1xuICAvLyBUT0RPOiB0eXBlIGBvY3Rva2l0LmF1dGhgIGJhc2VkIG9uIHBhc3NlZCBvcHRpb25zLmF1dGhTdHJhdGVneVxuICBhdXRoO1xufVxuZXhwb3J0IHtcbiAgT2N0b2tpdFxufTtcbiIsImNvbnN0IFZFUlNJT04gPSBcIjYuMC4wXCI7XG5leHBvcnQge1xuICBWRVJTSU9OXG59O1xuIiwiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuL3ZlcnNpb24uanNcIjtcbmZ1bmN0aW9uIHJlcXVlc3RMb2cob2N0b2tpdCkge1xuICBvY3Rva2l0Lmhvb2sud3JhcChcInJlcXVlc3RcIiwgKHJlcXVlc3QsIG9wdGlvbnMpID0+IHtcbiAgICBvY3Rva2l0LmxvZy5kZWJ1ZyhcInJlcXVlc3RcIiwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gb2N0b2tpdC5yZXF1ZXN0LmVuZHBvaW50LnBhcnNlKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhdGggPSByZXF1ZXN0T3B0aW9ucy51cmwucmVwbGFjZShvcHRpb25zLmJhc2VVcmwsIFwiXCIpO1xuICAgIHJldHVybiByZXF1ZXN0KG9wdGlvbnMpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXNwb25zZS5oZWFkZXJzW1wieC1naXRodWItcmVxdWVzdC1pZFwiXTtcbiAgICAgIG9jdG9raXQubG9nLmluZm8oXG4gICAgICAgIGAke3JlcXVlc3RPcHRpb25zLm1ldGhvZH0gJHtwYXRofSAtICR7cmVzcG9uc2Uuc3RhdHVzfSB3aXRoIGlkICR7cmVxdWVzdElkfSBpbiAke0RhdGUubm93KCkgLSBzdGFydH1tc2BcbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0SWQgPSBlcnJvci5yZXNwb25zZT8uaGVhZGVyc1tcIngtZ2l0aHViLXJlcXVlc3QtaWRcIl0gfHwgXCJVTktOT1dOXCI7XG4gICAgICBvY3Rva2l0LmxvZy5lcnJvcihcbiAgICAgICAgYCR7cmVxdWVzdE9wdGlvbnMubWV0aG9kfSAke3BhdGh9IC0gJHtlcnJvci5zdGF0dXN9IHdpdGggaWQgJHtyZXF1ZXN0SWR9IGluICR7RGF0ZS5ub3coKSAtIHN0YXJ0fW1zYFxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9KTtcbn1cbnJlcXVlc3RMb2cuVkVSU0lPTiA9IFZFUlNJT047XG5leHBvcnQge1xuICByZXF1ZXN0TG9nXG59O1xuIiwiLy8gcGtnL2Rpc3Qtc3JjL3ZlcnNpb24uanNcbnZhciBWRVJTSU9OID0gXCIwLjAuMC1kZXZlbG9wbWVudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvbm9ybWFsaXplLXBhZ2luYXRlZC1saXN0LXJlc3BvbnNlLmpzXG5mdW5jdGlvbiBub3JtYWxpemVQYWdpbmF0ZWRMaXN0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5kYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgZGF0YTogW11cbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlTmVlZHNOb3JtYWxpemF0aW9uID0gKFwidG90YWxfY291bnRcIiBpbiByZXNwb25zZS5kYXRhIHx8IFwidG90YWxfY29tbWl0c1wiIGluIHJlc3BvbnNlLmRhdGEpICYmICEoXCJ1cmxcIiBpbiByZXNwb25zZS5kYXRhKTtcbiAgaWYgKCFyZXNwb25zZU5lZWRzTm9ybWFsaXphdGlvbikgcmV0dXJuIHJlc3BvbnNlO1xuICBjb25zdCBpbmNvbXBsZXRlUmVzdWx0cyA9IHJlc3BvbnNlLmRhdGEuaW5jb21wbGV0ZV9yZXN1bHRzO1xuICBjb25zdCByZXBvc2l0b3J5U2VsZWN0aW9uID0gcmVzcG9uc2UuZGF0YS5yZXBvc2l0b3J5X3NlbGVjdGlvbjtcbiAgY29uc3QgdG90YWxDb3VudCA9IHJlc3BvbnNlLmRhdGEudG90YWxfY291bnQ7XG4gIGNvbnN0IHRvdGFsQ29tbWl0cyA9IHJlc3BvbnNlLmRhdGEudG90YWxfY29tbWl0cztcbiAgZGVsZXRlIHJlc3BvbnNlLmRhdGEuaW5jb21wbGV0ZV9yZXN1bHRzO1xuICBkZWxldGUgcmVzcG9uc2UuZGF0YS5yZXBvc2l0b3J5X3NlbGVjdGlvbjtcbiAgZGVsZXRlIHJlc3BvbnNlLmRhdGEudG90YWxfY291bnQ7XG4gIGRlbGV0ZSByZXNwb25zZS5kYXRhLnRvdGFsX2NvbW1pdHM7XG4gIGNvbnN0IG5hbWVzcGFjZUtleSA9IE9iamVjdC5rZXlzKHJlc3BvbnNlLmRhdGEpWzBdO1xuICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YVtuYW1lc3BhY2VLZXldO1xuICByZXNwb25zZS5kYXRhID0gZGF0YTtcbiAgaWYgKHR5cGVvZiBpbmNvbXBsZXRlUmVzdWx0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlLmRhdGEuaW5jb21wbGV0ZV9yZXN1bHRzID0gaW5jb21wbGV0ZVJlc3VsdHM7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXBvc2l0b3J5U2VsZWN0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2UuZGF0YS5yZXBvc2l0b3J5X3NlbGVjdGlvbiA9IHJlcG9zaXRvcnlTZWxlY3Rpb247XG4gIH1cbiAgcmVzcG9uc2UuZGF0YS50b3RhbF9jb3VudCA9IHRvdGFsQ291bnQ7XG4gIHJlc3BvbnNlLmRhdGEudG90YWxfY29tbWl0cyA9IHRvdGFsQ29tbWl0cztcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaXRlcmF0b3IuanNcbmZ1bmN0aW9uIGl0ZXJhdG9yKG9jdG9raXQsIHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygcm91dGUgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlLmVuZHBvaW50KHBhcmFtZXRlcnMpIDogb2N0b2tpdC5yZXF1ZXN0LmVuZHBvaW50KHJvdXRlLCBwYXJhbWV0ZXJzKTtcbiAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IHR5cGVvZiByb3V0ZSA9PT0gXCJmdW5jdGlvblwiID8gcm91dGUgOiBvY3Rva2l0LnJlcXVlc3Q7XG4gIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICBsZXQgdXJsID0gb3B0aW9ucy51cmw7XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gKHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGlmICghdXJsKSByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0TWV0aG9kKHsgbWV0aG9kLCB1cmwsIGhlYWRlcnMgfSk7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlc3BvbnNlID0gbm9ybWFsaXplUGFnaW5hdGVkTGlzdFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB1cmwgPSAoKG5vcm1hbGl6ZWRSZXNwb25zZS5oZWFkZXJzLmxpbmsgfHwgXCJcIikubWF0Y2goXG4gICAgICAgICAgICAvPChbXjw+XSspPjtcXHMqcmVsPVwibmV4dFwiL1xuICAgICAgICAgICkgfHwgW10pWzFdO1xuICAgICAgICAgIGlmICghdXJsICYmIFwidG90YWxfY29tbWl0c1wiIGluIG5vcm1hbGl6ZWRSZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKG5vcm1hbGl6ZWRSZXNwb25zZS51cmwpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VkVXJsLnNlYXJjaFBhcmFtcztcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChwYXJhbXMuZ2V0KFwicGFnZVwiKSB8fCBcIjFcIiwgMTApO1xuICAgICAgICAgICAgY29uc3QgcGVyX3BhZ2UgPSBwYXJzZUludChwYXJhbXMuZ2V0KFwicGVyX3BhZ2VcIikgfHwgXCIyNTBcIiwgMTApO1xuICAgICAgICAgICAgaWYgKHBhZ2UgKiBwZXJfcGFnZSA8IG5vcm1hbGl6ZWRSZXNwb25zZS5kYXRhLnRvdGFsX2NvbW1pdHMpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLnNldChcInBhZ2VcIiwgU3RyaW5nKHBhZ2UgKyAxKSk7XG4gICAgICAgICAgICAgIHVybCA9IHBhcnNlZFVybC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbm9ybWFsaXplZFJlc3BvbnNlIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyAhPT0gNDA5KSB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB1cmwgPSBcIlwiO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH07XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9wYWdpbmF0ZS5qc1xuZnVuY3Rpb24gcGFnaW5hdGUob2N0b2tpdCwgcm91dGUsIHBhcmFtZXRlcnMsIG1hcEZuKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1ldGVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbWFwRm4gPSBwYXJhbWV0ZXJzO1xuICAgIHBhcmFtZXRlcnMgPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGdhdGhlcihcbiAgICBvY3Rva2l0LFxuICAgIFtdLFxuICAgIGl0ZXJhdG9yKG9jdG9raXQsIHJvdXRlLCBwYXJhbWV0ZXJzKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSxcbiAgICBtYXBGblxuICApO1xufVxuZnVuY3Rpb24gZ2F0aGVyKG9jdG9raXQsIHJlc3VsdHMsIGl0ZXJhdG9yMiwgbWFwRm4pIHtcbiAgcmV0dXJuIGl0ZXJhdG9yMi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgbGV0IGVhcmx5RXhpdCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBlYXJseUV4aXQgPSB0cnVlO1xuICAgIH1cbiAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoXG4gICAgICBtYXBGbiA/IG1hcEZuKHJlc3VsdC52YWx1ZSwgZG9uZSkgOiByZXN1bHQudmFsdWUuZGF0YVxuICAgICk7XG4gICAgaWYgKGVhcmx5RXhpdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiBnYXRoZXIob2N0b2tpdCwgcmVzdWx0cywgaXRlcmF0b3IyLCBtYXBGbik7XG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvY29tcG9zZS1wYWdpbmF0ZS5qc1xudmFyIGNvbXBvc2VQYWdpbmF0ZVJlc3QgPSBPYmplY3QuYXNzaWduKHBhZ2luYXRlLCB7XG4gIGl0ZXJhdG9yXG59KTtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dlbmVyYXRlZC9wYWdpbmF0aW5nLWVuZHBvaW50cy5qc1xudmFyIHBhZ2luYXRpbmdFbmRwb2ludHMgPSBbXG4gIFwiR0VUIC9hZHZpc29yaWVzXCIsXG4gIFwiR0VUIC9hcHAvaG9vay9kZWxpdmVyaWVzXCIsXG4gIFwiR0VUIC9hcHAvaW5zdGFsbGF0aW9uLXJlcXVlc3RzXCIsXG4gIFwiR0VUIC9hcHAvaW5zdGFsbGF0aW9uc1wiLFxuICBcIkdFVCAvYXNzaWdubWVudHMve2Fzc2lnbm1lbnRfaWR9L2FjY2VwdGVkX2Fzc2lnbm1lbnRzXCIsXG4gIFwiR0VUIC9jbGFzc3Jvb21zXCIsXG4gIFwiR0VUIC9jbGFzc3Jvb21zL3tjbGFzc3Jvb21faWR9L2Fzc2lnbm1lbnRzXCIsXG4gIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9uc1wiLFxuICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2NvZGUtc2VjdXJpdHkvY29uZmlndXJhdGlvbnMve2NvbmZpZ3VyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiLFxuICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2RlcGVuZGFib3QvYWxlcnRzXCIsXG4gIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0c1wiLFxuICBcIkdFVCAvZXZlbnRzXCIsXG4gIFwiR0VUIC9naXN0c1wiLFxuICBcIkdFVCAvZ2lzdHMvcHVibGljXCIsXG4gIFwiR0VUIC9naXN0cy9zdGFycmVkXCIsXG4gIFwiR0VUIC9naXN0cy97Z2lzdF9pZH0vY29tbWVudHNcIixcbiAgXCJHRVQgL2dpc3RzL3tnaXN0X2lkfS9jb21taXRzXCIsXG4gIFwiR0VUIC9naXN0cy97Z2lzdF9pZH0vZm9ya3NcIixcbiAgXCJHRVQgL2luc3RhbGxhdGlvbi9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL2lzc3Vlc1wiLFxuICBcIkdFVCAvbGljZW5zZXNcIixcbiAgXCJHRVQgL21hcmtldHBsYWNlX2xpc3RpbmcvcGxhbnNcIixcbiAgXCJHRVQgL21hcmtldHBsYWNlX2xpc3RpbmcvcGxhbnMve3BsYW5faWR9L2FjY291bnRzXCIsXG4gIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3N0dWJiZWQvcGxhbnNcIixcbiAgXCJHRVQgL21hcmtldHBsYWNlX2xpc3Rpbmcvc3R1YmJlZC9wbGFucy97cGxhbl9pZH0vYWNjb3VudHNcIixcbiAgXCJHRVQgL25ldHdvcmtzL3tvd25lcn0ve3JlcG99L2V2ZW50c1wiLFxuICBcIkdFVCAvbm90aWZpY2F0aW9uc1wiLFxuICBcIkdFVCAvb3JnYW5pemF0aW9uc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL2NhY2hlL3VzYWdlLWJ5LXJlcG9zaXRvcnlcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ob3N0ZWQtcnVubmVyc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3JlcG9zaXRvcmllc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lci1ncm91cHNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXItZ3JvdXBzL3tydW5uZXJfZ3JvdXBfaWR9L2hvc3RlZC1ydW5uZXJzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVyLWdyb3Vwcy97cnVubmVyX2dyb3VwX2lkfS9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXItZ3JvdXBzL3tydW5uZXJfZ3JvdXBfaWR9L3J1bm5lcnNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvc2VjcmV0c1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy92YXJpYWJsZXNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy92YXJpYWJsZXMve25hbWV9L3JlcG9zaXRvcmllc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9hdHRlc3RhdGlvbnMve3N1YmplY3RfZGlnZXN0fVwiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9ibG9ja3NcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vY2FtcGFpZ25zXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2NvZGUtc2Nhbm5pbmcvYWxlcnRzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2NvZGUtc2VjdXJpdHkvY29uZmlndXJhdGlvbnNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9ucy97Y29uZmlndXJhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2NvZGVzcGFjZXNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vY29kZXNwYWNlcy9zZWNyZXRzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9jb3BpbG90L2JpbGxpbmcvc2VhdHNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vY29waWxvdC9tZXRyaWNzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3QvYWxlcnRzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0c1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vZXZlbnRzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2ZhaWxlZF9pbnZpdGF0aW9uc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9ob29rc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vZGVsaXZlcmllc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9pbnNpZ2h0cy9hcGkvcm91dGUtc3RhdHMve2FjdG9yX3R5cGV9L3thY3Rvcl9pZH1cIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vaW5zaWdodHMvYXBpL3N1YmplY3Qtc3RhdHNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vaW5zaWdodHMvYXBpL3VzZXItc3RhdHMve3VzZXJfaWR9XCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2luc3RhbGxhdGlvbnNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vaW52aXRhdGlvbnNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9L3RlYW1zXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L2lzc3Vlc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9tZW1iZXJzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L21lbWJlcnMve3VzZXJuYW1lfS9jb2Rlc3BhY2VzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vb3JnYW5pemF0aW9uLXJvbGVzL3tyb2xlX2lkfS90ZWFtc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9vcmdhbml6YXRpb24tcm9sZXMve3JvbGVfaWR9L3VzZXJzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L291dHNpZGVfY29sbGFib3JhdG9yc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9wZXJzb25hbC1hY2Nlc3MtdG9rZW4tcmVxdWVzdHNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vcGVyc29uYWwtYWNjZXNzLXRva2VuLXJlcXVlc3RzL3twYXRfcmVxdWVzdF9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3BlcnNvbmFsLWFjY2Vzcy10b2tlbnNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vcGVyc29uYWwtYWNjZXNzLXRva2Vucy97cGF0X2lkfS9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vcHJpdmF0ZS1yZWdpc3RyaWVzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3Byb2plY3RzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3Byb3BlcnRpZXMvdmFsdWVzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3B1YmxpY19tZW1iZXJzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3JlcG9zXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3J1bGVzZXRzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3J1bGVzZXRzL3J1bGUtc3VpdGVzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3J1bGVzZXRzL3tydWxlc2V0X2lkfS9oaXN0b3J5XCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3NlY3JldC1zY2FubmluZy9hbGVydHNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vc2VjdXJpdHktYWR2aXNvcmllc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS9zZXR0aW5ncy9uZXR3b3JrLWNvbmZpZ3VyYXRpb25zXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW0ve3RlYW1fc2x1Z30vY29waWxvdC9tZXRyaWNzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHNcIixcbiAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9pbnZpdGF0aW9uc1wiLFxuICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9tZW1iZXJzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3Byb2plY3RzXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3JlcG9zXCIsXG4gIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3RlYW1zXCIsXG4gIFwiR0VUIC9wcm9qZWN0cy9jb2x1bW5zL3tjb2x1bW5faWR9L2NhcmRzXCIsXG4gIFwiR0VUIC9wcm9qZWN0cy97cHJvamVjdF9pZH0vY29sbGFib3JhdG9yc1wiLFxuICBcIkdFVCAvcHJvamVjdHMve3Byb2plY3RfaWR9L2NvbHVtbnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvYXJ0aWZhY3RzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9vcmdhbml6YXRpb24tc2VjcmV0c1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9vcmdhbml6YXRpb24tdmFyaWFibGVzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVuc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2FydGlmYWN0c1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2F0dGVtcHRzL3thdHRlbXB0X251bWJlcn0vam9ic1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2pvYnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvc2VjcmV0c1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy92YXJpYWJsZXNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9L3J1bnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGl2aXR5XCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hc3NpZ25lZXNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F0dGVzdGF0aW9ucy97c3ViamVjdF9kaWdlc3R9XCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stcnVucy97Y2hlY2tfcnVuX2lkfS9hbm5vdGF0aW9uc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stc3VpdGVzL3tjaGVja19zdWl0ZV9pZH0vY2hlY2stcnVuc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbGVydHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2luc3RhbmNlc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbmFseXNlc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9kZXZjb250YWluZXJzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL3NlY3JldHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbGxhYm9yYXRvcnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21tZW50cy97Y29tbWVudF9pZH0vcmVhY3Rpb25zXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9jb21tZW50c1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97Y29tbWl0X3NoYX0vcHVsbHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn0vY2hlY2stcnVuc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfS9jaGVjay1zdWl0ZXNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn0vc3RhdHVzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L3N0YXR1c2VzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21wYXJlL3tiYXNlaGVhZH1cIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbXBhcmUve2Jhc2V9Li4ue2hlYWR9XCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb250cmlidXRvcnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGFib3QvYWxlcnRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudF9pZH0vc3RhdHVzZXNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50c1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9kZXBsb3ltZW50LWJyYW5jaC1wb2xpY2llc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9kZXBsb3ltZW50X3Byb3RlY3Rpb25fcnVsZXMvYXBwc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3ZhcmlhYmxlc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZXZlbnRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9mb3Jrc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3NcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9kZWxpdmVyaWVzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnZpdGF0aW9uc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9jb21tZW50cy97Y29tbWVudF9pZH0vcmVhY3Rpb25zXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvZXZlbnRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vY29tbWVudHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9ldmVudHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9sYWJlbHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9yZWFjdGlvbnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9zdWJfaXNzdWVzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vdGltZWxpbmVcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2xhYmVsc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lcy97bWlsZXN0b25lX251bWJlcn0vbGFiZWxzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ub3RpZmljYXRpb25zXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9idWlsZHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Byb2plY3RzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxsc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMvY29tbWVudHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29tbWVudHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29tbWl0c1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9maWxlc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3Mve3Jldmlld19pZH0vY29tbWVudHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vYXNzZXRzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vcmVhY3Rpb25zXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ydWxlcy9icmFuY2hlcy97YnJhbmNofVwiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcnVsZXNldHNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3J1bGVzZXRzL3J1bGUtc3VpdGVzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ydWxlc2V0cy97cnVsZXNldF9pZH0vaGlzdG9yeVwiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0c1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfS9sb2NhdGlvbnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3VyaXR5LWFkdmlzb3JpZXNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXJnYXplcnNcIixcbiAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N1YnNjcmliZXJzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90YWdzXCIsXG4gIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90ZWFtc1wiLFxuICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdG9waWNzXCIsXG4gIFwiR0VUIC9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL3NlYXJjaC9jb2RlXCIsXG4gIFwiR0VUIC9zZWFyY2gvY29tbWl0c1wiLFxuICBcIkdFVCAvc2VhcmNoL2lzc3Vlc1wiLFxuICBcIkdFVCAvc2VhcmNoL2xhYmVsc1wiLFxuICBcIkdFVCAvc2VhcmNoL3JlcG9zaXRvcmllc1wiLFxuICBcIkdFVCAvc2VhcmNoL3RvcGljc1wiLFxuICBcIkdFVCAvc2VhcmNoL3VzZXJzXCIsXG4gIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vZGlzY3Vzc2lvbnNcIixcbiAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzXCIsXG4gIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiLFxuICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vcmVhY3Rpb25zXCIsXG4gIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vaW52aXRhdGlvbnNcIixcbiAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS9tZW1iZXJzXCIsXG4gIFwiR0VUIC90ZWFtcy97dGVhbV9pZH0vcHJvamVjdHNcIixcbiAgXCJHRVQgL3RlYW1zL3t0ZWFtX2lkfS9yZXBvc1wiLFxuICBcIkdFVCAvdGVhbXMve3RlYW1faWR9L3RlYW1zXCIsXG4gIFwiR0VUIC91c2VyL2Jsb2Nrc1wiLFxuICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzXCIsXG4gIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0c1wiLFxuICBcIkdFVCAvdXNlci9lbWFpbHNcIixcbiAgXCJHRVQgL3VzZXIvZm9sbG93ZXJzXCIsXG4gIFwiR0VUIC91c2VyL2ZvbGxvd2luZ1wiLFxuICBcIkdFVCAvdXNlci9ncGdfa2V5c1wiLFxuICBcIkdFVCAvdXNlci9pbnN0YWxsYXRpb25zXCIsXG4gIFwiR0VUIC91c2VyL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCIsXG4gIFwiR0VUIC91c2VyL2lzc3Vlc1wiLFxuICBcIkdFVCAvdXNlci9rZXlzXCIsXG4gIFwiR0VUIC91c2VyL21hcmtldHBsYWNlX3B1cmNoYXNlc1wiLFxuICBcIkdFVCAvdXNlci9tYXJrZXRwbGFjZV9wdXJjaGFzZXMvc3R1YmJlZFwiLFxuICBcIkdFVCAvdXNlci9tZW1iZXJzaGlwcy9vcmdzXCIsXG4gIFwiR0VUIC91c2VyL21pZ3JhdGlvbnNcIixcbiAgXCJHRVQgL3VzZXIvbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9yZXBvc2l0b3JpZXNcIixcbiAgXCJHRVQgL3VzZXIvb3Jnc1wiLFxuICBcIkdFVCAvdXNlci9wYWNrYWdlc1wiLFxuICBcIkdFVCAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiLFxuICBcIkdFVCAvdXNlci9wdWJsaWNfZW1haWxzXCIsXG4gIFwiR0VUIC91c2VyL3JlcG9zXCIsXG4gIFwiR0VUIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnNcIixcbiAgXCJHRVQgL3VzZXIvc29jaWFsX2FjY291bnRzXCIsXG4gIFwiR0VUIC91c2VyL3NzaF9zaWduaW5nX2tleXNcIixcbiAgXCJHRVQgL3VzZXIvc3RhcnJlZFwiLFxuICBcIkdFVCAvdXNlci9zdWJzY3JpcHRpb25zXCIsXG4gIFwiR0VUIC91c2VyL3RlYW1zXCIsXG4gIFwiR0VUIC91c2Vyc1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9hdHRlc3RhdGlvbnMve3N1YmplY3RfZGlnZXN0fVwiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHNcIixcbiAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZXZlbnRzL29yZ3Mve29yZ31cIixcbiAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZXZlbnRzL3B1YmxpY1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9mb2xsb3dlcnNcIixcbiAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93aW5nXCIsXG4gIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2dpc3RzXCIsXG4gIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2dwZ19rZXlzXCIsXG4gIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2tleXNcIixcbiAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vb3Jnc1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlc1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9wcm9qZWN0c1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9yZWNlaXZlZF9ldmVudHNcIixcbiAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcmVjZWl2ZWRfZXZlbnRzL3B1YmxpY1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9yZXBvc1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zb2NpYWxfYWNjb3VudHNcIixcbiAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc3NoX3NpZ25pbmdfa2V5c1wiLFxuICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zdGFycmVkXCIsXG4gIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3N1YnNjcmlwdGlvbnNcIlxuXTtcblxuLy8gcGtnL2Rpc3Qtc3JjL3BhZ2luYXRpbmctZW5kcG9pbnRzLmpzXG5mdW5jdGlvbiBpc1BhZ2luYXRpbmdFbmRwb2ludChhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcGFnaW5hdGluZ0VuZHBvaW50cy5pbmNsdWRlcyhhcmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbmZ1bmN0aW9uIHBhZ2luYXRlUmVzdChvY3Rva2l0KSB7XG4gIHJldHVybiB7XG4gICAgcGFnaW5hdGU6IE9iamVjdC5hc3NpZ24ocGFnaW5hdGUuYmluZChudWxsLCBvY3Rva2l0KSwge1xuICAgICAgaXRlcmF0b3I6IGl0ZXJhdG9yLmJpbmQobnVsbCwgb2N0b2tpdClcbiAgICB9KVxuICB9O1xufVxucGFnaW5hdGVSZXN0LlZFUlNJT04gPSBWRVJTSU9OO1xuZXhwb3J0IHtcbiAgY29tcG9zZVBhZ2luYXRlUmVzdCxcbiAgaXNQYWdpbmF0aW5nRW5kcG9pbnQsXG4gIHBhZ2luYXRlUmVzdCxcbiAgcGFnaW5hdGluZ0VuZHBvaW50c1xufTtcbiIsImNvbnN0IFZFUlNJT04gPSBcIjE2LjAuMFwiO1xuZXhwb3J0IHtcbiAgVkVSU0lPTlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwXG4iLCJjb25zdCBFbmRwb2ludHMgPSB7XG4gIGFjdGlvbnM6IHtcbiAgICBhZGRDdXN0b21MYWJlbHNUb1NlbGZIb3N0ZWRSdW5uZXJGb3JPcmc6IFtcbiAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCJcbiAgICBdLFxuICAgIGFkZEN1c3RvbUxhYmVsc1RvU2VsZkhvc3RlZFJ1bm5lckZvclJlcG86IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiXG4gICAgXSxcbiAgICBhZGRSZXBvQWNjZXNzVG9TZWxmSG9zdGVkUnVubmVyR3JvdXBJbk9yZzogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXItZ3JvdXBzL3tydW5uZXJfZ3JvdXBfaWR9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIlxuICAgIF0sXG4gICAgYWRkU2VsZWN0ZWRSZXBvVG9PcmdTZWNyZXQ6IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIlxuICAgIF0sXG4gICAgYWRkU2VsZWN0ZWRSZXBvVG9PcmdWYXJpYWJsZTogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy92YXJpYWJsZXMve25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIlxuICAgIF0sXG4gICAgYXBwcm92ZVdvcmtmbG93UnVuOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hcHByb3ZlXCJcbiAgICBdLFxuICAgIGNhbmNlbFdvcmtmbG93UnVuOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9jYW5jZWxcIlxuICAgIF0sXG4gICAgY3JlYXRlRW52aXJvbm1lbnRWYXJpYWJsZTogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3ZhcmlhYmxlc1wiXG4gICAgXSxcbiAgICBjcmVhdGVIb3N0ZWRSdW5uZXJGb3JPcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vYWN0aW9ucy9ob3N0ZWQtcnVubmVyc1wiXSxcbiAgICBjcmVhdGVPclVwZGF0ZUVudmlyb25tZW50U2VjcmV0OiBbXG4gICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIlxuICAgIF0sXG4gICAgY3JlYXRlT3JVcGRhdGVPcmdTZWNyZXQ6IFtcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICBjcmVhdGVPclVwZGF0ZVJlcG9TZWNyZXQ6IFtcbiAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXG4gICAgXSxcbiAgICBjcmVhdGVPcmdWYXJpYWJsZTogW1wiUE9TVCAvb3Jncy97b3JnfS9hY3Rpb25zL3ZhcmlhYmxlc1wiXSxcbiAgICBjcmVhdGVSZWdpc3RyYXRpb25Ub2tlbkZvck9yZzogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVycy9yZWdpc3RyYXRpb24tdG9rZW5cIlxuICAgIF0sXG4gICAgY3JlYXRlUmVnaXN0cmF0aW9uVG9rZW5Gb3JSZXBvOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy9yZWdpc3RyYXRpb24tdG9rZW5cIlxuICAgIF0sXG4gICAgY3JlYXRlUmVtb3ZlVG9rZW5Gb3JPcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3JlbW92ZS10b2tlblwiXSxcbiAgICBjcmVhdGVSZW1vdmVUb2tlbkZvclJlcG86IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3JlbW92ZS10b2tlblwiXG4gICAgXSxcbiAgICBjcmVhdGVSZXBvVmFyaWFibGU6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvdmFyaWFibGVzXCJdLFxuICAgIGNyZWF0ZVdvcmtmbG93RGlzcGF0Y2g6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9kaXNwYXRjaGVzXCJcbiAgICBdLFxuICAgIGRlbGV0ZUFjdGlvbnNDYWNoZUJ5SWQ6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlcy97Y2FjaGVfaWR9XCJcbiAgICBdLFxuICAgIGRlbGV0ZUFjdGlvbnNDYWNoZUJ5S2V5OiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9jYWNoZXN7P2tleSxyZWZ9XCJcbiAgICBdLFxuICAgIGRlbGV0ZUFydGlmYWN0OiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9hcnRpZmFjdHMve2FydGlmYWN0X2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVFbnZpcm9ubWVudFNlY3JldDogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vc2VjcmV0cy97c2VjcmV0X25hbWV9XCJcbiAgICBdLFxuICAgIGRlbGV0ZUVudmlyb25tZW50VmFyaWFibGU6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L3ZhcmlhYmxlcy97bmFtZX1cIlxuICAgIF0sXG4gICAgZGVsZXRlSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL2hvc3RlZC1ydW5uZXJzL3tob3N0ZWRfcnVubmVyX2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVPcmdTZWNyZXQ6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICBkZWxldGVPcmdWYXJpYWJsZTogW1wiREVMRVRFIC9vcmdzL3tvcmd9L2FjdGlvbnMvdmFyaWFibGVzL3tuYW1lfVwiXSxcbiAgICBkZWxldGVSZXBvU2VjcmV0OiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIlxuICAgIF0sXG4gICAgZGVsZXRlUmVwb1ZhcmlhYmxlOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy92YXJpYWJsZXMve25hbWV9XCJcbiAgICBdLFxuICAgIGRlbGV0ZVNlbGZIb3N0ZWRSdW5uZXJGcm9tT3JnOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH1cIlxuICAgIF0sXG4gICAgZGVsZXRlU2VsZkhvc3RlZFJ1bm5lckZyb21SZXBvOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9XCJcbiAgICBdLFxuICAgIGRlbGV0ZVdvcmtmbG93UnVuOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfVwiXSxcbiAgICBkZWxldGVXb3JrZmxvd1J1bkxvZ3M6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vbG9nc1wiXG4gICAgXSxcbiAgICBkaXNhYmxlU2VsZWN0ZWRSZXBvc2l0b3J5R2l0aHViQWN0aW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCJcbiAgICBdLFxuICAgIGRpc2FibGVXb3JrZmxvdzogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzL3t3b3JrZmxvd19pZH0vZGlzYWJsZVwiXG4gICAgXSxcbiAgICBkb3dubG9hZEFydGlmYWN0OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9hcnRpZmFjdHMve2FydGlmYWN0X2lkfS97YXJjaGl2ZV9mb3JtYXR9XCJcbiAgICBdLFxuICAgIGRvd25sb2FkSm9iTG9nc0ZvcldvcmtmbG93UnVuOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9qb2JzL3tqb2JfaWR9L2xvZ3NcIlxuICAgIF0sXG4gICAgZG93bmxvYWRXb3JrZmxvd1J1bkF0dGVtcHRMb2dzOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2F0dGVtcHRzL3thdHRlbXB0X251bWJlcn0vbG9nc1wiXG4gICAgXSxcbiAgICBkb3dubG9hZFdvcmtmbG93UnVuTG9nczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9sb2dzXCJcbiAgICBdLFxuICAgIGVuYWJsZVNlbGVjdGVkUmVwb3NpdG9yeUdpdGh1YkFjdGlvbnNPcmdhbml6YXRpb246IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiXG4gICAgXSxcbiAgICBlbmFibGVXb3JrZmxvdzogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvd29ya2Zsb3dzL3t3b3JrZmxvd19pZH0vZW5hYmxlXCJcbiAgICBdLFxuICAgIGZvcmNlQ2FuY2VsV29ya2Zsb3dSdW46IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2ZvcmNlLWNhbmNlbFwiXG4gICAgXSxcbiAgICBnZW5lcmF0ZVJ1bm5lckppdGNvbmZpZ0Zvck9yZzogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVycy9nZW5lcmF0ZS1qaXRjb25maWdcIlxuICAgIF0sXG4gICAgZ2VuZXJhdGVSdW5uZXJKaXRjb25maWdGb3JSZXBvOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy9nZW5lcmF0ZS1qaXRjb25maWdcIlxuICAgIF0sXG4gICAgZ2V0QWN0aW9uc0NhY2hlTGlzdDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlc1wiXSxcbiAgICBnZXRBY3Rpb25zQ2FjaGVVc2FnZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2NhY2hlL3VzYWdlXCJdLFxuICAgIGdldEFjdGlvbnNDYWNoZVVzYWdlQnlSZXBvRm9yT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL2NhY2hlL3VzYWdlLWJ5LXJlcG9zaXRvcnlcIlxuICAgIF0sXG4gICAgZ2V0QWN0aW9uc0NhY2hlVXNhZ2VGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL2NhY2hlL3VzYWdlXCJdLFxuICAgIGdldEFsbG93ZWRBY3Rpb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3NlbGVjdGVkLWFjdGlvbnNcIlxuICAgIF0sXG4gICAgZ2V0QWxsb3dlZEFjdGlvbnNSZXBvc2l0b3J5OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy9zZWxlY3RlZC1hY3Rpb25zXCJcbiAgICBdLFxuICAgIGdldEFydGlmYWN0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvYXJ0aWZhY3RzL3thcnRpZmFjdF9pZH1cIl0sXG4gICAgZ2V0Q3VzdG9tT2lkY1N1YkNsYWltRm9yUmVwbzogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvb2lkYy9jdXN0b21pemF0aW9uL3N1YlwiXG4gICAgXSxcbiAgICBnZXRFbnZpcm9ubWVudFB1YmxpY0tleTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vc2VjcmV0cy9wdWJsaWMta2V5XCJcbiAgICBdLFxuICAgIGdldEVudmlyb25tZW50U2VjcmV0OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIlxuICAgIF0sXG4gICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vdmFyaWFibGVzL3tuYW1lfVwiXG4gICAgXSxcbiAgICBnZXRHaXRodWJBY3Rpb25zRGVmYXVsdFdvcmtmbG93UGVybWlzc2lvbnNPcmdhbml6YXRpb246IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnMvd29ya2Zsb3dcIlxuICAgIF0sXG4gICAgZ2V0R2l0aHViQWN0aW9uc0RlZmF1bHRXb3JrZmxvd1Blcm1pc3Npb25zUmVwb3NpdG9yeTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnMvd29ya2Zsb3dcIlxuICAgIF0sXG4gICAgZ2V0R2l0aHViQWN0aW9uc1Blcm1pc3Npb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zXCJcbiAgICBdLFxuICAgIGdldEdpdGh1YkFjdGlvbnNQZXJtaXNzaW9uc1JlcG9zaXRvcnk6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3Blcm1pc3Npb25zXCJcbiAgICBdLFxuICAgIGdldEhvc3RlZFJ1bm5lckZvck9yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ob3N0ZWQtcnVubmVycy97aG9zdGVkX3J1bm5lcl9pZH1cIlxuICAgIF0sXG4gICAgZ2V0SG9zdGVkUnVubmVyc0dpdGh1Yk93bmVkSW1hZ2VzRm9yT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL2hvc3RlZC1ydW5uZXJzL2ltYWdlcy9naXRodWItb3duZWRcIlxuICAgIF0sXG4gICAgZ2V0SG9zdGVkUnVubmVyc0xpbWl0c0Zvck9yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ob3N0ZWQtcnVubmVycy9saW1pdHNcIlxuICAgIF0sXG4gICAgZ2V0SG9zdGVkUnVubmVyc01hY2hpbmVTcGVjc0Zvck9yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ob3N0ZWQtcnVubmVycy9tYWNoaW5lLXNpemVzXCJcbiAgICBdLFxuICAgIGdldEhvc3RlZFJ1bm5lcnNQYXJ0bmVySW1hZ2VzRm9yT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL2hvc3RlZC1ydW5uZXJzL2ltYWdlcy9wYXJ0bmVyXCJcbiAgICBdLFxuICAgIGdldEhvc3RlZFJ1bm5lcnNQbGF0Zm9ybXNGb3JPcmc6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvaG9zdGVkLXJ1bm5lcnMvcGxhdGZvcm1zXCJcbiAgICBdLFxuICAgIGdldEpvYkZvcldvcmtmbG93UnVuOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvam9icy97am9iX2lkfVwiXSxcbiAgICBnZXRPcmdQdWJsaWNLZXk6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMvcHVibGljLWtleVwiXSxcbiAgICBnZXRPcmdTZWNyZXQ6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICBnZXRPcmdWYXJpYWJsZTogW1wiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvdmFyaWFibGVzL3tuYW1lfVwiXSxcbiAgICBnZXRQZW5kaW5nRGVwbG95bWVudHNGb3JSdW46IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vcGVuZGluZ19kZXBsb3ltZW50c1wiXG4gICAgXSxcbiAgICBnZXRSZXBvUGVybWlzc2lvbnM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3Blcm1pc3Npb25zXCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1wiYWN0aW9uc1wiLCBcImdldEdpdGh1YkFjdGlvbnNQZXJtaXNzaW9uc1JlcG9zaXRvcnlcIl0gfVxuICAgIF0sXG4gICAgZ2V0UmVwb1B1YmxpY0tleTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3NlY3JldHMvcHVibGljLWtleVwiXSxcbiAgICBnZXRSZXBvU2VjcmV0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJdLFxuICAgIGdldFJlcG9WYXJpYWJsZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3ZhcmlhYmxlcy97bmFtZX1cIl0sXG4gICAgZ2V0UmV2aWV3c0ZvclJ1bjogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hcHByb3ZhbHNcIlxuICAgIF0sXG4gICAgZ2V0U2VsZkhvc3RlZFJ1bm5lckZvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfVwiXSxcbiAgICBnZXRTZWxmSG9zdGVkUnVubmVyRm9yUmVwbzogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfVwiXG4gICAgXSxcbiAgICBnZXRXb3JrZmxvdzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9XCJdLFxuICAgIGdldFdvcmtmbG93QWNjZXNzVG9SZXBvc2l0b3J5OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy9hY2Nlc3NcIlxuICAgIF0sXG4gICAgZ2V0V29ya2Zsb3dSdW46IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9XCJdLFxuICAgIGdldFdvcmtmbG93UnVuQXR0ZW1wdDogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVucy97cnVuX2lkfS9hdHRlbXB0cy97YXR0ZW1wdF9udW1iZXJ9XCJcbiAgICBdLFxuICAgIGdldFdvcmtmbG93UnVuVXNhZ2U6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vdGltaW5nXCJcbiAgICBdLFxuICAgIGdldFdvcmtmbG93VXNhZ2U6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93cy97d29ya2Zsb3dfaWR9L3RpbWluZ1wiXG4gICAgXSxcbiAgICBsaXN0QXJ0aWZhY3RzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL2FydGlmYWN0c1wiXSxcbiAgICBsaXN0RW52aXJvbm1lbnRTZWNyZXRzOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfS9zZWNyZXRzXCJcbiAgICBdLFxuICAgIGxpc3RFbnZpcm9ubWVudFZhcmlhYmxlczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vdmFyaWFibGVzXCJcbiAgICBdLFxuICAgIGxpc3RHaXRodWJIb3N0ZWRSdW5uZXJzSW5Hcm91cEZvck9yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXItZ3JvdXBzL3tydW5uZXJfZ3JvdXBfaWR9L2hvc3RlZC1ydW5uZXJzXCJcbiAgICBdLFxuICAgIGxpc3RIb3N0ZWRSdW5uZXJzRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ob3N0ZWQtcnVubmVyc1wiXSxcbiAgICBsaXN0Sm9ic0ZvcldvcmtmbG93UnVuOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2pvYnNcIlxuICAgIF0sXG4gICAgbGlzdEpvYnNGb3JXb3JrZmxvd1J1bkF0dGVtcHQ6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vYXR0ZW1wdHMve2F0dGVtcHRfbnVtYmVyfS9qb2JzXCJcbiAgICBdLFxuICAgIGxpc3RMYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCJcbiAgICBdLFxuICAgIGxpc3RMYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yUmVwbzogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIlxuICAgIF0sXG4gICAgbGlzdE9yZ1NlY3JldHM6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHNcIl0sXG4gICAgbGlzdE9yZ1ZhcmlhYmxlczogW1wiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvdmFyaWFibGVzXCJdLFxuICAgIGxpc3RSZXBvT3JnYW5pemF0aW9uU2VjcmV0czogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvb3JnYW5pemF0aW9uLXNlY3JldHNcIlxuICAgIF0sXG4gICAgbGlzdFJlcG9Pcmdhbml6YXRpb25WYXJpYWJsZXM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL29yZ2FuaXphdGlvbi12YXJpYWJsZXNcIlxuICAgIF0sXG4gICAgbGlzdFJlcG9TZWNyZXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvc2VjcmV0c1wiXSxcbiAgICBsaXN0UmVwb1ZhcmlhYmxlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3ZhcmlhYmxlc1wiXSxcbiAgICBsaXN0UmVwb1dvcmtmbG93czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3dvcmtmbG93c1wiXSxcbiAgICBsaXN0UnVubmVyQXBwbGljYXRpb25zRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL2Rvd25sb2Fkc1wiXSxcbiAgICBsaXN0UnVubmVyQXBwbGljYXRpb25zRm9yUmVwbzogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy9kb3dubG9hZHNcIlxuICAgIF0sXG4gICAgbGlzdFNlbGVjdGVkUmVwb3NGb3JPcmdTZWNyZXQ6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2FjdGlvbnMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllc1wiXG4gICAgXSxcbiAgICBsaXN0U2VsZWN0ZWRSZXBvc0Zvck9yZ1ZhcmlhYmxlOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3ZhcmlhYmxlcy97bmFtZX0vcmVwb3NpdG9yaWVzXCJcbiAgICBdLFxuICAgIGxpc3RTZWxlY3RlZFJlcG9zaXRvcmllc0VuYWJsZWRHaXRodWJBY3Rpb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3JlcG9zaXRvcmllc1wiXG4gICAgXSxcbiAgICBsaXN0U2VsZkhvc3RlZFJ1bm5lcnNGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnNcIl0sXG4gICAgbGlzdFNlbGZIb3N0ZWRSdW5uZXJzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnNcIl0sXG4gICAgbGlzdFdvcmtmbG93UnVuQXJ0aWZhY3RzOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2FydGlmYWN0c1wiXG4gICAgXSxcbiAgICBsaXN0V29ya2Zsb3dSdW5zOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9ydW5zXCJcbiAgICBdLFxuICAgIGxpc3RXb3JrZmxvd1J1bnNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVuc1wiXSxcbiAgICByZVJ1bkpvYkZvcldvcmtmbG93UnVuOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvam9icy97am9iX2lkfS9yZXJ1blwiXG4gICAgXSxcbiAgICByZVJ1bldvcmtmbG93OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vcmVydW5cIl0sXG4gICAgcmVSdW5Xb3JrZmxvd0ZhaWxlZEpvYnM6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L3JlcnVuLWZhaWxlZC1qb2JzXCJcbiAgICBdLFxuICAgIHJlbW92ZUFsbEN1c3RvbUxhYmVsc0Zyb21TZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCJcbiAgICBdLFxuICAgIHJlbW92ZUFsbEN1c3RvbUxhYmVsc0Zyb21TZWxmSG9zdGVkUnVubmVyRm9yUmVwbzogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcnVubmVycy97cnVubmVyX2lkfS9sYWJlbHNcIlxuICAgIF0sXG4gICAgcmVtb3ZlQ3VzdG9tTGFiZWxGcm9tU2VsZkhvc3RlZFJ1bm5lckZvck9yZzogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVscy97bmFtZX1cIlxuICAgIF0sXG4gICAgcmVtb3ZlQ3VzdG9tTGFiZWxGcm9tU2VsZkhvc3RlZFJ1bm5lckZvclJlcG86IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzL3tuYW1lfVwiXG4gICAgXSxcbiAgICByZW1vdmVTZWxlY3RlZFJlcG9Gcm9tT3JnU2VjcmV0OiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9hY3Rpb25zL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCJcbiAgICBdLFxuICAgIHJlbW92ZVNlbGVjdGVkUmVwb0Zyb21PcmdWYXJpYWJsZTogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vYWN0aW9ucy92YXJpYWJsZXMve25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIlxuICAgIF0sXG4gICAgcmV2aWV3Q3VzdG9tR2F0ZXNGb3JSdW46IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5zL3tydW5faWR9L2RlcGxveW1lbnRfcHJvdGVjdGlvbl9ydWxlXCJcbiAgICBdLFxuICAgIHJldmlld1BlbmRpbmdEZXBsb3ltZW50c0ZvclJ1bjogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hY3Rpb25zL3J1bnMve3J1bl9pZH0vcGVuZGluZ19kZXBsb3ltZW50c1wiXG4gICAgXSxcbiAgICBzZXRBbGxvd2VkQWN0aW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy9zZWxlY3RlZC1hY3Rpb25zXCJcbiAgICBdLFxuICAgIHNldEFsbG93ZWRBY3Rpb25zUmVwb3NpdG9yeTogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnMvc2VsZWN0ZWQtYWN0aW9uc1wiXG4gICAgXSxcbiAgICBzZXRDdXN0b21MYWJlbHNGb3JTZWxmSG9zdGVkUnVubmVyRm9yT3JnOiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3J1bm5lcnMve3J1bm5lcl9pZH0vbGFiZWxzXCJcbiAgICBdLFxuICAgIHNldEN1c3RvbUxhYmVsc0ZvclNlbGZIb3N0ZWRSdW5uZXJGb3JSZXBvOiBbXG4gICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9ydW5uZXJzL3tydW5uZXJfaWR9L2xhYmVsc1wiXG4gICAgXSxcbiAgICBzZXRDdXN0b21PaWRjU3ViQ2xhaW1Gb3JSZXBvOiBbXG4gICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9vaWRjL2N1c3RvbWl6YXRpb24vc3ViXCJcbiAgICBdLFxuICAgIHNldEdpdGh1YkFjdGlvbnNEZWZhdWx0V29ya2Zsb3dQZXJtaXNzaW9uc09yZ2FuaXphdGlvbjogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9wZXJtaXNzaW9ucy93b3JrZmxvd1wiXG4gICAgXSxcbiAgICBzZXRHaXRodWJBY3Rpb25zRGVmYXVsdFdvcmtmbG93UGVybWlzc2lvbnNSZXBvc2l0b3J5OiBbXG4gICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYWN0aW9ucy9wZXJtaXNzaW9ucy93b3JrZmxvd1wiXG4gICAgXSxcbiAgICBzZXRHaXRodWJBY3Rpb25zUGVybWlzc2lvbnNPcmdhbml6YXRpb246IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2FjdGlvbnMvcGVybWlzc2lvbnNcIlxuICAgIF0sXG4gICAgc2V0R2l0aHViQWN0aW9uc1Blcm1pc3Npb25zUmVwb3NpdG9yeTogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnNcIlxuICAgIF0sXG4gICAgc2V0U2VsZWN0ZWRSZXBvc0Zvck9yZ1NlY3JldDogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzXCJcbiAgICBdLFxuICAgIHNldFNlbGVjdGVkUmVwb3NGb3JPcmdWYXJpYWJsZTogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy92YXJpYWJsZXMve25hbWV9L3JlcG9zaXRvcmllc1wiXG4gICAgXSxcbiAgICBzZXRTZWxlY3RlZFJlcG9zaXRvcmllc0VuYWJsZWRHaXRodWJBY3Rpb25zT3JnYW5pemF0aW9uOiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9hY3Rpb25zL3Blcm1pc3Npb25zL3JlcG9zaXRvcmllc1wiXG4gICAgXSxcbiAgICBzZXRXb3JrZmxvd0FjY2Vzc1RvUmVwb3NpdG9yeTogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvcGVybWlzc2lvbnMvYWNjZXNzXCJcbiAgICBdLFxuICAgIHVwZGF0ZUVudmlyb25tZW50VmFyaWFibGU6IFtcbiAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vdmFyaWFibGVzL3tuYW1lfVwiXG4gICAgXSxcbiAgICB1cGRhdGVIb3N0ZWRSdW5uZXJGb3JPcmc6IFtcbiAgICAgIFwiUEFUQ0ggL29yZ3Mve29yZ30vYWN0aW9ucy9ob3N0ZWQtcnVubmVycy97aG9zdGVkX3J1bm5lcl9pZH1cIlxuICAgIF0sXG4gICAgdXBkYXRlT3JnVmFyaWFibGU6IFtcIlBBVENIIC9vcmdzL3tvcmd9L2FjdGlvbnMvdmFyaWFibGVzL3tuYW1lfVwiXSxcbiAgICB1cGRhdGVSZXBvVmFyaWFibGU6IFtcbiAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGlvbnMvdmFyaWFibGVzL3tuYW1lfVwiXG4gICAgXVxuICB9LFxuICBhY3Rpdml0eToge1xuICAgIGNoZWNrUmVwb0lzU3RhcnJlZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9zdGFycmVkL3tvd25lcn0ve3JlcG99XCJdLFxuICAgIGRlbGV0ZVJlcG9TdWJzY3JpcHRpb246IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vc3Vic2NyaXB0aW9uXCJdLFxuICAgIGRlbGV0ZVRocmVhZFN1YnNjcmlwdGlvbjogW1xuICAgICAgXCJERUxFVEUgL25vdGlmaWNhdGlvbnMvdGhyZWFkcy97dGhyZWFkX2lkfS9zdWJzY3JpcHRpb25cIlxuICAgIF0sXG4gICAgZ2V0RmVlZHM6IFtcIkdFVCAvZmVlZHNcIl0sXG4gICAgZ2V0UmVwb1N1YnNjcmlwdGlvbjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdWJzY3JpcHRpb25cIl0sXG4gICAgZ2V0VGhyZWFkOiBbXCJHRVQgL25vdGlmaWNhdGlvbnMvdGhyZWFkcy97dGhyZWFkX2lkfVwiXSxcbiAgICBnZXRUaHJlYWRTdWJzY3JpcHRpb25Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJHRVQgL25vdGlmaWNhdGlvbnMvdGhyZWFkcy97dGhyZWFkX2lkfS9zdWJzY3JpcHRpb25cIlxuICAgIF0sXG4gICAgbGlzdEV2ZW50c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZXZlbnRzXCJdLFxuICAgIGxpc3ROb3RpZmljYXRpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvbm90aWZpY2F0aW9uc1wiXSxcbiAgICBsaXN0T3JnRXZlbnRzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L2V2ZW50cy9vcmdzL3tvcmd9XCJcbiAgICBdLFxuICAgIGxpc3RQdWJsaWNFdmVudHM6IFtcIkdFVCAvZXZlbnRzXCJdLFxuICAgIGxpc3RQdWJsaWNFdmVudHNGb3JSZXBvTmV0d29yazogW1wiR0VUIC9uZXR3b3Jrcy97b3duZXJ9L3tyZXBvfS9ldmVudHNcIl0sXG4gICAgbGlzdFB1YmxpY0V2ZW50c0ZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9ldmVudHMvcHVibGljXCJdLFxuICAgIGxpc3RQdWJsaWNPcmdFdmVudHM6IFtcIkdFVCAvb3Jncy97b3JnfS9ldmVudHNcIl0sXG4gICAgbGlzdFJlY2VpdmVkRXZlbnRzRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L3JlY2VpdmVkX2V2ZW50c1wiXSxcbiAgICBsaXN0UmVjZWl2ZWRQdWJsaWNFdmVudHNGb3JVc2VyOiBbXG4gICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9yZWNlaXZlZF9ldmVudHMvcHVibGljXCJcbiAgICBdLFxuICAgIGxpc3RSZXBvRXZlbnRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2V2ZW50c1wiXSxcbiAgICBsaXN0UmVwb05vdGlmaWNhdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L25vdGlmaWNhdGlvbnNcIlxuICAgIF0sXG4gICAgbGlzdFJlcG9zU3RhcnJlZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9zdGFycmVkXCJdLFxuICAgIGxpc3RSZXBvc1N0YXJyZWRCeVVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zdGFycmVkXCJdLFxuICAgIGxpc3RSZXBvc1dhdGNoZWRCeVVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zdWJzY3JpcHRpb25zXCJdLFxuICAgIGxpc3RTdGFyZ2F6ZXJzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGFyZ2F6ZXJzXCJdLFxuICAgIGxpc3RXYXRjaGVkUmVwb3NGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL3N1YnNjcmlwdGlvbnNcIl0sXG4gICAgbGlzdFdhdGNoZXJzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdWJzY3JpYmVyc1wiXSxcbiAgICBtYXJrTm90aWZpY2F0aW9uc0FzUmVhZDogW1wiUFVUIC9ub3RpZmljYXRpb25zXCJdLFxuICAgIG1hcmtSZXBvTm90aWZpY2F0aW9uc0FzUmVhZDogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ub3RpZmljYXRpb25zXCJdLFxuICAgIG1hcmtUaHJlYWRBc0RvbmU6IFtcIkRFTEVURSAvbm90aWZpY2F0aW9ucy90aHJlYWRzL3t0aHJlYWRfaWR9XCJdLFxuICAgIG1hcmtUaHJlYWRBc1JlYWQ6IFtcIlBBVENIIC9ub3RpZmljYXRpb25zL3RocmVhZHMve3RocmVhZF9pZH1cIl0sXG4gICAgc2V0UmVwb1N1YnNjcmlwdGlvbjogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdWJzY3JpcHRpb25cIl0sXG4gICAgc2V0VGhyZWFkU3Vic2NyaXB0aW9uOiBbXG4gICAgICBcIlBVVCAvbm90aWZpY2F0aW9ucy90aHJlYWRzL3t0aHJlYWRfaWR9L3N1YnNjcmlwdGlvblwiXG4gICAgXSxcbiAgICBzdGFyUmVwb0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQVVQgL3VzZXIvc3RhcnJlZC97b3duZXJ9L3tyZXBvfVwiXSxcbiAgICB1bnN0YXJSZXBvRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9zdGFycmVkL3tvd25lcn0ve3JlcG99XCJdXG4gIH0sXG4gIGFwcHM6IHtcbiAgICBhZGRSZXBvVG9JbnN0YWxsYXRpb246IFtcbiAgICAgIFwiUFVUIC91c2VyL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcImFwcHNcIiwgXCJhZGRSZXBvVG9JbnN0YWxsYXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9XG4gICAgXSxcbiAgICBhZGRSZXBvVG9JbnN0YWxsYXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJQVVQgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCJcbiAgICBdLFxuICAgIGNoZWNrVG9rZW46IFtcIlBPU1QgL2FwcGxpY2F0aW9ucy97Y2xpZW50X2lkfS90b2tlblwiXSxcbiAgICBjcmVhdGVGcm9tTWFuaWZlc3Q6IFtcIlBPU1QgL2FwcC1tYW5pZmVzdHMve2NvZGV9L2NvbnZlcnNpb25zXCJdLFxuICAgIGNyZWF0ZUluc3RhbGxhdGlvbkFjY2Vzc1Rva2VuOiBbXG4gICAgICBcIlBPU1QgL2FwcC9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9L2FjY2Vzc190b2tlbnNcIlxuICAgIF0sXG4gICAgZGVsZXRlQXV0aG9yaXphdGlvbjogW1wiREVMRVRFIC9hcHBsaWNhdGlvbnMve2NsaWVudF9pZH0vZ3JhbnRcIl0sXG4gICAgZGVsZXRlSW5zdGFsbGF0aW9uOiBbXCJERUxFVEUgL2FwcC9pbnN0YWxsYXRpb25zL3tpbnN0YWxsYXRpb25faWR9XCJdLFxuICAgIGRlbGV0ZVRva2VuOiBbXCJERUxFVEUgL2FwcGxpY2F0aW9ucy97Y2xpZW50X2lkfS90b2tlblwiXSxcbiAgICBnZXRBdXRoZW50aWNhdGVkOiBbXCJHRVQgL2FwcFwiXSxcbiAgICBnZXRCeVNsdWc6IFtcIkdFVCAvYXBwcy97YXBwX3NsdWd9XCJdLFxuICAgIGdldEluc3RhbGxhdGlvbjogW1wiR0VUIC9hcHAvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfVwiXSxcbiAgICBnZXRPcmdJbnN0YWxsYXRpb246IFtcIkdFVCAvb3Jncy97b3JnfS9pbnN0YWxsYXRpb25cIl0sXG4gICAgZ2V0UmVwb0luc3RhbGxhdGlvbjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnN0YWxsYXRpb25cIl0sXG4gICAgZ2V0U3Vic2NyaXB0aW9uUGxhbkZvckFjY291bnQ6IFtcbiAgICAgIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL2FjY291bnRzL3thY2NvdW50X2lkfVwiXG4gICAgXSxcbiAgICBnZXRTdWJzY3JpcHRpb25QbGFuRm9yQWNjb3VudFN0dWJiZWQ6IFtcbiAgICAgIFwiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3N0dWJiZWQvYWNjb3VudHMve2FjY291bnRfaWR9XCJcbiAgICBdLFxuICAgIGdldFVzZXJJbnN0YWxsYXRpb246IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9pbnN0YWxsYXRpb25cIl0sXG4gICAgZ2V0V2ViaG9va0NvbmZpZ0ZvckFwcDogW1wiR0VUIC9hcHAvaG9vay9jb25maWdcIl0sXG4gICAgZ2V0V2ViaG9va0RlbGl2ZXJ5OiBbXCJHRVQgL2FwcC9ob29rL2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfVwiXSxcbiAgICBsaXN0QWNjb3VudHNGb3JQbGFuOiBbXCJHRVQgL21hcmtldHBsYWNlX2xpc3RpbmcvcGxhbnMve3BsYW5faWR9L2FjY291bnRzXCJdLFxuICAgIGxpc3RBY2NvdW50c0ZvclBsYW5TdHViYmVkOiBbXG4gICAgICBcIkdFVCAvbWFya2V0cGxhY2VfbGlzdGluZy9zdHViYmVkL3BsYW5zL3twbGFuX2lkfS9hY2NvdW50c1wiXG4gICAgXSxcbiAgICBsaXN0SW5zdGFsbGF0aW9uUmVwb3NGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJHRVQgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXNcIlxuICAgIF0sXG4gICAgbGlzdEluc3RhbGxhdGlvblJlcXVlc3RzRm9yQXV0aGVudGljYXRlZEFwcDogW1xuICAgICAgXCJHRVQgL2FwcC9pbnN0YWxsYXRpb24tcmVxdWVzdHNcIlxuICAgIF0sXG4gICAgbGlzdEluc3RhbGxhdGlvbnM6IFtcIkdFVCAvYXBwL2luc3RhbGxhdGlvbnNcIl0sXG4gICAgbGlzdEluc3RhbGxhdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2luc3RhbGxhdGlvbnNcIl0sXG4gICAgbGlzdFBsYW5zOiBbXCJHRVQgL21hcmtldHBsYWNlX2xpc3RpbmcvcGxhbnNcIl0sXG4gICAgbGlzdFBsYW5zU3R1YmJlZDogW1wiR0VUIC9tYXJrZXRwbGFjZV9saXN0aW5nL3N0dWJiZWQvcGxhbnNcIl0sXG4gICAgbGlzdFJlcG9zQWNjZXNzaWJsZVRvSW5zdGFsbGF0aW9uOiBbXCJHRVQgL2luc3RhbGxhdGlvbi9yZXBvc2l0b3JpZXNcIl0sXG4gICAgbGlzdFN1YnNjcmlwdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL21hcmtldHBsYWNlX3B1cmNoYXNlc1wiXSxcbiAgICBsaXN0U3Vic2NyaXB0aW9uc0ZvckF1dGhlbnRpY2F0ZWRVc2VyU3R1YmJlZDogW1xuICAgICAgXCJHRVQgL3VzZXIvbWFya2V0cGxhY2VfcHVyY2hhc2VzL3N0dWJiZWRcIlxuICAgIF0sXG4gICAgbGlzdFdlYmhvb2tEZWxpdmVyaWVzOiBbXCJHRVQgL2FwcC9ob29rL2RlbGl2ZXJpZXNcIl0sXG4gICAgcmVkZWxpdmVyV2ViaG9va0RlbGl2ZXJ5OiBbXG4gICAgICBcIlBPU1QgL2FwcC9ob29rL2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfS9hdHRlbXB0c1wiXG4gICAgXSxcbiAgICByZW1vdmVSZXBvRnJvbUluc3RhbGxhdGlvbjogW1xuICAgICAgXCJERUxFVEUgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1wiYXBwc1wiLCBcInJlbW92ZVJlcG9Gcm9tSW5zdGFsbGF0aW9uRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgcmVtb3ZlUmVwb0Zyb21JbnN0YWxsYXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJERUxFVEUgL3VzZXIvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCJcbiAgICBdLFxuICAgIHJlc2V0VG9rZW46IFtcIlBBVENIIC9hcHBsaWNhdGlvbnMve2NsaWVudF9pZH0vdG9rZW5cIl0sXG4gICAgcmV2b2tlSW5zdGFsbGF0aW9uQWNjZXNzVG9rZW46IFtcIkRFTEVURSAvaW5zdGFsbGF0aW9uL3Rva2VuXCJdLFxuICAgIHNjb3BlVG9rZW46IFtcIlBPU1QgL2FwcGxpY2F0aW9ucy97Y2xpZW50X2lkfS90b2tlbi9zY29wZWRcIl0sXG4gICAgc3VzcGVuZEluc3RhbGxhdGlvbjogW1wiUFVUIC9hcHAvaW5zdGFsbGF0aW9ucy97aW5zdGFsbGF0aW9uX2lkfS9zdXNwZW5kZWRcIl0sXG4gICAgdW5zdXNwZW5kSW5zdGFsbGF0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvYXBwL2luc3RhbGxhdGlvbnMve2luc3RhbGxhdGlvbl9pZH0vc3VzcGVuZGVkXCJcbiAgICBdLFxuICAgIHVwZGF0ZVdlYmhvb2tDb25maWdGb3JBcHA6IFtcIlBBVENIIC9hcHAvaG9vay9jb25maWdcIl1cbiAgfSxcbiAgYmlsbGluZzoge1xuICAgIGdldEdpdGh1YkFjdGlvbnNCaWxsaW5nT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vc2V0dGluZ3MvYmlsbGluZy9hY3Rpb25zXCJdLFxuICAgIGdldEdpdGh1YkFjdGlvbnNCaWxsaW5nVXNlcjogW1xuICAgICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc2V0dGluZ3MvYmlsbGluZy9hY3Rpb25zXCJcbiAgICBdLFxuICAgIGdldEdpdGh1YkJpbGxpbmdVc2FnZVJlcG9ydE9yZzogW1xuICAgICAgXCJHRVQgL29yZ2FuaXphdGlvbnMve29yZ30vc2V0dGluZ3MvYmlsbGluZy91c2FnZVwiXG4gICAgXSxcbiAgICBnZXRHaXRodWJCaWxsaW5nVXNhZ2VSZXBvcnRVc2VyOiBbXG4gICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9zZXR0aW5ncy9iaWxsaW5nL3VzYWdlXCJcbiAgICBdLFxuICAgIGdldEdpdGh1YlBhY2thZ2VzQmlsbGluZ09yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3NldHRpbmdzL2JpbGxpbmcvcGFja2FnZXNcIl0sXG4gICAgZ2V0R2l0aHViUGFja2FnZXNCaWxsaW5nVXNlcjogW1xuICAgICAgXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc2V0dGluZ3MvYmlsbGluZy9wYWNrYWdlc1wiXG4gICAgXSxcbiAgICBnZXRTaGFyZWRTdG9yYWdlQmlsbGluZ09yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vc2V0dGluZ3MvYmlsbGluZy9zaGFyZWQtc3RvcmFnZVwiXG4gICAgXSxcbiAgICBnZXRTaGFyZWRTdG9yYWdlQmlsbGluZ1VzZXI6IFtcbiAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3NldHRpbmdzL2JpbGxpbmcvc2hhcmVkLXN0b3JhZ2VcIlxuICAgIF1cbiAgfSxcbiAgY2FtcGFpZ25zOiB7XG4gICAgY3JlYXRlQ2FtcGFpZ246IFtcIlBPU1QgL29yZ3Mve29yZ30vY2FtcGFpZ25zXCJdLFxuICAgIGRlbGV0ZUNhbXBhaWduOiBbXCJERUxFVEUgL29yZ3Mve29yZ30vY2FtcGFpZ25zL3tjYW1wYWlnbl9udW1iZXJ9XCJdLFxuICAgIGdldENhbXBhaWduU3VtbWFyeTogW1wiR0VUIC9vcmdzL3tvcmd9L2NhbXBhaWducy97Y2FtcGFpZ25fbnVtYmVyfVwiXSxcbiAgICBsaXN0T3JnQ2FtcGFpZ25zOiBbXCJHRVQgL29yZ3Mve29yZ30vY2FtcGFpZ25zXCJdLFxuICAgIHVwZGF0ZUNhbXBhaWduOiBbXCJQQVRDSCAvb3Jncy97b3JnfS9jYW1wYWlnbnMve2NhbXBhaWduX251bWJlcn1cIl1cbiAgfSxcbiAgY2hlY2tzOiB7XG4gICAgY3JlYXRlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1ydW5zXCJdLFxuICAgIGNyZWF0ZVN1aXRlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1zdWl0ZXNcIl0sXG4gICAgZ2V0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXJ1bnMve2NoZWNrX3J1bl9pZH1cIl0sXG4gICAgZ2V0U3VpdGU6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stc3VpdGVzL3tjaGVja19zdWl0ZV9pZH1cIl0sXG4gICAgbGlzdEFubm90YXRpb25zOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stcnVucy97Y2hlY2tfcnVuX2lkfS9hbm5vdGF0aW9uc1wiXG4gICAgXSxcbiAgICBsaXN0Rm9yUmVmOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn0vY2hlY2stcnVuc1wiXSxcbiAgICBsaXN0Rm9yU3VpdGU6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jaGVjay1zdWl0ZXMve2NoZWNrX3N1aXRlX2lkfS9jaGVjay1ydW5zXCJcbiAgICBdLFxuICAgIGxpc3RTdWl0ZXNGb3JSZWY6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfS9jaGVjay1zdWl0ZXNcIl0sXG4gICAgcmVyZXF1ZXN0UnVuOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXJ1bnMve2NoZWNrX3J1bl9pZH0vcmVyZXF1ZXN0XCJcbiAgICBdLFxuICAgIHJlcmVxdWVzdFN1aXRlOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXN1aXRlcy97Y2hlY2tfc3VpdGVfaWR9L3JlcmVxdWVzdFwiXG4gICAgXSxcbiAgICBzZXRTdWl0ZXNQcmVmZXJlbmNlczogW1xuICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vY2hlY2stc3VpdGVzL3ByZWZlcmVuY2VzXCJcbiAgICBdLFxuICAgIHVwZGF0ZTogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2NoZWNrLXJ1bnMve2NoZWNrX3J1bl9pZH1cIl1cbiAgfSxcbiAgY29kZVNjYW5uaW5nOiB7XG4gICAgY29tbWl0QXV0b2ZpeDogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfS9hdXRvZml4L2NvbW1pdHNcIlxuICAgIF0sXG4gICAgY3JlYXRlQXV0b2ZpeDogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfS9hdXRvZml4XCJcbiAgICBdLFxuICAgIGNyZWF0ZVZhcmlhbnRBbmFseXNpczogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2NvZGVxbC92YXJpYW50LWFuYWx5c2VzXCJcbiAgICBdLFxuICAgIGRlbGV0ZUFuYWx5c2lzOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbmFseXNlcy97YW5hbHlzaXNfaWR9ez9jb25maXJtX2RlbGV0ZX1cIlxuICAgIF0sXG4gICAgZGVsZXRlQ29kZXFsRGF0YWJhc2U6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2NvZGVxbC9kYXRhYmFzZXMve2xhbmd1YWdlfVwiXG4gICAgXSxcbiAgICBnZXRBbGVydDogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9XCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZFBhcmFtZXRlcnM6IHsgYWxlcnRfaWQ6IFwiYWxlcnRfbnVtYmVyXCIgfSB9XG4gICAgXSxcbiAgICBnZXRBbmFseXNpczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYW5hbHlzZXMve2FuYWx5c2lzX2lkfVwiXG4gICAgXSxcbiAgICBnZXRBdXRvZml4OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbGVydHMve2FsZXJ0X251bWJlcn0vYXV0b2ZpeFwiXG4gICAgXSxcbiAgICBnZXRDb2RlcWxEYXRhYmFzZTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvY29kZXFsL2RhdGFiYXNlcy97bGFuZ3VhZ2V9XCJcbiAgICBdLFxuICAgIGdldERlZmF1bHRTZXR1cDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2RlZmF1bHQtc2V0dXBcIl0sXG4gICAgZ2V0U2FyaWY6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9zYXJpZnMve3NhcmlmX2lkfVwiXSxcbiAgICBnZXRWYXJpYW50QW5hbHlzaXM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2NvZGVxbC92YXJpYW50LWFuYWx5c2VzL3tjb2RlcWxfdmFyaWFudF9hbmFseXNpc19pZH1cIlxuICAgIF0sXG4gICAgZ2V0VmFyaWFudEFuYWx5c2lzUmVwb1Rhc2s6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2NvZGVxbC92YXJpYW50LWFuYWx5c2VzL3tjb2RlcWxfdmFyaWFudF9hbmFseXNpc19pZH0vcmVwb3Mve3JlcG9fb3duZXJ9L3tyZXBvX25hbWV9XCJcbiAgICBdLFxuICAgIGxpc3RBbGVydEluc3RhbmNlczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2luc3RhbmNlc1wiXG4gICAgXSxcbiAgICBsaXN0QWxlcnRzRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vY29kZS1zY2FubmluZy9hbGVydHNcIl0sXG4gICAgbGlzdEFsZXJ0c0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9hbGVydHNcIl0sXG4gICAgbGlzdEFsZXJ0c0luc3RhbmNlczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2luc3RhbmNlc1wiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcImNvZGVTY2FubmluZ1wiLCBcImxpc3RBbGVydEluc3RhbmNlc1wiXSB9XG4gICAgXSxcbiAgICBsaXN0Q29kZXFsRGF0YWJhc2VzOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9jb2RlcWwvZGF0YWJhc2VzXCJcbiAgICBdLFxuICAgIGxpc3RSZWNlbnRBbmFseXNlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FuYWx5c2VzXCJdLFxuICAgIHVwZGF0ZUFsZXJ0OiBbXG4gICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2RlLXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiXG4gICAgXSxcbiAgICB1cGRhdGVEZWZhdWx0U2V0dXA6IFtcbiAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2Nhbm5pbmcvZGVmYXVsdC1zZXR1cFwiXG4gICAgXSxcbiAgICB1cGxvYWRTYXJpZjogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZS1zY2FubmluZy9zYXJpZnNcIl1cbiAgfSxcbiAgY29kZVNlY3VyaXR5OiB7XG4gICAgYXR0YWNoQ29uZmlndXJhdGlvbjogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L2NvZGUtc2VjdXJpdHkvY29uZmlndXJhdGlvbnMve2NvbmZpZ3VyYXRpb25faWR9L2F0dGFjaFwiXG4gICAgXSxcbiAgICBhdHRhY2hFbnRlcnByaXNlQ29uZmlndXJhdGlvbjogW1xuICAgICAgXCJQT1NUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9ucy97Y29uZmlndXJhdGlvbl9pZH0vYXR0YWNoXCJcbiAgICBdLFxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb246IFtcIlBPU1QgL29yZ3Mve29yZ30vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9uc1wiXSxcbiAgICBjcmVhdGVDb25maWd1cmF0aW9uRm9yRW50ZXJwcmlzZTogW1xuICAgICAgXCJQT1NUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9uc1wiXG4gICAgXSxcbiAgICBkZWxldGVDb25maWd1cmF0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9jb2RlLXNlY3VyaXR5L2NvbmZpZ3VyYXRpb25zL3tjb25maWd1cmF0aW9uX2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVDb25maWd1cmF0aW9uRm9yRW50ZXJwcmlzZTogW1xuICAgICAgXCJERUxFVEUgL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9jb2RlLXNlY3VyaXR5L2NvbmZpZ3VyYXRpb25zL3tjb25maWd1cmF0aW9uX2lkfVwiXG4gICAgXSxcbiAgICBkZXRhY2hDb25maWd1cmF0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9jb2RlLXNlY3VyaXR5L2NvbmZpZ3VyYXRpb25zL2RldGFjaFwiXG4gICAgXSxcbiAgICBnZXRDb25maWd1cmF0aW9uOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9jb2RlLXNlY3VyaXR5L2NvbmZpZ3VyYXRpb25zL3tjb25maWd1cmF0aW9uX2lkfVwiXG4gICAgXSxcbiAgICBnZXRDb25maWd1cmF0aW9uRm9yUmVwb3NpdG9yeTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGUtc2VjdXJpdHktY29uZmlndXJhdGlvblwiXG4gICAgXSxcbiAgICBnZXRDb25maWd1cmF0aW9uc0ZvckVudGVycHJpc2U6IFtcbiAgICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9uc1wiXG4gICAgXSxcbiAgICBnZXRDb25maWd1cmF0aW9uc0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2NvZGUtc2VjdXJpdHkvY29uZmlndXJhdGlvbnNcIl0sXG4gICAgZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb25zOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9jb2RlLXNlY3VyaXR5L2NvbmZpZ3VyYXRpb25zL2RlZmF1bHRzXCJcbiAgICBdLFxuICAgIGdldERlZmF1bHRDb25maWd1cmF0aW9uc0ZvckVudGVycHJpc2U6IFtcbiAgICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9ucy9kZWZhdWx0c1wiXG4gICAgXSxcbiAgICBnZXRSZXBvc2l0b3JpZXNGb3JDb25maWd1cmF0aW9uOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9jb2RlLXNlY3VyaXR5L2NvbmZpZ3VyYXRpb25zL3tjb25maWd1cmF0aW9uX2lkfS9yZXBvc2l0b3JpZXNcIlxuICAgIF0sXG4gICAgZ2V0UmVwb3NpdG9yaWVzRm9yRW50ZXJwcmlzZUNvbmZpZ3VyYXRpb246IFtcbiAgICAgIFwiR0VUIC9lbnRlcnByaXNlcy97ZW50ZXJwcmlzZX0vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9ucy97Y29uZmlndXJhdGlvbl9pZH0vcmVwb3NpdG9yaWVzXCJcbiAgICBdLFxuICAgIGdldFNpbmdsZUNvbmZpZ3VyYXRpb25Gb3JFbnRlcnByaXNlOiBbXG4gICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2NvZGUtc2VjdXJpdHkvY29uZmlndXJhdGlvbnMve2NvbmZpZ3VyYXRpb25faWR9XCJcbiAgICBdLFxuICAgIHNldENvbmZpZ3VyYXRpb25Bc0RlZmF1bHQ6IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2NvZGUtc2VjdXJpdHkvY29uZmlndXJhdGlvbnMve2NvbmZpZ3VyYXRpb25faWR9L2RlZmF1bHRzXCJcbiAgICBdLFxuICAgIHNldENvbmZpZ3VyYXRpb25Bc0RlZmF1bHRGb3JFbnRlcnByaXNlOiBbXG4gICAgICBcIlBVVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2NvZGUtc2VjdXJpdHkvY29uZmlndXJhdGlvbnMve2NvbmZpZ3VyYXRpb25faWR9L2RlZmF1bHRzXCJcbiAgICBdLFxuICAgIHVwZGF0ZUNvbmZpZ3VyYXRpb246IFtcbiAgICAgIFwiUEFUQ0ggL29yZ3Mve29yZ30vY29kZS1zZWN1cml0eS9jb25maWd1cmF0aW9ucy97Y29uZmlndXJhdGlvbl9pZH1cIlxuICAgIF0sXG4gICAgdXBkYXRlRW50ZXJwcmlzZUNvbmZpZ3VyYXRpb246IFtcbiAgICAgIFwiUEFUQ0ggL2VudGVycHJpc2VzL3tlbnRlcnByaXNlfS9jb2RlLXNlY3VyaXR5L2NvbmZpZ3VyYXRpb25zL3tjb25maWd1cmF0aW9uX2lkfVwiXG4gICAgXVxuICB9LFxuICBjb2Rlc09mQ29uZHVjdDoge1xuICAgIGdldEFsbENvZGVzT2ZDb25kdWN0OiBbXCJHRVQgL2NvZGVzX29mX2NvbmR1Y3RcIl0sXG4gICAgZ2V0Q29uZHVjdENvZGU6IFtcIkdFVCAvY29kZXNfb2ZfY29uZHVjdC97a2V5fVwiXVxuICB9LFxuICBjb2Rlc3BhY2VzOiB7XG4gICAgYWRkUmVwb3NpdG9yeUZvclNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIlBVVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCJcbiAgICBdLFxuICAgIGFkZFNlbGVjdGVkUmVwb1RvT3JnU2VjcmV0OiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXMve3JlcG9zaXRvcnlfaWR9XCJcbiAgICBdLFxuICAgIGNoZWNrUGVybWlzc2lvbnNGb3JEZXZjb250YWluZXI6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL3Blcm1pc3Npb25zX2NoZWNrXCJcbiAgICBdLFxuICAgIGNvZGVzcGFjZU1hY2hpbmVzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfS9tYWNoaW5lc1wiXG4gICAgXSxcbiAgICBjcmVhdGVGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUE9TVCAvdXNlci9jb2Rlc3BhY2VzXCJdLFxuICAgIGNyZWF0ZU9yVXBkYXRlT3JnU2VjcmV0OiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXG4gICAgXSxcbiAgICBjcmVhdGVPclVwZGF0ZVJlcG9TZWNyZXQ6IFtcbiAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXG4gICAgXSxcbiAgICBjcmVhdGVPclVwZGF0ZVNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIlBVVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXG4gICAgXSxcbiAgICBjcmVhdGVXaXRoUHJGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2NvZGVzcGFjZXNcIlxuICAgIF0sXG4gICAgY3JlYXRlV2l0aFJlcG9Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzXCJcbiAgICBdLFxuICAgIGRlbGV0ZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJERUxFVEUgL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9XCJdLFxuICAgIGRlbGV0ZUZyb21Pcmdhbml6YXRpb246IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L21lbWJlcnMve3VzZXJuYW1lfS9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX1cIlxuICAgIF0sXG4gICAgZGVsZXRlT3JnU2VjcmV0OiBbXCJERUxFVEUgL29yZ3Mve29yZ30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIl0sXG4gICAgZGVsZXRlUmVwb1NlY3JldDogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJcbiAgICBdLFxuICAgIGRlbGV0ZVNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfVwiXG4gICAgXSxcbiAgICBleHBvcnRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJQT1NUIC91c2VyL2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfS9leHBvcnRzXCJcbiAgICBdLFxuICAgIGdldENvZGVzcGFjZXNGb3JVc2VySW5Pcmc6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L21lbWJlcnMve3VzZXJuYW1lfS9jb2Rlc3BhY2VzXCJcbiAgICBdLFxuICAgIGdldEV4cG9ydERldGFpbHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJHRVQgL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9L2V4cG9ydHMve2V4cG9ydF9pZH1cIlxuICAgIF0sXG4gICAgZ2V0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX1cIl0sXG4gICAgZ2V0T3JnUHVibGljS2V5OiBbXCJHRVQgL29yZ3Mve29yZ30vY29kZXNwYWNlcy9zZWNyZXRzL3B1YmxpYy1rZXlcIl0sXG4gICAgZ2V0T3JnU2VjcmV0OiBbXCJHRVQgL29yZ3Mve29yZ30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIl0sXG4gICAgZ2V0UHVibGljS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy9wdWJsaWMta2V5XCJcbiAgICBdLFxuICAgIGdldFJlcG9QdWJsaWNLZXk6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL3NlY3JldHMvcHVibGljLWtleVwiXG4gICAgXSxcbiAgICBnZXRSZXBvU2VjcmV0OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX1cIlxuICAgIF0sXG4gICAgZ2V0U2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJcbiAgICBdLFxuICAgIGxpc3REZXZjb250YWluZXJzSW5SZXBvc2l0b3J5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL2RldmNvbnRhaW5lcnNcIlxuICAgIF0sXG4gICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvY29kZXNwYWNlc1wiXSxcbiAgICBsaXN0SW5Pcmdhbml6YXRpb246IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2NvZGVzcGFjZXNcIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkUGFyYW1ldGVyczogeyBvcmdfaWQ6IFwib3JnXCIgfSB9XG4gICAgXSxcbiAgICBsaXN0SW5SZXBvc2l0b3J5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzXCJcbiAgICBdLFxuICAgIGxpc3RPcmdTZWNyZXRzOiBbXCJHRVQgL29yZ3Mve29yZ30vY29kZXNwYWNlcy9zZWNyZXRzXCJdLFxuICAgIGxpc3RSZXBvU2VjcmV0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL3NlY3JldHNcIl0sXG4gICAgbGlzdFJlcG9zaXRvcmllc0ZvclNlY3JldEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIkdFVCAvdXNlci9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIlxuICAgIF0sXG4gICAgbGlzdFNlY3JldHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0c1wiXSxcbiAgICBsaXN0U2VsZWN0ZWRSZXBvc0Zvck9yZ1NlY3JldDogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzXCJcbiAgICBdLFxuICAgIHByZUZsaWdodFdpdGhSZXBvRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2Rlc3BhY2VzL25ld1wiXG4gICAgXSxcbiAgICBwdWJsaXNoRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiUE9TVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vcHVibGlzaFwiXG4gICAgXSxcbiAgICByZW1vdmVSZXBvc2l0b3J5Rm9yU2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiREVMRVRFIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIlxuICAgIF0sXG4gICAgcmVtb3ZlU2VsZWN0ZWRSZXBvRnJvbU9yZ1NlY3JldDogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vY29kZXNwYWNlcy9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiXG4gICAgXSxcbiAgICByZXBvTWFjaGluZXNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvZGVzcGFjZXMvbWFjaGluZXNcIlxuICAgIF0sXG4gICAgc2V0UmVwb3NpdG9yaWVzRm9yU2VjcmV0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiUFVUIC91c2VyL2NvZGVzcGFjZXMvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllc1wiXG4gICAgXSxcbiAgICBzZXRTZWxlY3RlZFJlcG9zRm9yT3JnU2VjcmV0OiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9jb2Rlc3BhY2VzL3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIlxuICAgIF0sXG4gICAgc3RhcnRGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUE9TVCAvdXNlci9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vc3RhcnRcIl0sXG4gICAgc3RvcEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL2NvZGVzcGFjZXMve2NvZGVzcGFjZV9uYW1lfS9zdG9wXCJdLFxuICAgIHN0b3BJbk9yZ2FuaXphdGlvbjogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L21lbWJlcnMve3VzZXJuYW1lfS9jb2Rlc3BhY2VzL3tjb2Rlc3BhY2VfbmFtZX0vc3RvcFwiXG4gICAgXSxcbiAgICB1cGRhdGVGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUEFUQ0ggL3VzZXIvY29kZXNwYWNlcy97Y29kZXNwYWNlX25hbWV9XCJdXG4gIH0sXG4gIGNvcGlsb3Q6IHtcbiAgICBhZGRDb3BpbG90U2VhdHNGb3JUZWFtczogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L2NvcGlsb3QvYmlsbGluZy9zZWxlY3RlZF90ZWFtc1wiXG4gICAgXSxcbiAgICBhZGRDb3BpbG90U2VhdHNGb3JVc2VyczogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L2NvcGlsb3QvYmlsbGluZy9zZWxlY3RlZF91c2Vyc1wiXG4gICAgXSxcbiAgICBjYW5jZWxDb3BpbG90U2VhdEFzc2lnbm1lbnRGb3JUZWFtczogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vY29waWxvdC9iaWxsaW5nL3NlbGVjdGVkX3RlYW1zXCJcbiAgICBdLFxuICAgIGNhbmNlbENvcGlsb3RTZWF0QXNzaWdubWVudEZvclVzZXJzOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9jb3BpbG90L2JpbGxpbmcvc2VsZWN0ZWRfdXNlcnNcIlxuICAgIF0sXG4gICAgY29waWxvdE1ldHJpY3NGb3JPcmdhbml6YXRpb246IFtcIkdFVCAvb3Jncy97b3JnfS9jb3BpbG90L21ldHJpY3NcIl0sXG4gICAgY29waWxvdE1ldHJpY3NGb3JUZWFtOiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbS97dGVhbV9zbHVnfS9jb3BpbG90L21ldHJpY3NcIl0sXG4gICAgZ2V0Q29waWxvdE9yZ2FuaXphdGlvbkRldGFpbHM6IFtcIkdFVCAvb3Jncy97b3JnfS9jb3BpbG90L2JpbGxpbmdcIl0sXG4gICAgZ2V0Q29waWxvdFNlYXREZXRhaWxzRm9yVXNlcjogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vbWVtYmVycy97dXNlcm5hbWV9L2NvcGlsb3RcIlxuICAgIF0sXG4gICAgbGlzdENvcGlsb3RTZWF0czogW1wiR0VUIC9vcmdzL3tvcmd9L2NvcGlsb3QvYmlsbGluZy9zZWF0c1wiXVxuICB9LFxuICBjcmVkZW50aWFsczogeyByZXZva2U6IFtcIlBPU1QgL2NyZWRlbnRpYWxzL3Jldm9rZVwiXSB9LFxuICBkZXBlbmRhYm90OiB7XG4gICAgYWRkU2VsZWN0ZWRSZXBvVG9PcmdTZWNyZXQ6IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9L3JlcG9zaXRvcmllcy97cmVwb3NpdG9yeV9pZH1cIlxuICAgIF0sXG4gICAgY3JlYXRlT3JVcGRhdGVPcmdTZWNyZXQ6IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJcbiAgICBdLFxuICAgIGNyZWF0ZU9yVXBkYXRlUmVwb1NlY3JldDogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJcbiAgICBdLFxuICAgIGRlbGV0ZU9yZ1NlY3JldDogW1wiREVMRVRFIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJdLFxuICAgIGRlbGV0ZVJlcG9TZWNyZXQ6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiXG4gICAgXSxcbiAgICBnZXRBbGVydDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiXSxcbiAgICBnZXRPcmdQdWJsaWNLZXk6IFtcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMvcHVibGljLWtleVwiXSxcbiAgICBnZXRPcmdTZWNyZXQ6IFtcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfVwiXSxcbiAgICBnZXRSZXBvUHVibGljS2V5OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwZW5kYWJvdC9zZWNyZXRzL3B1YmxpYy1rZXlcIlxuICAgIF0sXG4gICAgZ2V0UmVwb1NlY3JldDogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGFib3Qvc2VjcmV0cy97c2VjcmV0X25hbWV9XCJcbiAgICBdLFxuICAgIGxpc3RBbGVydHNGb3JFbnRlcnByaXNlOiBbXG4gICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L2RlcGVuZGFib3QvYWxlcnRzXCJcbiAgICBdLFxuICAgIGxpc3RBbGVydHNGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L2FsZXJ0c1wiXSxcbiAgICBsaXN0QWxlcnRzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRhYm90L2FsZXJ0c1wiXSxcbiAgICBsaXN0T3JnU2VjcmV0czogW1wiR0VUIC9vcmdzL3tvcmd9L2RlcGVuZGFib3Qvc2VjcmV0c1wiXSxcbiAgICBsaXN0UmVwb1NlY3JldHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwZW5kYWJvdC9zZWNyZXRzXCJdLFxuICAgIGxpc3RTZWxlY3RlZFJlcG9zRm9yT3JnU2VjcmV0OiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIlxuICAgIF0sXG4gICAgcmVtb3ZlU2VsZWN0ZWRSZXBvRnJvbU9yZ1NlY3JldDogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vZGVwZW5kYWJvdC9zZWNyZXRzL3tzZWNyZXRfbmFtZX0vcmVwb3NpdG9yaWVzL3tyZXBvc2l0b3J5X2lkfVwiXG4gICAgXSxcbiAgICBzZXRTZWxlY3RlZFJlcG9zRm9yT3JnU2VjcmV0OiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9kZXBlbmRhYm90L3NlY3JldHMve3NlY3JldF9uYW1lfS9yZXBvc2l0b3JpZXNcIlxuICAgIF0sXG4gICAgdXBkYXRlQWxlcnQ6IFtcbiAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGFib3QvYWxlcnRzL3thbGVydF9udW1iZXJ9XCJcbiAgICBdXG4gIH0sXG4gIGRlcGVuZGVuY3lHcmFwaDoge1xuICAgIGNyZWF0ZVJlcG9zaXRvcnlTbmFwc2hvdDogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRlbmN5LWdyYXBoL3NuYXBzaG90c1wiXG4gICAgXSxcbiAgICBkaWZmUmFuZ2U6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBlbmRlbmN5LWdyYXBoL2NvbXBhcmUve2Jhc2VoZWFkfVwiXG4gICAgXSxcbiAgICBleHBvcnRTYm9tOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGVuZGVuY3ktZ3JhcGgvc2JvbVwiXVxuICB9LFxuICBlbW9qaXM6IHsgZ2V0OiBbXCJHRVQgL2Vtb2ppc1wiXSB9LFxuICBnaXN0czoge1xuICAgIGNoZWNrSXNTdGFycmVkOiBbXCJHRVQgL2dpc3RzL3tnaXN0X2lkfS9zdGFyXCJdLFxuICAgIGNyZWF0ZTogW1wiUE9TVCAvZ2lzdHNcIl0sXG4gICAgY3JlYXRlQ29tbWVudDogW1wiUE9TVCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzXCJdLFxuICAgIGRlbGV0ZTogW1wiREVMRVRFIC9naXN0cy97Z2lzdF9pZH1cIl0sXG4gICAgZGVsZXRlQ29tbWVudDogW1wiREVMRVRFIC9naXN0cy97Z2lzdF9pZH0vY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgIGZvcms6IFtcIlBPU1QgL2dpc3RzL3tnaXN0X2lkfS9mb3Jrc1wiXSxcbiAgICBnZXQ6IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9XCJdLFxuICAgIGdldENvbW1lbnQ6IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICBnZXRSZXZpc2lvbjogW1wiR0VUIC9naXN0cy97Z2lzdF9pZH0ve3NoYX1cIl0sXG4gICAgbGlzdDogW1wiR0VUIC9naXN0c1wiXSxcbiAgICBsaXN0Q29tbWVudHM6IFtcIkdFVCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzXCJdLFxuICAgIGxpc3RDb21taXRzOiBbXCJHRVQgL2dpc3RzL3tnaXN0X2lkfS9jb21taXRzXCJdLFxuICAgIGxpc3RGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZ2lzdHNcIl0sXG4gICAgbGlzdEZvcmtzOiBbXCJHRVQgL2dpc3RzL3tnaXN0X2lkfS9mb3Jrc1wiXSxcbiAgICBsaXN0UHVibGljOiBbXCJHRVQgL2dpc3RzL3B1YmxpY1wiXSxcbiAgICBsaXN0U3RhcnJlZDogW1wiR0VUIC9naXN0cy9zdGFycmVkXCJdLFxuICAgIHN0YXI6IFtcIlBVVCAvZ2lzdHMve2dpc3RfaWR9L3N0YXJcIl0sXG4gICAgdW5zdGFyOiBbXCJERUxFVEUgL2dpc3RzL3tnaXN0X2lkfS9zdGFyXCJdLFxuICAgIHVwZGF0ZTogW1wiUEFUQ0ggL2dpc3RzL3tnaXN0X2lkfVwiXSxcbiAgICB1cGRhdGVDb21tZW50OiBbXCJQQVRDSCAvZ2lzdHMve2dpc3RfaWR9L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXVxuICB9LFxuICBnaXQ6IHtcbiAgICBjcmVhdGVCbG9iOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvYmxvYnNcIl0sXG4gICAgY3JlYXRlQ29tbWl0OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvY29tbWl0c1wiXSxcbiAgICBjcmVhdGVSZWY6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9yZWZzXCJdLFxuICAgIGNyZWF0ZVRhZzogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RhZ3NcIl0sXG4gICAgY3JlYXRlVHJlZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RyZWVzXCJdLFxuICAgIGRlbGV0ZVJlZjogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvcmVmcy97cmVmfVwiXSxcbiAgICBnZXRCbG9iOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9icy97ZmlsZV9zaGF9XCJdLFxuICAgIGdldENvbW1pdDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvY29tbWl0cy97Y29tbWl0X3NoYX1cIl0sXG4gICAgZ2V0UmVmOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9yZWYve3JlZn1cIl0sXG4gICAgZ2V0VGFnOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90YWdzL3t0YWdfc2hhfVwiXSxcbiAgICBnZXRUcmVlOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90cmVlcy97dHJlZV9zaGF9XCJdLFxuICAgIGxpc3RNYXRjaGluZ1JlZnM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L21hdGNoaW5nLXJlZnMve3JlZn1cIl0sXG4gICAgdXBkYXRlUmVmOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZnMve3JlZn1cIl1cbiAgfSxcbiAgZ2l0aWdub3JlOiB7XG4gICAgZ2V0QWxsVGVtcGxhdGVzOiBbXCJHRVQgL2dpdGlnbm9yZS90ZW1wbGF0ZXNcIl0sXG4gICAgZ2V0VGVtcGxhdGU6IFtcIkdFVCAvZ2l0aWdub3JlL3RlbXBsYXRlcy97bmFtZX1cIl1cbiAgfSxcbiAgaG9zdGVkQ29tcHV0ZToge1xuICAgIGNyZWF0ZU5ldHdvcmtDb25maWd1cmF0aW9uRm9yT3JnOiBbXG4gICAgICBcIlBPU1QgL29yZ3Mve29yZ30vc2V0dGluZ3MvbmV0d29yay1jb25maWd1cmF0aW9uc1wiXG4gICAgXSxcbiAgICBkZWxldGVOZXR3b3JrQ29uZmlndXJhdGlvbkZyb21Pcmc6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3NldHRpbmdzL25ldHdvcmstY29uZmlndXJhdGlvbnMve25ldHdvcmtfY29uZmlndXJhdGlvbl9pZH1cIlxuICAgIF0sXG4gICAgZ2V0TmV0d29ya0NvbmZpZ3VyYXRpb25Gb3JPcmc6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3NldHRpbmdzL25ldHdvcmstY29uZmlndXJhdGlvbnMve25ldHdvcmtfY29uZmlndXJhdGlvbl9pZH1cIlxuICAgIF0sXG4gICAgZ2V0TmV0d29ya1NldHRpbmdzRm9yT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9zZXR0aW5ncy9uZXR3b3JrLXNldHRpbmdzL3tuZXR3b3JrX3NldHRpbmdzX2lkfVwiXG4gICAgXSxcbiAgICBsaXN0TmV0d29ya0NvbmZpZ3VyYXRpb25zRm9yT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9zZXR0aW5ncy9uZXR3b3JrLWNvbmZpZ3VyYXRpb25zXCJcbiAgICBdLFxuICAgIHVwZGF0ZU5ldHdvcmtDb25maWd1cmF0aW9uRm9yT3JnOiBbXG4gICAgICBcIlBBVENIIC9vcmdzL3tvcmd9L3NldHRpbmdzL25ldHdvcmstY29uZmlndXJhdGlvbnMve25ldHdvcmtfY29uZmlndXJhdGlvbl9pZH1cIlxuICAgIF1cbiAgfSxcbiAgaW50ZXJhY3Rpb25zOiB7XG4gICAgZ2V0UmVzdHJpY3Rpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgZ2V0UmVzdHJpY3Rpb25zRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgIGdldFJlc3RyaWN0aW9uc0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgIGdldFJlc3RyaWN0aW9uc0ZvcllvdXJQdWJsaWNSZXBvczogW1xuICAgICAgXCJHRVQgL3VzZXIvaW50ZXJhY3Rpb24tbGltaXRzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1wiaW50ZXJhY3Rpb25zXCIsIFwiZ2V0UmVzdHJpY3Rpb25zRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgcmVtb3ZlUmVzdHJpY3Rpb25zRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgcmVtb3ZlUmVzdHJpY3Rpb25zRm9yT3JnOiBbXCJERUxFVEUgL29yZ3Mve29yZ30vaW50ZXJhY3Rpb24tbGltaXRzXCJdLFxuICAgIHJlbW92ZVJlc3RyaWN0aW9uc0ZvclJlcG86IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnRlcmFjdGlvbi1saW1pdHNcIlxuICAgIF0sXG4gICAgcmVtb3ZlUmVzdHJpY3Rpb25zRm9yWW91clB1YmxpY1JlcG9zOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJpbnRlcmFjdGlvbnNcIiwgXCJyZW1vdmVSZXN0cmljdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9XG4gICAgXSxcbiAgICBzZXRSZXN0cmljdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUFVUIC91c2VyL2ludGVyYWN0aW9uLWxpbWl0c1wiXSxcbiAgICBzZXRSZXN0cmljdGlvbnNGb3JPcmc6IFtcIlBVVCAvb3Jncy97b3JnfS9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgc2V0UmVzdHJpY3Rpb25zRm9yUmVwbzogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnRlcmFjdGlvbi1saW1pdHNcIl0sXG4gICAgc2V0UmVzdHJpY3Rpb25zRm9yWW91clB1YmxpY1JlcG9zOiBbXG4gICAgICBcIlBVVCAvdXNlci9pbnRlcmFjdGlvbi1saW1pdHNcIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJpbnRlcmFjdGlvbnNcIiwgXCJzZXRSZXN0cmljdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9XG4gICAgXVxuICB9LFxuICBpc3N1ZXM6IHtcbiAgICBhZGRBc3NpZ25lZXM6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2Fzc2lnbmVlc1wiXG4gICAgXSxcbiAgICBhZGRMYWJlbHM6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9sYWJlbHNcIl0sXG4gICAgYWRkU3ViSXNzdWU6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3N1Yl9pc3N1ZXNcIlxuICAgIF0sXG4gICAgY2hlY2tVc2VyQ2FuQmVBc3NpZ25lZDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hc3NpZ25lZXMve2Fzc2lnbmVlfVwiXSxcbiAgICBjaGVja1VzZXJDYW5CZUFzc2lnbmVkVG9Jc3N1ZTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9hc3NpZ25lZXMve2Fzc2lnbmVlfVwiXG4gICAgXSxcbiAgICBjcmVhdGU6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlc1wiXSxcbiAgICBjcmVhdGVDb21tZW50OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9jb21tZW50c1wiXG4gICAgXSxcbiAgICBjcmVhdGVMYWJlbDogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vbGFiZWxzXCJdLFxuICAgIGNyZWF0ZU1pbGVzdG9uZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWlsZXN0b25lc1wiXSxcbiAgICBkZWxldGVDb21tZW50OiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVMYWJlbDogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHMve25hbWV9XCJdLFxuICAgIGRlbGV0ZU1pbGVzdG9uZTogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXMve21pbGVzdG9uZV9udW1iZXJ9XCJcbiAgICBdLFxuICAgIGdldDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn1cIl0sXG4gICAgZ2V0Q29tbWVudDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgIGdldEV2ZW50OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy9ldmVudHMve2V2ZW50X2lkfVwiXSxcbiAgICBnZXRMYWJlbDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHMve25hbWV9XCJdLFxuICAgIGdldE1pbGVzdG9uZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9taWxlc3RvbmVzL3ttaWxlc3RvbmVfbnVtYmVyfVwiXSxcbiAgICBsaXN0OiBbXCJHRVQgL2lzc3Vlc1wiXSxcbiAgICBsaXN0QXNzaWduZWVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Fzc2lnbmVlc1wiXSxcbiAgICBsaXN0Q29tbWVudHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2NvbW1lbnRzXCJdLFxuICAgIGxpc3RDb21tZW50c0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzXCJdLFxuICAgIGxpc3RFdmVudHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2V2ZW50c1wiXSxcbiAgICBsaXN0RXZlbnRzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvZXZlbnRzXCJdLFxuICAgIGxpc3RFdmVudHNGb3JUaW1lbGluZTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS90aW1lbGluZVwiXG4gICAgXSxcbiAgICBsaXN0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9pc3N1ZXNcIl0sXG4gICAgbGlzdEZvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L2lzc3Vlc1wiXSxcbiAgICBsaXN0Rm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXNcIl0sXG4gICAgbGlzdExhYmVsc0Zvck1pbGVzdG9uZTogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXMve21pbGVzdG9uZV9udW1iZXJ9L2xhYmVsc1wiXG4gICAgXSxcbiAgICBsaXN0TGFiZWxzRm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYWJlbHNcIl0sXG4gICAgbGlzdExhYmVsc09uSXNzdWU6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vbGFiZWxzXCJcbiAgICBdLFxuICAgIGxpc3RNaWxlc3RvbmVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXNcIl0sXG4gICAgbGlzdFN1Yklzc3VlczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9zdWJfaXNzdWVzXCJcbiAgICBdLFxuICAgIGxvY2s6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xvY2tcIl0sXG4gICAgcmVtb3ZlQWxsTGFiZWxzOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVsc1wiXG4gICAgXSxcbiAgICByZW1vdmVBc3NpZ25lZXM6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vYXNzaWduZWVzXCJcbiAgICBdLFxuICAgIHJlbW92ZUxhYmVsOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVscy97bmFtZX1cIlxuICAgIF0sXG4gICAgcmVtb3ZlU3ViSXNzdWU6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vc3ViX2lzc3VlXCJcbiAgICBdLFxuICAgIHJlcHJpb3JpdGl6ZVN1Yklzc3VlOiBbXG4gICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMve2lzc3VlX251bWJlcn0vc3ViX2lzc3Vlcy9wcmlvcml0eVwiXG4gICAgXSxcbiAgICBzZXRMYWJlbHM6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xhYmVsc1wiXSxcbiAgICB1bmxvY2s6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L2xvY2tcIl0sXG4gICAgdXBkYXRlOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9XCJdLFxuICAgIHVwZGF0ZUNvbW1lbnQ6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9XCJdLFxuICAgIHVwZGF0ZUxhYmVsOiBbXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vbGFiZWxzL3tuYW1lfVwiXSxcbiAgICB1cGRhdGVNaWxlc3RvbmU6IFtcbiAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L21pbGVzdG9uZXMve21pbGVzdG9uZV9udW1iZXJ9XCJcbiAgICBdXG4gIH0sXG4gIGxpY2Vuc2VzOiB7XG4gICAgZ2V0OiBbXCJHRVQgL2xpY2Vuc2VzL3tsaWNlbnNlfVwiXSxcbiAgICBnZXRBbGxDb21tb25seVVzZWQ6IFtcIkdFVCAvbGljZW5zZXNcIl0sXG4gICAgZ2V0Rm9yUmVwbzogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9saWNlbnNlXCJdXG4gIH0sXG4gIG1hcmtkb3duOiB7XG4gICAgcmVuZGVyOiBbXCJQT1NUIC9tYXJrZG93blwiXSxcbiAgICByZW5kZXJSYXc6IFtcbiAgICAgIFwiUE9TVCAvbWFya2Rvd24vcmF3XCIsXG4gICAgICB7IGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIgfSB9XG4gICAgXVxuICB9LFxuICBtZXRhOiB7XG4gICAgZ2V0OiBbXCJHRVQgL21ldGFcIl0sXG4gICAgZ2V0QWxsVmVyc2lvbnM6IFtcIkdFVCAvdmVyc2lvbnNcIl0sXG4gICAgZ2V0T2N0b2NhdDogW1wiR0VUIC9vY3RvY2F0XCJdLFxuICAgIGdldFplbjogW1wiR0VUIC96ZW5cIl0sXG4gICAgcm9vdDogW1wiR0VUIC9cIl1cbiAgfSxcbiAgbWlncmF0aW9uczoge1xuICAgIGRlbGV0ZUFyY2hpdmVGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJERUxFVEUgL3VzZXIvbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfS9hcmNoaXZlXCJcbiAgICBdLFxuICAgIGRlbGV0ZUFyY2hpdmVGb3JPcmc6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vYXJjaGl2ZVwiXG4gICAgXSxcbiAgICBkb3dubG9hZEFyY2hpdmVGb3JPcmc6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vYXJjaGl2ZVwiXG4gICAgXSxcbiAgICBnZXRBcmNoaXZlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vYXJjaGl2ZVwiXG4gICAgXSxcbiAgICBnZXRTdGF0dXNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH1cIl0sXG4gICAgZ2V0U3RhdHVzRm9yT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vbWlncmF0aW9ucy97bWlncmF0aW9uX2lkfVwiXSxcbiAgICBsaXN0Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9taWdyYXRpb25zXCJdLFxuICAgIGxpc3RGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9taWdyYXRpb25zXCJdLFxuICAgIGxpc3RSZXBvc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIkdFVCAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiXG4gICAgXSxcbiAgICBsaXN0UmVwb3NGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiXSxcbiAgICBsaXN0UmVwb3NGb3JVc2VyOiBbXG4gICAgICBcIkdFVCAvdXNlci9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zaXRvcmllc1wiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcIm1pZ3JhdGlvbnNcIiwgXCJsaXN0UmVwb3NGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9XG4gICAgXSxcbiAgICBzdGFydEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL21pZ3JhdGlvbnNcIl0sXG4gICAgc3RhcnRGb3JPcmc6IFtcIlBPU1QgL29yZ3Mve29yZ30vbWlncmF0aW9uc1wiXSxcbiAgICB1bmxvY2tSZXBvRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiREVMRVRFIC91c2VyL21pZ3JhdGlvbnMve21pZ3JhdGlvbl9pZH0vcmVwb3Mve3JlcG9fbmFtZX0vbG9ja1wiXG4gICAgXSxcbiAgICB1bmxvY2tSZXBvRm9yT3JnOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9taWdyYXRpb25zL3ttaWdyYXRpb25faWR9L3JlcG9zL3tyZXBvX25hbWV9L2xvY2tcIlxuICAgIF1cbiAgfSxcbiAgb2lkYzoge1xuICAgIGdldE9pZGNDdXN0b21TdWJUZW1wbGF0ZUZvck9yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vYWN0aW9ucy9vaWRjL2N1c3RvbWl6YXRpb24vc3ViXCJcbiAgICBdLFxuICAgIHVwZGF0ZU9pZGNDdXN0b21TdWJUZW1wbGF0ZUZvck9yZzogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vYWN0aW9ucy9vaWRjL2N1c3RvbWl6YXRpb24vc3ViXCJcbiAgICBdXG4gIH0sXG4gIG9yZ3M6IHtcbiAgICBhZGRTZWN1cml0eU1hbmFnZXJUZWFtOiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9zZWN1cml0eS1tYW5hZ2Vycy90ZWFtcy97dGVhbV9zbHVnfVwiLFxuICAgICAge30sXG4gICAgICB7XG4gICAgICAgIGRlcHJlY2F0ZWQ6IFwib2N0b2tpdC5yZXN0Lm9yZ3MuYWRkU2VjdXJpdHlNYW5hZ2VyVGVhbSgpIGlzIGRlcHJlY2F0ZWQsIHNlZSBodHRwczovL2RvY3MuZ2l0aHViLmNvbS9yZXN0L29yZ3Mvc2VjdXJpdHktbWFuYWdlcnMjYWRkLWEtc2VjdXJpdHktbWFuYWdlci10ZWFtXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGFzc2lnblRlYW1Ub09yZ1JvbGU6IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L29yZ2FuaXphdGlvbi1yb2xlcy90ZWFtcy97dGVhbV9zbHVnfS97cm9sZV9pZH1cIlxuICAgIF0sXG4gICAgYXNzaWduVXNlclRvT3JnUm9sZTogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vb3JnYW5pemF0aW9uLXJvbGVzL3VzZXJzL3t1c2VybmFtZX0ve3JvbGVfaWR9XCJcbiAgICBdLFxuICAgIGJsb2NrVXNlcjogW1wiUFVUIC9vcmdzL3tvcmd9L2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgIGNhbmNlbEludml0YXRpb246IFtcIkRFTEVURSAvb3Jncy97b3JnfS9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH1cIl0sXG4gICAgY2hlY2tCbG9ja2VkVXNlcjogW1wiR0VUIC9vcmdzL3tvcmd9L2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgIGNoZWNrTWVtYmVyc2hpcEZvclVzZXI6IFtcIkdFVCAvb3Jncy97b3JnfS9tZW1iZXJzL3t1c2VybmFtZX1cIl0sXG4gICAgY2hlY2tQdWJsaWNNZW1iZXJzaGlwRm9yVXNlcjogW1wiR0VUIC9vcmdzL3tvcmd9L3B1YmxpY19tZW1iZXJzL3t1c2VybmFtZX1cIl0sXG4gICAgY29udmVydE1lbWJlclRvT3V0c2lkZUNvbGxhYm9yYXRvcjogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vb3V0c2lkZV9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX1cIlxuICAgIF0sXG4gICAgY3JlYXRlSW52aXRhdGlvbjogW1wiUE9TVCAvb3Jncy97b3JnfS9pbnZpdGF0aW9uc1wiXSxcbiAgICBjcmVhdGVJc3N1ZVR5cGU6IFtcIlBPU1QgL29yZ3Mve29yZ30vaXNzdWUtdHlwZXNcIl0sXG4gICAgY3JlYXRlT3JVcGRhdGVDdXN0b21Qcm9wZXJ0aWVzOiBbXCJQQVRDSCAvb3Jncy97b3JnfS9wcm9wZXJ0aWVzL3NjaGVtYVwiXSxcbiAgICBjcmVhdGVPclVwZGF0ZUN1c3RvbVByb3BlcnRpZXNWYWx1ZXNGb3JSZXBvczogW1xuICAgICAgXCJQQVRDSCAvb3Jncy97b3JnfS9wcm9wZXJ0aWVzL3ZhbHVlc1wiXG4gICAgXSxcbiAgICBjcmVhdGVPclVwZGF0ZUN1c3RvbVByb3BlcnR5OiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS9wcm9wZXJ0aWVzL3NjaGVtYS97Y3VzdG9tX3Byb3BlcnR5X25hbWV9XCJcbiAgICBdLFxuICAgIGNyZWF0ZVdlYmhvb2s6IFtcIlBPU1QgL29yZ3Mve29yZ30vaG9va3NcIl0sXG4gICAgZGVsZXRlOiBbXCJERUxFVEUgL29yZ3Mve29yZ31cIl0sXG4gICAgZGVsZXRlSXNzdWVUeXBlOiBbXCJERUxFVEUgL29yZ3Mve29yZ30vaXNzdWUtdHlwZXMve2lzc3VlX3R5cGVfaWR9XCJdLFxuICAgIGRlbGV0ZVdlYmhvb2s6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgZW5hYmxlT3JEaXNhYmxlU2VjdXJpdHlQcm9kdWN0T25BbGxPcmdSZXBvczogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L3tzZWN1cml0eV9wcm9kdWN0fS97ZW5hYmxlbWVudH1cIixcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICBkZXByZWNhdGVkOiBcIm9jdG9raXQucmVzdC5vcmdzLmVuYWJsZU9yRGlzYWJsZVNlY3VyaXR5UHJvZHVjdE9uQWxsT3JnUmVwb3MoKSBpcyBkZXByZWNhdGVkLCBzZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vcmVzdC9vcmdzL29yZ3MjZW5hYmxlLW9yLWRpc2FibGUtYS1zZWN1cml0eS1mZWF0dXJlLWZvci1hbi1vcmdhbml6YXRpb25cIlxuICAgICAgfVxuICAgIF0sXG4gICAgZ2V0OiBbXCJHRVQgL29yZ3Mve29yZ31cIl0sXG4gICAgZ2V0QWxsQ3VzdG9tUHJvcGVydGllczogW1wiR0VUIC9vcmdzL3tvcmd9L3Byb3BlcnRpZXMvc2NoZW1hXCJdLFxuICAgIGdldEN1c3RvbVByb3BlcnR5OiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9wcm9wZXJ0aWVzL3NjaGVtYS97Y3VzdG9tX3Byb3BlcnR5X25hbWV9XCJcbiAgICBdLFxuICAgIGdldE1lbWJlcnNoaXBGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL21lbWJlcnNoaXBzL29yZ3Mve29yZ31cIl0sXG4gICAgZ2V0TWVtYmVyc2hpcEZvclVzZXI6IFtcIkdFVCAvb3Jncy97b3JnfS9tZW1iZXJzaGlwcy97dXNlcm5hbWV9XCJdLFxuICAgIGdldE9yZ1JvbGU6IFtcIkdFVCAvb3Jncy97b3JnfS9vcmdhbml6YXRpb24tcm9sZXMve3JvbGVfaWR9XCJdLFxuICAgIGdldE9yZ1J1bGVzZXRIaXN0b3J5OiBbXCJHRVQgL29yZ3Mve29yZ30vcnVsZXNldHMve3J1bGVzZXRfaWR9L2hpc3RvcnlcIl0sXG4gICAgZ2V0T3JnUnVsZXNldFZlcnNpb246IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3J1bGVzZXRzL3tydWxlc2V0X2lkfS9oaXN0b3J5L3t2ZXJzaW9uX2lkfVwiXG4gICAgXSxcbiAgICBnZXRXZWJob29rOiBbXCJHRVQgL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9XCJdLFxuICAgIGdldFdlYmhvb2tDb25maWdGb3JPcmc6IFtcIkdFVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vY29uZmlnXCJdLFxuICAgIGdldFdlYmhvb2tEZWxpdmVyeTogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfVwiXG4gICAgXSxcbiAgICBsaXN0OiBbXCJHRVQgL29yZ2FuaXphdGlvbnNcIl0sXG4gICAgbGlzdEFwcEluc3RhbGxhdGlvbnM6IFtcIkdFVCAvb3Jncy97b3JnfS9pbnN0YWxsYXRpb25zXCJdLFxuICAgIGxpc3RBdHRlc3RhdGlvbnM6IFtcIkdFVCAvb3Jncy97b3JnfS9hdHRlc3RhdGlvbnMve3N1YmplY3RfZGlnZXN0fVwiXSxcbiAgICBsaXN0QmxvY2tlZFVzZXJzOiBbXCJHRVQgL29yZ3Mve29yZ30vYmxvY2tzXCJdLFxuICAgIGxpc3RDdXN0b21Qcm9wZXJ0aWVzVmFsdWVzRm9yUmVwb3M6IFtcIkdFVCAvb3Jncy97b3JnfS9wcm9wZXJ0aWVzL3ZhbHVlc1wiXSxcbiAgICBsaXN0RmFpbGVkSW52aXRhdGlvbnM6IFtcIkdFVCAvb3Jncy97b3JnfS9mYWlsZWRfaW52aXRhdGlvbnNcIl0sXG4gICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvb3Jnc1wiXSxcbiAgICBsaXN0Rm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L29yZ3NcIl0sXG4gICAgbGlzdEludml0YXRpb25UZWFtczogW1wiR0VUIC9vcmdzL3tvcmd9L2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfS90ZWFtc1wiXSxcbiAgICBsaXN0SXNzdWVUeXBlczogW1wiR0VUIC9vcmdzL3tvcmd9L2lzc3VlLXR5cGVzXCJdLFxuICAgIGxpc3RNZW1iZXJzOiBbXCJHRVQgL29yZ3Mve29yZ30vbWVtYmVyc1wiXSxcbiAgICBsaXN0TWVtYmVyc2hpcHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL21lbWJlcnNoaXBzL29yZ3NcIl0sXG4gICAgbGlzdE9yZ1JvbGVUZWFtczogW1wiR0VUIC9vcmdzL3tvcmd9L29yZ2FuaXphdGlvbi1yb2xlcy97cm9sZV9pZH0vdGVhbXNcIl0sXG4gICAgbGlzdE9yZ1JvbGVVc2VyczogW1wiR0VUIC9vcmdzL3tvcmd9L29yZ2FuaXphdGlvbi1yb2xlcy97cm9sZV9pZH0vdXNlcnNcIl0sXG4gICAgbGlzdE9yZ1JvbGVzOiBbXCJHRVQgL29yZ3Mve29yZ30vb3JnYW5pemF0aW9uLXJvbGVzXCJdLFxuICAgIGxpc3RPcmdhbml6YXRpb25GaW5lR3JhaW5lZFBlcm1pc3Npb25zOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9vcmdhbml6YXRpb24tZmluZS1ncmFpbmVkLXBlcm1pc3Npb25zXCJcbiAgICBdLFxuICAgIGxpc3RPdXRzaWRlQ29sbGFib3JhdG9yczogW1wiR0VUIC9vcmdzL3tvcmd9L291dHNpZGVfY29sbGFib3JhdG9yc1wiXSxcbiAgICBsaXN0UGF0R3JhbnRSZXBvc2l0b3JpZXM6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3BlcnNvbmFsLWFjY2Vzcy10b2tlbnMve3BhdF9pZH0vcmVwb3NpdG9yaWVzXCJcbiAgICBdLFxuICAgIGxpc3RQYXRHcmFudFJlcXVlc3RSZXBvc2l0b3JpZXM6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3BlcnNvbmFsLWFjY2Vzcy10b2tlbi1yZXF1ZXN0cy97cGF0X3JlcXVlc3RfaWR9L3JlcG9zaXRvcmllc1wiXG4gICAgXSxcbiAgICBsaXN0UGF0R3JhbnRSZXF1ZXN0czogW1wiR0VUIC9vcmdzL3tvcmd9L3BlcnNvbmFsLWFjY2Vzcy10b2tlbi1yZXF1ZXN0c1wiXSxcbiAgICBsaXN0UGF0R3JhbnRzOiBbXCJHRVQgL29yZ3Mve29yZ30vcGVyc29uYWwtYWNjZXNzLXRva2Vuc1wiXSxcbiAgICBsaXN0UGVuZGluZ0ludml0YXRpb25zOiBbXCJHRVQgL29yZ3Mve29yZ30vaW52aXRhdGlvbnNcIl0sXG4gICAgbGlzdFB1YmxpY01lbWJlcnM6IFtcIkdFVCAvb3Jncy97b3JnfS9wdWJsaWNfbWVtYmVyc1wiXSxcbiAgICBsaXN0U2VjdXJpdHlNYW5hZ2VyVGVhbXM6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3NlY3VyaXR5LW1hbmFnZXJzXCIsXG4gICAgICB7fSxcbiAgICAgIHtcbiAgICAgICAgZGVwcmVjYXRlZDogXCJvY3Rva2l0LnJlc3Qub3Jncy5saXN0U2VjdXJpdHlNYW5hZ2VyVGVhbXMoKSBpcyBkZXByZWNhdGVkLCBzZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vcmVzdC9vcmdzL3NlY3VyaXR5LW1hbmFnZXJzI2xpc3Qtc2VjdXJpdHktbWFuYWdlci10ZWFtc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBsaXN0V2ViaG9va0RlbGl2ZXJpZXM6IFtcIkdFVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vZGVsaXZlcmllc1wiXSxcbiAgICBsaXN0V2ViaG9va3M6IFtcIkdFVCAvb3Jncy97b3JnfS9ob29rc1wiXSxcbiAgICBwaW5nV2ViaG9vazogW1wiUE9TVCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vcGluZ3NcIl0sXG4gICAgcmVkZWxpdmVyV2ViaG9va0RlbGl2ZXJ5OiBbXG4gICAgICBcIlBPU1QgL29yZ3Mve29yZ30vaG9va3Mve2hvb2tfaWR9L2RlbGl2ZXJpZXMve2RlbGl2ZXJ5X2lkfS9hdHRlbXB0c1wiXG4gICAgXSxcbiAgICByZW1vdmVDdXN0b21Qcm9wZXJ0eTogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vcHJvcGVydGllcy9zY2hlbWEve2N1c3RvbV9wcm9wZXJ0eV9uYW1lfVwiXG4gICAgXSxcbiAgICByZW1vdmVNZW1iZXI6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9tZW1iZXJzL3t1c2VybmFtZX1cIl0sXG4gICAgcmVtb3ZlTWVtYmVyc2hpcEZvclVzZXI6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9tZW1iZXJzaGlwcy97dXNlcm5hbWV9XCJdLFxuICAgIHJlbW92ZU91dHNpZGVDb2xsYWJvcmF0b3I6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L291dHNpZGVfY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCJcbiAgICBdLFxuICAgIHJlbW92ZVB1YmxpY01lbWJlcnNoaXBGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vcHVibGljX21lbWJlcnMve3VzZXJuYW1lfVwiXG4gICAgXSxcbiAgICByZW1vdmVTZWN1cml0eU1hbmFnZXJUZWFtOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9zZWN1cml0eS1tYW5hZ2Vycy90ZWFtcy97dGVhbV9zbHVnfVwiLFxuICAgICAge30sXG4gICAgICB7XG4gICAgICAgIGRlcHJlY2F0ZWQ6IFwib2N0b2tpdC5yZXN0Lm9yZ3MucmVtb3ZlU2VjdXJpdHlNYW5hZ2VyVGVhbSgpIGlzIGRlcHJlY2F0ZWQsIHNlZSBodHRwczovL2RvY3MuZ2l0aHViLmNvbS9yZXN0L29yZ3Mvc2VjdXJpdHktbWFuYWdlcnMjcmVtb3ZlLWEtc2VjdXJpdHktbWFuYWdlci10ZWFtXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHJldmlld1BhdEdyYW50UmVxdWVzdDogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L3BlcnNvbmFsLWFjY2Vzcy10b2tlbi1yZXF1ZXN0cy97cGF0X3JlcXVlc3RfaWR9XCJcbiAgICBdLFxuICAgIHJldmlld1BhdEdyYW50UmVxdWVzdHNJbkJ1bGs6IFtcbiAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9wZXJzb25hbC1hY2Nlc3MtdG9rZW4tcmVxdWVzdHNcIlxuICAgIF0sXG4gICAgcmV2b2tlQWxsT3JnUm9sZXNUZWFtOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9vcmdhbml6YXRpb24tcm9sZXMvdGVhbXMve3RlYW1fc2x1Z31cIlxuICAgIF0sXG4gICAgcmV2b2tlQWxsT3JnUm9sZXNVc2VyOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9vcmdhbml6YXRpb24tcm9sZXMvdXNlcnMve3VzZXJuYW1lfVwiXG4gICAgXSxcbiAgICByZXZva2VPcmdSb2xlVGVhbTogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vb3JnYW5pemF0aW9uLXJvbGVzL3RlYW1zL3t0ZWFtX3NsdWd9L3tyb2xlX2lkfVwiXG4gICAgXSxcbiAgICByZXZva2VPcmdSb2xlVXNlcjogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vb3JnYW5pemF0aW9uLXJvbGVzL3VzZXJzL3t1c2VybmFtZX0ve3JvbGVfaWR9XCJcbiAgICBdLFxuICAgIHNldE1lbWJlcnNoaXBGb3JVc2VyOiBbXCJQVVQgL29yZ3Mve29yZ30vbWVtYmVyc2hpcHMve3VzZXJuYW1lfVwiXSxcbiAgICBzZXRQdWJsaWNNZW1iZXJzaGlwRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiUFVUIC9vcmdzL3tvcmd9L3B1YmxpY19tZW1iZXJzL3t1c2VybmFtZX1cIlxuICAgIF0sXG4gICAgdW5ibG9ja1VzZXI6IFtcIkRFTEVURSAvb3Jncy97b3JnfS9ibG9ja3Mve3VzZXJuYW1lfVwiXSxcbiAgICB1cGRhdGU6IFtcIlBBVENIIC9vcmdzL3tvcmd9XCJdLFxuICAgIHVwZGF0ZUlzc3VlVHlwZTogW1wiUFVUIC9vcmdzL3tvcmd9L2lzc3VlLXR5cGVzL3tpc3N1ZV90eXBlX2lkfVwiXSxcbiAgICB1cGRhdGVNZW1iZXJzaGlwRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiUEFUQ0ggL3VzZXIvbWVtYmVyc2hpcHMvb3Jncy97b3JnfVwiXG4gICAgXSxcbiAgICB1cGRhdGVQYXRBY2Nlc3M6IFtcIlBPU1QgL29yZ3Mve29yZ30vcGVyc29uYWwtYWNjZXNzLXRva2Vucy97cGF0X2lkfVwiXSxcbiAgICB1cGRhdGVQYXRBY2Nlc3NlczogW1wiUE9TVCAvb3Jncy97b3JnfS9wZXJzb25hbC1hY2Nlc3MtdG9rZW5zXCJdLFxuICAgIHVwZGF0ZVdlYmhvb2s6IFtcIlBBVENIIC9vcmdzL3tvcmd9L2hvb2tzL3tob29rX2lkfVwiXSxcbiAgICB1cGRhdGVXZWJob29rQ29uZmlnRm9yT3JnOiBbXCJQQVRDSCAvb3Jncy97b3JnfS9ob29rcy97aG9va19pZH0vY29uZmlnXCJdXG4gIH0sXG4gIHBhY2thZ2VzOiB7XG4gICAgZGVsZXRlUGFja2FnZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfVwiXG4gICAgXSxcbiAgICBkZWxldGVQYWNrYWdlRm9yT3JnOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfVwiXG4gICAgXSxcbiAgICBkZWxldGVQYWNrYWdlRm9yVXNlcjogW1xuICAgICAgXCJERUxFVEUgL3VzZXJzL3t1c2VybmFtZX0vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX1cIlxuICAgIF0sXG4gICAgZGVsZXRlUGFja2FnZVZlcnNpb25Gb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJERUxFVEUgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH1cIlxuICAgIF0sXG4gICAgZGVsZXRlUGFja2FnZVZlcnNpb25Gb3JPcmc6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9XCJcbiAgICBdLFxuICAgIGRlbGV0ZVBhY2thZ2VWZXJzaW9uRm9yVXNlcjogW1xuICAgICAgXCJERUxFVEUgL3VzZXJzL3t1c2VybmFtZX0vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH1cIlxuICAgIF0sXG4gICAgZ2V0QWxsUGFja2FnZVZlcnNpb25zRm9yQVBhY2thZ2VPd25lZEJ5QW5Pcmc6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1wicGFja2FnZXNcIiwgXCJnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JQYWNrYWdlT3duZWRCeU9yZ1wiXSB9XG4gICAgXSxcbiAgICBnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JBUGFja2FnZU93bmVkQnlUaGVBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJHRVQgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnNcIixcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICByZW5hbWVkOiBbXG4gICAgICAgICAgXCJwYWNrYWdlc1wiLFxuICAgICAgICAgIFwiZ2V0QWxsUGFja2FnZVZlcnNpb25zRm9yUGFja2FnZU93bmVkQnlBdXRoZW50aWNhdGVkVXNlclwiXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdLFxuICAgIGdldEFsbFBhY2thZ2VWZXJzaW9uc0ZvclBhY2thZ2VPd25lZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCJcbiAgICBdLFxuICAgIGdldEFsbFBhY2thZ2VWZXJzaW9uc0ZvclBhY2thZ2VPd25lZEJ5T3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9uc1wiXG4gICAgXSxcbiAgICBnZXRBbGxQYWNrYWdlVmVyc2lvbnNGb3JQYWNrYWdlT3duZWRCeVVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zXCJcbiAgICBdLFxuICAgIGdldFBhY2thZ2VGb3JBdXRoZW50aWNhdGVkVXNlcjogW1xuICAgICAgXCJHRVQgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX1cIlxuICAgIF0sXG4gICAgZ2V0UGFja2FnZUZvck9yZ2FuaXphdGlvbjogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX1cIlxuICAgIF0sXG4gICAgZ2V0UGFja2FnZUZvclVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9XCJcbiAgICBdLFxuICAgIGdldFBhY2thZ2VWZXJzaW9uRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9XCJcbiAgICBdLFxuICAgIGdldFBhY2thZ2VWZXJzaW9uRm9yT3JnYW5pemF0aW9uOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfVwiXG4gICAgXSxcbiAgICBnZXRQYWNrYWdlVmVyc2lvbkZvclVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzL3twYWNrYWdlX3R5cGV9L3twYWNrYWdlX25hbWV9L3ZlcnNpb25zL3twYWNrYWdlX3ZlcnNpb25faWR9XCJcbiAgICBdLFxuICAgIGxpc3REb2NrZXJNaWdyYXRpb25Db25mbGljdGluZ1BhY2thZ2VzRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL2RvY2tlci9jb25mbGljdHNcIlxuICAgIF0sXG4gICAgbGlzdERvY2tlck1pZ3JhdGlvbkNvbmZsaWN0aW5nUGFja2FnZXNGb3JPcmdhbml6YXRpb246IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L2RvY2tlci9jb25mbGljdHNcIlxuICAgIF0sXG4gICAgbGlzdERvY2tlck1pZ3JhdGlvbkNvbmZsaWN0aW5nUGFja2FnZXNGb3JVc2VyOiBbXG4gICAgICBcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9kb2NrZXIvY29uZmxpY3RzXCJcbiAgICBdLFxuICAgIGxpc3RQYWNrYWdlc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvcGFja2FnZXNcIl0sXG4gICAgbGlzdFBhY2thZ2VzRm9yT3JnYW5pemF0aW9uOiBbXCJHRVQgL29yZ3Mve29yZ30vcGFja2FnZXNcIl0sXG4gICAgbGlzdFBhY2thZ2VzRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L3BhY2thZ2VzXCJdLFxuICAgIHJlc3RvcmVQYWNrYWdlRm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiUE9TVCAvdXNlci9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS9yZXN0b3Jlez90b2tlbn1cIlxuICAgIF0sXG4gICAgcmVzdG9yZVBhY2thZ2VGb3JPcmc6IFtcbiAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS9yZXN0b3Jlez90b2tlbn1cIlxuICAgIF0sXG4gICAgcmVzdG9yZVBhY2thZ2VGb3JVc2VyOiBbXG4gICAgICBcIlBPU1QgL3VzZXJzL3t1c2VybmFtZX0vcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vcmVzdG9yZXs/dG9rZW59XCJcbiAgICBdLFxuICAgIHJlc3RvcmVQYWNrYWdlVmVyc2lvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIlBPU1QgL3VzZXIvcGFja2FnZXMve3BhY2thZ2VfdHlwZX0ve3BhY2thZ2VfbmFtZX0vdmVyc2lvbnMve3BhY2thZ2VfdmVyc2lvbl9pZH0vcmVzdG9yZVwiXG4gICAgXSxcbiAgICByZXN0b3JlUGFja2FnZVZlcnNpb25Gb3JPcmc6IFtcbiAgICAgIFwiUE9TVCAvb3Jncy97b3JnfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfS9yZXN0b3JlXCJcbiAgICBdLFxuICAgIHJlc3RvcmVQYWNrYWdlVmVyc2lvbkZvclVzZXI6IFtcbiAgICAgIFwiUE9TVCAvdXNlcnMve3VzZXJuYW1lfS9wYWNrYWdlcy97cGFja2FnZV90eXBlfS97cGFja2FnZV9uYW1lfS92ZXJzaW9ucy97cGFja2FnZV92ZXJzaW9uX2lkfS9yZXN0b3JlXCJcbiAgICBdXG4gIH0sXG4gIHByaXZhdGVSZWdpc3RyaWVzOiB7XG4gICAgY3JlYXRlT3JnUHJpdmF0ZVJlZ2lzdHJ5OiBbXCJQT1NUIC9vcmdzL3tvcmd9L3ByaXZhdGUtcmVnaXN0cmllc1wiXSxcbiAgICBkZWxldGVPcmdQcml2YXRlUmVnaXN0cnk6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3ByaXZhdGUtcmVnaXN0cmllcy97c2VjcmV0X25hbWV9XCJcbiAgICBdLFxuICAgIGdldE9yZ1ByaXZhdGVSZWdpc3RyeTogW1wiR0VUIC9vcmdzL3tvcmd9L3ByaXZhdGUtcmVnaXN0cmllcy97c2VjcmV0X25hbWV9XCJdLFxuICAgIGdldE9yZ1B1YmxpY0tleTogW1wiR0VUIC9vcmdzL3tvcmd9L3ByaXZhdGUtcmVnaXN0cmllcy9wdWJsaWMta2V5XCJdLFxuICAgIGxpc3RPcmdQcml2YXRlUmVnaXN0cmllczogW1wiR0VUIC9vcmdzL3tvcmd9L3ByaXZhdGUtcmVnaXN0cmllc1wiXSxcbiAgICB1cGRhdGVPcmdQcml2YXRlUmVnaXN0cnk6IFtcbiAgICAgIFwiUEFUQ0ggL29yZ3Mve29yZ30vcHJpdmF0ZS1yZWdpc3RyaWVzL3tzZWNyZXRfbmFtZX1cIlxuICAgIF1cbiAgfSxcbiAgcHVsbHM6IHtcbiAgICBjaGVja0lmTWVyZ2VkOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vbWVyZ2VcIl0sXG4gICAgY3JlYXRlOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxsc1wiXSxcbiAgICBjcmVhdGVSZXBseUZvclJldmlld0NvbW1lbnQ6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9pZH0vcmVwbGllc1wiXG4gICAgXSxcbiAgICBjcmVhdGVSZXZpZXc6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3c1wiXSxcbiAgICBjcmVhdGVSZXZpZXdDb21tZW50OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vY29tbWVudHNcIlxuICAgIF0sXG4gICAgZGVsZXRlUGVuZGluZ1JldmlldzogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3cy97cmV2aWV3X2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVSZXZpZXdDb21tZW50OiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMvY29tbWVudHMve2NvbW1lbnRfaWR9XCJcbiAgICBdLFxuICAgIGRpc21pc3NSZXZpZXc6IFtcbiAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3Mve3Jldmlld19pZH0vZGlzbWlzc2Fsc1wiXG4gICAgXSxcbiAgICBnZXQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfVwiXSxcbiAgICBnZXRSZXZpZXc6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3Mve3Jldmlld19pZH1cIlxuICAgIF0sXG4gICAgZ2V0UmV2aWV3Q29tbWVudDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy9jb21tZW50cy97Y29tbWVudF9pZH1cIl0sXG4gICAgbGlzdDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxsc1wiXSxcbiAgICBsaXN0Q29tbWVudHNGb3JSZXZpZXc6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3Mve3Jldmlld19pZH0vY29tbWVudHNcIlxuICAgIF0sXG4gICAgbGlzdENvbW1pdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb21taXRzXCJdLFxuICAgIGxpc3RGaWxlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L2ZpbGVzXCJdLFxuICAgIGxpc3RSZXF1ZXN0ZWRSZXZpZXdlcnM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3JlcXVlc3RlZF9yZXZpZXdlcnNcIlxuICAgIF0sXG4gICAgbGlzdFJldmlld0NvbW1lbnRzOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9jb21tZW50c1wiXG4gICAgXSxcbiAgICBsaXN0UmV2aWV3Q29tbWVudHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzXCJdLFxuICAgIGxpc3RSZXZpZXdzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmV2aWV3c1wiXSxcbiAgICBtZXJnZTogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L21lcmdlXCJdLFxuICAgIHJlbW92ZVJlcXVlc3RlZFJldmlld2VyczogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmVxdWVzdGVkX3Jldmlld2Vyc1wiXG4gICAgXSxcbiAgICByZXF1ZXN0UmV2aWV3ZXJzOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vcmVxdWVzdGVkX3Jldmlld2Vyc1wiXG4gICAgXSxcbiAgICBzdWJtaXRSZXZpZXc6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMve3B1bGxfbnVtYmVyfS9yZXZpZXdzL3tyZXZpZXdfaWR9L2V2ZW50c1wiXG4gICAgXSxcbiAgICB1cGRhdGU6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9XCJdLFxuICAgIHVwZGF0ZUJyYW5jaDogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL3twdWxsX251bWJlcn0vdXBkYXRlLWJyYW5jaFwiXG4gICAgXSxcbiAgICB1cGRhdGVSZXZpZXc6IFtcbiAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wdWxscy97cHVsbF9udW1iZXJ9L3Jldmlld3Mve3Jldmlld19pZH1cIlxuICAgIF0sXG4gICAgdXBkYXRlUmV2aWV3Q29tbWVudDogW1xuICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vcHVsbHMvY29tbWVudHMve2NvbW1lbnRfaWR9XCJcbiAgICBdXG4gIH0sXG4gIHJhdGVMaW1pdDogeyBnZXQ6IFtcIkdFVCAvcmF0ZV9saW1pdFwiXSB9LFxuICByZWFjdGlvbnM6IHtcbiAgICBjcmVhdGVGb3JDb21taXRDb21tZW50OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIlxuICAgIF0sXG4gICAgY3JlYXRlRm9ySXNzdWU6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3JlYWN0aW9uc1wiXG4gICAgXSxcbiAgICBjcmVhdGVGb3JJc3N1ZUNvbW1lbnQ6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIlxuICAgIF0sXG4gICAgY3JlYXRlRm9yUHVsbFJlcXVlc3RSZXZpZXdDb21tZW50OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIlxuICAgIF0sXG4gICAgY3JlYXRlRm9yUmVsZWFzZTogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vcmVhY3Rpb25zXCJcbiAgICBdLFxuICAgIGNyZWF0ZUZvclRlYW1EaXNjdXNzaW9uQ29tbWVudEluT3JnOiBbXG4gICAgICBcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiXG4gICAgXSxcbiAgICBjcmVhdGVGb3JUZWFtRGlzY3Vzc2lvbkluT3JnOiBbXG4gICAgICBcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9yZWFjdGlvbnNcIlxuICAgIF0sXG4gICAgZGVsZXRlRm9yQ29tbWl0Q29tbWVudDogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnMve3JlYWN0aW9uX2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVGb3JJc3N1ZTogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2lzc3Vlcy97aXNzdWVfbnVtYmVyfS9yZWFjdGlvbnMve3JlYWN0aW9uX2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVGb3JJc3N1ZUNvbW1lbnQ6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pc3N1ZXMvY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCJcbiAgICBdLFxuICAgIGRlbGV0ZUZvclB1bGxSZXF1ZXN0Q29tbWVudDogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnMve3JlYWN0aW9uX2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVGb3JSZWxlYXNlOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCJcbiAgICBdLFxuICAgIGRlbGV0ZUZvclRlYW1EaXNjdXNzaW9uOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCJcbiAgICBdLFxuICAgIGRlbGV0ZUZvclRlYW1EaXNjdXNzaW9uQ29tbWVudDogW1xuICAgICAgXCJERUxFVEUgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9ucy97cmVhY3Rpb25faWR9XCJcbiAgICBdLFxuICAgIGxpc3RGb3JDb21taXRDb21tZW50OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWVudHMve2NvbW1lbnRfaWR9L3JlYWN0aW9uc1wiXG4gICAgXSxcbiAgICBsaXN0Rm9ySXNzdWU6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL3tpc3N1ZV9udW1iZXJ9L3JlYWN0aW9uc1wiXSxcbiAgICBsaXN0Rm9ySXNzdWVDb21tZW50OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaXNzdWVzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIlxuICAgIF0sXG4gICAgbGlzdEZvclB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3B1bGxzL2NvbW1lbnRzL3tjb21tZW50X2lkfS9yZWFjdGlvbnNcIlxuICAgIF0sXG4gICAgbGlzdEZvclJlbGVhc2U6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH0vcmVhY3Rpb25zXCJcbiAgICBdLFxuICAgIGxpc3RGb3JUZWFtRGlzY3Vzc2lvbkNvbW1lbnRJbk9yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9jb21tZW50cy97Y29tbWVudF9udW1iZXJ9L3JlYWN0aW9uc1wiXG4gICAgXSxcbiAgICBsaXN0Rm9yVGVhbURpc2N1c3Npb25Jbk9yZzogW1xuICAgICAgXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfS9yZWFjdGlvbnNcIlxuICAgIF1cbiAgfSxcbiAgcmVwb3M6IHtcbiAgICBhY2NlcHRJbnZpdGF0aW9uOiBbXG4gICAgICBcIlBBVENIIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1wicmVwb3NcIiwgXCJhY2NlcHRJbnZpdGF0aW9uRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgYWNjZXB0SW52aXRhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIlBBVENIIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCJcbiAgICBdLFxuICAgIGFkZEFwcEFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy9hcHBzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcImFwcHNcIiB9XG4gICAgXSxcbiAgICBhZGRDb2xsYWJvcmF0b3I6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCJdLFxuICAgIGFkZFN0YXR1c0NoZWNrQ29udGV4dHM6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zdGF0dXNfY2hlY2tzL2NvbnRleHRzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcImNvbnRleHRzXCIgfVxuICAgIF0sXG4gICAgYWRkVGVhbUFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy90ZWFtc1wiLFxuICAgICAge30sXG4gICAgICB7IG1hcFRvRGF0YTogXCJ0ZWFtc1wiIH1cbiAgICBdLFxuICAgIGFkZFVzZXJBY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvdXNlcnNcIixcbiAgICAgIHt9LFxuICAgICAgeyBtYXBUb0RhdGE6IFwidXNlcnNcIiB9XG4gICAgXSxcbiAgICBjYW5jZWxQYWdlc0RlcGxveW1lbnQ6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXMvZGVwbG95bWVudHMve3BhZ2VzX2RlcGxveW1lbnRfaWR9L2NhbmNlbFwiXG4gICAgXSxcbiAgICBjaGVja0F1dG9tYXRlZFNlY3VyaXR5Rml4ZXM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hdXRvbWF0ZWQtc2VjdXJpdHktZml4ZXNcIlxuICAgIF0sXG4gICAgY2hlY2tDb2xsYWJvcmF0b3I6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCJdLFxuICAgIGNoZWNrUHJpdmF0ZVZ1bG5lcmFiaWxpdHlSZXBvcnRpbmc6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wcml2YXRlLXZ1bG5lcmFiaWxpdHktcmVwb3J0aW5nXCJcbiAgICBdLFxuICAgIGNoZWNrVnVsbmVyYWJpbGl0eUFsZXJ0czogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Z1bG5lcmFiaWxpdHktYWxlcnRzXCJcbiAgICBdLFxuICAgIGNvZGVvd25lcnNFcnJvcnM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29kZW93bmVycy9lcnJvcnNcIl0sXG4gICAgY29tcGFyZUNvbW1pdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tcGFyZS97YmFzZX0uLi57aGVhZH1cIl0sXG4gICAgY29tcGFyZUNvbW1pdHNXaXRoQmFzZWhlYWQ6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21wYXJlL3tiYXNlaGVhZH1cIlxuICAgIF0sXG4gICAgY3JlYXRlQXR0ZXN0YXRpb246IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F0dGVzdGF0aW9uc1wiXSxcbiAgICBjcmVhdGVBdXRvbGluazogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYXV0b2xpbmtzXCJdLFxuICAgIGNyZWF0ZUNvbW1pdENvbW1lbnQ6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97Y29tbWl0X3NoYX0vY29tbWVudHNcIlxuICAgIF0sXG4gICAgY3JlYXRlQ29tbWl0U2lnbmF0dXJlUHJvdGVjdGlvbjogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3NpZ25hdHVyZXNcIlxuICAgIF0sXG4gICAgY3JlYXRlQ29tbWl0U3RhdHVzOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGF0dXNlcy97c2hhfVwiXSxcbiAgICBjcmVhdGVEZXBsb3lLZXk6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXNcIl0sXG4gICAgY3JlYXRlRGVwbG95bWVudDogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHNcIl0sXG4gICAgY3JlYXRlRGVwbG95bWVudEJyYW5jaFBvbGljeTogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L2RlcGxveW1lbnQtYnJhbmNoLXBvbGljaWVzXCJcbiAgICBdLFxuICAgIGNyZWF0ZURlcGxveW1lbnRQcm90ZWN0aW9uUnVsZTogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L2RlcGxveW1lbnRfcHJvdGVjdGlvbl9ydWxlc1wiXG4gICAgXSxcbiAgICBjcmVhdGVEZXBsb3ltZW50U3RhdHVzOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50X2lkfS9zdGF0dXNlc1wiXG4gICAgXSxcbiAgICBjcmVhdGVEaXNwYXRjaEV2ZW50OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kaXNwYXRjaGVzXCJdLFxuICAgIGNyZWF0ZUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL3JlcG9zXCJdLFxuICAgIGNyZWF0ZUZvcms6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ZvcmtzXCJdLFxuICAgIGNyZWF0ZUluT3JnOiBbXCJQT1NUIC9vcmdzL3tvcmd9L3JlcG9zXCJdLFxuICAgIGNyZWF0ZU9yVXBkYXRlQ3VzdG9tUHJvcGVydGllc1ZhbHVlczogW1xuICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vcHJvcGVydGllcy92YWx1ZXNcIlxuICAgIF0sXG4gICAgY3JlYXRlT3JVcGRhdGVFbnZpcm9ubWVudDogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX1cIlxuICAgIF0sXG4gICAgY3JlYXRlT3JVcGRhdGVGaWxlQ29udGVudHM6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29udGVudHMve3BhdGh9XCJdLFxuICAgIGNyZWF0ZU9yZ1J1bGVzZXQ6IFtcIlBPU1QgL29yZ3Mve29yZ30vcnVsZXNldHNcIl0sXG4gICAgY3JlYXRlUGFnZXNEZXBsb3ltZW50OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9kZXBsb3ltZW50c1wiXSxcbiAgICBjcmVhdGVQYWdlc1NpdGU6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzXCJdLFxuICAgIGNyZWF0ZVJlbGVhc2U6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzXCJdLFxuICAgIGNyZWF0ZVJlcG9SdWxlc2V0OiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ydWxlc2V0c1wiXSxcbiAgICBjcmVhdGVVc2luZ1RlbXBsYXRlOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3t0ZW1wbGF0ZV9vd25lcn0ve3RlbXBsYXRlX3JlcG99L2dlbmVyYXRlXCJcbiAgICBdLFxuICAgIGNyZWF0ZVdlYmhvb2s6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzXCJdLFxuICAgIGRlY2xpbmVJbnZpdGF0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9yZXBvc2l0b3J5X2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfVwiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcInJlcG9zXCIsIFwiZGVjbGluZUludml0YXRpb25Gb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9XG4gICAgXSxcbiAgICBkZWNsaW5lSW52aXRhdGlvbkZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9yZXBvc2l0b3J5X2ludml0YXRpb25zL3tpbnZpdGF0aW9uX2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGU6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb31cIl0sXG4gICAgZGVsZXRlQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnNcIlxuICAgIF0sXG4gICAgZGVsZXRlQWRtaW5CcmFuY2hQcm90ZWN0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9lbmZvcmNlX2FkbWluc1wiXG4gICAgXSxcbiAgICBkZWxldGVBbkVudmlyb25tZW50OiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfVwiXG4gICAgXSxcbiAgICBkZWxldGVBdXRvbGluazogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hdXRvbGlua3Mve2F1dG9saW5rX2lkfVwiXSxcbiAgICBkZWxldGVCcmFuY2hQcm90ZWN0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvblwiXG4gICAgXSxcbiAgICBkZWxldGVDb21taXRDb21tZW50OiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICBkZWxldGVDb21taXRTaWduYXR1cmVQcm90ZWN0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zaWduYXR1cmVzXCJcbiAgICBdLFxuICAgIGRlbGV0ZURlcGxveUtleTogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9rZXlzL3trZXlfaWR9XCJdLFxuICAgIGRlbGV0ZURlcGxveW1lbnQ6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudF9pZH1cIlxuICAgIF0sXG4gICAgZGVsZXRlRGVwbG95bWVudEJyYW5jaFBvbGljeTogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vZGVwbG95bWVudC1icmFuY2gtcG9saWNpZXMve2JyYW5jaF9wb2xpY3lfaWR9XCJcbiAgICBdLFxuICAgIGRlbGV0ZUZpbGU6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29udGVudHMve3BhdGh9XCJdLFxuICAgIGRlbGV0ZUludml0YXRpb246IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnZpdGF0aW9ucy97aW52aXRhdGlvbl9pZH1cIlxuICAgIF0sXG4gICAgZGVsZXRlT3JnUnVsZXNldDogW1wiREVMRVRFIC9vcmdzL3tvcmd9L3J1bGVzZXRzL3tydWxlc2V0X2lkfVwiXSxcbiAgICBkZWxldGVQYWdlc1NpdGU6IFtcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXNcIl0sXG4gICAgZGVsZXRlUHVsbFJlcXVlc3RSZXZpZXdQcm90ZWN0aW9uOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9wdWxsX3JlcXVlc3RfcmV2aWV3c1wiXG4gICAgXSxcbiAgICBkZWxldGVSZWxlYXNlOiBbXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfVwiXSxcbiAgICBkZWxldGVSZWxlYXNlQXNzZXQ6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9hc3NldHMve2Fzc2V0X2lkfVwiXG4gICAgXSxcbiAgICBkZWxldGVSZXBvUnVsZXNldDogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ydWxlc2V0cy97cnVsZXNldF9pZH1cIl0sXG4gICAgZGVsZXRlV2ViaG9vazogW1wiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgZGlzYWJsZUF1dG9tYXRlZFNlY3VyaXR5Rml4ZXM6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hdXRvbWF0ZWQtc2VjdXJpdHktZml4ZXNcIlxuICAgIF0sXG4gICAgZGlzYWJsZURlcGxveW1lbnRQcm90ZWN0aW9uUnVsZTogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vZGVwbG95bWVudF9wcm90ZWN0aW9uX3J1bGVzL3twcm90ZWN0aW9uX3J1bGVfaWR9XCJcbiAgICBdLFxuICAgIGRpc2FibGVQcml2YXRlVnVsbmVyYWJpbGl0eVJlcG9ydGluZzogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L3ByaXZhdGUtdnVsbmVyYWJpbGl0eS1yZXBvcnRpbmdcIlxuICAgIF0sXG4gICAgZGlzYWJsZVZ1bG5lcmFiaWxpdHlBbGVydHM6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS92dWxuZXJhYmlsaXR5LWFsZXJ0c1wiXG4gICAgXSxcbiAgICBkb3dubG9hZEFyY2hpdmU6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS96aXBiYWxsL3tyZWZ9XCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1wicmVwb3NcIiwgXCJkb3dubG9hZFppcGJhbGxBcmNoaXZlXCJdIH1cbiAgICBdLFxuICAgIGRvd25sb2FkVGFyYmFsbEFyY2hpdmU6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vdGFyYmFsbC97cmVmfVwiXSxcbiAgICBkb3dubG9hZFppcGJhbGxBcmNoaXZlOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3ppcGJhbGwve3JlZn1cIl0sXG4gICAgZW5hYmxlQXV0b21hdGVkU2VjdXJpdHlGaXhlczogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F1dG9tYXRlZC1zZWN1cml0eS1maXhlc1wiXG4gICAgXSxcbiAgICBlbmFibGVQcml2YXRlVnVsbmVyYWJpbGl0eVJlcG9ydGluZzogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3ByaXZhdGUtdnVsbmVyYWJpbGl0eS1yZXBvcnRpbmdcIlxuICAgIF0sXG4gICAgZW5hYmxlVnVsbmVyYWJpbGl0eUFsZXJ0czogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Z1bG5lcmFiaWxpdHktYWxlcnRzXCJcbiAgICBdLFxuICAgIGdlbmVyYXRlUmVsZWFzZU5vdGVzOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL2dlbmVyYXRlLW5vdGVzXCJcbiAgICBdLFxuICAgIGdldDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfVwiXSxcbiAgICBnZXRBY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9uc1wiXG4gICAgXSxcbiAgICBnZXRBZG1pbkJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL2VuZm9yY2VfYWRtaW5zXCJcbiAgICBdLFxuICAgIGdldEFsbERlcGxveW1lbnRQcm90ZWN0aW9uUnVsZXM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L2RlcGxveW1lbnRfcHJvdGVjdGlvbl9ydWxlc1wiXG4gICAgXSxcbiAgICBnZXRBbGxFbnZpcm9ubWVudHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzXCJdLFxuICAgIGdldEFsbFN0YXR1c0NoZWNrQ29udGV4dHM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3MvY29udGV4dHNcIlxuICAgIF0sXG4gICAgZ2V0QWxsVG9waWNzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RvcGljc1wiXSxcbiAgICBnZXRBcHBzV2l0aEFjY2Vzc1RvUHJvdGVjdGVkQnJhbmNoOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvYXBwc1wiXG4gICAgXSxcbiAgICBnZXRBdXRvbGluazogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hdXRvbGlua3Mve2F1dG9saW5rX2lkfVwiXSxcbiAgICBnZXRCcmFuY2g6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH1cIl0sXG4gICAgZ2V0QnJhbmNoUHJvdGVjdGlvbjogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb25cIlxuICAgIF0sXG4gICAgZ2V0QnJhbmNoUnVsZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcnVsZXMvYnJhbmNoZXMve2JyYW5jaH1cIl0sXG4gICAgZ2V0Q2xvbmVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYWZmaWMvY2xvbmVzXCJdLFxuICAgIGdldENvZGVGcmVxdWVuY3lTdGF0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGF0cy9jb2RlX2ZyZXF1ZW5jeVwiXSxcbiAgICBnZXRDb2xsYWJvcmF0b3JQZXJtaXNzaW9uTGV2ZWw6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb2xsYWJvcmF0b3JzL3t1c2VybmFtZX0vcGVybWlzc2lvblwiXG4gICAgXSxcbiAgICBnZXRDb21iaW5lZFN0YXR1c0ZvclJlZjogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9L3N0YXR1c1wiXSxcbiAgICBnZXRDb21taXQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfVwiXSxcbiAgICBnZXRDb21taXRBY3Rpdml0eVN0YXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXRzL2NvbW1pdF9hY3Rpdml0eVwiXSxcbiAgICBnZXRDb21taXRDb21tZW50OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzL3tjb21tZW50X2lkfVwiXSxcbiAgICBnZXRDb21taXRTaWduYXR1cmVQcm90ZWN0aW9uOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zaWduYXR1cmVzXCJcbiAgICBdLFxuICAgIGdldENvbW11bml0eVByb2ZpbGVNZXRyaWNzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW11bml0eS9wcm9maWxlXCJdLFxuICAgIGdldENvbnRlbnQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29udGVudHMve3BhdGh9XCJdLFxuICAgIGdldENvbnRyaWJ1dG9yc1N0YXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXRzL2NvbnRyaWJ1dG9yc1wiXSxcbiAgICBnZXRDdXN0b21EZXBsb3ltZW50UHJvdGVjdGlvblJ1bGU6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L2RlcGxveW1lbnRfcHJvdGVjdGlvbl9ydWxlcy97cHJvdGVjdGlvbl9ydWxlX2lkfVwiXG4gICAgXSxcbiAgICBnZXRDdXN0b21Qcm9wZXJ0aWVzVmFsdWVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3Byb3BlcnRpZXMvdmFsdWVzXCJdLFxuICAgIGdldERlcGxveUtleTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9rZXlzL3trZXlfaWR9XCJdLFxuICAgIGdldERlcGxveW1lbnQ6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9XCJdLFxuICAgIGdldERlcGxveW1lbnRCcmFuY2hQb2xpY3k6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L2RlcGxveW1lbnQtYnJhbmNoLXBvbGljaWVzL3ticmFuY2hfcG9saWN5X2lkfVwiXG4gICAgXSxcbiAgICBnZXREZXBsb3ltZW50U3RhdHVzOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHMve2RlcGxveW1lbnRfaWR9L3N0YXR1c2VzL3tzdGF0dXNfaWR9XCJcbiAgICBdLFxuICAgIGdldEVudmlyb25tZW50OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZW52aXJvbm1lbnRzL3tlbnZpcm9ubWVudF9uYW1lfVwiXG4gICAgXSxcbiAgICBnZXRMYXRlc3RQYWdlc0J1aWxkOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzL2J1aWxkcy9sYXRlc3RcIl0sXG4gICAgZ2V0TGF0ZXN0UmVsZWFzZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9sYXRlc3RcIl0sXG4gICAgZ2V0T3JnUnVsZVN1aXRlOiBbXCJHRVQgL29yZ3Mve29yZ30vcnVsZXNldHMvcnVsZS1zdWl0ZXMve3J1bGVfc3VpdGVfaWR9XCJdLFxuICAgIGdldE9yZ1J1bGVTdWl0ZXM6IFtcIkdFVCAvb3Jncy97b3JnfS9ydWxlc2V0cy9ydWxlLXN1aXRlc1wiXSxcbiAgICBnZXRPcmdSdWxlc2V0OiBbXCJHRVQgL29yZ3Mve29yZ30vcnVsZXNldHMve3J1bGVzZXRfaWR9XCJdLFxuICAgIGdldE9yZ1J1bGVzZXRzOiBbXCJHRVQgL29yZ3Mve29yZ30vcnVsZXNldHNcIl0sXG4gICAgZ2V0UGFnZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXNcIl0sXG4gICAgZ2V0UGFnZXNCdWlsZDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9idWlsZHMve2J1aWxkX2lkfVwiXSxcbiAgICBnZXRQYWdlc0RlcGxveW1lbnQ6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9kZXBsb3ltZW50cy97cGFnZXNfZGVwbG95bWVudF9pZH1cIlxuICAgIF0sXG4gICAgZ2V0UGFnZXNIZWFsdGhDaGVjazogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9wYWdlcy9oZWFsdGhcIl0sXG4gICAgZ2V0UGFydGljaXBhdGlvblN0YXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3N0YXRzL3BhcnRpY2lwYXRpb25cIl0sXG4gICAgZ2V0UHVsbFJlcXVlc3RSZXZpZXdQcm90ZWN0aW9uOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9wdWxsX3JlcXVlc3RfcmV2aWV3c1wiXG4gICAgXSxcbiAgICBnZXRQdW5jaENhcmRTdGF0czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zdGF0cy9wdW5jaF9jYXJkXCJdLFxuICAgIGdldFJlYWRtZTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWFkbWVcIl0sXG4gICAgZ2V0UmVhZG1lSW5EaXJlY3Rvcnk6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVhZG1lL3tkaXJ9XCJdLFxuICAgIGdldFJlbGVhc2U6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMve3JlbGVhc2VfaWR9XCJdLFxuICAgIGdldFJlbGVhc2VBc3NldDogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9hc3NldHMve2Fzc2V0X2lkfVwiXSxcbiAgICBnZXRSZWxlYXNlQnlUYWc6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcmVsZWFzZXMvdGFncy97dGFnfVwiXSxcbiAgICBnZXRSZXBvUnVsZVN1aXRlOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vcnVsZXNldHMvcnVsZS1zdWl0ZXMve3J1bGVfc3VpdGVfaWR9XCJcbiAgICBdLFxuICAgIGdldFJlcG9SdWxlU3VpdGVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3J1bGVzZXRzL3J1bGUtc3VpdGVzXCJdLFxuICAgIGdldFJlcG9SdWxlc2V0OiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3J1bGVzZXRzL3tydWxlc2V0X2lkfVwiXSxcbiAgICBnZXRSZXBvUnVsZXNldEhpc3Rvcnk6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ydWxlc2V0cy97cnVsZXNldF9pZH0vaGlzdG9yeVwiXG4gICAgXSxcbiAgICBnZXRSZXBvUnVsZXNldFZlcnNpb246IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ydWxlc2V0cy97cnVsZXNldF9pZH0vaGlzdG9yeS97dmVyc2lvbl9pZH1cIlxuICAgIF0sXG4gICAgZ2V0UmVwb1J1bGVzZXRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3J1bGVzZXRzXCJdLFxuICAgIGdldFN0YXR1c0NoZWNrc1Byb3RlY3Rpb246IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3NcIlxuICAgIF0sXG4gICAgZ2V0VGVhbXNXaXRoQWNjZXNzVG9Qcm90ZWN0ZWRCcmFuY2g6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy90ZWFtc1wiXG4gICAgXSxcbiAgICBnZXRUb3BQYXRoczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90cmFmZmljL3BvcHVsYXIvcGF0aHNcIl0sXG4gICAgZ2V0VG9wUmVmZXJyZXJzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYWZmaWMvcG9wdWxhci9yZWZlcnJlcnNcIl0sXG4gICAgZ2V0VXNlcnNXaXRoQWNjZXNzVG9Qcm90ZWN0ZWRCcmFuY2g6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy91c2Vyc1wiXG4gICAgXSxcbiAgICBnZXRWaWV3czogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90cmFmZmljL3ZpZXdzXCJdLFxuICAgIGdldFdlYmhvb2s6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9XCJdLFxuICAgIGdldFdlYmhvb2tDb25maWdGb3JSZXBvOiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vaG9va3Mve2hvb2tfaWR9L2NvbmZpZ1wiXG4gICAgXSxcbiAgICBnZXRXZWJob29rRGVsaXZlcnk6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH0vZGVsaXZlcmllcy97ZGVsaXZlcnlfaWR9XCJcbiAgICBdLFxuICAgIGxpc3RBY3Rpdml0aWVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2FjdGl2aXR5XCJdLFxuICAgIGxpc3RBdHRlc3RhdGlvbnM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9hdHRlc3RhdGlvbnMve3N1YmplY3RfZGlnZXN0fVwiXG4gICAgXSxcbiAgICBsaXN0QXV0b2xpbmtzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2F1dG9saW5rc1wiXSxcbiAgICBsaXN0QnJhbmNoZXM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXNcIl0sXG4gICAgbGlzdEJyYW5jaGVzRm9ySGVhZENvbW1pdDogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve2NvbW1pdF9zaGF9L2JyYW5jaGVzLXdoZXJlLWhlYWRcIlxuICAgIF0sXG4gICAgbGlzdENvbGxhYm9yYXRvcnM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29sbGFib3JhdG9yc1wiXSxcbiAgICBsaXN0Q29tbWVudHNGb3JDb21taXQ6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9jb21tZW50c1wiXG4gICAgXSxcbiAgICBsaXN0Q29tbWl0Q29tbWVudHNGb3JSZXBvOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1lbnRzXCJdLFxuICAgIGxpc3RDb21taXRTdGF0dXNlc0ZvclJlZjogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn0vc3RhdHVzZXNcIlxuICAgIF0sXG4gICAgbGlzdENvbW1pdHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0c1wiXSxcbiAgICBsaXN0Q29udHJpYnV0b3JzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbnRyaWJ1dG9yc1wiXSxcbiAgICBsaXN0Q3VzdG9tRGVwbG95bWVudFJ1bGVJbnRlZ3JhdGlvbnM6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9lbnZpcm9ubWVudHMve2Vudmlyb25tZW50X25hbWV9L2RlcGxveW1lbnRfcHJvdGVjdGlvbl9ydWxlcy9hcHBzXCJcbiAgICBdLFxuICAgIGxpc3REZXBsb3lLZXlzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2tleXNcIl0sXG4gICAgbGlzdERlcGxveW1lbnRCcmFuY2hQb2xpY2llczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vZGVwbG95bWVudC1icmFuY2gtcG9saWNpZXNcIlxuICAgIF0sXG4gICAgbGlzdERlcGxveW1lbnRTdGF0dXNlczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50X2lkfS9zdGF0dXNlc1wiXG4gICAgXSxcbiAgICBsaXN0RGVwbG95bWVudHM6IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZGVwbG95bWVudHNcIl0sXG4gICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvcmVwb3NcIl0sXG4gICAgbGlzdEZvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3JlcG9zXCJdLFxuICAgIGxpc3RGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vcmVwb3NcIl0sXG4gICAgbGlzdEZvcmtzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2ZvcmtzXCJdLFxuICAgIGxpc3RJbnZpdGF0aW9uczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9pbnZpdGF0aW9uc1wiXSxcbiAgICBsaXN0SW52aXRhdGlvbnNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL3JlcG9zaXRvcnlfaW52aXRhdGlvbnNcIl0sXG4gICAgbGlzdExhbmd1YWdlczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9sYW5ndWFnZXNcIl0sXG4gICAgbGlzdFBhZ2VzQnVpbGRzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzL2J1aWxkc1wiXSxcbiAgICBsaXN0UHVibGljOiBbXCJHRVQgL3JlcG9zaXRvcmllc1wiXSxcbiAgICBsaXN0UHVsbFJlcXVlc3RzQXNzb2NpYXRlZFdpdGhDb21taXQ6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tjb21taXRfc2hhfS9wdWxsc1wiXG4gICAgXSxcbiAgICBsaXN0UmVsZWFzZUFzc2V0czogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfS9hc3NldHNcIlxuICAgIF0sXG4gICAgbGlzdFJlbGVhc2VzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzXCJdLFxuICAgIGxpc3RUYWdzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RhZ3NcIl0sXG4gICAgbGlzdFRlYW1zOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RlYW1zXCJdLFxuICAgIGxpc3RXZWJob29rRGVsaXZlcmllczogW1xuICAgICAgXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9kZWxpdmVyaWVzXCJcbiAgICBdLFxuICAgIGxpc3RXZWJob29rczogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rc1wiXSxcbiAgICBtZXJnZTogW1wiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vbWVyZ2VzXCJdLFxuICAgIG1lcmdlVXBzdHJlYW06IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L21lcmdlLXVwc3RyZWFtXCJdLFxuICAgIHBpbmdXZWJob29rOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH0vcGluZ3NcIl0sXG4gICAgcmVkZWxpdmVyV2ViaG9va0RlbGl2ZXJ5OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9kZWxpdmVyaWVzL3tkZWxpdmVyeV9pZH0vYXR0ZW1wdHNcIlxuICAgIF0sXG4gICAgcmVtb3ZlQXBwQWNjZXNzUmVzdHJpY3Rpb25zOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXN0cmljdGlvbnMvYXBwc1wiLFxuICAgICAge30sXG4gICAgICB7IG1hcFRvRGF0YTogXCJhcHBzXCIgfVxuICAgIF0sXG4gICAgcmVtb3ZlQ29sbGFib3JhdG9yOiBbXG4gICAgICBcIkRFTEVURSAvcmVwb3Mve293bmVyfS97cmVwb30vY29sbGFib3JhdG9ycy97dXNlcm5hbWV9XCJcbiAgICBdLFxuICAgIHJlbW92ZVN0YXR1c0NoZWNrQ29udGV4dHM6IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3MvY29udGV4dHNcIixcbiAgICAgIHt9LFxuICAgICAgeyBtYXBUb0RhdGE6IFwiY29udGV4dHNcIiB9XG4gICAgXSxcbiAgICByZW1vdmVTdGF0dXNDaGVja1Byb3RlY3Rpb246IFtcbiAgICAgIFwiREVMRVRFIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3N0YXR1c19jaGVja3NcIlxuICAgIF0sXG4gICAgcmVtb3ZlVGVhbUFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3RlYW1zXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcInRlYW1zXCIgfVxuICAgIF0sXG4gICAgcmVtb3ZlVXNlckFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgXCJERUxFVEUgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3VzZXJzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcInVzZXJzXCIgfVxuICAgIF0sXG4gICAgcmVuYW1lQnJhbmNoOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9yZW5hbWVcIl0sXG4gICAgcmVwbGFjZUFsbFRvcGljczogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS90b3BpY3NcIl0sXG4gICAgcmVxdWVzdFBhZ2VzQnVpbGQ6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3BhZ2VzL2J1aWxkc1wiXSxcbiAgICBzZXRBZG1pbkJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9lbmZvcmNlX2FkbWluc1wiXG4gICAgXSxcbiAgICBzZXRBcHBBY2Nlc3NSZXN0cmljdGlvbnM6IFtcbiAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3Jlc3RyaWN0aW9ucy9hcHBzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcImFwcHNcIiB9XG4gICAgXSxcbiAgICBzZXRTdGF0dXNDaGVja0NvbnRleHRzOiBbXG4gICAgICBcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zdGF0dXNfY2hlY2tzL2NvbnRleHRzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcImNvbnRleHRzXCIgfVxuICAgIF0sXG4gICAgc2V0VGVhbUFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3RlYW1zXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcInRlYW1zXCIgfVxuICAgIF0sXG4gICAgc2V0VXNlckFjY2Vzc1Jlc3RyaWN0aW9uczogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVzdHJpY3Rpb25zL3VzZXJzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgbWFwVG9EYXRhOiBcInVzZXJzXCIgfVxuICAgIF0sXG4gICAgdGVzdFB1c2hXZWJob29rOiBbXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH0vdGVzdHNcIl0sXG4gICAgdHJhbnNmZXI6IFtcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3RyYW5zZmVyXCJdLFxuICAgIHVwZGF0ZTogW1wiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99XCJdLFxuICAgIHVwZGF0ZUJyYW5jaFByb3RlY3Rpb246IFtcbiAgICAgIFwiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uXCJcbiAgICBdLFxuICAgIHVwZGF0ZUNvbW1pdENvbW1lbnQ6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21tZW50cy97Y29tbWVudF9pZH1cIl0sXG4gICAgdXBkYXRlRGVwbG95bWVudEJyYW5jaFBvbGljeTogW1xuICAgICAgXCJQVVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2Vudmlyb25tZW50cy97ZW52aXJvbm1lbnRfbmFtZX0vZGVwbG95bWVudC1icmFuY2gtcG9saWNpZXMve2JyYW5jaF9wb2xpY3lfaWR9XCJcbiAgICBdLFxuICAgIHVwZGF0ZUluZm9ybWF0aW9uQWJvdXRQYWdlc1NpdGU6IFtcIlBVVCAvcmVwb3Mve293bmVyfS97cmVwb30vcGFnZXNcIl0sXG4gICAgdXBkYXRlSW52aXRhdGlvbjogW1xuICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vaW52aXRhdGlvbnMve2ludml0YXRpb25faWR9XCJcbiAgICBdLFxuICAgIHVwZGF0ZU9yZ1J1bGVzZXQ6IFtcIlBVVCAvb3Jncy97b3JnfS9ydWxlc2V0cy97cnVsZXNldF9pZH1cIl0sXG4gICAgdXBkYXRlUHVsbFJlcXVlc3RSZXZpZXdQcm90ZWN0aW9uOiBbXG4gICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlcy97YnJhbmNofS9wcm90ZWN0aW9uL3JlcXVpcmVkX3B1bGxfcmVxdWVzdF9yZXZpZXdzXCJcbiAgICBdLFxuICAgIHVwZGF0ZVJlbGVhc2U6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy97cmVsZWFzZV9pZH1cIl0sXG4gICAgdXBkYXRlUmVsZWFzZUFzc2V0OiBbXG4gICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9yZWxlYXNlcy9hc3NldHMve2Fzc2V0X2lkfVwiXG4gICAgXSxcbiAgICB1cGRhdGVSZXBvUnVsZXNldDogW1wiUFVUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ydWxlc2V0cy97cnVsZXNldF9pZH1cIl0sXG4gICAgdXBkYXRlU3RhdHVzQ2hlY2tQb3RlY3Rpb246IFtcbiAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzL3ticmFuY2h9L3Byb3RlY3Rpb24vcmVxdWlyZWRfc3RhdHVzX2NoZWNrc1wiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcInJlcG9zXCIsIFwidXBkYXRlU3RhdHVzQ2hlY2tQcm90ZWN0aW9uXCJdIH1cbiAgICBdLFxuICAgIHVwZGF0ZVN0YXR1c0NoZWNrUHJvdGVjdGlvbjogW1xuICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXMve2JyYW5jaH0vcHJvdGVjdGlvbi9yZXF1aXJlZF9zdGF0dXNfY2hlY2tzXCJcbiAgICBdLFxuICAgIHVwZGF0ZVdlYmhvb2s6IFtcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9ob29rcy97aG9va19pZH1cIl0sXG4gICAgdXBkYXRlV2ViaG9va0NvbmZpZ0ZvclJlcG86IFtcbiAgICAgIFwiUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2hvb2tzL3tob29rX2lkfS9jb25maWdcIlxuICAgIF0sXG4gICAgdXBsb2FkUmVsZWFzZUFzc2V0OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3JlbGVhc2VzL3tyZWxlYXNlX2lkfS9hc3NldHN7P25hbWUsbGFiZWx9XCIsXG4gICAgICB7IGJhc2VVcmw6IFwiaHR0cHM6Ly91cGxvYWRzLmdpdGh1Yi5jb21cIiB9XG4gICAgXVxuICB9LFxuICBzZWFyY2g6IHtcbiAgICBjb2RlOiBbXCJHRVQgL3NlYXJjaC9jb2RlXCJdLFxuICAgIGNvbW1pdHM6IFtcIkdFVCAvc2VhcmNoL2NvbW1pdHNcIl0sXG4gICAgaXNzdWVzQW5kUHVsbFJlcXVlc3RzOiBbXG4gICAgICBcIkdFVCAvc2VhcmNoL2lzc3Vlc1wiLFxuICAgICAge30sXG4gICAgICB7XG4gICAgICAgIGRlcHJlY2F0ZWQ6IFwib2N0b2tpdC5yZXN0LnNlYXJjaC5pc3N1ZXNBbmRQdWxsUmVxdWVzdHMoKSBpcyBkZXByZWNhdGVkLCBzZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vcmVzdC9zZWFyY2gvc2VhcmNoI3NlYXJjaC1pc3N1ZXMtYW5kLXB1bGwtcmVxdWVzdHNcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbGFiZWxzOiBbXCJHRVQgL3NlYXJjaC9sYWJlbHNcIl0sXG4gICAgcmVwb3M6IFtcIkdFVCAvc2VhcmNoL3JlcG9zaXRvcmllc1wiXSxcbiAgICB0b3BpY3M6IFtcIkdFVCAvc2VhcmNoL3RvcGljc1wiXSxcbiAgICB1c2VyczogW1wiR0VUIC9zZWFyY2gvdXNlcnNcIl1cbiAgfSxcbiAgc2VjcmV0U2Nhbm5pbmc6IHtcbiAgICBjcmVhdGVQdXNoUHJvdGVjdGlvbkJ5cGFzczogW1xuICAgICAgXCJQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvcHVzaC1wcm90ZWN0aW9uLWJ5cGFzc2VzXCJcbiAgICBdLFxuICAgIGdldEFsZXJ0OiBbXG4gICAgICBcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiXG4gICAgXSxcbiAgICBnZXRTY2FuSGlzdG9yeTogW1wiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvc2Nhbi1oaXN0b3J5XCJdLFxuICAgIGxpc3RBbGVydHNGb3JFbnRlcnByaXNlOiBbXG4gICAgICBcIkdFVCAvZW50ZXJwcmlzZXMve2VudGVycHJpc2V9L3NlY3JldC1zY2FubmluZy9hbGVydHNcIlxuICAgIF0sXG4gICAgbGlzdEFsZXJ0c0Zvck9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3NlY3JldC1zY2FubmluZy9hbGVydHNcIl0sXG4gICAgbGlzdEFsZXJ0c0ZvclJlcG86IFtcIkdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0c1wiXSxcbiAgICBsaXN0TG9jYXRpb25zRm9yQWxlcnQ6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWNyZXQtc2Nhbm5pbmcvYWxlcnRzL3thbGVydF9udW1iZXJ9L2xvY2F0aW9uc1wiXG4gICAgXSxcbiAgICB1cGRhdGVBbGVydDogW1xuICAgICAgXCJQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjcmV0LXNjYW5uaW5nL2FsZXJ0cy97YWxlcnRfbnVtYmVyfVwiXG4gICAgXVxuICB9LFxuICBzZWN1cml0eUFkdmlzb3JpZXM6IHtcbiAgICBjcmVhdGVGb3JrOiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3VyaXR5LWFkdmlzb3JpZXMve2doc2FfaWR9L2ZvcmtzXCJcbiAgICBdLFxuICAgIGNyZWF0ZVByaXZhdGVWdWxuZXJhYmlsaXR5UmVwb3J0OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3VyaXR5LWFkdmlzb3JpZXMvcmVwb3J0c1wiXG4gICAgXSxcbiAgICBjcmVhdGVSZXBvc2l0b3J5QWR2aXNvcnk6IFtcbiAgICAgIFwiUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vc2VjdXJpdHktYWR2aXNvcmllc1wiXG4gICAgXSxcbiAgICBjcmVhdGVSZXBvc2l0b3J5QWR2aXNvcnlDdmVSZXF1ZXN0OiBbXG4gICAgICBcIlBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3VyaXR5LWFkdmlzb3JpZXMve2doc2FfaWR9L2N2ZVwiXG4gICAgXSxcbiAgICBnZXRHbG9iYWxBZHZpc29yeTogW1wiR0VUIC9hZHZpc29yaWVzL3tnaHNhX2lkfVwiXSxcbiAgICBnZXRSZXBvc2l0b3J5QWR2aXNvcnk6IFtcbiAgICAgIFwiR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWN1cml0eS1hZHZpc29yaWVzL3tnaHNhX2lkfVwiXG4gICAgXSxcbiAgICBsaXN0R2xvYmFsQWR2aXNvcmllczogW1wiR0VUIC9hZHZpc29yaWVzXCJdLFxuICAgIGxpc3RPcmdSZXBvc2l0b3J5QWR2aXNvcmllczogW1wiR0VUIC9vcmdzL3tvcmd9L3NlY3VyaXR5LWFkdmlzb3JpZXNcIl0sXG4gICAgbGlzdFJlcG9zaXRvcnlBZHZpc29yaWVzOiBbXCJHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L3NlY3VyaXR5LWFkdmlzb3JpZXNcIl0sXG4gICAgdXBkYXRlUmVwb3NpdG9yeUFkdmlzb3J5OiBbXG4gICAgICBcIlBBVENIIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9zZWN1cml0eS1hZHZpc29yaWVzL3tnaHNhX2lkfVwiXG4gICAgXVxuICB9LFxuICB0ZWFtczoge1xuICAgIGFkZE9yVXBkYXRlTWVtYmVyc2hpcEZvclVzZXJJbk9yZzogW1xuICAgICAgXCJQVVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vbWVtYmVyc2hpcHMve3VzZXJuYW1lfVwiXG4gICAgXSxcbiAgICBhZGRPclVwZGF0ZVJlcG9QZXJtaXNzaW9uc0luT3JnOiBbXG4gICAgICBcIlBVVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9yZXBvcy97b3duZXJ9L3tyZXBvfVwiXG4gICAgXSxcbiAgICBjaGVja1Blcm1pc3Npb25zRm9yUmVwb0luT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9yZXBvcy97b3duZXJ9L3tyZXBvfVwiXG4gICAgXSxcbiAgICBjcmVhdGU6IFtcIlBPU1QgL29yZ3Mve29yZ30vdGVhbXNcIl0sXG4gICAgY3JlYXRlRGlzY3Vzc2lvbkNvbW1lbnRJbk9yZzogW1xuICAgICAgXCJQT1NUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHNcIlxuICAgIF0sXG4gICAgY3JlYXRlRGlzY3Vzc2lvbkluT3JnOiBbXCJQT1NUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zXCJdLFxuICAgIGRlbGV0ZURpc2N1c3Npb25Db21tZW50SW5Pcmc6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHMve2NvbW1lbnRfbnVtYmVyfVwiXG4gICAgXSxcbiAgICBkZWxldGVEaXNjdXNzaW9uSW5Pcmc6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn1cIlxuICAgIF0sXG4gICAgZGVsZXRlSW5Pcmc6IFtcIkRFTEVURSAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfVwiXSxcbiAgICBnZXRCeU5hbWU6IFtcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfVwiXSxcbiAgICBnZXREaXNjdXNzaW9uQ29tbWVudEluT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzL3tjb21tZW50X251bWJlcn1cIlxuICAgIF0sXG4gICAgZ2V0RGlzY3Vzc2lvbkluT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9XCJcbiAgICBdLFxuICAgIGdldE1lbWJlcnNoaXBGb3JVc2VySW5Pcmc6IFtcbiAgICAgIFwiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L21lbWJlcnNoaXBzL3t1c2VybmFtZX1cIlxuICAgIF0sXG4gICAgbGlzdDogW1wiR0VUIC9vcmdzL3tvcmd9L3RlYW1zXCJdLFxuICAgIGxpc3RDaGlsZEluT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vdGVhbXNcIl0sXG4gICAgbGlzdERpc2N1c3Npb25Db21tZW50c0luT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9kaXNjdXNzaW9ucy97ZGlzY3Vzc2lvbl9udW1iZXJ9L2NvbW1lbnRzXCJcbiAgICBdLFxuICAgIGxpc3REaXNjdXNzaW9uc0luT3JnOiBbXCJHRVQgL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnNcIl0sXG4gICAgbGlzdEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvdGVhbXNcIl0sXG4gICAgbGlzdE1lbWJlcnNJbk9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L21lbWJlcnNcIl0sXG4gICAgbGlzdFBlbmRpbmdJbnZpdGF0aW9uc0luT3JnOiBbXG4gICAgICBcIkdFVCAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9pbnZpdGF0aW9uc1wiXG4gICAgXSxcbiAgICBsaXN0UmVwb3NJbk9yZzogW1wiR0VUIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L3JlcG9zXCJdLFxuICAgIHJlbW92ZU1lbWJlcnNoaXBGb3JVc2VySW5Pcmc6IFtcbiAgICAgIFwiREVMRVRFIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L21lbWJlcnNoaXBzL3t1c2VybmFtZX1cIlxuICAgIF0sXG4gICAgcmVtb3ZlUmVwb0luT3JnOiBbXG4gICAgICBcIkRFTEVURSAvb3Jncy97b3JnfS90ZWFtcy97dGVhbV9zbHVnfS9yZXBvcy97b3duZXJ9L3tyZXBvfVwiXG4gICAgXSxcbiAgICB1cGRhdGVEaXNjdXNzaW9uQ29tbWVudEluT3JnOiBbXG4gICAgICBcIlBBVENIIC9vcmdzL3tvcmd9L3RlYW1zL3t0ZWFtX3NsdWd9L2Rpc2N1c3Npb25zL3tkaXNjdXNzaW9uX251bWJlcn0vY29tbWVudHMve2NvbW1lbnRfbnVtYmVyfVwiXG4gICAgXSxcbiAgICB1cGRhdGVEaXNjdXNzaW9uSW5Pcmc6IFtcbiAgICAgIFwiUEFUQ0ggL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z30vZGlzY3Vzc2lvbnMve2Rpc2N1c3Npb25fbnVtYmVyfVwiXG4gICAgXSxcbiAgICB1cGRhdGVJbk9yZzogW1wiUEFUQ0ggL29yZ3Mve29yZ30vdGVhbXMve3RlYW1fc2x1Z31cIl1cbiAgfSxcbiAgdXNlcnM6IHtcbiAgICBhZGRFbWFpbEZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgIFwiUE9TVCAvdXNlci9lbWFpbHNcIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImFkZEVtYWlsRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgYWRkRW1haWxGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiUE9TVCAvdXNlci9lbWFpbHNcIl0sXG4gICAgYWRkU29jaWFsQWNjb3VudEZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL3NvY2lhbF9hY2NvdW50c1wiXSxcbiAgICBibG9jazogW1wiUFVUIC91c2VyL2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgIGNoZWNrQmxvY2tlZDogW1wiR0VUIC91c2VyL2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgIGNoZWNrRm9sbG93aW5nRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2ZvbGxvd2luZy97dGFyZ2V0X3VzZXJ9XCJdLFxuICAgIGNoZWNrUGVyc29uSXNGb2xsb3dlZEJ5QXV0aGVudGljYXRlZDogW1wiR0VUIC91c2VyL2ZvbGxvd2luZy97dXNlcm5hbWV9XCJdLFxuICAgIGNyZWF0ZUdwZ0tleUZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgIFwiUE9TVCAvdXNlci9ncGdfa2V5c1wiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwiY3JlYXRlR3BnS2V5Rm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgY3JlYXRlR3BnS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIlBPU1QgL3VzZXIvZ3BnX2tleXNcIl0sXG4gICAgY3JlYXRlUHVibGljU3NoS2V5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgXCJQT1NUIC91c2VyL2tleXNcIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImNyZWF0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH1cbiAgICBdLFxuICAgIGNyZWF0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL2tleXNcIl0sXG4gICAgY3JlYXRlU3NoU2lnbmluZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJQT1NUIC91c2VyL3NzaF9zaWduaW5nX2tleXNcIl0sXG4gICAgZGVsZXRlRW1haWxGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9lbWFpbHNcIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImRlbGV0ZUVtYWlsRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgZGVsZXRlRW1haWxGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiREVMRVRFIC91c2VyL2VtYWlsc1wiXSxcbiAgICBkZWxldGVHcGdLZXlGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9ncGdfa2V5cy97Z3BnX2tleV9pZH1cIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImRlbGV0ZUdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH1cbiAgICBdLFxuICAgIGRlbGV0ZUdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJERUxFVEUgL3VzZXIvZ3BnX2tleXMve2dwZ19rZXlfaWR9XCJdLFxuICAgIGRlbGV0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgIFwiREVMRVRFIC91c2VyL2tleXMve2tleV9pZH1cIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImRlbGV0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH1cbiAgICBdLFxuICAgIGRlbGV0ZVB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJERUxFVEUgL3VzZXIva2V5cy97a2V5X2lkfVwiXSxcbiAgICBkZWxldGVTb2NpYWxBY2NvdW50Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcIkRFTEVURSAvdXNlci9zb2NpYWxfYWNjb3VudHNcIl0sXG4gICAgZGVsZXRlU3NoU2lnbmluZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIkRFTEVURSAvdXNlci9zc2hfc2lnbmluZ19rZXlzL3tzc2hfc2lnbmluZ19rZXlfaWR9XCJcbiAgICBdLFxuICAgIGZvbGxvdzogW1wiUFVUIC91c2VyL2ZvbGxvd2luZy97dXNlcm5hbWV9XCJdLFxuICAgIGdldEF1dGhlbnRpY2F0ZWQ6IFtcIkdFVCAvdXNlclwiXSxcbiAgICBnZXRCeUlkOiBbXCJHRVQgL3VzZXIve2FjY291bnRfaWR9XCJdLFxuICAgIGdldEJ5VXNlcm5hbWU6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfVwiXSxcbiAgICBnZXRDb250ZXh0Rm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2hvdmVyY2FyZFwiXSxcbiAgICBnZXRHcGdLZXlGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICBcIkdFVCAvdXNlci9ncGdfa2V5cy97Z3BnX2tleV9pZH1cIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImdldEdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH1cbiAgICBdLFxuICAgIGdldEdwZ0tleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvZ3BnX2tleXMve2dwZ19rZXlfaWR9XCJdLFxuICAgIGdldFB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgIFwiR0VUIC91c2VyL2tleXMve2tleV9pZH1cIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImdldFB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyXCJdIH1cbiAgICBdLFxuICAgIGdldFB1YmxpY1NzaEtleUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIva2V5cy97a2V5X2lkfVwiXSxcbiAgICBnZXRTc2hTaWduaW5nS2V5Rm9yQXV0aGVudGljYXRlZFVzZXI6IFtcbiAgICAgIFwiR0VUIC91c2VyL3NzaF9zaWduaW5nX2tleXMve3NzaF9zaWduaW5nX2tleV9pZH1cIlxuICAgIF0sXG4gICAgbGlzdDogW1wiR0VUIC91c2Vyc1wiXSxcbiAgICBsaXN0QXR0ZXN0YXRpb25zOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vYXR0ZXN0YXRpb25zL3tzdWJqZWN0X2RpZ2VzdH1cIl0sXG4gICAgbGlzdEJsb2NrZWRCeUF1dGhlbnRpY2F0ZWQ6IFtcbiAgICAgIFwiR0VUIC91c2VyL2Jsb2Nrc1wiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwibGlzdEJsb2NrZWRCeUF1dGhlbnRpY2F0ZWRVc2VyXCJdIH1cbiAgICBdLFxuICAgIGxpc3RCbG9ja2VkQnlBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2Jsb2Nrc1wiXSxcbiAgICBsaXN0RW1haWxzRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgXCJHRVQgL3VzZXIvZW1haWxzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0RW1haWxzRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgbGlzdEVtYWlsc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvZW1haWxzXCJdLFxuICAgIGxpc3RGb2xsb3dlZEJ5QXV0aGVudGljYXRlZDogW1xuICAgICAgXCJHRVQgL3VzZXIvZm9sbG93aW5nXCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0Rm9sbG93ZWRCeUF1dGhlbnRpY2F0ZWRVc2VyXCJdIH1cbiAgICBdLFxuICAgIGxpc3RGb2xsb3dlZEJ5QXV0aGVudGljYXRlZFVzZXI6IFtcIkdFVCAvdXNlci9mb2xsb3dpbmdcIl0sXG4gICAgbGlzdEZvbGxvd2Vyc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvZm9sbG93ZXJzXCJdLFxuICAgIGxpc3RGb2xsb3dlcnNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93ZXJzXCJdLFxuICAgIGxpc3RGb2xsb3dpbmdGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vZm9sbG93aW5nXCJdLFxuICAgIGxpc3RHcGdLZXlzRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgXCJHRVQgL3VzZXIvZ3BnX2tleXNcIixcbiAgICAgIHt9LFxuICAgICAgeyByZW5hbWVkOiBbXCJ1c2Vyc1wiLCBcImxpc3RHcGdLZXlzRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgbGlzdEdwZ0tleXNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL2dwZ19rZXlzXCJdLFxuICAgIGxpc3RHcGdLZXlzRm9yVXNlcjogW1wiR0VUIC91c2Vycy97dXNlcm5hbWV9L2dwZ19rZXlzXCJdLFxuICAgIGxpc3RQdWJsaWNFbWFpbHNGb3JBdXRoZW50aWNhdGVkOiBbXG4gICAgICBcIkdFVCAvdXNlci9wdWJsaWNfZW1haWxzXCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJsaXN0UHVibGljRW1haWxzRm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgbGlzdFB1YmxpY0VtYWlsc0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvcHVibGljX2VtYWlsc1wiXSxcbiAgICBsaXN0UHVibGljS2V5c0ZvclVzZXI6IFtcIkdFVCAvdXNlcnMve3VzZXJuYW1lfS9rZXlzXCJdLFxuICAgIGxpc3RQdWJsaWNTc2hLZXlzRm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgXCJHRVQgL3VzZXIva2V5c1wiLFxuICAgICAge30sXG4gICAgICB7IHJlbmFtZWQ6IFtcInVzZXJzXCIsIFwibGlzdFB1YmxpY1NzaEtleXNGb3JBdXRoZW50aWNhdGVkVXNlclwiXSB9XG4gICAgXSxcbiAgICBsaXN0UHVibGljU3NoS2V5c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIva2V5c1wiXSxcbiAgICBsaXN0U29jaWFsQWNjb3VudHNGb3JBdXRoZW50aWNhdGVkVXNlcjogW1wiR0VUIC91c2VyL3NvY2lhbF9hY2NvdW50c1wiXSxcbiAgICBsaXN0U29jaWFsQWNjb3VudHNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc29jaWFsX2FjY291bnRzXCJdLFxuICAgIGxpc3RTc2hTaWduaW5nS2V5c0ZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXCJHRVQgL3VzZXIvc3NoX3NpZ25pbmdfa2V5c1wiXSxcbiAgICBsaXN0U3NoU2lnbmluZ0tleXNGb3JVc2VyOiBbXCJHRVQgL3VzZXJzL3t1c2VybmFtZX0vc3NoX3NpZ25pbmdfa2V5c1wiXSxcbiAgICBzZXRQcmltYXJ5RW1haWxWaXNpYmlsaXR5Rm9yQXV0aGVudGljYXRlZDogW1xuICAgICAgXCJQQVRDSCAvdXNlci9lbWFpbC92aXNpYmlsaXR5XCIsXG4gICAgICB7fSxcbiAgICAgIHsgcmVuYW1lZDogW1widXNlcnNcIiwgXCJzZXRQcmltYXJ5RW1haWxWaXNpYmlsaXR5Rm9yQXV0aGVudGljYXRlZFVzZXJcIl0gfVxuICAgIF0sXG4gICAgc2V0UHJpbWFyeUVtYWlsVmlzaWJpbGl0eUZvckF1dGhlbnRpY2F0ZWRVc2VyOiBbXG4gICAgICBcIlBBVENIIC91c2VyL2VtYWlsL3Zpc2liaWxpdHlcIlxuICAgIF0sXG4gICAgdW5ibG9jazogW1wiREVMRVRFIC91c2VyL2Jsb2Nrcy97dXNlcm5hbWV9XCJdLFxuICAgIHVuZm9sbG93OiBbXCJERUxFVEUgL3VzZXIvZm9sbG93aW5nL3t1c2VybmFtZX1cIl0sXG4gICAgdXBkYXRlQXV0aGVudGljYXRlZDogW1wiUEFUQ0ggL3VzZXJcIl1cbiAgfVxufTtcbnZhciBlbmRwb2ludHNfZGVmYXVsdCA9IEVuZHBvaW50cztcbmV4cG9ydCB7XG4gIGVuZHBvaW50c19kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmRwb2ludHMuanMubWFwXG4iLCJpbXBvcnQgRU5EUE9JTlRTIGZyb20gXCIuL2dlbmVyYXRlZC9lbmRwb2ludHMuanNcIjtcbmNvbnN0IGVuZHBvaW50TWV0aG9kc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mb3IgKGNvbnN0IFtzY29wZSwgZW5kcG9pbnRzXSBvZiBPYmplY3QuZW50cmllcyhFTkRQT0lOVFMpKSB7XG4gIGZvciAoY29uc3QgW21ldGhvZE5hbWUsIGVuZHBvaW50XSBvZiBPYmplY3QuZW50cmllcyhlbmRwb2ludHMpKSB7XG4gICAgY29uc3QgW3JvdXRlLCBkZWZhdWx0cywgZGVjb3JhdGlvbnNdID0gZW5kcG9pbnQ7XG4gICAgY29uc3QgW21ldGhvZCwgdXJsXSA9IHJvdXRlLnNwbGl0KC8gLyk7XG4gICAgY29uc3QgZW5kcG9pbnREZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdXJsXG4gICAgICB9LFxuICAgICAgZGVmYXVsdHNcbiAgICApO1xuICAgIGlmICghZW5kcG9pbnRNZXRob2RzTWFwLmhhcyhzY29wZSkpIHtcbiAgICAgIGVuZHBvaW50TWV0aG9kc01hcC5zZXQoc2NvcGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBlbmRwb2ludE1ldGhvZHNNYXAuZ2V0KHNjb3BlKS5zZXQobWV0aG9kTmFtZSwge1xuICAgICAgc2NvcGUsXG4gICAgICBtZXRob2ROYW1lLFxuICAgICAgZW5kcG9pbnREZWZhdWx0cyxcbiAgICAgIGRlY29yYXRpb25zXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGhhbmRsZXIgPSB7XG4gIGhhcyh7IHNjb3BlIH0sIG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRNZXRob2RzTWFwLmdldChzY29wZSkuaGFzKG1ldGhvZE5hbWUpO1xuICB9LFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0aGlzLmdldCh0YXJnZXQsIG1ldGhvZE5hbWUpLFxuICAgICAgLy8gZW5zdXJlcyBtZXRob2QgaXMgaW4gdGhlIGNhY2hlXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9O1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG1ldGhvZE5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LmNhY2hlLCBtZXRob2ROYW1lLCBkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBtZXRob2ROYW1lKSB7XG4gICAgZGVsZXRlIHRhcmdldC5jYWNoZVttZXRob2ROYW1lXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgb3duS2V5cyh7IHNjb3BlIH0pIHtcbiAgICByZXR1cm4gWy4uLmVuZHBvaW50TWV0aG9kc01hcC5nZXQoc2NvcGUpLmtleXMoKV07XG4gIH0sXG4gIHNldCh0YXJnZXQsIG1ldGhvZE5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRhcmdldC5jYWNoZVttZXRob2ROYW1lXSA9IHZhbHVlO1xuICB9LFxuICBnZXQoeyBvY3Rva2l0LCBzY29wZSwgY2FjaGUgfSwgbWV0aG9kTmFtZSkge1xuICAgIGlmIChjYWNoZVttZXRob2ROYW1lXSkge1xuICAgICAgcmV0dXJuIGNhY2hlW21ldGhvZE5hbWVdO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBlbmRwb2ludE1ldGhvZHNNYXAuZ2V0KHNjb3BlKS5nZXQobWV0aG9kTmFtZSk7XG4gICAgaWYgKCFtZXRob2QpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHsgZW5kcG9pbnREZWZhdWx0cywgZGVjb3JhdGlvbnMgfSA9IG1ldGhvZDtcbiAgICBpZiAoZGVjb3JhdGlvbnMpIHtcbiAgICAgIGNhY2hlW21ldGhvZE5hbWVdID0gZGVjb3JhdGUoXG4gICAgICAgIG9jdG9raXQsXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICBlbmRwb2ludERlZmF1bHRzLFxuICAgICAgICBkZWNvcmF0aW9uc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVbbWV0aG9kTmFtZV0gPSBvY3Rva2l0LnJlcXVlc3QuZGVmYXVsdHMoZW5kcG9pbnREZWZhdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVttZXRob2ROYW1lXTtcbiAgfVxufTtcbmZ1bmN0aW9uIGVuZHBvaW50c1RvTWV0aG9kcyhvY3Rva2l0KSB7XG4gIGNvbnN0IG5ld01ldGhvZHMgPSB7fTtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBlbmRwb2ludE1ldGhvZHNNYXAua2V5cygpKSB7XG4gICAgbmV3TWV0aG9kc1tzY29wZV0gPSBuZXcgUHJveHkoeyBvY3Rva2l0LCBzY29wZSwgY2FjaGU6IHt9IH0sIGhhbmRsZXIpO1xuICB9XG4gIHJldHVybiBuZXdNZXRob2RzO1xufVxuZnVuY3Rpb24gZGVjb3JhdGUob2N0b2tpdCwgc2NvcGUsIG1ldGhvZE5hbWUsIGRlZmF1bHRzLCBkZWNvcmF0aW9ucykge1xuICBjb25zdCByZXF1ZXN0V2l0aERlZmF1bHRzID0gb2N0b2tpdC5yZXF1ZXN0LmRlZmF1bHRzKGRlZmF1bHRzKTtcbiAgZnVuY3Rpb24gd2l0aERlY29yYXRpb25zKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHJlcXVlc3RXaXRoRGVmYXVsdHMuZW5kcG9pbnQubWVyZ2UoLi4uYXJncyk7XG4gICAgaWYgKGRlY29yYXRpb25zLm1hcFRvRGF0YSkge1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZGF0YTogb3B0aW9uc1tkZWNvcmF0aW9ucy5tYXBUb0RhdGFdLFxuICAgICAgICBbZGVjb3JhdGlvbnMubWFwVG9EYXRhXTogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXF1ZXN0V2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdGlvbnMucmVuYW1lZCkge1xuICAgICAgY29uc3QgW25ld1Njb3BlLCBuZXdNZXRob2ROYW1lXSA9IGRlY29yYXRpb25zLnJlbmFtZWQ7XG4gICAgICBvY3Rva2l0LmxvZy53YXJuKFxuICAgICAgICBgb2N0b2tpdC4ke3Njb3BlfS4ke21ldGhvZE5hbWV9KCkgaGFzIGJlZW4gcmVuYW1lZCB0byBvY3Rva2l0LiR7bmV3U2NvcGV9LiR7bmV3TWV0aG9kTmFtZX0oKWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWNvcmF0aW9ucy5kZXByZWNhdGVkKSB7XG4gICAgICBvY3Rva2l0LmxvZy53YXJuKGRlY29yYXRpb25zLmRlcHJlY2F0ZWQpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdGlvbnMucmVuYW1lZFBhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMyID0gcmVxdWVzdFdpdGhEZWZhdWx0cy5lbmRwb2ludC5tZXJnZSguLi5hcmdzKTtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIGFsaWFzXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgZGVjb3JhdGlvbnMucmVuYW1lZFBhcmFtZXRlcnNcbiAgICAgICkpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gb3B0aW9uczIpIHtcbiAgICAgICAgICBvY3Rva2l0LmxvZy53YXJuKFxuICAgICAgICAgICAgYFwiJHtuYW1lfVwiIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIGZvciBcIm9jdG9raXQuJHtzY29wZX0uJHttZXRob2ROYW1lfSgpXCIuIFVzZSBcIiR7YWxpYXN9XCIgaW5zdGVhZGBcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghKGFsaWFzIGluIG9wdGlvbnMyKSkge1xuICAgICAgICAgICAgb3B0aW9uczJbYWxpYXNdID0gb3B0aW9uczJbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zMltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3RXaXRoRGVmYXVsdHMob3B0aW9uczIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdFdpdGhEZWZhdWx0cyguLi5hcmdzKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih3aXRoRGVjb3JhdGlvbnMsIHJlcXVlc3RXaXRoRGVmYXVsdHMpO1xufVxuZXhwb3J0IHtcbiAgZW5kcG9pbnRzVG9NZXRob2RzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5kcG9pbnRzLXRvLW1ldGhvZHMuanMubWFwXG4iLCJpbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuaW1wb3J0IHsgZW5kcG9pbnRzVG9NZXRob2RzIH0gZnJvbSBcIi4vZW5kcG9pbnRzLXRvLW1ldGhvZHMuanNcIjtcbmZ1bmN0aW9uIHJlc3RFbmRwb2ludE1ldGhvZHMob2N0b2tpdCkge1xuICBjb25zdCBhcGkgPSBlbmRwb2ludHNUb01ldGhvZHMob2N0b2tpdCk7XG4gIHJldHVybiB7XG4gICAgcmVzdDogYXBpXG4gIH07XG59XG5yZXN0RW5kcG9pbnRNZXRob2RzLlZFUlNJT04gPSBWRVJTSU9OO1xuZnVuY3Rpb24gbGVnYWN5UmVzdEVuZHBvaW50TWV0aG9kcyhvY3Rva2l0KSB7XG4gIGNvbnN0IGFwaSA9IGVuZHBvaW50c1RvTWV0aG9kcyhvY3Rva2l0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hcGksXG4gICAgcmVzdDogYXBpXG4gIH07XG59XG5sZWdhY3lSZXN0RW5kcG9pbnRNZXRob2RzLlZFUlNJT04gPSBWRVJTSU9OO1xuZXhwb3J0IHtcbiAgbGVnYWN5UmVzdEVuZHBvaW50TWV0aG9kcyxcbiAgcmVzdEVuZHBvaW50TWV0aG9kc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiY29uc3QgVkVSU0lPTiA9IFwiMjIuMC4wXCI7XG5leHBvcnQge1xuICBWRVJTSU9OXG59O1xuIiwiaW1wb3J0IHsgT2N0b2tpdCBhcyBDb3JlIH0gZnJvbSBcIkBvY3Rva2l0L2NvcmVcIjtcbmltcG9ydCB7IHJlcXVlc3RMb2cgfSBmcm9tIFwiQG9jdG9raXQvcGx1Z2luLXJlcXVlc3QtbG9nXCI7XG5pbXBvcnQge1xuICBwYWdpbmF0ZVJlc3Rcbn0gZnJvbSBcIkBvY3Rva2l0L3BsdWdpbi1wYWdpbmF0ZS1yZXN0XCI7XG5pbXBvcnQgeyBsZWdhY3lSZXN0RW5kcG9pbnRNZXRob2RzIH0gZnJvbSBcIkBvY3Rva2l0L3BsdWdpbi1yZXN0LWVuZHBvaW50LW1ldGhvZHNcIjtcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tIFwiLi92ZXJzaW9uLmpzXCI7XG5jb25zdCBPY3Rva2l0ID0gQ29yZS5wbHVnaW4ocmVxdWVzdExvZywgbGVnYWN5UmVzdEVuZHBvaW50TWV0aG9kcywgcGFnaW5hdGVSZXN0KS5kZWZhdWx0cyhcbiAge1xuICAgIHVzZXJBZ2VudDogYG9jdG9raXQtcmVzdC5qcy8ke1ZFUlNJT059YFxuICB9XG4pO1xuZXhwb3J0IHtcbiAgT2N0b2tpdFxufTtcbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlUHJlUHVibGlzaENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sncHJlLXB1Ymxpc2gnXSwgWydwcmVwdWJsaXNoJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVXBkYXRlIHBhY2thZ2UuanNvbiBhbmQgY29weSBhZGRvbnMgaW50byBwZXIgcGxhdGZvcm0gcGFja2FnZXMnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpciwtcCcsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gIHRhZ1N0eWxlID0gT3B0aW9uLlN0cmluZygnLS10YWctc3R5bGUsLS10YWdzdHlsZSwtdCcsICdsZXJuYScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ2dpdCB0YWcgc3R5bGUsIGBucG1gIG9yIGBsZXJuYWAnLFxuICB9KVxuXG4gIGdoUmVsZWFzZSA9IE9wdGlvbi5Cb29sZWFuKCctLWdoLXJlbGVhc2UnLCB0cnVlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGNyZWF0ZSBHaXRIdWIgcmVsZWFzZScsXG4gIH0pXG5cbiAgZ2hSZWxlYXNlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZ2gtcmVsZWFzZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOiAnR2l0SHViIHJlbGVhc2UgbmFtZScsXG4gIH0pXG5cbiAgZ2hSZWxlYXNlSWQ/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWdoLXJlbGVhc2UtaWQnLCB7XG4gICAgZGVzY3JpcHRpb246ICdFeGlzdGluZyBHaXRIdWIgcmVsZWFzZSBpZCcsXG4gIH0pXG5cbiAgc2tpcE9wdGlvbmFsUHVibGlzaCA9IE9wdGlvbi5Cb29sZWFuKCctLXNraXAtb3B0aW9uYWwtcHVibGlzaCcsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIHNraXAgb3B0aW9uYWxEZXBlbmRlbmNpZXMgcGFja2FnZXMgcHVibGlzaCcsXG4gIH0pXG5cbiAgZHJ5UnVuID0gT3B0aW9uLkJvb2xlYW4oJy0tZHJ5LXJ1bicsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdEcnkgcnVuIHdpdGhvdXQgdG91Y2hpbmcgZmlsZSBzeXN0ZW0nLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIHRhZ1N0eWxlOiB0aGlzLnRhZ1N0eWxlLFxuICAgICAgZ2hSZWxlYXNlOiB0aGlzLmdoUmVsZWFzZSxcbiAgICAgIGdoUmVsZWFzZU5hbWU6IHRoaXMuZ2hSZWxlYXNlTmFtZSxcbiAgICAgIGdoUmVsZWFzZUlkOiB0aGlzLmdoUmVsZWFzZUlkLFxuICAgICAgc2tpcE9wdGlvbmFsUHVibGlzaDogdGhpcy5za2lwT3B0aW9uYWxQdWJsaXNoLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgcGFja2FnZS5qc29uIGFuZCBjb3B5IGFkZG9ucyBpbnRvIHBlciBwbGF0Zm9ybSBwYWNrYWdlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByZVB1Ymxpc2hPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGdpdCB0YWcgc3R5bGUsIGBucG1gIG9yIGBsZXJuYWBcbiAgICpcbiAgICogQGRlZmF1bHQgJ2xlcm5hJ1xuICAgKi9cbiAgdGFnU3R5bGU/OiAnbnBtJyB8ICdsZXJuYSdcbiAgLyoqXG4gICAqIFdoZXRoZXIgY3JlYXRlIEdpdEh1YiByZWxlYXNlXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGdoUmVsZWFzZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEdpdEh1YiByZWxlYXNlIG5hbWVcbiAgICovXG4gIGdoUmVsZWFzZU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEV4aXN0aW5nIEdpdEh1YiByZWxlYXNlIGlkXG4gICAqL1xuICBnaFJlbGVhc2VJZD86IHN0cmluZ1xuICAvKipcbiAgICogV2hldGhlciBza2lwIG9wdGlvbmFsRGVwZW5kZW5jaWVzIHBhY2thZ2VzIHB1Ymxpc2hcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNraXBPcHRpb25hbFB1Ymxpc2g/OiBib29sZWFuXG4gIC8qKlxuICAgKiBEcnkgcnVuIHdpdGhvdXQgdG91Y2hpbmcgZmlsZSBzeXN0ZW1cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyeVJ1bj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFByZVB1Ymxpc2hPcHRpb25zKG9wdGlvbnM6IFByZVB1Ymxpc2hPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICB0YWdTdHlsZTogJ2xlcm5hJyxcbiAgICBnaFJlbGVhc2U6IHRydWUsXG4gICAgc2tpcE9wdGlvbmFsUHVibGlzaDogZmFsc2UsXG4gICAgZHJ5UnVuOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVZlcnNpb25Db21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3ZlcnNpb24nXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ1VwZGF0ZSB2ZXJzaW9uIGluIGNyZWF0ZWQgbnBtIHBhY2thZ2VzJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHZlcnNpb24gaW4gY3JlYXRlZCBucG0gcGFja2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWZXJzaW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRWZXJzaW9uT3B0aW9ucyhvcHRpb25zOiBWZXJzaW9uT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgYXBwbHlEZWZhdWx0VmVyc2lvbk9wdGlvbnMsIFZlcnNpb25PcHRpb25zIH0gZnJvbSAnLi4vZGVmL3ZlcnNpb24uanMnXG5pbXBvcnQge1xuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICB1cGRhdGVQYWNrYWdlSnNvbixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCd2ZXJzaW9uJylcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcnNpb24odXNlck9wdGlvbnM6IFZlcnNpb25PcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRWZXJzaW9uT3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcblxuICBmb3IgKGNvbnN0IHRhcmdldCBvZiBjb25maWcudGFyZ2V0cykge1xuICAgIGNvbnN0IHBrZ0RpciA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMubnBtRGlyLCB0YXJnZXQucGxhdGZvcm1BcmNoQUJJKVxuXG4gICAgZGVidWcoYFVwZGF0ZSB2ZXJzaW9uIHRvICVpIGluIFslaV1gLCBjb25maWcucGFja2FnZUpzb24udmVyc2lvbiwgcGtnRGlyKVxuICAgIGF3YWl0IHVwZGF0ZVBhY2thZ2VKc29uKGpvaW4ocGtnRGlyLCAncGFja2FnZS5qc29uJyksIHtcbiAgICAgIHZlcnNpb246IGNvbmZpZy5wYWNrYWdlSnNvbi52ZXJzaW9uLFxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgZXhpc3RzU3luYywgc3RhdFN5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgT2N0b2tpdCB9IGZyb20gJ0BvY3Rva2l0L3Jlc3QnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdFByZVB1Ymxpc2hPcHRpb25zLFxuICBQcmVQdWJsaXNoT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL3ByZS1wdWJsaXNoLmpzJ1xuaW1wb3J0IHtcbiAgcmVhZEZpbGVBc3luYyxcbiAgcmVhZE5hcGlDb25maWcsXG4gIGRlYnVnRmFjdG9yeSxcbiAgdXBkYXRlUGFja2FnZUpzb24sXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgncHJlLXB1Ymxpc2gnKVxuXG5pbnRlcmZhY2UgUGFja2FnZUluZm8ge1xuICBuYW1lOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIHRhZzogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVQdWJsaXNoKHVzZXJPcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucykge1xuICBkZWJ1ZygnUmVjZWl2ZSBwcmUtcHVibGlzaCBvcHRpb25zOicpXG4gIGRlYnVnKCcgICVPJywgdXNlck9wdGlvbnMpXG5cbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByZVB1Ymxpc2hPcHRpb25zKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IHsgcGFja2FnZUpzb24sIHRhcmdldHMsIHBhY2thZ2VOYW1lLCBiaW5hcnlOYW1lLCBucG1DbGllbnQgfSA9XG4gICAgYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICAgIClcblxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVHaFJlbGVhc2UocGFja2FnZU5hbWU6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nKSB7XG4gICAgaWYgKCFvcHRpb25zLmdoUmVsZWFzZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIHJlcG86IG51bGwsXG4gICAgICAgIHBrZ0luZm86IHsgbmFtZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdGFnOiBudWxsIH0sXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgcmVwbywgb3duZXIsIHBrZ0luZm8sIG9jdG9raXQgfSA9IGdldFJlcG9JbmZvKHBhY2thZ2VOYW1lLCB2ZXJzaW9uKVxuXG4gICAgaWYgKCFyZXBvIHx8ICFvd25lcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIHJlcG86IG51bGwsXG4gICAgICAgIHBrZ0luZm86IHsgbmFtZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdGFnOiBudWxsIH0sXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb2N0b2tpdC5yZXBvcy5jcmVhdGVSZWxlYXNlKHtcbiAgICAgICAgICBvd25lcixcbiAgICAgICAgICByZXBvLFxuICAgICAgICAgIHRhZ19uYW1lOiBwa2dJbmZvLnRhZyxcbiAgICAgICAgICBuYW1lOiBvcHRpb25zLmdoUmVsZWFzZU5hbWUsXG4gICAgICAgICAgcHJlcmVsZWFzZTpcbiAgICAgICAgICAgIHZlcnNpb24uaW5jbHVkZXMoJ2FscGhhJykgfHxcbiAgICAgICAgICAgIHZlcnNpb24uaW5jbHVkZXMoJ2JldGEnKSB8fFxuICAgICAgICAgICAgdmVyc2lvbi5pbmNsdWRlcygncmMnKSxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgYFBhcmFtczogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHsgb3duZXIsIHJlcG8sIHRhZ19uYW1lOiBwa2dJbmZvLnRhZyB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgKX1gLFxuICAgICAgICApXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3duZXIsIHJlcG8sIHBrZ0luZm8sIG9jdG9raXQgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVwb0luZm8ocGFja2FnZU5hbWU6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nKSB7XG4gICAgY29uc3QgaGVhZENvbW1pdCA9IGV4ZWNTeW5jKCdnaXQgbG9nIC0xIC0tcHJldHR5PSVCJywge1xuICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgfSkudHJpbSgpXG5cbiAgICBjb25zdCB7IEdJVEhVQl9SRVBPU0lUT1JZIH0gPSBwcm9jZXNzLmVudlxuICAgIGlmICghR0lUSFVCX1JFUE9TSVRPUlkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1ZyhgR2l0aHViIHJlcG9zaXRvcnk6ICR7R0lUSFVCX1JFUE9TSVRPUll9YClcbiAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gR0lUSFVCX1JFUE9TSVRPUlkuc3BsaXQoJy8nKVxuICAgIGNvbnN0IG9jdG9raXQgPSBuZXcgT2N0b2tpdCh7XG4gICAgICBhdXRoOiBwcm9jZXNzLmVudi5HSVRIVUJfVE9LRU4sXG4gICAgfSlcbiAgICBsZXQgcGtnSW5mbzogUGFja2FnZUluZm8gfCB1bmRlZmluZWRcbiAgICBpZiAob3B0aW9ucy50YWdTdHlsZSA9PT0gJ2xlcm5hJykge1xuICAgICAgY29uc3QgcGFja2FnZXNUb1B1Ymxpc2ggPSBoZWFkQ29tbWl0XG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcCgobGluZSkgPT4gbGluZS50cmltKCkpXG4gICAgICAgIC5maWx0ZXIoKGxpbmUsIGluZGV4KSA9PiBsaW5lLmxlbmd0aCAmJiBpbmRleClcbiAgICAgICAgLm1hcCgobGluZSkgPT4gbGluZS5zdWJzdHJpbmcoMikpXG4gICAgICAgIC5tYXAocGFyc2VUYWcpXG5cbiAgICAgIHBrZ0luZm8gPSBwYWNrYWdlc1RvUHVibGlzaC5maW5kKFxuICAgICAgICAocGtnSW5mbykgPT4gcGtnSW5mby5uYW1lID09PSBwYWNrYWdlTmFtZSxcbiAgICAgIClcblxuICAgICAgaWYgKCFwa2dJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYE5vIHJlbGVhc2UgY29tbWl0IGZvdW5kIHdpdGggJHtwYWNrYWdlTmFtZX0sIG9yaWdpbmFsIGNvbW1pdCBpbmZvOiAke2hlYWRDb21taXR9YCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwa2dJbmZvID0ge1xuICAgICAgICB0YWc6IGB2JHt2ZXJzaW9ufWAsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIG5hbWU6IHBhY2thZ2VOYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBvd25lciwgcmVwbywgcGtnSW5mbywgb2N0b2tpdCB9XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgYXdhaXQgdmVyc2lvbih1c2VyT3B0aW9ucylcbiAgICBhd2FpdCB1cGRhdGVQYWNrYWdlSnNvbihwYWNrYWdlSnNvblBhdGgsIHtcbiAgICAgIG9wdGlvbmFsRGVwZW5kZW5jaWVzOiB0YXJnZXRzLnJlZHVjZShcbiAgICAgICAgKGRlcHMsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIGRlcHNbYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gXSA9IHBhY2thZ2VKc29uLnZlcnNpb25cblxuICAgICAgICAgIHJldHVybiBkZXBzXG4gICAgICAgIH0sXG4gICAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgICApLFxuICAgIH0pXG4gIH1cblxuICBjb25zdCB7IG93bmVyLCByZXBvLCBwa2dJbmZvLCBvY3Rva2l0IH0gPSBvcHRpb25zLmdoUmVsZWFzZUlkXG4gICAgPyBnZXRSZXBvSW5mbyhwYWNrYWdlTmFtZSwgcGFja2FnZUpzb24udmVyc2lvbilcbiAgICA6IGF3YWl0IGNyZWF0ZUdoUmVsZWFzZShwYWNrYWdlTmFtZSwgcGFja2FnZUpzb24udmVyc2lvbilcblxuICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgY29uc3QgcGtnRGlyID0gcmVzb2x2ZShcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5ucG1EaXIsXG4gICAgICBgJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfWAsXG4gICAgKVxuICAgIGNvbnN0IGV4dCA9XG4gICAgICB0YXJnZXQucGxhdGZvcm0gPT09ICd3YXNpJyB8fCB0YXJnZXQucGxhdGZvcm0gPT09ICd3YXNtJyA/ICd3YXNtJyA6ICdub2RlJ1xuICAgIGNvbnN0IGZpbGVuYW1lID0gYCR7YmluYXJ5TmFtZX0uJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfS4ke2V4dH1gXG4gICAgY29uc3QgZHN0UGF0aCA9IGpvaW4ocGtnRGlyLCBmaWxlbmFtZSlcblxuICAgIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIGlmICghZXhpc3RzU3luYyhkc3RQYXRoKSkge1xuICAgICAgICBkZWJ1Zy53YXJuKGAlcyBkb2Vzbid0IGV4aXN0YCwgZHN0UGF0aClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnNraXBPcHRpb25hbFB1Ymxpc2gpIHtcbiAgICAgICAgZXhlY1N5bmMoYCR7bnBtQ2xpZW50fSBwdWJsaXNoYCwge1xuICAgICAgICAgIGN3ZDogcGtnRGlyLFxuICAgICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmdoUmVsZWFzZSAmJiByZXBvICYmIG93bmVyKSB7XG4gICAgICAgIGRlYnVnLmluZm8oYENyZWF0aW5nIEdpdEh1YiByZWxlYXNlICR7cGtnSW5mby50YWd9YClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZWxlYXNlSWQgPSBvcHRpb25zLmdoUmVsZWFzZUlkXG4gICAgICAgICAgICA/IE51bWJlcihvcHRpb25zLmdoUmVsZWFzZUlkKVxuICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICAgYXdhaXQgb2N0b2tpdCEucmVwb3MuZ2V0UmVsZWFzZUJ5VGFnKHtcbiAgICAgICAgICAgICAgICAgIHJlcG86IHJlcG8sXG4gICAgICAgICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICAgICAgICB0YWc6IHBrZ0luZm8udGFnLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICkuZGF0YS5pZFxuICAgICAgICAgIGNvbnN0IGRzdEZpbGVTdGF0cyA9IHN0YXRTeW5jKGRzdFBhdGgpXG4gICAgICAgICAgY29uc3QgYXNzZXRJbmZvID0gYXdhaXQgb2N0b2tpdCEucmVwb3MudXBsb2FkUmVsZWFzZUFzc2V0KHtcbiAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgIHJlcG86IHJlcG8sXG4gICAgICAgICAgICBuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgIHJlbGVhc2VfaWQ6IHJlbGVhc2VJZCxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogeyBmb3JtYXQ6ICdyYXcnIH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdjb250ZW50LWxlbmd0aCc6IGRzdEZpbGVTdGF0cy5zaXplLFxuICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBvY3Rva2l0IHR5cGVzIGFyZSB3cm9uZ1xuICAgICAgICAgICAgZGF0YTogYXdhaXQgcmVhZEZpbGVBc3luYyhkc3RQYXRoKSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGRlYnVnLmluZm8oYEdpdEh1YiByZWxlYXNlIGNyZWF0ZWRgKVxuICAgICAgICAgIGRlYnVnLmluZm8oYERvd25sb2FkIFVSTDogJXNgLCBhc3NldEluZm8uZGF0YS5icm93c2VyX2Rvd25sb2FkX3VybClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnLmVycm9yKFxuICAgICAgICAgICAgYFBhcmFtOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICB7IG93bmVyLCByZXBvLCB0YWc6IHBrZ0luZm8udGFnLCBmaWxlbmFtZTogZHN0UGF0aCB9LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgKX1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFnKHRhZzogc3RyaW5nKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gdGFnLnNwbGl0KCdAJylcbiAgY29uc3QgdmVyc2lvbiA9IHNlZ21lbnRzLnBvcCgpIVxuICBjb25zdCBuYW1lID0gc2VnbWVudHMuam9pbignQCcpXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHZlcnNpb24sXG4gICAgdGFnLFxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVVuaXZlcnNhbGl6ZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sndW5pdmVyc2FsaXplJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdDb21iaWxlIGJ1aWx0IGJpbmFyaWVzIGludG8gb25lIHVuaXZlcnNhbCBiaW5hcnknLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG91dHB1dERpciA9IE9wdGlvbi5TdHJpbmcoJy0tb3V0cHV0LWRpciwtbycsICcuLycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmQnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgb3V0cHV0RGlyOiB0aGlzLm91dHB1dERpcixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21iaWxlIGJ1aWx0IGJpbmFyaWVzIGludG8gb25lIHVuaXZlcnNhbCBiaW5hcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVbml2ZXJzYWxpemVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kXG4gICAqXG4gICAqIEBkZWZhdWx0ICcuLydcbiAgICovXG4gIG91dHB1dERpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyhvcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgb3V0cHV0RGlyOiAnLi8nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IHNwYXduU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdFVuaXZlcnNhbGl6ZU9wdGlvbnMsXG4gIFVuaXZlcnNhbGl6ZU9wdGlvbnMsXG59IGZyb20gJy4uL2RlZi91bml2ZXJzYWxpemUuanMnXG5pbXBvcnQgeyByZWFkTmFwaUNvbmZpZyB9IGZyb20gJy4uL3V0aWxzL2NvbmZpZy5qcydcbmltcG9ydCB7IGRlYnVnRmFjdG9yeSB9IGZyb20gJy4uL3V0aWxzL2xvZy5qcydcbmltcG9ydCB7IGZpbGVFeGlzdHMgfSBmcm9tICcuLi91dGlscy9taXNjLmpzJ1xuaW1wb3J0IHsgVW5pQXJjaHNCeVBsYXRmb3JtIH0gZnJvbSAnLi4vdXRpbHMvdGFyZ2V0LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndW5pdmVyc2FsaXplJylcblxuY29uc3QgdW5pdmVyc2FsaXplcnM6IFBhcnRpYWw8XG4gIFJlY29yZDxOb2RlSlMuUGxhdGZvcm0sIChpbnB1dHM6IHN0cmluZ1tdLCBvdXRwdXQ6IHN0cmluZykgPT4gdm9pZD5cbj4gPSB7XG4gIGRhcndpbjogKGlucHV0cywgb3V0cHV0KSA9PiB7XG4gICAgc3Bhd25TeW5jKCdsaXBvJywgWyctY3JlYXRlJywgJy1vdXRwdXQnLCBvdXRwdXQsIC4uLmlucHV0c10sIHtcbiAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgfSlcbiAgfSxcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVuaXZlcnNhbGl6ZUJpbmFyaWVzKHVzZXJPcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRVbml2ZXJzYWxpemVPcHRpb25zKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgY29uc3QgdGFyZ2V0ID0gY29uZmlnLnRhcmdldHMuZmluZChcbiAgICAodCkgPT4gdC5wbGF0Zm9ybSA9PT0gcHJvY2Vzcy5wbGF0Zm9ybSAmJiB0LmFyY2ggPT09ICd1bml2ZXJzYWwnLFxuICApXG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJ3VuaXZlcnNhbCcgYXJjaCBmb3IgcGxhdGZvcm0gJyR7cHJvY2Vzcy5wbGF0Zm9ybX0nIG5vdCBmb3VuZCBpbiBjb25maWchYCxcbiAgICApXG4gIH1cblxuICBjb25zdCBzcmNGaWxlcyA9IFVuaUFyY2hzQnlQbGF0Zm9ybVtwcm9jZXNzLnBsYXRmb3JtXT8ubWFwKChhcmNoKSA9PlxuICAgIHJlc29sdmUoXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMub3V0cHV0RGlyLFxuICAgICAgYCR7Y29uZmlnLmJpbmFyeU5hbWV9LiR7cHJvY2Vzcy5wbGF0Zm9ybX0tJHthcmNofS5ub2RlYCxcbiAgICApLFxuICApXG5cbiAgaWYgKCFzcmNGaWxlcyB8fCAhdW5pdmVyc2FsaXplcnNbcHJvY2Vzcy5wbGF0Zm9ybV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJ3VuaXZlcnNhbCcgYXJjaCBmb3IgcGxhdGZvcm0gJyR7cHJvY2Vzcy5wbGF0Zm9ybX0nIG5vdCBzdXBwb3J0ZWQuYCxcbiAgICApXG4gIH1cblxuICBkZWJ1ZyhgTG9va2luZyB1cCBzb3VyY2UgYmluYXJpZXMgdG8gY29tYmluZTogYClcbiAgZGVidWcoJyAgJU8nLCBzcmNGaWxlcylcblxuICBjb25zdCBzcmNGaWxlTG9va3VwID0gYXdhaXQgUHJvbWlzZS5hbGwoc3JjRmlsZXMubWFwKChmKSA9PiBmaWxlRXhpc3RzKGYpKSlcblxuICBjb25zdCBub3RGb3VuZEZpbGVzID0gc3JjRmlsZXMuZmlsdGVyKChfLCBpKSA9PiAhc3JjRmlsZUxvb2t1cFtpXSlcblxuICBpZiAobm90Rm91bmRGaWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgU29tZSBiaW5hcnkgZmlsZXMgd2VyZSBub3QgZm91bmQ6ICR7SlNPTi5zdHJpbmdpZnkobm90Rm91bmRGaWxlcyl9YCxcbiAgICApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSByZXNvbHZlKFxuICAgIG9wdGlvbnMuY3dkLFxuICAgIG9wdGlvbnMub3V0cHV0RGlyLFxuICAgIGAke2NvbmZpZy5iaW5hcnlOYW1lfS4ke3Byb2Nlc3MucGxhdGZvcm19LXVuaXZlcnNhbC5ub2RlYCxcbiAgKVxuXG4gIHVuaXZlcnNhbGl6ZXJzW3Byb2Nlc3MucGxhdGZvcm1dPy4oc3JjRmlsZXMsIG91dHB1dClcblxuICBkZWJ1ZyhgUHJvZHVjZWQgdW5pdmVyc2FsIGJpbmFyeTogJHtvdXRwdXR9YClcbn1cbiIsImltcG9ydCB7IGNvbGxlY3RBcnRpZmFjdHMgfSBmcm9tICcuL2FwaS9hcnRpZmFjdHMuanMnXG5pbXBvcnQgeyBidWlsZFByb2plY3QgfSBmcm9tICcuL2FwaS9idWlsZC5qcydcbmltcG9ydCB7IGNyZWF0ZU5wbURpcnMgfSBmcm9tICcuL2FwaS9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQgeyBuZXdQcm9qZWN0IH0gZnJvbSAnLi9hcGkvbmV3LmpzJ1xuaW1wb3J0IHsgcHJlUHVibGlzaCB9IGZyb20gJy4vYXBpL3ByZS1wdWJsaXNoLmpzJ1xuaW1wb3J0IHsgcmVuYW1lUHJvamVjdCB9IGZyb20gJy4vYXBpL3JlbmFtZS5qcydcbmltcG9ydCB7IHVuaXZlcnNhbGl6ZUJpbmFyaWVzIH0gZnJvbSAnLi9hcGkvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vYXBpL3ZlcnNpb24uanMnXG5cbi8qKlxuICpcbiAqIEB1c2FnZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGkgPSBuZXcgTmFwaUNsaSgpXG4gKlxuICogY2xpLmJ1aWxkKHtcbiAqICAgY3dkOiAnL3BhdGgvdG8veW91ci9wcm9qZWN0JyxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5hcGlDbGkge1xuICBhcnRpZmFjdHMgPSBjb2xsZWN0QXJ0aWZhY3RzXG4gIG5ldyA9IG5ld1Byb2plY3RcbiAgYnVpbGQgPSBidWlsZFByb2plY3RcbiAgY3JlYXRlTnBtRGlycyA9IGNyZWF0ZU5wbURpcnNcbiAgcHJlUHVibGlzaCA9IHByZVB1Ymxpc2hcbiAgcmVuYW1lID0gcmVuYW1lUHJvamVjdFxuICB1bml2ZXJzYWxpemUgPSB1bml2ZXJzYWxpemVCaW5hcmllc1xuICB2ZXJzaW9uID0gdmVyc2lvblxufVxuXG5leHBvcnQgeyBwYXJzZVRyaXBsZSB9IGZyb20gJy4vdXRpbHMvdGFyZ2V0LmpzJ1xuIl0sInhfZ29vZ2xlX2lnbm9yZUxpc3QiOls3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLDExNCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEyMywxMjQsMTI1LDEyNiwxMjcsMTI4LDEyOSwxMzAsMTMxLDEzMiwxMzMsMTM0LDEzNSwxMzYsMTM3LDEzOCwxMzksMTQwLDE0MSwxNDIsMTQzLDE0NCwxNDUsMTQ2LDE0NywxNDgsMTQ5LDE1MCwxNTEsMTUyLDE1MywxNTQsMTU1LDE1NiwxNTcsMTU4LDE1OSwxNjAsMTYxLDE2MiwxNjMsMTY0LDE2NSwxNjYsMTY3LDE2OCwxNjksMTcwLDE3MSwxNzIsMTczLDE3NCwxNzUsMTc2LDE3NywxNzgsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxODcsMTg4LDE4OSwxOTAsMTkxLDE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDIxMCwyMTEsMjEyLDIxMywyMTQsMjE4LDIxOSwyMjAsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzgsMjM5XSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQSxJQUFzQix1QkFBdEIsY0FBbURBLGtCQUFRO0NBQ3pELE9BQU8sUUFBUSxDQUFDLENBQUMsV0FBWSxDQUFDO0NBRTlCLE9BQU8sUUFBUUEsa0JBQVEsTUFBTSxFQUMzQixhQUNFLDRFQUNILEVBQUM7Q0FFRixNQUFNQyxpQkFBTyxPQUFPLFNBQVMsUUFBUSxLQUFLLEVBQUUsRUFDMUMsYUFDRSxxSEFDSCxFQUFDO0NBRUYsYUFBc0JBLGlCQUFPLE9BQU8sb0JBQW9CLEVBQ3RELGFBQWEsa0NBQ2QsRUFBQztDQUVGLGtCQUFrQkEsaUJBQU8sT0FBTyx1QkFBdUIsZ0JBQWdCLEVBQ3JFLGFBQWEseUJBQ2QsRUFBQztDQUVGLFlBQVlBLGlCQUFPLE9BQU8sc0JBQXNCLGVBQWUsRUFDN0QsYUFDRSxnR0FDSCxFQUFDO0NBRUYsU0FBU0EsaUJBQU8sT0FBTyxhQUFhLE9BQU8sRUFDekMsYUFBYSxnREFDZCxFQUFDO0NBRUYsaUJBQTBCQSxpQkFBTyxPQUFPLHNCQUFzQixFQUM1RCxhQUNFLGtGQUNILEVBQUM7Q0FFRixhQUFhO0FBQ1gsU0FBTztHQUNMLEtBQUssS0FBSztHQUNWLFlBQVksS0FBSztHQUNqQixpQkFBaUIsS0FBSztHQUN0QixXQUFXLEtBQUs7R0FDaEIsUUFBUSxLQUFLO0dBQ2IsZ0JBQWdCLEtBQUs7RUFDdEI7Q0FDRjtBQUNGO0FBd0NELFNBQWdCLDZCQUE2QkMsU0FBMkI7QUFDdEUsUUFBTztFQUNMLEtBQUssUUFBUSxLQUFLO0VBQ2xCLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsUUFBUTtFQUNSLEdBQUc7Q0FDSjtBQUNGOzs7O0FDN0ZEQyxjQUFTLFdBQVcsSUFBSSxDQUFDLE1BQU07QUFDN0IsUUFBT0MsVUFBTyxNQUFNLEVBQUU7QUFDdkI7QUFVRCxNQUFhLGVBQWUsQ0FBQ0MsY0FBc0I7Q0FDakQsTUFBTUMsNkJBQWlCLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQztDQUUzQ0EsUUFBTSxPQUFPLENBQUMsR0FBRyxTQUNmLFFBQVEsTUFBTUYsVUFBTyxNQUFNQSxVQUFPLFFBQVEsU0FBUyxDQUFDLEVBQUUsR0FBRyxLQUFLO0NBQ2hFRSxRQUFNLE9BQU8sQ0FBQyxHQUFHLFNBQ2YsUUFBUSxNQUFNRixVQUFPLE1BQU1BLFVBQU8sU0FBUyxZQUFZLENBQUMsRUFBRSxHQUFHLEtBQUs7Q0FDcEVFLFFBQU0sUUFBUSxDQUFDLEdBQUcsU0FDaEIsUUFBUSxNQUNORixVQUFPLE1BQU1BLFVBQU8sTUFBTSxVQUFVLENBQUMsRUFDckMsR0FBRyxLQUFLLElBQUksQ0FBQyxRQUNYLGVBQWUsUUFBUyxJQUFJLFNBQVMsSUFBSSxVQUFXLElBQ3JELENBQ0Y7QUFFSCxRQUFPRTtBQUNSO0FBQ0QsTUFBYUEsVUFBUSxhQUFhLFFBQVE7Ozs7V0NoQ2hDO2dCQUNHO2tCQUNJO2FBQ0w7ZUFDRTtjQUNEO1dBQ0g7Y0FDRyxFQUNULFFBQVEsUUFDVDtVQUNNO0NBQ0wsUUFBUTtDQUNSLFlBQVk7QUFDYjtXQUNPO2VBQ0U7Z0JBQ0M7Q0FDVCxLQUFLO0VBQ0gsVUFBVTtHQUNSLFNBQVM7R0FDVCxXQUFXO0VBQ1o7RUFDRCxXQUFXO0dBQ1QsU0FBUztHQUNULFdBQVc7RUFDWjtDQUNGO0NBQ0Qsa0JBQWtCO0VBQ2hCLFVBQVU7RUFDVixXQUFXO0NBQ1o7QUFDRjtZQUNRLENBQ1AsUUFDQSxLQUNEO2VBQ1c7Q0FDVjtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtBQUNEO2tCQUNjLENBQ2I7Q0FDRSxRQUFRO0NBQ1IsU0FBUztDQUNULFlBQVk7QUFDYixHQUNEO0NBQ0UsUUFBUTtDQUNSLFlBQVk7QUFDYixDQUNGO2lCQUNhO0NBQ1osUUFBUTtDQUNSLE9BQU87QUFDUjtvQkFDZ0I7Q0FDZixZQUFZO0NBQ1osVUFBVTtBQUNYO1dBQ08sRUFDTixPQUFPLDRDQUNSO21CQUNlO0NBQ2QscUJBQXFCO0NBQ3JCLDRCQUE0QjtDQUM1Qix1QkFBdUI7Q0FDdkIsaUJBQWlCO0NBQ2pCLGFBQWE7Q0FDYixhQUFhO0NBQ2IsU0FBUztDQUNULFVBQVU7Q0FDVixXQUFXO0NBQ1gsV0FBVztDQUNYLGFBQWE7Q0FDYixVQUFVO0NBQ1YsWUFBWTtBQUNiO3NCQUNrQjtDQUNqQixnQkFBZ0I7Q0FDaEIsbUJBQW1CO0NBQ25CLGtCQUFrQjtDQUNsQixhQUFhO0NBQ2IsZ0JBQWdCO0NBQ2hCLG1CQUFtQjtDQUNuQixrQkFBa0I7Q0FDbEIsb0JBQW9CO0NBQ3BCLGVBQWU7Q0FDZixpQkFBaUI7Q0FDakIsT0FBTztDQUNQLGFBQWE7Q0FDYixZQUFZO0NBQ1osWUFBWTtDQUNaLFNBQVM7Q0FDVCxjQUFjO0FBQ2Y7dUJBQ21CO0NBQ2xCLG1CQUFtQjtDQUNuQixVQUFVO0FBQ1g7MkJBQ3VCO0NBQ3RCLG1CQUFtQixFQUNqQixZQUFZLEtBQ2I7Q0FDRCxVQUFVLEVBQ1IsWUFBWSxLQUNiO0FBQ0Y7Y0FDVTtDQUNULFFBQVE7Q0FDUixPQUFPO0FBQ1I7Y0FDVTtDQUNULFNBQVM7Q0FDVCxXQUFXO0NBQ1gsU0FBUztDQUNULFFBQVE7QUFDVDtVQUNNO0NBQ0wsY0FBYyxFQUNaLE1BQU0sU0FDUDtDQUNELFdBQVc7Q0FDWCxTQUFTLENBQ1AsNkJBQ0Esa0JBQ0Q7QUFDRjtjQUNVO3NCQXJJYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0lDOzs7O0FDeEhELE1BQWEseUNBQTBCQyxpQkFBUztBQUNoRCxNQUFhLDBDQUEyQkMsa0JBQVU7QUFDbEQsTUFBYSx1Q0FBd0JDLGVBQU87QUFDNUMsTUFBYSx5Q0FBMEJDLGlCQUFTO0FBQ2hELE1BQWEsc0NBQXVCQyxjQUFNO0FBQzFDLE1BQWEscUNBQXNCQyxhQUFLO0FBQ3hDLE1BQWEsd0NBQXlCQyxnQkFBUTtBQUU5QyxlQUFzQixXQUFXQyxRQUFjO0NBQzdDLE1BQU0sU0FBUyxNQUFNLFVBQVVDLE9BQUssQ0FDakMsS0FBSyxNQUFNLEtBQUssQ0FDaEIsTUFBTSxNQUFNLE1BQU07QUFDckIsUUFBTztBQUNSO0FBRUQsZUFBc0IsZUFBZUQsUUFBYztBQUNqRCxLQUFJO0VBQ0YsTUFBTSxRQUFRLE1BQU0sVUFBVUMsT0FBSztBQUNuQyxTQUFPLE1BQU0sYUFBYTtDQUMzQixRQUFPO0FBQ04sU0FBTztDQUNSO0FBQ0Y7QUFFRCxTQUFnQixLQUEyQkMsR0FBTSxHQUFHQyxRQUF1QjtBQUN6RSxRQUFPQSxPQUFLLE9BQU8sQ0FBQyxLQUFLLFFBQVE7RUFDL0IsSUFBSSxPQUFPLEVBQUU7QUFDYixTQUFPO0NBQ1IsR0FBRSxDQUFFLEVBQU07QUFDWjtBQUVELGVBQXNCLGtCQUNwQkgsUUFDQUksU0FDQTtDQUNBLE1BQU0sU0FBUyxNQUFNLFdBQVdILE9BQUs7QUFDckMsS0FBSSxDQUFDLFFBQVE7RUFDWEksUUFBTSxDQUFDLGdCQUFnQixFQUFFSixRQUFNLENBQUM7QUFDaEM7Q0FDRDtDQUNELE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxjQUFjQSxRQUFNLE9BQU8sQ0FBQztDQUN6RCxNQUFNLGVBQWVBLFFBQU0sS0FBSyxVQUFVO0VBQUUsR0FBRztFQUFLLEdBQUc7Q0FBUyxHQUFFLE1BQU0sRUFBRSxDQUFDO0FBQzVFO0FBRUQsTUFBYSxjQUFjSyxnQkFBUTs7OztBQ2xEbkMsTUFBYSxvQkFBb0I7Q0FDL0I7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7QUFDRDtBQUlELE1BQWEsa0JBQWtCO0NBQzdCO0NBQ0E7Q0FDQTtDQUNBO0FBQ0Q7QUFFRCxNQUFhQyxnQkFBd0M7Q0FDbkQsOEJBQThCO0NBQzlCLCtCQUErQjtDQUMvQixpQ0FBaUM7Q0FDakMsMkJBQTJCO0FBQzVCO0FBbUJELE1BQU1DLGdCQUE0QztDQUNoRCxRQUFRO0NBQ1IsU0FBUztDQUNULE1BQU07Q0FDTixPQUFPO0NBQ1AsV0FBVztDQUNYLGFBQWE7QUFDZDtBQVdELE1BQU1DLG9CQUE4QztDQUNsRCxPQUFPO0NBQ1AsU0FBUztDQUNULFFBQVE7Q0FDUixTQUFTO0NBQ1QsTUFBTTtBQUNQO0FBRUQsTUFBYUMscUJBQThELEVBQ3pFLFFBQVEsQ0FBQyxPQUFPLE9BQVEsRUFDekI7Ozs7Ozs7Ozs7O0FBb0JELFNBQWdCLFlBQVlDLFdBQTJCO0FBQ3JELEtBQ0UsY0FBYyxpQkFDZCxjQUFjLGtDQUNkLFVBQVUsV0FBVyxlQUFlLENBRXBDLFFBQU87RUFDTCxRQUFRO0VBQ1IsaUJBQWlCO0VBQ2pCLFVBQVU7RUFDVixNQUFNO0VBQ04sS0FBSztDQUNOO0NBRUgsTUFBTSxTQUFTLFVBQVUsU0FBUyxPQUFPLEdBQ3JDLEdBQUcsVUFBVSxNQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUNoQztDQUNKLE1BQU0sVUFBVSxPQUFPLE1BQU0sSUFBSTtDQUNqQyxJQUFJQztDQUNKLElBQUlDO0NBQ0osSUFBSUMsTUFBcUI7QUFDekIsS0FBSSxRQUFRLFdBQVcsR0FHcEIsQ0FBQyxLQUFLLElBQUksR0FBRztNQU1iLENBQUMsT0FBTyxLQUFLLE1BQU0sS0FBSyxHQUFHO0NBRzlCLE1BQU0sV0FBVyxrQkFBa0IsUUFBUztDQUM1QyxNQUFNLE9BQU8sY0FBYyxRQUFTO0FBRXBDLEtBQUksVUFBVSxTQUFTLE9BQU8sQ0FDNUIsUUFBTztFQUNMLFFBQVE7RUFDUixpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxLQUFLLENBQUM7RUFDckMsVUFBVTtFQUNWO0VBQ0EsS0FBSztDQUNOO0FBRUgsUUFBTztFQUNMLFFBQVE7RUFDUixpQkFBaUIsTUFBTSxHQUFHLFNBQVMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssR0FBRyxHQUFHLFNBQVMsQ0FBQyxFQUFFLE1BQU07RUFDM0U7RUFDQTtFQUNBO0NBQ0Q7QUFDRjtBQUVELFNBQWdCLHlCQUFpQztDQUMvQyxNQUFNLHdDQUFnQixDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQ2pDLEtBQUssUUFBUSxJQUNkLEVBQUMsQ0FDQyxTQUFTLE9BQU8sQ0FDaEIsTUFBTSxLQUFLLENBQ1gsS0FBSyxDQUFDLFNBQVMsS0FBSyxXQUFXLFNBQVMsQ0FBQztDQUM1QyxNQUFNLFNBQVMsTUFBTSxNQUFNLEVBQWdCO0FBQzNDLEtBQUksQ0FBQyxPQUNILE9BQU0sSUFBSSxVQUFVLENBQUMscUNBQXFDLENBQUM7QUFFN0QsUUFBTyxZQUFZLE9BQU87QUFDM0I7QUFFRCxTQUFnQixnQkFBZ0JDLFFBQW9DO0FBQ2xFLFFBQU8sY0FBYztBQUN0QjtBQUVELFNBQWdCLGVBQWVBLFFBQXdCO0FBQ3JELFFBQU8sT0FBTyxRQUFRLE1BQU0sSUFBSSxDQUFDLGFBQWE7QUFDL0M7Ozs7QUM1TEQsSUFBWSxzREFBTDs7Ozs7Ozs7Ozs7QUFVTjtBQUtELE1BQU0sc0JBQXNCLElBQUksSUFBeUI7Q0FDdkQsQ0FBQyxZQUFZLE9BQU8sd0JBQXlCO0NBQzdDLENBQUMsWUFBWSxPQUFPLHlCQUEwQjtDQUM5QyxDQUFDLFlBQVksT0FBTyxtQ0FBb0M7Q0FDeEQsQ0FBQyxZQUFZLE9BQU8sMkJBQTRCO0NBQ2hELENBQUMsWUFBWSxPQUFPLDRCQUE2QjtDQUNqRCxDQUFDLFlBQVksT0FBTyw0QkFBNkI7Q0FDakQsQ0FBQyxZQUFZLE9BQU8sc0NBQXVDO0NBQzNELENBQUMsWUFBWSxPQUFPLHNDQUF1QztDQUMzRCxDQUFDLFlBQVksT0FBTywyQkFBNEI7QUFDakQ7QUFRRCxTQUFTLGlCQUFpQkMsR0FBd0I7Q0FDaEQsTUFBTSxVQUFVLEVBQUUsTUFBTSxrQ0FBa0M7QUFFMUQsS0FBSSxDQUFDLFFBQ0gsT0FBTSxJQUFJLE1BQU0sa0NBQWtDO0NBR3BELE1BQU0sR0FBRyxPQUFPLE9BQU8sTUFBTSxHQUFHO0FBRWhDLFFBQU87RUFDTCxPQUFPLFNBQVMsTUFBTTtFQUN0QixPQUFPLFNBQVMsTUFBTTtFQUN0QixPQUFPLFNBQVMsTUFBTTtDQUN2QjtBQUNGO0FBRUQsU0FBUyxxQkFBcUJDLGFBQXlDO0NBQ3JFLE1BQU0sY0FBYyxvQkFBb0IsSUFBSSxZQUFZO0FBRXhELEtBQUksQ0FBQyxZQUNILFFBQU8sQ0FBQyxpQkFBaUIsU0FBUyxBQUFDO0FBR3JDLFFBQU8sWUFBWSxNQUFNLElBQUksQ0FBQyxJQUFJLGlCQUFpQjtBQUNwRDtBQUVELFNBQVMsb0JBQW9CQyxVQUFpQztDQUM1RCxNQUFNQyxlQUF5QixDQUFFO0NBQ2pDLFNBQVMsUUFBUSxDQUFDLEdBQUcsTUFBTTtFQUN6QixJQUFJLE1BQU07QUFDVixNQUFJLE1BQU0sR0FBRztHQUNYLE1BQU0sY0FBYyxTQUFTLElBQUk7R0FDakMsT0FBTyxDQUFDLEVBQUUsRUFBRSxZQUFZLFFBQVEsR0FBRztFQUNwQztFQUVELE9BQU8sR0FBRyxNQUFNLElBQUksS0FBSyxPQUFPLEdBQUcsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPO0VBQ3BFLGFBQWEsS0FBSyxJQUFJO0NBQ3ZCLEVBQUM7QUFFRixRQUFPLGFBQWEsS0FBSyxJQUFJO0FBQzlCO0FBRUQsU0FBZ0Isc0JBQXNCRixhQUFrQztBQUN0RSxRQUFPLG9CQUFvQixxQkFBcUIsWUFBWSxDQUFDO0FBQzlEOzs7O0FDM0JELGVBQXNCLGNBQWNHLGNBQXNCO0FBQ3hELEtBQUksQ0FBQ0MsZ0JBQUcsV0FBVyxhQUFhLENBQzlCLE9BQU0sSUFBSSxNQUFNLENBQUMsNEJBQTRCLEVBQUUsY0FBYztDQUcvRCxNQUFNLDZDQUNKLFNBQ0E7RUFBQztFQUFZO0VBQW1CO0VBQWM7RUFBb0I7Q0FBSSxHQUN0RSxFQUFFLE9BQU8sT0FBUSxFQUNsQjtDQUVELElBQUksU0FBUztDQUNiLElBQUksU0FBUztDQUNiLElBQUksU0FBUztDQUNiLElBQUksUUFBUTtDQUVaLGFBQWEsT0FBTyxHQUFHLFFBQVEsQ0FBQyxTQUFTO0VBQ3ZDLFVBQVU7Q0FDWCxFQUFDO0NBRUYsYUFBYSxPQUFPLEdBQUcsUUFBUSxDQUFDLFNBQVM7RUFDdkMsVUFBVTtDQUNYLEVBQUM7Q0FFRixNQUFNLElBQUksUUFBYyxDQUFDQyxjQUFZO0VBQ25DLGFBQWEsR0FBRyxTQUFTLENBQUMsU0FBUztHQUNqQyxTQUFTLFFBQVE7R0FDakJBLFdBQVM7RUFDVixFQUFDO0NBQ0g7QUFFRCxLQUFJLE1BQ0YsT0FBTSxJQUFJLE1BQU0sZ0NBQWdDLEVBQUUsT0FBTyxNQUFPO0FBRWxFLEtBQUksV0FBVyxHQUFHO0VBQ2hCLE1BQU0sZ0JBQWdCLENBQUMsZ0NBQWdDLEVBQUUsUUFBUTtBQUNqRSxRQUFNLElBQUksTUFBTSxHQUFHLGNBQWMsdUJBQXVCLEVBQUUsUUFBUSxFQUFFLEVBQ2xFLE9BQU8sSUFBSSxNQUFNLGVBQ2xCO0NBQ0Y7QUFFRCxLQUFJO0FBQ0YsU0FBTyxLQUFLLE1BQU0sT0FBTztDQUMxQixTQUFRLEdBQUc7QUFDVixRQUFNLElBQUksTUFBTSx1Q0FBdUMsRUFBRSxPQUFPLEVBQUc7Q0FDcEU7QUFDRjs7Ozs7QUMvRkQsSUFBSSxhQUFhLE9BQU8sVUFBVSxZQUFZLFVBQVUsT0FBTyxXQUFXLFVBQVU7QUFFcEYsMEJBQWU7Ozs7O0FDQWYsSUFBSSxXQUFXLE9BQU8sUUFBUSxZQUFZLFFBQVEsS0FBSyxXQUFXLFVBQVU7O0FBRzVFLElBQUksT0FBT0MsdUJBQWMsWUFBWSxTQUFTLGNBQWMsRUFBRTtBQUU5RCxvQkFBZTs7Ozs7QUNMZixJQUFJQyxXQUFTQyxjQUFLO0FBRWxCLHNCQUFlRDs7Ozs7QUNGZixJQUFJRSxpQkFBYyxPQUFPOztBQUd6QixJQUFJQyxvQkFBaUJELGVBQVk7Ozs7OztBQU9qQyxJQUFJRSx5QkFBdUJGLGVBQVk7O0FBR3ZDLElBQUlHLG1CQUFpQkMsa0JBQVNBLGdCQUFPLGNBQWM7Ozs7Ozs7O0FBU25ELFNBQVMsVUFBVUMsU0FBTztDQUN4QixJQUFJLFFBQVFKLGtCQUFlLEtBQUtJLFNBQU9GLGlCQUFlLEVBQ2xELE1BQU1FLFFBQU1GO0FBRWhCLEtBQUk7RUFDRkUsUUFBTUYsb0JBQWtCO0VBQ3hCLElBQUksV0FBVztDQUNoQixTQUFRLEdBQUcsQ0FBRTtDQUVkLElBQUksU0FBU0QsdUJBQXFCLEtBQUtHLFFBQU07QUFDN0MsS0FBSSxTQUNGLEtBQUksT0FDRkEsUUFBTUYsb0JBQWtCO01BRXhCLE9BQU9FLFFBQU1GO0FBR2pCLFFBQU87QUFDUjtBQUVELHlCQUFlOzs7OztBQzVDZixJQUFJRyxpQkFBYyxPQUFPOzs7Ozs7QUFPekIsSUFBSSx1QkFBdUJBLGVBQVk7Ozs7Ozs7O0FBU3ZDLFNBQVMsZUFBZUMsU0FBTztBQUM3QixRQUFPLHFCQUFxQixLQUFLQSxRQUFNO0FBQ3hDO0FBRUQsOEJBQWU7Ozs7O0FDaEJmLElBQUksVUFBVSxpQkFDVixlQUFlOztBQUduQixJQUFJLGlCQUFpQkMsa0JBQVNBLGdCQUFPLGNBQWM7Ozs7Ozs7O0FBU25ELFNBQVMsV0FBV0MsU0FBTztBQUN6QixLQUFJQSxXQUFTLEtBQ1gsUUFBT0EsWUFBVSxTQUFZLGVBQWU7QUFFOUMsUUFBUSxrQkFBa0Isa0JBQWtCLE9BQU9BLFFBQU0sR0FDckRDLG1CQUFVRCxRQUFNLEdBQ2hCRSx3QkFBZUYsUUFBTTtBQUMxQjtBQUVELDBCQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSGYsU0FBUyxhQUFhRyxTQUFPO0FBQzNCLFFBQU9BLFdBQVMsUUFBUSxPQUFPQSxXQUFTO0FBQ3pDO0FBRUQsMkJBQWU7Ozs7O0FDeEJmLElBQUlDLGNBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CaEIsU0FBUyxTQUFTQyxTQUFPO0FBQ3ZCLFFBQU8sT0FBT0EsV0FBUyxZQUNwQkMscUJBQWFELFFBQU0sSUFBSUUsb0JBQVdGLFFBQU0sSUFBSUQ7QUFDaEQ7QUFFRCx1QkFBZTs7Ozs7Ozs7Ozs7OztBQ25CZixTQUFTLFNBQVMsT0FBTyxVQUFVO0NBQ2pDLElBQUksUUFBUSxJQUNSLFNBQVMsU0FBUyxPQUFPLElBQUksTUFBTSxRQUNuQyxTQUFTLE1BQU0sT0FBTztBQUUxQixRQUFPLEVBQUUsUUFBUSxRQUNmLE9BQU8sU0FBUyxTQUFTLE1BQU0sUUFBUSxPQUFPLE1BQU07QUFFdEQsUUFBTztBQUNSO0FBRUQsd0JBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0dmLElBQUksVUFBVSxNQUFNO0FBRXBCLHNCQUFlOzs7OztBQ25CZixJQUFJSSxhQUFXOztBQUdmLElBQUlDLGdCQUFjQyxrQkFBU0EsZ0JBQU8sWUFBWSxRQUMxQyxpQkFBaUJELGdCQUFjQSxjQUFZLFdBQVc7Ozs7Ozs7OztBQVUxRCxTQUFTLGFBQWFFLFNBQU87QUFFM0IsS0FBSSxPQUFPQSxXQUFTLFNBQ2xCLFFBQU9BO0FBRVQsS0FBSUMsZ0JBQVFELFFBQU0sQ0FFaEIsUUFBT0Usa0JBQVNGLFNBQU8sYUFBYSxHQUFHO0FBRXpDLEtBQUlHLGlCQUFTSCxRQUFNLENBQ2pCLFFBQU8saUJBQWlCLGVBQWUsS0FBS0EsUUFBTSxHQUFHO0NBRXZELElBQUksU0FBVUEsVUFBUTtBQUN0QixRQUFRLFVBQVUsT0FBUSxJQUFJQSxXQUFVLENBQUNILGFBQVksT0FBTztBQUM3RDtBQUVELDRCQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hmLFNBQVNPLFdBQVNDLFNBQU87Q0FDdkIsSUFBSUMsU0FBTyxPQUFPRDtBQUNsQixRQUFPQSxXQUFTLFNBQVNDLFVBQVEsWUFBWUEsVUFBUTtBQUN0RDtBQUVELHVCQUFlRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkZixTQUFTLFNBQVNHLFNBQU87QUFDdkIsUUFBT0E7QUFDUjtBQUVELHVCQUFlOzs7OztBQ2hCZixJQUFJLFdBQVcsMEJBQ1hDLFlBQVUscUJBQ1ZDLFdBQVMsOEJBQ1QsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJmLFNBQVMsV0FBV0MsU0FBTztBQUN6QixLQUFJLENBQUNDLGlCQUFTRCxRQUFNLENBQ2xCLFFBQU87Q0FJVCxJQUFJLE1BQU1FLG9CQUFXRixRQUFNO0FBQzNCLFFBQU8sT0FBT0YsYUFBVyxPQUFPQyxZQUFVLE9BQU8sWUFBWSxPQUFPO0FBQ3JFO0FBRUQseUJBQWU7Ozs7O0FDakNmLElBQUksYUFBYUksY0FBSztBQUV0QiwwQkFBZTs7Ozs7QUNGZixJQUFJLGFBQWMsV0FBVztDQUMzQixJQUFJLE1BQU0sU0FBUyxLQUFLQyx1QkFBY0Esb0JBQVcsUUFBUUEsb0JBQVcsS0FBSyxZQUFZLEdBQUc7QUFDeEYsUUFBTyxNQUFPLG1CQUFtQixNQUFPO0FBQ3pDLEdBQUU7Ozs7Ozs7O0FBU0gsU0FBUyxTQUFTLE1BQU07QUFDdEIsUUFBTyxDQUFDLENBQUMsY0FBZSxjQUFjO0FBQ3ZDO0FBRUQsd0JBQWU7Ozs7O0FDbEJmLElBQUlDLGNBQVksU0FBUzs7QUFHekIsSUFBSUMsaUJBQWVELFlBQVU7Ozs7Ozs7O0FBUzdCLFNBQVMsU0FBUyxNQUFNO0FBQ3RCLEtBQUksUUFBUSxNQUFNO0FBQ2hCLE1BQUk7QUFDRixVQUFPQyxlQUFhLEtBQUssS0FBSztFQUMvQixTQUFRLEdBQUcsQ0FBRTtBQUNkLE1BQUk7QUFDRixVQUFRLE9BQU87RUFDaEIsU0FBUSxHQUFHLENBQUU7Q0FDZjtBQUNELFFBQU87QUFDUjtBQUVELHdCQUFlOzs7Ozs7OztBQ2hCZixJQUFJLGVBQWU7O0FBR25CLElBQUksZUFBZTs7QUFHbkIsSUFBSUMsY0FBWSxTQUFTLFdBQ3JCQyxpQkFBYyxPQUFPOztBQUd6QixJQUFJQyxpQkFBZUYsWUFBVTs7QUFHN0IsSUFBSUcsb0JBQWlCRixlQUFZOztBQUdqQyxJQUFJLGFBQWEsT0FBTyxNQUN0QkMsZUFBYSxLQUFLQyxrQkFBZSxDQUFDLFFBQVEsY0FBYyxPQUFPLENBQzlELFFBQVEsMERBQTBELFFBQVEsR0FBRyxJQUMvRTs7Ozs7Ozs7O0FBVUQsU0FBUyxhQUFhQyxTQUFPO0FBQzNCLEtBQUksQ0FBQ0MsaUJBQVNELFFBQU0sSUFBSUUsa0JBQVNGLFFBQU0sQ0FDckMsUUFBTztDQUVULElBQUksVUFBVUcsbUJBQVdILFFBQU0sR0FBRyxhQUFhO0FBQy9DLFFBQU8sUUFBUSxLQUFLSSxrQkFBU0osUUFBTSxDQUFDO0FBQ3JDO0FBRUQsNEJBQWU7Ozs7Ozs7Ozs7OztBQ3RDZixTQUFTLFNBQVMsUUFBUSxLQUFLO0FBQzdCLFFBQU8sVUFBVSxPQUFPLFNBQVksT0FBTztBQUM1QztBQUVELHdCQUFlOzs7Ozs7Ozs7Ozs7QUNEZixTQUFTLFVBQVUsUUFBUSxLQUFLO0NBQzlCLElBQUlLLFVBQVFDLGtCQUFTLFFBQVEsSUFBSTtBQUNqQyxRQUFPQyxzQkFBYUYsUUFBTSxHQUFHQSxVQUFRO0FBQ3RDO0FBRUQseUJBQWU7Ozs7QUNaZixJQUFJLFVBQVVHLG1CQUFVQyxlQUFNLFVBQVU7QUFFeEMsdUJBQWU7Ozs7O0FDSGYsSUFBSSxlQUFlLE9BQU87Ozs7Ozs7OztBQVUxQixJQUFJLGFBQWMsV0FBVztDQUMzQixTQUFTLFNBQVMsQ0FBRTtBQUNwQixRQUFPLFNBQVMsT0FBTztBQUNyQixNQUFJLENBQUNDLGlCQUFTLE1BQU0sQ0FDbEIsUUFBTyxDQUFFO0FBRVgsTUFBSSxhQUNGLFFBQU8sYUFBYSxNQUFNO0VBRTVCLE9BQU8sWUFBWTtFQUNuQixJQUFJLFNBQVMsSUFBSTtFQUNqQixPQUFPLFlBQVk7QUFDbkIsU0FBTztDQUNSO0FBQ0YsR0FBRTtBQUVILDBCQUFlOzs7Ozs7Ozs7Ozs7OztBQ25CZixTQUFTLE1BQU0sTUFBTSxTQUFTLE1BQU07QUFDbEMsU0FBUSxLQUFLLFFBQWI7RUFDRSxLQUFLLEVBQUcsUUFBTyxLQUFLLEtBQUssUUFBUTtFQUNqQyxLQUFLLEVBQUcsUUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLEdBQUc7RUFDMUMsS0FBSyxFQUFHLFFBQU8sS0FBSyxLQUFLLFNBQVMsS0FBSyxJQUFJLEtBQUssR0FBRztFQUNuRCxLQUFLLEVBQUcsUUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssR0FBRztDQUM3RDtBQUNELFFBQU8sS0FBSyxNQUFNLFNBQVMsS0FBSztBQUNqQztBQUVELHFCQUFlOzs7Ozs7Ozs7Ozs7QUNaZixTQUFTLFVBQVUsUUFBUSxPQUFPO0NBQ2hDLElBQUksUUFBUSxJQUNSLFNBQVMsT0FBTztDQUVwQixVQUFVLFFBQVEsTUFBTSxPQUFPO0FBQy9CLFFBQU8sRUFBRSxRQUFRLFFBQ2YsTUFBTSxTQUFTLE9BQU87QUFFeEIsUUFBTztBQUNSO0FBRUQseUJBQWU7Ozs7O0FDbEJmLElBQUksWUFBWSxLQUNaLFdBQVc7QUFHZixJQUFJLFlBQVksS0FBSzs7Ozs7Ozs7OztBQVdyQixTQUFTLFNBQVMsTUFBTTtDQUN0QixJQUFJLFFBQVEsR0FDUixhQUFhO0FBRWpCLFFBQU8sV0FBVztFQUNoQixJQUFJLFFBQVEsV0FBVyxFQUNuQixZQUFZLFlBQVksUUFBUTtFQUVwQyxhQUFhO0FBQ2IsTUFBSSxZQUFZLEdBQ2Q7T0FBSSxFQUFFLFNBQVMsVUFDYixRQUFPLFVBQVU7RUFDbEIsT0FFRCxRQUFRO0FBRVYsU0FBTyxLQUFLLE1BQU0sUUFBVyxVQUFVO0NBQ3hDO0FBQ0Y7QUFFRCx3QkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQmYsU0FBUyxTQUFTQyxTQUFPO0FBQ3ZCLFFBQU8sV0FBVztBQUNoQixTQUFPQTtDQUNSO0FBQ0Y7QUFFRCx1QkFBZTs7OztBQ3ZCZixJQUFJLGlCQUFrQixXQUFXO0FBQy9CLEtBQUk7RUFDRixJQUFJLE9BQU9DLG1CQUFVLFFBQVEsaUJBQWlCO0VBQzlDLEtBQUssQ0FBRSxHQUFFLElBQUksQ0FBRSxFQUFDO0FBQ2hCLFNBQU87Q0FDUixTQUFRLEdBQUcsQ0FBRTtBQUNmLEdBQUU7QUFFSCw4QkFBZTs7Ozs7Ozs7Ozs7O0FDRWYsSUFBSSxrQkFBa0IsQ0FBQ0MsMEJBQWlCQyxtQkFBVyxTQUFTLE1BQU0sUUFBUTtBQUN4RSxRQUFPRCx3QkFBZSxNQUFNLFlBQVk7RUFDdEMsZ0JBQWdCO0VBQ2hCLGNBQWM7RUFDZCxTQUFTRSxpQkFBUyxPQUFPO0VBQ3pCLFlBQVk7Q0FDYixFQUFDO0FBQ0g7QUFFRCwrQkFBZTs7Ozs7Ozs7Ozs7O0FDVmYsSUFBSSxjQUFjQyxrQkFBU0MseUJBQWdCO0FBRTNDLDJCQUFlOzs7Ozs7Ozs7Ozs7O0FDSmYsU0FBUyxVQUFVLE9BQU8sVUFBVTtDQUNsQyxJQUFJLFFBQVEsSUFDUixTQUFTLFNBQVMsT0FBTyxJQUFJLE1BQU07QUFFdkMsUUFBTyxFQUFFLFFBQVEsT0FDZixLQUFJLFNBQVMsTUFBTSxRQUFRLE9BQU8sTUFBTSxLQUFLLE1BQzNDO0FBR0osUUFBTztBQUNSO0FBRUQseUJBQWU7Ozs7O0FDcEJmLElBQUlDLHFCQUFtQjs7QUFHdkIsSUFBSSxXQUFXOzs7Ozs7Ozs7QUFVZixTQUFTLFFBQVFDLFNBQU8sUUFBUTtDQUM5QixJQUFJQyxTQUFPLE9BQU9EO0NBQ2xCLFNBQVMsVUFBVSxPQUFPRCxxQkFBbUI7QUFFN0MsUUFBTyxDQUFDLENBQUMsV0FDTkUsVUFBUSxZQUNOQSxVQUFRLFlBQVksU0FBUyxLQUFLRCxRQUFNLEtBQ3RDQSxVQUFRLE1BQU1BLFVBQVEsS0FBSyxLQUFLQSxVQUFRO0FBQ2hEO0FBRUQsdUJBQWU7Ozs7Ozs7Ozs7Ozs7QUNiZixTQUFTLGdCQUFnQixRQUFRLEtBQUtFLFNBQU87QUFDM0MsS0FBSSxPQUFPLGVBQWVDLHlCQUN4QkEsd0JBQWUsUUFBUSxLQUFLO0VBQzFCLGdCQUFnQjtFQUNoQixjQUFjO0VBQ2QsU0FBU0Q7RUFDVCxZQUFZO0NBQ2IsRUFBQztNQUVGLE9BQU8sT0FBT0E7QUFFakI7QUFFRCwrQkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUWYsU0FBUyxHQUFHRSxTQUFPLE9BQU87QUFDeEIsUUFBT0EsWUFBVSxTQUFVQSxZQUFVQSxXQUFTLFVBQVU7QUFDekQ7QUFFRCxpQkFBZTs7Ozs7QUNoQ2YsSUFBSUMsaUJBQWMsT0FBTzs7QUFHekIsSUFBSUMsb0JBQWlCRCxlQUFZOzs7Ozs7Ozs7OztBQVlqQyxTQUFTLFlBQVksUUFBUSxLQUFLRSxTQUFPO0NBQ3ZDLElBQUksV0FBVyxPQUFPO0FBQ3RCLEtBQUksRUFBRUQsa0JBQWUsS0FBSyxRQUFRLElBQUksSUFBSUUsV0FBRyxVQUFVRCxRQUFNLEtBQ3hEQSxZQUFVLFVBQWEsRUFBRSxPQUFPLFNBQ25DRSx5QkFBZ0IsUUFBUSxLQUFLRixRQUFNO0FBRXRDO0FBRUQsMkJBQWU7Ozs7Ozs7Ozs7Ozs7O0FDZGYsU0FBUyxXQUFXLFFBQVEsT0FBTyxRQUFRLFlBQVk7Q0FDckQsSUFBSSxRQUFRLENBQUM7Q0FDYixXQUFXLFNBQVMsQ0FBRTtDQUV0QixJQUFJLFFBQVEsSUFDUixTQUFTLE1BQU07QUFFbkIsUUFBTyxFQUFFLFFBQVEsUUFBUTtFQUN2QixJQUFJLE1BQU0sTUFBTTtFQUVoQixJQUFJLFdBQVcsYUFDWCxXQUFXLE9BQU8sTUFBTSxPQUFPLE1BQU0sS0FBSyxRQUFRLE9BQU8sR0FDekQ7QUFFSixNQUFJLGFBQWEsUUFDZixXQUFXLE9BQU87QUFFcEIsTUFBSSxPQUNGRyx5QkFBZ0IsUUFBUSxLQUFLLFNBQVM7T0FFdENDLHFCQUFZLFFBQVEsS0FBSyxTQUFTO0NBRXJDO0FBQ0QsUUFBTztBQUNSO0FBRUQsMEJBQWU7Ozs7QUNwQ2YsSUFBSSxZQUFZLEtBQUs7Ozs7Ozs7Ozs7QUFXckIsU0FBUyxTQUFTLE1BQU0sT0FBTyxXQUFXO0NBQ3hDLFFBQVEsVUFBVSxVQUFVLFNBQWEsS0FBSyxTQUFTLElBQUssT0FBTyxFQUFFO0FBQ3JFLFFBQU8sV0FBVztFQUNoQixJQUFJLE9BQU8sV0FDUCxRQUFRLElBQ1IsU0FBUyxVQUFVLEtBQUssU0FBUyxPQUFPLEVBQUUsRUFDMUMsUUFBUSxNQUFNLE9BQU87QUFFekIsU0FBTyxFQUFFLFFBQVEsUUFDZixNQUFNLFNBQVMsS0FBSyxRQUFRO0VBRTlCLFFBQVE7RUFDUixJQUFJLFlBQVksTUFBTSxRQUFRLEVBQUU7QUFDaEMsU0FBTyxFQUFFLFFBQVEsT0FDZixVQUFVLFNBQVMsS0FBSztFQUUxQixVQUFVLFNBQVMsVUFBVSxNQUFNO0FBQ25DLFNBQU9DLGVBQU0sTUFBTSxNQUFNLFVBQVU7Q0FDcEM7QUFDRjtBQUVELHdCQUFlOzs7Ozs7Ozs7Ozs7QUN2QmYsU0FBUyxTQUFTLE1BQU0sT0FBTztBQUM3QixRQUFPQyxxQkFBWUMsa0JBQVMsTUFBTSxPQUFPQyxpQkFBUyxFQUFFLE9BQU8sR0FBRztBQUMvRDtBQUVELHdCQUFlOzs7OztBQ2ZmLElBQUksbUJBQW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QnZCLFNBQVMsU0FBU0MsU0FBTztBQUN2QixRQUFPLE9BQU9BLFdBQVMsWUFDckJBLFVBQVEsTUFBTUEsVUFBUSxLQUFLLEtBQUtBLFdBQVM7QUFDNUM7QUFFRCx1QkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOZixTQUFTLFlBQVlDLFNBQU87QUFDMUIsUUFBT0EsV0FBUyxRQUFRQyxpQkFBU0QsUUFBTSxPQUFPLElBQUksQ0FBQ0UsbUJBQVdGLFFBQU07QUFDckU7QUFFRCwwQkFBZTs7Ozs7Ozs7Ozs7Ozs7QUNqQmYsU0FBUyxlQUFlRyxTQUFPLE9BQU8sUUFBUTtBQUM1QyxLQUFJLENBQUNDLGlCQUFTLE9BQU8sQ0FDbkIsUUFBTztDQUVULElBQUlDLFNBQU8sT0FBTztBQUNsQixLQUFJQSxVQUFRLFdBQ0hDLG9CQUFZLE9BQU8sSUFBSUMsaUJBQVEsT0FBTyxPQUFPLE9BQU8sR0FDcERGLFVBQVEsWUFBWSxTQUFTLE9BRXBDLFFBQU9HLFdBQUcsT0FBTyxRQUFRTCxRQUFNO0FBRWpDLFFBQU87QUFDUjtBQUVELDhCQUFlOzs7Ozs7Ozs7OztBQ25CZixTQUFTLGVBQWUsVUFBVTtBQUNoQyxRQUFPTSxrQkFBUyxTQUFTLFFBQVEsU0FBUztFQUN4QyxJQUFJLFFBQVEsSUFDUixTQUFTLFFBQVEsUUFDakIsYUFBYSxTQUFTLElBQUksUUFBUSxTQUFTLEtBQUssUUFDaEQsUUFBUSxTQUFTLElBQUksUUFBUSxLQUFLO0VBRXRDLGFBQWMsU0FBUyxTQUFTLEtBQUssT0FBTyxjQUFjLGNBQ3JELFVBQVUsY0FDWDtBQUVKLE1BQUksU0FBU0Msd0JBQWUsUUFBUSxJQUFJLFFBQVEsSUFBSSxNQUFNLEVBQUU7R0FDMUQsYUFBYSxTQUFTLElBQUksU0FBWTtHQUN0QyxTQUFTO0VBQ1Y7RUFDRCxTQUFTLE9BQU8sT0FBTztBQUN2QixTQUFPLEVBQUUsUUFBUSxRQUFRO0dBQ3ZCLElBQUksU0FBUyxRQUFRO0FBQ3JCLE9BQUksUUFDRixTQUFTLFFBQVEsUUFBUSxPQUFPLFdBQVc7RUFFOUM7QUFDRCxTQUFPO0NBQ1IsRUFBQztBQUNIO0FBRUQsOEJBQWU7Ozs7O0FDbkNmLElBQUlDLGlCQUFjLE9BQU87Ozs7Ozs7O0FBU3pCLFNBQVMsWUFBWUMsU0FBTztDQUMxQixJQUFJLE9BQU9BLFdBQVNBLFFBQU0sYUFDdEIsUUFBUyxPQUFPLFFBQVEsY0FBYyxLQUFLLGFBQWNEO0FBRTdELFFBQU9DLFlBQVU7QUFDbEI7QUFFRCwyQkFBZTs7Ozs7Ozs7Ozs7OztBQ1JmLFNBQVMsVUFBVSxHQUFHLFVBQVU7Q0FDOUIsSUFBSSxRQUFRLElBQ1IsU0FBUyxNQUFNLEVBQUU7QUFFckIsUUFBTyxFQUFFLFFBQVEsR0FDZixPQUFPLFNBQVMsU0FBUyxNQUFNO0FBRWpDLFFBQU87QUFDUjtBQUVELHlCQUFlOzs7OztBQ2ZmLElBQUlDLFlBQVU7Ozs7Ozs7O0FBU2QsU0FBUyxnQkFBZ0JDLFNBQU87QUFDOUIsUUFBT0MscUJBQWFELFFBQU0sSUFBSUUsb0JBQVdGLFFBQU0sSUFBSUQ7QUFDcEQ7QUFFRCwrQkFBZTs7Ozs7QUNiZixJQUFJSSxpQkFBYyxPQUFPOztBQUd6QixJQUFJQyxtQkFBaUJELGVBQVk7O0FBR2pDLElBQUlFLHlCQUF1QkYsZUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CdkMsSUFBSSxjQUFjRyx5QkFBZ0IsV0FBVztBQUFFLFFBQU87QUFBWSxHQUFFLENBQUMsR0FBR0EsMkJBQWtCLFNBQVNDLFNBQU87QUFDeEcsUUFBT0MscUJBQWFELFFBQU0sSUFBSUgsaUJBQWUsS0FBS0csU0FBTyxTQUFTLElBQ2hFLENBQUNGLHVCQUFxQixLQUFLRSxTQUFPLFNBQVM7QUFDOUM7QUFFRCwwQkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QmYsU0FBUyxZQUFZO0FBQ25CLFFBQU87QUFDUjtBQUVELHdCQUFlOzs7OztBQ2JmLElBQUlFLGdCQUFjLE9BQU8sV0FBVyxZQUFZLFdBQVcsQ0FBQyxRQUFRLFlBQVk7O0FBR2hGLElBQUlDLGVBQWFELGlCQUFlLE9BQU8sVUFBVSxZQUFZLFVBQVUsQ0FBQyxPQUFPLFlBQVk7O0FBRzNGLElBQUlFLGtCQUFnQkQsZ0JBQWNBLGFBQVcsWUFBWUQ7O0FBR3pELElBQUlHLFdBQVNELGtCQUFnQkUsY0FBSyxTQUFTO0FBRzNDLElBQUksaUJBQWlCRCxXQUFTQSxTQUFPLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CaEQsSUFBSSxXQUFXLGtCQUFrQkU7QUFFakMsdUJBQWU7Ozs7O0FDaENmLElBQUlDLFlBQVUsc0JBQ1ZDLGFBQVcsa0JBQ1hDLFlBQVUsb0JBQ1ZDLFlBQVUsaUJBQ1ZDLGFBQVcsa0JBQ1hDLFlBQVUscUJBQ1ZDLFdBQVMsZ0JBQ1RDLGNBQVksbUJBQ1pDLGNBQVksbUJBQ1pDLGNBQVksbUJBQ1pDLFdBQVMsZ0JBQ1RDLGNBQVksbUJBQ1pDLGVBQWE7QUFFakIsSUFBSUMsbUJBQWlCLHdCQUNqQkMsZ0JBQWMscUJBQ2RDLGVBQWEseUJBQ2JDLGVBQWEseUJBQ2JDLFlBQVUsc0JBQ1ZDLGFBQVcsdUJBQ1hDLGFBQVcsdUJBQ1hDLGFBQVcsdUJBQ1hDLG9CQUFrQiw4QkFDbEJDLGNBQVksd0JBQ1pDLGNBQVk7O0FBR2hCLElBQUksaUJBQWlCLENBQUU7QUFDdkIsZUFBZVIsZ0JBQWMsZUFBZUMsZ0JBQzVDLGVBQWVDLGFBQVcsZUFBZUMsY0FDekMsZUFBZUMsY0FBWSxlQUFlQyxjQUMxQyxlQUFlQyxxQkFBbUIsZUFBZUMsZUFDakQsZUFBZUMsZUFBYTtBQUM1QixlQUFldkIsYUFBVyxlQUFlQyxjQUN6QyxlQUFlWSxvQkFBa0IsZUFBZVgsYUFDaEQsZUFBZVksaUJBQWUsZUFBZVgsYUFDN0MsZUFBZUMsY0FBWSxlQUFlQyxhQUMxQyxlQUFlQyxZQUFVLGVBQWVDLGVBQ3hDLGVBQWVDLGVBQWEsZUFBZUMsZUFDM0MsZUFBZUMsWUFBVSxlQUFlQyxlQUN4QyxlQUFlQyxnQkFBYzs7Ozs7Ozs7QUFTN0IsU0FBUyxpQkFBaUJZLFNBQU87QUFDL0IsUUFBT0MscUJBQWFELFFBQU0sSUFDeEJFLGlCQUFTRixRQUFNLE9BQU8sSUFBSSxDQUFDLENBQUMsZUFBZUcsb0JBQVdILFFBQU07QUFDL0Q7QUFFRCxnQ0FBZTs7Ozs7Ozs7Ozs7QUNwRGYsU0FBUyxVQUFVLE1BQU07QUFDdkIsUUFBTyxTQUFTSSxTQUFPO0FBQ3JCLFNBQU8sS0FBS0EsUUFBTTtDQUNuQjtBQUNGO0FBRUQseUJBQWU7Ozs7O0FDVmYsSUFBSUMsZ0JBQWMsT0FBTyxXQUFXLFlBQVksV0FBVyxDQUFDLFFBQVEsWUFBWTs7QUFHaEYsSUFBSUMsZUFBYUQsaUJBQWUsT0FBTyxVQUFVLFlBQVksVUFBVSxDQUFDLE9BQU8sWUFBWTs7QUFHM0YsSUFBSUUsa0JBQWdCRCxnQkFBY0EsYUFBVyxZQUFZRDs7QUFHekQsSUFBSSxjQUFjRSxtQkFBaUJDLG9CQUFXOztBQUc5QyxJQUFJLFdBQVksV0FBVztBQUN6QixLQUFJO0VBRUYsSUFBSSxRQUFRRixnQkFBY0EsYUFBVyxXQUFXQSxhQUFXLFFBQVEsT0FBTyxDQUFDO0FBRTNFLE1BQUksTUFDRixRQUFPO0FBSVQsU0FBTyxlQUFlLFlBQVksV0FBVyxZQUFZLFFBQVEsT0FBTztDQUN6RSxTQUFRLEdBQUcsQ0FBRTtBQUNmLEdBQUU7QUFFSCx3QkFBZTs7OztBQ3hCZixJQUFJLG1CQUFtQkcscUJBQVlBLGtCQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQjVDLElBQUksZUFBZSxtQkFBbUJDLG1CQUFVLGlCQUFpQixHQUFHQztBQUVwRSwyQkFBZTs7Ozs7QUNsQmYsSUFBSUMsZ0JBQWMsT0FBTzs7QUFHekIsSUFBSUMsbUJBQWlCRCxjQUFZOzs7Ozs7Ozs7QUFVakMsU0FBUyxjQUFjRSxTQUFPLFdBQVc7Q0FDdkMsSUFBSSxRQUFRQyxnQkFBUUQsUUFBTSxFQUN0QixRQUFRLENBQUMsU0FBU0Usb0JBQVlGLFFBQU0sRUFDcEMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTRyxpQkFBU0gsUUFBTSxFQUM1QyxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxVQUFVSSxxQkFBYUosUUFBTSxFQUMzRCxjQUFjLFNBQVMsU0FBUyxVQUFVLFFBQzFDLFNBQVMsY0FBY0ssbUJBQVVMLFFBQU0sUUFBUSxPQUFPLEdBQUcsQ0FBRSxHQUMzRCxTQUFTLE9BQU87QUFFcEIsTUFBSyxJQUFJLE9BQU9BLFFBQ2QsTUFBSyxhQUFhRCxpQkFBZSxLQUFLQyxTQUFPLElBQUksS0FDN0MsRUFBRSxnQkFFQyxPQUFPLFlBRU4sV0FBVyxPQUFPLFlBQVksT0FBTyxhQUVyQyxXQUFXLE9BQU8sWUFBWSxPQUFPLGdCQUFnQixPQUFPLGlCQUU3RE0saUJBQVEsS0FBSyxPQUFPLElBRXpCLE9BQU8sS0FBSyxJQUFJO0FBR3BCLFFBQU87QUFDUjtBQUVELDZCQUFlOzs7Ozs7Ozs7Ozs7QUN4Q2YsU0FBUyxRQUFRLE1BQU0sV0FBVztBQUNoQyxRQUFPLFNBQVMsS0FBSztBQUNuQixTQUFPLEtBQUssVUFBVSxJQUFJLENBQUM7Q0FDNUI7QUFDRjtBQUVELHVCQUFlOzs7O0FDWGYsSUFBSSxhQUFhQyxpQkFBUSxPQUFPLE1BQU0sT0FBTztBQUU3QywwQkFBZTs7Ozs7QUNEZixJQUFJQyxnQkFBYyxPQUFPOztBQUd6QixJQUFJQyxtQkFBaUJELGNBQVk7Ozs7Ozs7O0FBU2pDLFNBQVMsU0FBUyxRQUFRO0FBQ3hCLEtBQUksQ0FBQ0UscUJBQVksT0FBTyxDQUN0QixRQUFPQyxvQkFBVyxPQUFPO0NBRTNCLElBQUksU0FBUyxDQUFFO0FBQ2YsTUFBSyxJQUFJLE9BQU8sT0FBTyxPQUFPLENBQzVCLEtBQUlGLGlCQUFlLEtBQUssUUFBUSxJQUFJLElBQUksT0FBTyxlQUM3QyxPQUFPLEtBQUssSUFBSTtBQUdwQixRQUFPO0FBQ1I7QUFFRCx3QkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNHZixTQUFTLEtBQUssUUFBUTtBQUNwQixRQUFPRyxvQkFBWSxPQUFPLEdBQUdDLHVCQUFjLE9BQU8sR0FBR0Msa0JBQVMsT0FBTztBQUN0RTtBQUVELG1CQUFlOzs7Ozs7Ozs7Ozs7O0FDM0JmLFNBQVMsYUFBYSxRQUFRO0NBQzVCLElBQUksU0FBUyxDQUFFO0FBQ2YsS0FBSSxVQUFVLEtBQ1osTUFBSyxJQUFJLE9BQU8sT0FBTyxPQUFPLEVBQzVCLE9BQU8sS0FBSyxJQUFJO0FBR3BCLFFBQU87QUFDUjtBQUVELDRCQUFlOzs7OztBQ2RmLElBQUlDLGdCQUFjLE9BQU87O0FBR3pCLElBQUlDLG1CQUFpQkQsY0FBWTs7Ozs7Ozs7QUFTakMsU0FBUyxXQUFXLFFBQVE7QUFDMUIsS0FBSSxDQUFDRSxpQkFBUyxPQUFPLENBQ25CLFFBQU9DLHNCQUFhLE9BQU87Q0FFN0IsSUFBSSxVQUFVQyxxQkFBWSxPQUFPLEVBQzdCLFNBQVMsQ0FBRTtBQUVmLE1BQUssSUFBSSxPQUFPLE9BQ2QsS0FBSSxFQUFFLE9BQU8sa0JBQWtCLFdBQVcsQ0FBQ0gsaUJBQWUsS0FBSyxRQUFRLElBQUksSUFDekUsT0FBTyxLQUFLLElBQUk7QUFHcEIsUUFBTztBQUNSO0FBRUQsMEJBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xmLFNBQVMsT0FBTyxRQUFRO0FBQ3RCLFFBQU9JLG9CQUFZLE9BQU8sR0FBR0MsdUJBQWMsUUFBUSxLQUFLLEdBQUdDLG9CQUFXLE9BQU87QUFDOUU7QUFFRCxxQkFBZTs7Ozs7QUMzQmYsSUFBSSxlQUFlLG9EQUNmLGdCQUFnQjs7Ozs7Ozs7O0FBVXBCLFNBQVMsTUFBTUMsU0FBTyxRQUFRO0FBQzVCLEtBQUlDLGdCQUFRRCxRQUFNLENBQ2hCLFFBQU87Q0FFVCxJQUFJRSxTQUFPLE9BQU9GO0FBQ2xCLEtBQUlFLFVBQVEsWUFBWUEsVUFBUSxZQUFZQSxVQUFRLGFBQ2hERixXQUFTLFFBQVFHLGlCQUFTSCxRQUFNLENBQ2xDLFFBQU87QUFFVCxRQUFPLGNBQWMsS0FBS0EsUUFBTSxJQUFJLENBQUMsYUFBYSxLQUFLQSxRQUFNLElBQzFELFVBQVUsUUFBUUEsV0FBUyxPQUFPLE9BQU87QUFDN0M7QUFFRCxxQkFBZTs7OztBQ3pCZixJQUFJLGVBQWVJLG1CQUFVLFFBQVEsU0FBUztBQUU5Qyw0QkFBZTs7Ozs7Ozs7Ozs7QUNJZixTQUFTLFlBQVk7Q0FDbkIsS0FBSyxXQUFXQyx3QkFBZUEsc0JBQWEsS0FBSyxHQUFHLENBQUU7Q0FDdEQsS0FBSyxPQUFPO0FBQ2I7QUFFRCx5QkFBZTs7Ozs7Ozs7Ozs7Ozs7QUNKZixTQUFTLFdBQVcsS0FBSztDQUN2QixJQUFJLFNBQVMsS0FBSyxJQUFJLElBQUksSUFBSSxPQUFPLEtBQUssU0FBUztDQUNuRCxLQUFLLFFBQVEsU0FBUyxJQUFJO0FBQzFCLFFBQU87QUFDUjtBQUVELDBCQUFlOzs7OztBQ2JmLElBQUlDLG1CQUFpQjs7QUFHckIsSUFBSUMsZ0JBQWMsT0FBTzs7QUFHekIsSUFBSUMsbUJBQWlCRCxjQUFZOzs7Ozs7Ozs7O0FBV2pDLFNBQVMsUUFBUSxLQUFLO0NBQ3BCLElBQUksT0FBTyxLQUFLO0FBQ2hCLEtBQUlFLHVCQUFjO0VBQ2hCLElBQUksU0FBUyxLQUFLO0FBQ2xCLFNBQU8sV0FBV0gsbUJBQWlCLFNBQVk7Q0FDaEQ7QUFDRCxRQUFPRSxpQkFBZSxLQUFLLE1BQU0sSUFBSSxHQUFHLEtBQUssT0FBTztBQUNyRDtBQUVELHVCQUFlOzs7OztBQzFCZixJQUFJRSxnQkFBYyxPQUFPOztBQUd6QixJQUFJQyxtQkFBaUJELGNBQVk7Ozs7Ozs7Ozs7QUFXakMsU0FBUyxRQUFRLEtBQUs7Q0FDcEIsSUFBSSxPQUFPLEtBQUs7QUFDaEIsUUFBT0Usd0JBQWdCLEtBQUssU0FBUyxTQUFhRCxpQkFBZSxLQUFLLE1BQU0sSUFBSTtBQUNqRjtBQUVELHVCQUFlOzs7OztBQ25CZixJQUFJRSxtQkFBaUI7Ozs7Ozs7Ozs7O0FBWXJCLFNBQVMsUUFBUSxLQUFLQyxTQUFPO0NBQzNCLElBQUksT0FBTyxLQUFLO0NBQ2hCLEtBQUssUUFBUSxLQUFLLElBQUksSUFBSSxHQUFHLElBQUk7Q0FDakMsS0FBSyxPQUFRQyx5QkFBZ0JELFlBQVUsU0FBYUQsbUJBQWlCQztBQUNyRSxRQUFPO0FBQ1I7QUFFRCx1QkFBZTs7Ozs7Ozs7Ozs7QUNUZixTQUFTLEtBQUssU0FBUztDQUNyQixJQUFJLFFBQVEsSUFDUixTQUFTLFdBQVcsT0FBTyxJQUFJLFFBQVE7Q0FFM0MsS0FBSyxPQUFPO0FBQ1osUUFBTyxFQUFFLFFBQVEsUUFBUTtFQUN2QixJQUFJLFFBQVEsUUFBUTtFQUNwQixLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRztDQUM3QjtBQUNGO0FBR0QsS0FBSyxVQUFVLFFBQVFFO0FBQ3ZCLEtBQUssVUFBVSxZQUFZQztBQUMzQixLQUFLLFVBQVUsTUFBTUM7QUFDckIsS0FBSyxVQUFVLE1BQU1DO0FBQ3JCLEtBQUssVUFBVSxNQUFNQztBQUVyQixvQkFBZTs7Ozs7Ozs7Ozs7QUN4QmYsU0FBUyxpQkFBaUI7Q0FDeEIsS0FBSyxXQUFXLENBQUU7Q0FDbEIsS0FBSyxPQUFPO0FBQ2I7QUFFRCw4QkFBZTs7Ozs7Ozs7Ozs7O0FDRmYsU0FBUyxhQUFhLE9BQU8sS0FBSztDQUNoQyxJQUFJLFNBQVMsTUFBTTtBQUNuQixRQUFPLFNBQ0wsS0FBSUMsV0FBRyxNQUFNLFFBQVEsSUFBSSxJQUFJLENBQzNCLFFBQU87QUFHWCxRQUFPO0FBQ1I7QUFFRCw0QkFBZTs7Ozs7QUNqQmYsSUFBSSxhQUFhLE1BQU07O0FBR3ZCLElBQUksU0FBUyxXQUFXOzs7Ozs7Ozs7O0FBV3hCLFNBQVMsZ0JBQWdCLEtBQUs7Q0FDNUIsSUFBSSxPQUFPLEtBQUssVUFDWixRQUFRQyxzQkFBYSxNQUFNLElBQUk7QUFFbkMsS0FBSSxRQUFRLEVBQ1YsUUFBTztDQUVULElBQUksWUFBWSxLQUFLLFNBQVM7QUFDOUIsS0FBSSxTQUFTLFdBQ1gsS0FBSyxLQUFLO01BRVYsT0FBTyxLQUFLLE1BQU0sT0FBTyxFQUFFO0NBRTdCLEVBQUUsS0FBSztBQUNQLFFBQU87QUFDUjtBQUVELCtCQUFlOzs7Ozs7Ozs7Ozs7O0FDdkJmLFNBQVMsYUFBYSxLQUFLO0NBQ3pCLElBQUksT0FBTyxLQUFLLFVBQ1osUUFBUUMsc0JBQWEsTUFBTSxJQUFJO0FBRW5DLFFBQU8sUUFBUSxJQUFJLFNBQVksS0FBSyxPQUFPO0FBQzVDO0FBRUQsNEJBQWU7Ozs7Ozs7Ozs7Ozs7QUNQZixTQUFTLGFBQWEsS0FBSztBQUN6QixRQUFPQyxzQkFBYSxLQUFLLFVBQVUsSUFBSSxHQUFHO0FBQzNDO0FBRUQsNEJBQWU7Ozs7Ozs7Ozs7Ozs7O0FDSGYsU0FBUyxhQUFhLEtBQUtDLFNBQU87Q0FDaEMsSUFBSSxPQUFPLEtBQUssVUFDWixRQUFRQyxzQkFBYSxNQUFNLElBQUk7QUFFbkMsS0FBSSxRQUFRLEdBQUc7RUFDYixFQUFFLEtBQUs7RUFDUCxLQUFLLEtBQUssQ0FBQyxLQUFLRCxPQUFNLEVBQUM7Q0FDeEIsT0FDQyxLQUFLLE9BQU8sS0FBS0E7QUFFbkIsUUFBTztBQUNSO0FBRUQsNEJBQWU7Ozs7Ozs7Ozs7O0FDWmYsU0FBUyxVQUFVLFNBQVM7Q0FDMUIsSUFBSSxRQUFRLElBQ1IsU0FBUyxXQUFXLE9BQU8sSUFBSSxRQUFRO0NBRTNDLEtBQUssT0FBTztBQUNaLFFBQU8sRUFBRSxRQUFRLFFBQVE7RUFDdkIsSUFBSSxRQUFRLFFBQVE7RUFDcEIsS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUc7Q0FDN0I7QUFDRjtBQUdELFVBQVUsVUFBVSxRQUFRRTtBQUM1QixVQUFVLFVBQVUsWUFBWUM7QUFDaEMsVUFBVSxVQUFVLE1BQU1DO0FBQzFCLFVBQVUsVUFBVSxNQUFNQztBQUMxQixVQUFVLFVBQVUsTUFBTUM7QUFFMUIseUJBQWU7Ozs7QUMzQmYsSUFBSUMsUUFBTUMsbUJBQVVDLGVBQU0sTUFBTTtBQUVoQyxtQkFBZUY7Ozs7Ozs7Ozs7O0FDS2YsU0FBUyxnQkFBZ0I7Q0FDdkIsS0FBSyxPQUFPO0NBQ1osS0FBSyxXQUFXO0VBQ2QsUUFBUSxJQUFJRztFQUNaLE9BQU8sS0FBS0MsZ0JBQU9DO0VBQ25CLFVBQVUsSUFBSUY7Q0FDZjtBQUNGO0FBRUQsNkJBQWU7Ozs7Ozs7Ozs7O0FDYmYsU0FBUyxVQUFVRyxTQUFPO0NBQ3hCLElBQUlDLFNBQU8sT0FBT0Q7QUFDbEIsUUFBUUMsVUFBUSxZQUFZQSxVQUFRLFlBQVlBLFVBQVEsWUFBWUEsVUFBUSxZQUN2RUQsWUFBVSxjQUNWQSxZQUFVO0FBQ2hCO0FBRUQseUJBQWU7Ozs7Ozs7Ozs7OztBQ0pmLFNBQVMsV0FBVyxLQUFLLEtBQUs7Q0FDNUIsSUFBSSxPQUFPLElBQUk7QUFDZixRQUFPRSxtQkFBVSxJQUFJLEdBQ2pCLEtBQUssT0FBTyxPQUFPLFdBQVcsV0FBVyxVQUN6QyxLQUFLO0FBQ1Y7QUFFRCwwQkFBZTs7Ozs7Ozs7Ozs7OztBQ05mLFNBQVMsZUFBZSxLQUFLO0NBQzNCLElBQUksU0FBU0Msb0JBQVcsTUFBTSxJQUFJLENBQUMsVUFBVSxJQUFJO0NBQ2pELEtBQUssUUFBUSxTQUFTLElBQUk7QUFDMUIsUUFBTztBQUNSO0FBRUQsOEJBQWU7Ozs7Ozs7Ozs7Ozs7QUNOZixTQUFTLFlBQVksS0FBSztBQUN4QixRQUFPQyxvQkFBVyxNQUFNLElBQUksQ0FBQyxJQUFJLElBQUk7QUFDdEM7QUFFRCwyQkFBZTs7Ozs7Ozs7Ozs7OztBQ0pmLFNBQVMsWUFBWSxLQUFLO0FBQ3hCLFFBQU9DLG9CQUFXLE1BQU0sSUFBSSxDQUFDLElBQUksSUFBSTtBQUN0QztBQUVELDJCQUFlOzs7Ozs7Ozs7Ozs7OztBQ0hmLFNBQVMsWUFBWSxLQUFLQyxTQUFPO0NBQy9CLElBQUksT0FBT0Msb0JBQVcsTUFBTSxJQUFJLEVBQzVCLE9BQU8sS0FBSztDQUVoQixLQUFLLElBQUksS0FBS0QsUUFBTTtDQUNwQixLQUFLLFFBQVEsS0FBSyxRQUFRLE9BQU8sSUFBSTtBQUNyQyxRQUFPO0FBQ1I7QUFFRCwyQkFBZTs7Ozs7Ozs7Ozs7QUNSZixTQUFTLFNBQVMsU0FBUztDQUN6QixJQUFJLFFBQVEsSUFDUixTQUFTLFdBQVcsT0FBTyxJQUFJLFFBQVE7Q0FFM0MsS0FBSyxPQUFPO0FBQ1osUUFBTyxFQUFFLFFBQVEsUUFBUTtFQUN2QixJQUFJLFFBQVEsUUFBUTtFQUNwQixLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRztDQUM3QjtBQUNGO0FBR0QsU0FBUyxVQUFVLFFBQVFFO0FBQzNCLFNBQVMsVUFBVSxZQUFZQztBQUMvQixTQUFTLFVBQVUsTUFBTUM7QUFDekIsU0FBUyxVQUFVLE1BQU1DO0FBQ3pCLFNBQVMsVUFBVSxNQUFNQztBQUV6Qix3QkFBZTs7Ozs7QUM1QmYsSUFBSUMsb0JBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q3RCLFNBQVMsUUFBUSxNQUFNLFVBQVU7QUFDL0IsS0FBSSxPQUFPLFFBQVEsY0FBZSxZQUFZLFFBQVEsT0FBTyxZQUFZLFdBQ3ZFLE9BQU0sSUFBSSxVQUFVQTtDQUV0QixJQUFJLFdBQVcsV0FBVztFQUN4QixJQUFJLE9BQU8sV0FDUCxNQUFNLFdBQVcsU0FBUyxNQUFNLE1BQU0sS0FBSyxHQUFHLEtBQUssSUFDbkQsUUFBUSxTQUFTO0FBRXJCLE1BQUksTUFBTSxJQUFJLElBQUksQ0FDaEIsUUFBTyxNQUFNLElBQUksSUFBSTtFQUV2QixJQUFJLFNBQVMsS0FBSyxNQUFNLE1BQU0sS0FBSztFQUNuQyxTQUFTLFFBQVEsTUFBTSxJQUFJLEtBQUssT0FBTyxJQUFJO0FBQzNDLFNBQU87Q0FDUjtDQUNELFNBQVMsUUFBUSxLQUFLLFFBQVEsU0FBU0M7QUFDdkMsUUFBTztBQUNSO0FBR0QsUUFBUSxRQUFRQTtBQUVoQixzQkFBZTs7Ozs7QUNyRWYsSUFBSSxtQkFBbUI7Ozs7Ozs7OztBQVV2QixTQUFTLGNBQWMsTUFBTTtDQUMzQixJQUFJLFNBQVNDLGdCQUFRLE1BQU0sU0FBUyxLQUFLO0FBQ3ZDLE1BQUksTUFBTSxTQUFTLGtCQUNqQixNQUFNLE9BQU87QUFFZixTQUFPO0NBQ1IsRUFBQztDQUVGLElBQUksUUFBUSxPQUFPO0FBQ25CLFFBQU87QUFDUjtBQUVELDZCQUFlOzs7OztBQ3RCZixJQUFJLGFBQWE7O0FBR2pCLElBQUksZUFBZTs7Ozs7Ozs7QUFTbkIsSUFBSSxlQUFlQyx1QkFBYyxTQUFTLFFBQVE7Q0FDaEQsSUFBSSxTQUFTLENBQUU7QUFDZixLQUFJLE9BQU8sV0FBVyxFQUFFLEtBQUssSUFDM0IsT0FBTyxLQUFLLEdBQUc7Q0FFakIsT0FBTyxRQUFRLFlBQVksU0FBUyxPQUFPLFFBQVEsT0FBTyxXQUFXO0VBQ25FLE9BQU8sS0FBSyxRQUFRLFVBQVUsUUFBUSxjQUFjLEtBQUssR0FBSSxVQUFVLE1BQU87Q0FDL0UsRUFBQztBQUNGLFFBQU87QUFDUixFQUFDO0FBRUYsNEJBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIZixTQUFTLFNBQVNDLFNBQU87QUFDdkIsUUFBT0EsV0FBUyxPQUFPLEtBQUtDLHNCQUFhRCxRQUFNO0FBQ2hEO0FBRUQsdUJBQWU7Ozs7Ozs7Ozs7OztBQ2RmLFNBQVMsU0FBU0UsU0FBTyxRQUFRO0FBQy9CLEtBQUlDLGdCQUFRRCxRQUFNLENBQ2hCLFFBQU9BO0FBRVQsUUFBT0UsZUFBTUYsU0FBTyxPQUFPLEdBQUcsQ0FBQ0EsT0FBTSxJQUFHRyxzQkFBYUMsaUJBQVNKLFFBQU0sQ0FBQztBQUN0RTtBQUVELHdCQUFlOzs7OztBQ2pCZixJQUFJLFdBQVc7Ozs7Ozs7O0FBU2YsU0FBUyxNQUFNSyxTQUFPO0FBQ3BCLEtBQUksT0FBT0EsV0FBUyxZQUFZQyxpQkFBU0QsUUFBTSxDQUM3QyxRQUFPQTtDQUVULElBQUksU0FBVUEsVUFBUTtBQUN0QixRQUFRLFVBQVUsT0FBUSxJQUFJQSxXQUFVLENBQUMsV0FBWSxPQUFPO0FBQzdEO0FBRUQscUJBQWU7Ozs7Ozs7Ozs7OztBQ1RmLFNBQVMsUUFBUSxRQUFRRSxRQUFNO0NBQzdCQSxTQUFPQyxrQkFBU0QsUUFBTSxPQUFPO0NBRTdCLElBQUksUUFBUSxHQUNSLFNBQVNBLE9BQUs7QUFFbEIsUUFBTyxVQUFVLFFBQVEsUUFBUSxRQUMvQixTQUFTLE9BQU9FLGVBQU1GLE9BQUssU0FBUztBQUV0QyxRQUFRLFNBQVMsU0FBUyxTQUFVLFNBQVM7QUFDOUM7QUFFRCx1QkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNJZixTQUFTLElBQUksUUFBUUcsUUFBTSxjQUFjO0NBQ3ZDLElBQUksU0FBUyxVQUFVLE9BQU8sU0FBWUMsaUJBQVEsUUFBUUQsT0FBSztBQUMvRCxRQUFPLFdBQVcsU0FBWSxlQUFlO0FBQzlDO0FBRUQsa0JBQWU7Ozs7Ozs7Ozs7OztBQ3hCZixTQUFTLFVBQVUsT0FBTyxRQUFRO0NBQ2hDLElBQUksUUFBUSxJQUNSLFNBQVMsT0FBTyxRQUNoQixTQUFTLE1BQU07QUFFbkIsUUFBTyxFQUFFLFFBQVEsUUFDZixNQUFNLFNBQVMsU0FBUyxPQUFPO0FBRWpDLFFBQU87QUFDUjtBQUVELHlCQUFlOzs7OztBQ2RmLElBQUksbUJBQW1CRSxrQkFBU0EsZ0JBQU8scUJBQXFCOzs7Ozs7OztBQVM1RCxTQUFTLGNBQWNDLFNBQU87QUFDNUIsUUFBT0MsZ0JBQVFELFFBQU0sSUFBSUUsb0JBQVlGLFFBQU0sSUFDekMsQ0FBQyxFQUFFLG9CQUFvQkEsV0FBU0EsUUFBTTtBQUN6QztBQUVELDZCQUFlOzs7Ozs7Ozs7Ozs7Ozs7QUNMZixTQUFTLFlBQVksT0FBTyxPQUFPLFdBQVcsVUFBVSxRQUFRO0NBQzlELElBQUksUUFBUSxJQUNSLFNBQVMsTUFBTTtDQUVuQixjQUFjLFlBQVlHO0NBQzFCLFdBQVcsU0FBUyxDQUFFO0FBRXRCLFFBQU8sRUFBRSxRQUFRLFFBQVE7RUFDdkIsSUFBSUMsVUFBUSxNQUFNO0FBQ2xCLE1BQUksUUFBUSxLQUFLLFVBQVVBLFFBQU0sQ0FDL0IsS0FBSSxRQUFRLEdBRVYsWUFBWUEsU0FBTyxRQUFRLEdBQUcsV0FBVyxVQUFVLE9BQU87T0FFMURDLG1CQUFVLFFBQVFELFFBQU07V0FFakIsQ0FBQyxVQUNWLE9BQU8sT0FBTyxVQUFVQTtDQUUzQjtBQUNELFFBQU87QUFDUjtBQUVELDJCQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQmYsU0FBUyxRQUFRLE9BQU87Q0FDdEIsSUFBSSxTQUFTLFNBQVMsT0FBTyxJQUFJLE1BQU07QUFDdkMsUUFBTyxTQUFTRSxxQkFBWSxPQUFPLEVBQUUsR0FBRyxDQUFFO0FBQzNDO0FBRUQsc0JBQWU7Ozs7Ozs7Ozs7O0FDVmYsU0FBUyxTQUFTLE1BQU07QUFDdEIsUUFBT0MscUJBQVlDLGtCQUFTLE1BQU0sUUFBV0MsZ0JBQVEsRUFBRSxPQUFPLEdBQUc7QUFDbEU7QUFFRCx3QkFBZTs7Ozs7QUNaZixJQUFJLGVBQWVDLGlCQUFRLE9BQU8sZ0JBQWdCLE9BQU87QUFFekQsNEJBQWU7Ozs7O0FDQWYsSUFBSUMsY0FBWTs7QUFHaEIsSUFBSSxZQUFZLFNBQVMsV0FDckJDLGdCQUFjLE9BQU87O0FBR3pCLElBQUksZUFBZSxVQUFVOztBQUc3QixJQUFJQyxtQkFBaUJELGNBQVk7O0FBR2pDLElBQUksbUJBQW1CLGFBQWEsS0FBSyxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCaEQsU0FBU0UsZ0JBQWNDLFNBQU87QUFDNUIsS0FBSSxDQUFDQyxxQkFBYUQsUUFBTSxJQUFJRSxvQkFBV0YsUUFBTSxJQUFJSixZQUMvQyxRQUFPO0NBRVQsSUFBSSxRQUFRTyxzQkFBYUgsUUFBTTtBQUMvQixLQUFJLFVBQVUsS0FDWixRQUFPO0NBRVQsSUFBSSxPQUFPRixpQkFBZSxLQUFLLE9BQU8sY0FBYyxJQUFJLE1BQU07QUFDOUQsUUFBTyxPQUFPLFFBQVEsY0FBYyxnQkFBZ0IsUUFDbEQsYUFBYSxLQUFLLEtBQUssSUFBSTtBQUM5QjtBQUVELDRCQUFlQzs7Ozs7Ozs7Ozs7OztBQ3BEZixTQUFTLFVBQVUsT0FBTyxPQUFPLEtBQUs7Q0FDcEMsSUFBSSxRQUFRLElBQ1IsU0FBUyxNQUFNO0FBRW5CLEtBQUksUUFBUSxHQUNWLFFBQVEsQ0FBQyxRQUFRLFNBQVMsSUFBSyxTQUFTO0NBRTFDLE1BQU0sTUFBTSxTQUFTLFNBQVM7QUFDOUIsS0FBSSxNQUFNLEdBQ1IsT0FBTztDQUVULFNBQVMsUUFBUSxNQUFNLElBQU0sTUFBTSxVQUFXO0NBQzlDLFdBQVc7Q0FFWCxJQUFJLFNBQVMsTUFBTSxPQUFPO0FBQzFCLFFBQU8sRUFBRSxRQUFRLFFBQ2YsT0FBTyxTQUFTLE1BQU0sUUFBUTtBQUVoQyxRQUFPO0FBQ1I7QUFFRCx5QkFBZTs7Ozs7Ozs7Ozs7QUNyQmYsU0FBUyxhQUFhO0NBQ3BCLEtBQUssV0FBVyxJQUFJSztDQUNwQixLQUFLLE9BQU87QUFDYjtBQUVELDBCQUFlOzs7Ozs7Ozs7Ozs7O0FDTGYsU0FBUyxZQUFZLEtBQUs7Q0FDeEIsSUFBSSxPQUFPLEtBQUssVUFDWixTQUFTLEtBQUssVUFBVSxJQUFJO0NBRWhDLEtBQUssT0FBTyxLQUFLO0FBQ2pCLFFBQU87QUFDUjtBQUVELDJCQUFlOzs7Ozs7Ozs7Ozs7O0FDUmYsU0FBUyxTQUFTLEtBQUs7QUFDckIsUUFBTyxLQUFLLFNBQVMsSUFBSSxJQUFJO0FBQzlCO0FBRUQsd0JBQWU7Ozs7Ozs7Ozs7Ozs7QUNKZixTQUFTLFNBQVMsS0FBSztBQUNyQixRQUFPLEtBQUssU0FBUyxJQUFJLElBQUk7QUFDOUI7QUFFRCx3QkFBZTs7Ozs7QUNSZixJQUFJLG1CQUFtQjs7Ozs7Ozs7Ozs7QUFZdkIsU0FBUyxTQUFTLEtBQUtDLFNBQU87Q0FDNUIsSUFBSSxPQUFPLEtBQUs7QUFDaEIsS0FBSSxnQkFBZ0JDLG9CQUFXO0VBQzdCLElBQUksUUFBUSxLQUFLO0FBQ2pCLE1BQUksQ0FBQ0MsZ0JBQVEsTUFBTSxTQUFTLG1CQUFtQixHQUFJO0dBQ2pELE1BQU0sS0FBSyxDQUFDLEtBQUtGLE9BQU0sRUFBQztHQUN4QixLQUFLLE9BQU8sRUFBRSxLQUFLO0FBQ25CLFVBQU87RUFDUjtFQUNELE9BQU8sS0FBSyxXQUFXLElBQUlHLGtCQUFTO0NBQ3JDO0NBQ0QsS0FBSyxJQUFJLEtBQUtILFFBQU07Q0FDcEIsS0FBSyxPQUFPLEtBQUs7QUFDakIsUUFBTztBQUNSO0FBRUQsd0JBQWU7Ozs7Ozs7Ozs7O0FDbkJmLFNBQVMsTUFBTSxTQUFTO0NBQ3RCLElBQUksT0FBTyxLQUFLLFdBQVcsSUFBSUksbUJBQVU7Q0FDekMsS0FBSyxPQUFPLEtBQUs7QUFDbEI7QUFHRCxNQUFNLFVBQVUsUUFBUUM7QUFDeEIsTUFBTSxVQUFVLFlBQVlDO0FBQzVCLE1BQU0sVUFBVSxNQUFNQztBQUN0QixNQUFNLFVBQVUsTUFBTUM7QUFDdEIsTUFBTSxVQUFVLE1BQU1DO0FBRXRCLHFCQUFlOzs7Ozs7Ozs7Ozs7O0FDZGYsU0FBUyxXQUFXLFFBQVEsUUFBUTtBQUNsQyxRQUFPLFVBQVVDLG9CQUFXLFFBQVFDLGFBQUssT0FBTyxFQUFFLE9BQU87QUFDMUQ7QUFFRCwwQkFBZTs7Ozs7Ozs7Ozs7OztBQ0pmLFNBQVMsYUFBYSxRQUFRLFFBQVE7QUFDcEMsUUFBTyxVQUFVQyxvQkFBVyxRQUFRQyxlQUFPLE9BQU8sRUFBRSxPQUFPO0FBQzVEO0FBRUQsNEJBQWU7Ozs7O0FDYmYsSUFBSSxjQUFjLE9BQU8sV0FBVyxZQUFZLFdBQVcsQ0FBQyxRQUFRLFlBQVk7O0FBR2hGLElBQUksYUFBYSxlQUFlLE9BQU8sVUFBVSxZQUFZLFVBQVUsQ0FBQyxPQUFPLFlBQVk7O0FBRzNGLElBQUksZ0JBQWdCLGNBQWMsV0FBVyxZQUFZOztBQUd6RCxJQUFJQyxXQUFTLGdCQUFnQkMsY0FBSyxTQUFTLFFBQ3ZDLGNBQWNELFdBQVNBLFNBQU8sY0FBYzs7Ozs7Ozs7O0FBVWhELFNBQVMsWUFBWSxRQUFRLFFBQVE7QUFDbkMsS0FBSSxPQUNGLFFBQU8sT0FBTyxPQUFPO0NBRXZCLElBQUksU0FBUyxPQUFPLFFBQ2hCLFNBQVMsY0FBYyxZQUFZLE9BQU8sR0FBRyxJQUFJLE9BQU8sWUFBWTtDQUV4RSxPQUFPLEtBQUssT0FBTztBQUNuQixRQUFPO0FBQ1I7QUFFRCwyQkFBZTs7Ozs7Ozs7Ozs7OztBQ3pCZixTQUFTLFlBQVksT0FBTyxXQUFXO0NBQ3JDLElBQUksUUFBUSxJQUNSLFNBQVMsU0FBUyxPQUFPLElBQUksTUFBTSxRQUNuQyxXQUFXLEdBQ1gsU0FBUyxDQUFFO0FBRWYsUUFBTyxFQUFFLFFBQVEsUUFBUTtFQUN2QixJQUFJRSxVQUFRLE1BQU07QUFDbEIsTUFBSSxVQUFVQSxTQUFPLE9BQU8sTUFBTSxFQUNoQyxPQUFPLGNBQWNBO0NBRXhCO0FBQ0QsUUFBTztBQUNSO0FBRUQsMkJBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOZixTQUFTLFlBQVk7QUFDbkIsUUFBTyxDQUFFO0FBQ1Y7QUFFRCx3QkFBZTs7Ozs7QUNsQmYsSUFBSUMsZ0JBQWMsT0FBTzs7QUFHekIsSUFBSSx1QkFBdUJBLGNBQVk7QUFHdkMsSUFBSUMscUJBQW1CLE9BQU87Ozs7Ozs7O0FBUzlCLElBQUksYUFBYSxDQUFDQSxxQkFBbUJDLG9CQUFZLFNBQVMsUUFBUTtBQUNoRSxLQUFJLFVBQVUsS0FDWixRQUFPLENBQUU7Q0FFWCxTQUFTLE9BQU8sT0FBTztBQUN2QixRQUFPQyxxQkFBWUYsbUJBQWlCLE9BQU8sRUFBRSxTQUFTLFFBQVE7QUFDNUQsU0FBTyxxQkFBcUIsS0FBSyxRQUFRLE9BQU87Q0FDakQsRUFBQztBQUNIO0FBRUQsMEJBQWU7Ozs7Ozs7Ozs7OztBQ2xCZixTQUFTLFlBQVksUUFBUSxRQUFRO0FBQ25DLFFBQU9HLG9CQUFXLFFBQVFDLG9CQUFXLE9BQU8sRUFBRSxPQUFPO0FBQ3REO0FBRUQsMkJBQWU7Ozs7QUNUZixJQUFJLG1CQUFtQixPQUFPOzs7Ozs7OztBQVM5QixJQUFJLGVBQWUsQ0FBQyxtQkFBbUJDLG9CQUFZLFNBQVMsUUFBUTtDQUNsRSxJQUFJLFNBQVMsQ0FBRTtBQUNmLFFBQU8sUUFBUTtFQUNiQyxtQkFBVSxRQUFRQyxvQkFBVyxPQUFPLENBQUM7RUFDckMsU0FBU0Msc0JBQWEsT0FBTztDQUM5QjtBQUNELFFBQU87QUFDUjtBQUVELDRCQUFlOzs7Ozs7Ozs7Ozs7QUNiZixTQUFTLGNBQWMsUUFBUSxRQUFRO0FBQ3JDLFFBQU9DLG9CQUFXLFFBQVFDLHNCQUFhLE9BQU8sRUFBRSxPQUFPO0FBQ3hEO0FBRUQsNkJBQWU7Ozs7Ozs7Ozs7Ozs7OztBQ0RmLFNBQVMsZUFBZSxRQUFRLFVBQVUsYUFBYTtDQUNyRCxJQUFJLFNBQVMsU0FBUyxPQUFPO0FBQzdCLFFBQU9DLGdCQUFRLE9BQU8sR0FBRyxTQUFTQyxtQkFBVSxRQUFRLFlBQVksT0FBTyxDQUFDO0FBQ3pFO0FBRUQsOEJBQWU7Ozs7Ozs7Ozs7O0FDUmYsU0FBUyxXQUFXLFFBQVE7QUFDMUIsUUFBT0Msd0JBQWUsUUFBUUMsY0FBTUMsb0JBQVc7QUFDaEQ7QUFFRCwwQkFBZTs7Ozs7Ozs7Ozs7O0FDSGYsU0FBUyxhQUFhLFFBQVE7QUFDNUIsUUFBT0Msd0JBQWUsUUFBUUMsZ0JBQVFDLHNCQUFhO0FBQ3BEO0FBRUQsNEJBQWU7Ozs7QUNaZixJQUFJLFdBQVdDLG1CQUFVQyxlQUFNLFdBQVc7QUFFMUMsd0JBQWU7Ozs7QUNGZixJQUFJQyxZQUFVQyxtQkFBVUMsZUFBTSxVQUFVO0FBRXhDLHVCQUFlRjs7OztBQ0ZmLElBQUlHLFFBQU1DLG1CQUFVQyxlQUFNLE1BQU07QUFFaEMsbUJBQWVGOzs7OztBQ0dmLElBQUlHLFdBQVMsZ0JBQ1RDLGNBQVksbUJBQ1osYUFBYSxvQkFDYkMsV0FBUyxnQkFDVEMsZUFBYTtBQUVqQixJQUFJQyxnQkFBYzs7QUFHbEIsSUFBSSxxQkFBcUJDLGtCQUFTQyxrQkFBUyxFQUN2QyxnQkFBZ0JELGtCQUFTRSxhQUFJLEVBQzdCLG9CQUFvQkYsa0JBQVNHLGlCQUFRLEVBQ3JDLGdCQUFnQkgsa0JBQVNJLGFBQUksRUFDN0Isb0JBQW9CSixrQkFBU0ssaUJBQVE7Ozs7Ozs7O0FBU3pDLElBQUksU0FBU0M7QUFHYixJQUFLTCxxQkFBWSxPQUFPLElBQUlBLGtDQUFTLElBQUksWUFBWSxJQUFJLElBQUlGLGlCQUN4REcsZ0JBQU8sT0FBTyxJQUFJQSxlQUFJLElBQUlQLFlBQzFCUSxvQkFBVyxPQUFPQSxpQkFBUSxTQUFTLENBQUMsSUFBSSxjQUN4Q0MsZ0JBQU8sT0FBTyxJQUFJQSxlQUFJLElBQUlQLFlBQzFCUSxvQkFBVyxPQUFPLElBQUlBLG1CQUFRLElBQUlQLGNBQ3JDLFNBQVMsU0FBU1MsU0FBTztDQUN2QixJQUFJLFNBQVNELG9CQUFXQyxRQUFNLEVBQzFCLE9BQU8sVUFBVVgsY0FBWVcsUUFBTSxjQUFjLFFBQ2pELGFBQWEsT0FBT1Asa0JBQVMsS0FBSyxHQUFHO0FBRXpDLEtBQUksV0FDRixTQUFRLFlBQVI7RUFDRSxLQUFLLG1CQUFvQixRQUFPRDtFQUNoQyxLQUFLLGNBQWUsUUFBT0o7RUFDM0IsS0FBSyxrQkFBbUIsUUFBTztFQUMvQixLQUFLLGNBQWUsUUFBT0U7RUFDM0IsS0FBSyxrQkFBbUIsUUFBT0M7Q0FDaEM7QUFFSCxRQUFPO0FBQ1I7QUFHSCxzQkFBZTs7Ozs7QUN4RGYsSUFBSVUsZ0JBQWMsT0FBTzs7QUFHekIsSUFBSUMsbUJBQWlCRCxjQUFZOzs7Ozs7OztBQVNqQyxTQUFTLGVBQWUsT0FBTztDQUM3QixJQUFJLFNBQVMsTUFBTSxRQUNmLFNBQVMsSUFBSSxNQUFNLFlBQVk7QUFHbkMsS0FBSSxVQUFVLE9BQU8sTUFBTSxNQUFNLFlBQVlDLGlCQUFlLEtBQUssT0FBTyxRQUFRLEVBQUU7RUFDaEYsT0FBTyxRQUFRLE1BQU07RUFDckIsT0FBTyxRQUFRLE1BQU07Q0FDdEI7QUFDRCxRQUFPO0FBQ1I7QUFFRCw4QkFBZTs7Ozs7QUN0QmYsSUFBSUMsZUFBYUMsY0FBSztBQUV0QiwwQkFBZUQ7Ozs7Ozs7Ozs7O0FDSWYsU0FBUyxpQkFBaUIsYUFBYTtDQUNyQyxJQUFJLFNBQVMsSUFBSSxZQUFZLFlBQVksWUFBWTtDQUNyRCxJQUFJRSxvQkFBVyxRQUFRLElBQUksSUFBSUEsb0JBQVcsYUFBYTtBQUN2RCxRQUFPO0FBQ1I7QUFFRCxnQ0FBZTs7Ozs7Ozs7Ozs7O0FDTGYsU0FBUyxjQUFjLFVBQVUsUUFBUTtDQUN2QyxJQUFJLFNBQVMsU0FBU0MsMEJBQWlCLFNBQVMsT0FBTyxHQUFHLFNBQVM7QUFDbkUsUUFBTyxJQUFJLFNBQVMsWUFBWSxRQUFRLFNBQVMsWUFBWSxTQUFTO0FBQ3ZFO0FBRUQsNkJBQWU7Ozs7O0FDZGYsSUFBSSxVQUFVOzs7Ozs7OztBQVNkLFNBQVMsWUFBWSxRQUFRO0NBQzNCLElBQUksU0FBUyxJQUFJLE9BQU8sWUFBWSxPQUFPLFFBQVEsUUFBUSxLQUFLLE9BQU87Q0FDdkUsT0FBTyxZQUFZLE9BQU87QUFDMUIsUUFBTztBQUNSO0FBRUQsMkJBQWU7Ozs7O0FDYmYsSUFBSUMsZ0JBQWNDLGtCQUFTQSxnQkFBTyxZQUFZLFFBQzFDQyxrQkFBZ0JGLGdCQUFjQSxjQUFZLFVBQVU7Ozs7Ozs7O0FBU3hELFNBQVMsWUFBWSxRQUFRO0FBQzNCLFFBQU9FLGtCQUFnQixPQUFPQSxnQkFBYyxLQUFLLE9BQU8sQ0FBQyxHQUFHLENBQUU7QUFDL0Q7QUFFRCwyQkFBZTs7Ozs7Ozs7Ozs7O0FDUGYsU0FBUyxnQkFBZ0IsWUFBWSxRQUFRO0NBQzNDLElBQUksU0FBUyxTQUFTQywwQkFBaUIsV0FBVyxPQUFPLEdBQUcsV0FBVztBQUN2RSxRQUFPLElBQUksV0FBVyxZQUFZLFFBQVEsV0FBVyxZQUFZLFdBQVc7QUFDN0U7QUFFRCwrQkFBZTs7Ozs7QUNSZixJQUFJQyxZQUFVLG9CQUNWQyxZQUFVLGlCQUNWQyxXQUFTLGdCQUNUQyxjQUFZLG1CQUNaQyxjQUFZLG1CQUNaQyxXQUFTLGdCQUNUQyxjQUFZLG1CQUNaQyxjQUFZO0FBRWhCLElBQUlDLG1CQUFpQix3QkFDakJDLGdCQUFjLHFCQUNkQyxlQUFhLHlCQUNiQyxlQUFhLHlCQUNiQyxZQUFVLHNCQUNWQyxhQUFXLHVCQUNYQyxhQUFXLHVCQUNYQyxhQUFXLHVCQUNYQyxvQkFBa0IsOEJBQ2xCQyxjQUFZLHdCQUNaQyxjQUFZOzs7Ozs7Ozs7Ozs7O0FBY2hCLFNBQVMsZUFBZSxRQUFRLEtBQUssUUFBUTtDQUMzQyxJQUFJLE9BQU8sT0FBTztBQUNsQixTQUFRLEtBQVI7RUFDRSxLQUFLVixpQkFDSCxRQUFPVywwQkFBaUIsT0FBTztFQUVqQyxLQUFLbkI7RUFDTCxLQUFLQyxVQUNILFFBQU8sSUFBSSxLQUFLLENBQUM7RUFFbkIsS0FBS1EsY0FDSCxRQUFPVyx1QkFBYyxRQUFRLE9BQU87RUFFdEMsS0FBS1Y7RUFBWSxLQUFLQztFQUN0QixLQUFLQztFQUFTLEtBQUtDO0VBQVUsS0FBS0M7RUFDbEMsS0FBS0M7RUFBVSxLQUFLQztFQUFpQixLQUFLQztFQUFXLEtBQUtDLFlBQ3hELFFBQU9HLHlCQUFnQixRQUFRLE9BQU87RUFFeEMsS0FBS25CLFNBQ0gsUUFBTyxJQUFJO0VBRWIsS0FBS0M7RUFDTCxLQUFLRyxZQUNILFFBQU8sSUFBSSxLQUFLO0VBRWxCLEtBQUtGLFlBQ0gsUUFBT2tCLHFCQUFZLE9BQU87RUFFNUIsS0FBS2pCLFNBQ0gsUUFBTyxJQUFJO0VBRWIsS0FBS0UsWUFDSCxRQUFPZ0IscUJBQVksT0FBTztDQUM3QjtBQUNGO0FBRUQsOEJBQWU7Ozs7Ozs7Ozs7O0FDakVmLFNBQVMsZ0JBQWdCLFFBQVE7QUFDL0IsUUFBUSxPQUFPLE9BQU8sZUFBZSxjQUFjLENBQUNDLHFCQUFZLE9BQU8sR0FDbkVDLG9CQUFXQyxzQkFBYSxPQUFPLENBQUMsR0FDaEMsQ0FBRTtBQUNQO0FBRUQsK0JBQWU7Ozs7O0FDYmYsSUFBSUMsV0FBUzs7Ozs7Ozs7QUFTYixTQUFTLFVBQVVDLFNBQU87QUFDeEIsUUFBT0MscUJBQWFELFFBQU0sSUFBSUUsZ0JBQU9GLFFBQU0sSUFBSUQ7QUFDaEQ7QUFFRCx5QkFBZTs7OztBQ1pmLElBQUksWUFBWUkscUJBQVlBLGtCQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQnJDLElBQUksUUFBUSxZQUFZQyxtQkFBVSxVQUFVLEdBQUdDO0FBRS9DLG9CQUFlOzs7OztBQ3RCZixJQUFJQyxXQUFTOzs7Ozs7OztBQVNiLFNBQVMsVUFBVUMsU0FBTztBQUN4QixRQUFPQyxxQkFBYUQsUUFBTSxJQUFJRSxnQkFBT0YsUUFBTSxJQUFJRDtBQUNoRDtBQUVELHlCQUFlOzs7O0FDWmYsSUFBSSxZQUFZSSxxQkFBWUEsa0JBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CckMsSUFBSSxRQUFRLFlBQVlDLG1CQUFVLFVBQVUsR0FBR0M7QUFFL0Msb0JBQWU7Ozs7O0FDRmYsSUFBSUMsb0JBQWtCLEdBQ2xCQyxvQkFBa0IsR0FDbEJDLHVCQUFxQjs7QUFHekIsSUFBSUMsWUFBVSxzQkFDVkMsYUFBVyxrQkFDWEMsWUFBVSxvQkFDVkMsWUFBVSxpQkFDVkMsYUFBVyxrQkFDWCxVQUFVLHFCQUNWLFNBQVMsOEJBQ1RDLFdBQVMsZ0JBQ1RDLGNBQVksbUJBQ1pDLGNBQVksbUJBQ1pDLGNBQVksbUJBQ1pDLFdBQVMsZ0JBQ1RDLGNBQVksbUJBQ1pDLGNBQVksbUJBQ1osYUFBYTtBQUVqQixJQUFJQyxtQkFBaUIsd0JBQ2pCQyxnQkFBYyxxQkFDZCxhQUFhLHlCQUNiLGFBQWEseUJBQ2IsVUFBVSxzQkFDVixXQUFXLHVCQUNYLFdBQVcsdUJBQ1gsV0FBVyx1QkFDWCxrQkFBa0IsOEJBQ2xCLFlBQVksd0JBQ1osWUFBWTs7QUFHaEIsSUFBSSxnQkFBZ0IsQ0FBRTtBQUN0QixjQUFjYixhQUFXLGNBQWNDLGNBQ3ZDLGNBQWNXLG9CQUFrQixjQUFjQyxpQkFDOUMsY0FBY1gsYUFBVyxjQUFjQyxhQUN2QyxjQUFjLGNBQWMsY0FBYyxjQUMxQyxjQUFjLFdBQVcsY0FBYyxZQUN2QyxjQUFjLFlBQVksY0FBY0UsWUFDeEMsY0FBY0MsZUFBYSxjQUFjQyxlQUN6QyxjQUFjQyxlQUFhLGNBQWNDLFlBQ3pDLGNBQWNDLGVBQWEsY0FBY0MsZUFDekMsY0FBYyxZQUFZLGNBQWMsbUJBQ3hDLGNBQWMsYUFBYSxjQUFjLGFBQWE7QUFDdEQsY0FBY1AsY0FBWSxjQUFjLFdBQ3hDLGNBQWMsY0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQjVCLFNBQVMsVUFBVVUsU0FBTyxTQUFTLFlBQVksS0FBSyxRQUFRLE9BQU87Q0FDakUsSUFBSSxRQUNBLFNBQVMsVUFBVWpCLG1CQUNuQixTQUFTLFVBQVVDLG1CQUNuQixTQUFTLFVBQVVDO0FBRXZCLEtBQUksWUFDRixTQUFTLFNBQVMsV0FBV2UsU0FBTyxLQUFLLFFBQVEsTUFBTSxHQUFHLFdBQVdBLFFBQU07QUFFN0UsS0FBSSxXQUFXLE9BQ2IsUUFBTztBQUVULEtBQUksQ0FBQ0MsaUJBQVNELFFBQU0sQ0FDbEIsUUFBT0E7Q0FFVCxJQUFJLFFBQVFFLGdCQUFRRixRQUFNO0FBQzFCLEtBQUksT0FBTztFQUNULFNBQVNHLHdCQUFlSCxRQUFNO0FBQzlCLE1BQUksQ0FBQyxPQUNILFFBQU9JLG1CQUFVSixTQUFPLE9BQU87Q0FFbEMsT0FBTTtFQUNMLElBQUksTUFBTUssZ0JBQU9MLFFBQU0sRUFDbkIsU0FBUyxPQUFPLFdBQVcsT0FBTztBQUV0QyxNQUFJTSxpQkFBU04sUUFBTSxDQUNqQixRQUFPTyxxQkFBWVAsU0FBTyxPQUFPO0FBRW5DLE1BQUksT0FBT1AsZUFBYSxPQUFPUCxhQUFZLFVBQVUsQ0FBQyxRQUFTO0dBQzdELFNBQVUsVUFBVSxTQUFVLENBQUUsSUFBR3NCLHlCQUFnQlIsUUFBTTtBQUN6RCxPQUFJLENBQUMsT0FDSCxRQUFPLFNBQ0hTLHVCQUFjVCxTQUFPVSxzQkFBYSxRQUFRVixRQUFNLENBQUMsR0FDakRXLHFCQUFZWCxTQUFPWSxvQkFBVyxRQUFRWixRQUFNLENBQUM7RUFFcEQsT0FBTTtBQUNMLE9BQUksQ0FBQyxjQUFjLEtBQ2pCLFFBQU8sU0FBU0EsVUFBUSxDQUFFO0dBRTVCLFNBQVNhLHdCQUFlYixTQUFPLEtBQUssT0FBTztFQUM1QztDQUNGO0NBRUQsVUFBVSxRQUFRLElBQUljO0NBQ3RCLElBQUksVUFBVSxNQUFNLElBQUlkLFFBQU07QUFDOUIsS0FBSSxRQUNGLFFBQU87Q0FFVCxNQUFNLElBQUlBLFNBQU8sT0FBTztBQUV4QixLQUFJZSxjQUFNZixRQUFNLEVBQ2RBLFFBQU0sUUFBUSxTQUFTLFVBQVU7RUFDL0IsT0FBTyxJQUFJLFVBQVUsVUFBVSxTQUFTLFlBQVksVUFBVUEsU0FBTyxNQUFNLENBQUM7Q0FDN0UsRUFBQztVQUNPZ0IsY0FBTWhCLFFBQU0sRUFDckJBLFFBQU0sUUFBUSxTQUFTLFVBQVVpQixPQUFLO0VBQ3BDLE9BQU8sSUFBSUEsT0FBSyxVQUFVLFVBQVUsU0FBUyxZQUFZQSxPQUFLakIsU0FBTyxNQUFNLENBQUM7Q0FDN0UsRUFBQztDQUdKLElBQUksV0FBVyxTQUNWLFNBQVNrQix3QkFBZUMsc0JBQ3hCLFNBQVNDLGlCQUFTQztDQUV2QixJQUFJLFFBQVEsUUFBUSxTQUFZLFNBQVNyQixRQUFNO0NBQy9Dc0IsbUJBQVUsU0FBU3RCLFNBQU8sU0FBUyxVQUFVaUIsT0FBSztBQUNoRCxNQUFJLE9BQU87R0FDVEEsUUFBTTtHQUNOLFdBQVdqQixRQUFNaUI7RUFDbEI7RUFFRE0scUJBQVksUUFBUU4sT0FBSyxVQUFVLFVBQVUsU0FBUyxZQUFZQSxPQUFLakIsU0FBTyxNQUFNLENBQUM7Q0FDdEYsRUFBQztBQUNGLFFBQU87QUFDUjtBQUVELHlCQUFlOzs7OztBQ3BLZixJQUFJLGlCQUFpQjs7Ozs7Ozs7Ozs7QUFZckIsU0FBUyxZQUFZd0IsU0FBTztDQUMxQixLQUFLLFNBQVMsSUFBSUEsU0FBTyxlQUFlO0FBQ3hDLFFBQU87QUFDUjtBQUVELDJCQUFlOzs7Ozs7Ozs7Ozs7O0FDVGYsU0FBUyxZQUFZQyxTQUFPO0FBQzFCLFFBQU8sS0FBSyxTQUFTLElBQUlBLFFBQU07QUFDaEM7QUFFRCwyQkFBZTs7Ozs7Ozs7Ozs7O0FDRGYsU0FBUyxTQUFTLFFBQVE7Q0FDeEIsSUFBSSxRQUFRLElBQ1IsU0FBUyxVQUFVLE9BQU8sSUFBSSxPQUFPO0NBRXpDLEtBQUssV0FBVyxJQUFJQztBQUNwQixRQUFPLEVBQUUsUUFBUSxRQUNmLEtBQUssSUFBSSxPQUFPLE9BQU87QUFFMUI7QUFHRCxTQUFTLFVBQVUsTUFBTSxTQUFTLFVBQVUsT0FBT0M7QUFDbkQsU0FBUyxVQUFVLE1BQU1DO0FBRXpCLHdCQUFlOzs7Ozs7Ozs7Ozs7OztBQ2hCZixTQUFTLFVBQVUsT0FBTyxXQUFXO0NBQ25DLElBQUksUUFBUSxJQUNSLFNBQVMsU0FBUyxPQUFPLElBQUksTUFBTTtBQUV2QyxRQUFPLEVBQUUsUUFBUSxPQUNmLEtBQUksVUFBVSxNQUFNLFFBQVEsT0FBTyxNQUFNLENBQ3ZDLFFBQU87QUFHWCxRQUFPO0FBQ1I7QUFFRCx5QkFBZTs7Ozs7Ozs7Ozs7O0FDZGYsU0FBUyxTQUFTLE9BQU8sS0FBSztBQUM1QixRQUFPLE1BQU0sSUFBSSxJQUFJO0FBQ3RCO0FBRUQsd0JBQWU7Ozs7O0FDUGYsSUFBSUMseUJBQXVCLEdBQ3ZCQywyQkFBeUI7Ozs7Ozs7Ozs7Ozs7O0FBZTdCLFNBQVMsWUFBWSxPQUFPLE9BQU8sU0FBUyxZQUFZLFdBQVcsT0FBTztDQUN4RSxJQUFJLFlBQVksVUFBVUQsd0JBQ3RCLFlBQVksTUFBTSxRQUNsQixZQUFZLE1BQU07QUFFdEIsS0FBSSxhQUFhLGFBQWEsRUFBRSxhQUFhLFlBQVksV0FDdkQsUUFBTztDQUdULElBQUksYUFBYSxNQUFNLElBQUksTUFBTTtDQUNqQyxJQUFJLGFBQWEsTUFBTSxJQUFJLE1BQU07QUFDakMsS0FBSSxjQUFjLFdBQ2hCLFFBQU8sY0FBYyxTQUFTLGNBQWM7Q0FFOUMsSUFBSSxRQUFRLElBQ1IsU0FBUyxNQUNULE9BQVEsVUFBVUMsMkJBQTBCLElBQUlDLHNCQUFXO0NBRS9ELE1BQU0sSUFBSSxPQUFPLE1BQU07Q0FDdkIsTUFBTSxJQUFJLE9BQU8sTUFBTTtBQUd2QixRQUFPLEVBQUUsUUFBUSxXQUFXO0VBQzFCLElBQUksV0FBVyxNQUFNLFFBQ2pCLFdBQVcsTUFBTTtBQUVyQixNQUFJLFlBQ0YsSUFBSSxXQUFXLFlBQ1gsV0FBVyxVQUFVLFVBQVUsT0FBTyxPQUFPLE9BQU8sTUFBTSxHQUMxRCxXQUFXLFVBQVUsVUFBVSxPQUFPLE9BQU8sT0FBTyxNQUFNO0FBRWhFLE1BQUksYUFBYSxRQUFXO0FBQzFCLE9BQUksU0FDRjtHQUVGLFNBQVM7QUFDVDtFQUNEO0FBRUQsTUFBSSxNQUNGO09BQUksQ0FBQ0MsbUJBQVUsT0FBTyxTQUFTQyxZQUFVLFVBQVU7QUFDN0MsUUFBSSxDQUFDQyxrQkFBUyxNQUFNLFNBQVMsS0FDeEIsYUFBYUQsY0FBWSxVQUFVLFVBQVVBLFlBQVUsU0FBUyxZQUFZLE1BQU0sRUFDckYsUUFBTyxLQUFLLEtBQUssU0FBUztHQUU3QixFQUFDLEVBQUU7SUFDTixTQUFTO0FBQ1Q7R0FDRDthQUNRLEVBQ0wsYUFBYSxZQUNYLFVBQVUsVUFBVSxVQUFVLFNBQVMsWUFBWSxNQUFNLEdBQzFEO0dBQ0wsU0FBUztBQUNUO0VBQ0Q7Q0FDRjtDQUNELE1BQU0sVUFBVSxNQUFNO0NBQ3RCLE1BQU0sVUFBVSxNQUFNO0FBQ3RCLFFBQU87QUFDUjtBQUVELDJCQUFlOzs7Ozs7Ozs7OztBQzVFZixTQUFTLFdBQVcsS0FBSztDQUN2QixJQUFJLFFBQVEsSUFDUixTQUFTLE1BQU0sSUFBSSxLQUFLO0NBRTVCLElBQUksUUFBUSxTQUFTRSxTQUFPLEtBQUs7RUFDL0IsT0FBTyxFQUFFLFNBQVMsQ0FBQyxLQUFLQSxPQUFNO0NBQy9CLEVBQUM7QUFDRixRQUFPO0FBQ1I7QUFFRCwwQkFBZTs7Ozs7Ozs7Ozs7QUNWZixTQUFTLFdBQVcsS0FBSztDQUN2QixJQUFJLFFBQVEsSUFDUixTQUFTLE1BQU0sSUFBSSxLQUFLO0NBRTVCLElBQUksUUFBUSxTQUFTQyxTQUFPO0VBQzFCLE9BQU8sRUFBRSxTQUFTQTtDQUNuQixFQUFDO0FBQ0YsUUFBTztBQUNSO0FBRUQsMEJBQWU7Ozs7O0FDVGYsSUFBSUMseUJBQXVCLEdBQ3ZCQywyQkFBeUI7O0FBRzdCLElBQUksVUFBVSxvQkFDVixVQUFVLGlCQUNWLFdBQVcsa0JBQ1gsU0FBUyxnQkFDVCxZQUFZLG1CQUNaLFlBQVksbUJBQ1osU0FBUyxnQkFDVCxZQUFZLG1CQUNaLFlBQVk7QUFFaEIsSUFBSSxpQkFBaUIsd0JBQ2pCLGNBQWM7O0FBR2xCLElBQUksY0FBY0Msa0JBQVNBLGdCQUFPLFlBQVksUUFDMUMsZ0JBQWdCLGNBQWMsWUFBWSxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQnhELFNBQVMsV0FBVyxRQUFRLE9BQU8sS0FBSyxTQUFTLFlBQVksV0FBVyxPQUFPO0FBQzdFLFNBQVEsS0FBUjtFQUNFLEtBQUs7QUFDSCxPQUFLLE9BQU8sY0FBYyxNQUFNLGNBQzNCLE9BQU8sY0FBYyxNQUFNLFdBQzlCLFFBQU87R0FFVCxTQUFTLE9BQU87R0FDaEIsUUFBUSxNQUFNO0VBRWhCLEtBQUs7QUFDSCxPQUFLLE9BQU8sY0FBYyxNQUFNLGNBQzVCLENBQUMsVUFBVSxJQUFJQyxvQkFBVyxTQUFTLElBQUlBLG9CQUFXLE9BQU8sQ0FDM0QsUUFBTztBQUVULFVBQU87RUFFVCxLQUFLO0VBQ0wsS0FBSztFQUNMLEtBQUssVUFHSCxRQUFPQyxXQUFHLENBQUMsUUFBUSxDQUFDLE1BQU07RUFFNUIsS0FBSyxTQUNILFFBQU8sT0FBTyxRQUFRLE1BQU0sUUFBUSxPQUFPLFdBQVcsTUFBTTtFQUU5RCxLQUFLO0VBQ0wsS0FBSyxVQUlILFFBQU8sVUFBVyxRQUFRO0VBRTVCLEtBQUssUUFDSCxJQUFJLFVBQVVDO0VBRWhCLEtBQUs7R0FDSCxJQUFJLFlBQVksVUFBVUw7R0FDMUIsWUFBWSxVQUFVTTtBQUV0QixPQUFJLE9BQU8sUUFBUSxNQUFNLFFBQVEsQ0FBQyxVQUNoQyxRQUFPO0dBR1QsSUFBSSxVQUFVLE1BQU0sSUFBSSxPQUFPO0FBQy9CLE9BQUksUUFDRixRQUFPLFdBQVc7R0FFcEIsV0FBV0w7R0FHWCxNQUFNLElBQUksUUFBUSxNQUFNO0dBQ3hCLElBQUksU0FBU00scUJBQVksUUFBUSxPQUFPLEVBQUUsUUFBUSxNQUFNLEVBQUUsU0FBUyxZQUFZLFdBQVcsTUFBTTtHQUNoRyxNQUFNLFVBQVUsT0FBTztBQUN2QixVQUFPO0VBRVQsS0FBSyxVQUNILEtBQUksY0FDRixRQUFPLGNBQWMsS0FBSyxPQUFPLElBQUksY0FBYyxLQUFLLE1BQU07Q0FFbkU7QUFDRCxRQUFPO0FBQ1I7QUFFRCwwQkFBZTs7Ozs7QUM1R2YsSUFBSUMseUJBQXVCOztBQUczQixJQUFJQyxnQkFBYyxPQUFPOztBQUd6QixJQUFJQyxtQkFBaUJELGNBQVk7Ozs7Ozs7Ozs7Ozs7O0FBZWpDLFNBQVMsYUFBYSxRQUFRLE9BQU8sU0FBUyxZQUFZLFdBQVcsT0FBTztDQUMxRSxJQUFJLFlBQVksVUFBVUQsd0JBQ3RCLFdBQVdHLG9CQUFXLE9BQU8sRUFDN0IsWUFBWSxTQUFTLFFBQ3JCLFdBQVdBLG9CQUFXLE1BQU0sRUFDNUIsWUFBWSxTQUFTO0FBRXpCLEtBQUksYUFBYSxhQUFhLENBQUMsVUFDN0IsUUFBTztDQUVULElBQUksUUFBUTtBQUNaLFFBQU8sU0FBUztFQUNkLElBQUksTUFBTSxTQUFTO0FBQ25CLE1BQUksRUFBRSxZQUFZLE9BQU8sUUFBUUQsaUJBQWUsS0FBSyxPQUFPLElBQUksRUFDOUQsUUFBTztDQUVWO0NBRUQsSUFBSSxhQUFhLE1BQU0sSUFBSSxPQUFPO0NBQ2xDLElBQUksYUFBYSxNQUFNLElBQUksTUFBTTtBQUNqQyxLQUFJLGNBQWMsV0FDaEIsUUFBTyxjQUFjLFNBQVMsY0FBYztDQUU5QyxJQUFJLFNBQVM7Q0FDYixNQUFNLElBQUksUUFBUSxNQUFNO0NBQ3hCLE1BQU0sSUFBSSxPQUFPLE9BQU87Q0FFeEIsSUFBSSxXQUFXO0FBQ2YsUUFBTyxFQUFFLFFBQVEsV0FBVztFQUMxQixNQUFNLFNBQVM7RUFDZixJQUFJLFdBQVcsT0FBTyxNQUNsQixXQUFXLE1BQU07QUFFckIsTUFBSSxZQUNGLElBQUksV0FBVyxZQUNYLFdBQVcsVUFBVSxVQUFVLEtBQUssT0FBTyxRQUFRLE1BQU0sR0FDekQsV0FBVyxVQUFVLFVBQVUsS0FBSyxRQUFRLE9BQU8sTUFBTTtBQUcvRCxNQUFJLEVBQUUsYUFBYSxTQUNWLGFBQWEsWUFBWSxVQUFVLFVBQVUsVUFBVSxTQUFTLFlBQVksTUFBTSxHQUNuRixXQUNEO0dBQ0wsU0FBUztBQUNUO0VBQ0Q7RUFDRCxhQUFhLFdBQVcsT0FBTztDQUNoQztBQUNELEtBQUksVUFBVSxDQUFDLFVBQVU7RUFDdkIsSUFBSSxVQUFVLE9BQU8sYUFDakIsVUFBVSxNQUFNO0FBR3BCLE1BQUksV0FBVyxXQUNWLGlCQUFpQixVQUFVLGlCQUFpQixTQUM3QyxFQUFFLE9BQU8sV0FBVyxjQUFjLG1CQUFtQixXQUNuRCxPQUFPLFdBQVcsY0FBYyxtQkFBbUIsVUFDdkQsU0FBUztDQUVaO0NBQ0QsTUFBTSxVQUFVLE9BQU87Q0FDdkIsTUFBTSxVQUFVLE1BQU07QUFDdEIsUUFBTztBQUNSO0FBRUQsNEJBQWU7Ozs7O0FDL0VmLElBQUlFLHlCQUF1Qjs7QUFHM0IsSUFBSSxVQUFVLHNCQUNWLFdBQVcsa0JBQ1gsWUFBWTs7QUFHaEIsSUFBSSxjQUFjLE9BQU87O0FBR3pCLElBQUksaUJBQWlCLFlBQVk7Ozs7Ozs7Ozs7Ozs7OztBQWdCakMsU0FBUyxnQkFBZ0IsUUFBUSxPQUFPLFNBQVMsWUFBWSxXQUFXLE9BQU87Q0FDN0UsSUFBSSxXQUFXQyxnQkFBUSxPQUFPLEVBQzFCLFdBQVdBLGdCQUFRLE1BQU0sRUFDekIsU0FBUyxXQUFXLFdBQVdDLGdCQUFPLE9BQU8sRUFDN0MsU0FBUyxXQUFXLFdBQVdBLGdCQUFPLE1BQU07Q0FFaEQsU0FBUyxVQUFVLFVBQVUsWUFBWTtDQUN6QyxTQUFTLFVBQVUsVUFBVSxZQUFZO0NBRXpDLElBQUksV0FBVyxVQUFVLFdBQ3JCLFdBQVcsVUFBVSxXQUNyQixZQUFZLFVBQVU7QUFFMUIsS0FBSSxhQUFhQyxpQkFBUyxPQUFPLEVBQUU7QUFDakMsTUFBSSxDQUFDQSxpQkFBUyxNQUFNLENBQ2xCLFFBQU87RUFFVCxXQUFXO0VBQ1gsV0FBVztDQUNaO0FBQ0QsS0FBSSxhQUFhLENBQUMsVUFBVTtFQUMxQixVQUFVLFFBQVEsSUFBSUM7QUFDdEIsU0FBUSxZQUFZQyxxQkFBYSxPQUFPLEdBQ3BDQyxxQkFBWSxRQUFRLE9BQU8sU0FBUyxZQUFZLFdBQVcsTUFBTSxHQUNqRUMsb0JBQVcsUUFBUSxPQUFPLFFBQVEsU0FBUyxZQUFZLFdBQVcsTUFBTTtDQUM3RTtBQUNELEtBQUksRUFBRSxVQUFVUCx5QkFBdUI7RUFDckMsSUFBSSxlQUFlLFlBQVksZUFBZSxLQUFLLFFBQVEsY0FBYyxFQUNyRSxlQUFlLFlBQVksZUFBZSxLQUFLLE9BQU8sY0FBYztBQUV4RSxNQUFJLGdCQUFnQixjQUFjO0dBQ2hDLElBQUksZUFBZSxlQUFlLE9BQU8sT0FBTyxHQUFHLFFBQy9DLGVBQWUsZUFBZSxNQUFNLE9BQU8sR0FBRztHQUVsRCxVQUFVLFFBQVEsSUFBSUk7QUFDdEIsVUFBTyxVQUFVLGNBQWMsY0FBYyxTQUFTLFlBQVksTUFBTTtFQUN6RTtDQUNGO0FBQ0QsS0FBSSxDQUFDLFVBQ0gsUUFBTztDQUVULFVBQVUsUUFBUSxJQUFJQTtBQUN0QixRQUFPSSxzQkFBYSxRQUFRLE9BQU8sU0FBUyxZQUFZLFdBQVcsTUFBTTtBQUMxRTtBQUVELCtCQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRWYsU0FBUyxZQUFZQyxTQUFPLE9BQU8sU0FBUyxZQUFZLE9BQU87QUFDN0QsS0FBSUEsWUFBVSxNQUNaLFFBQU87QUFFVCxLQUFJQSxXQUFTLFFBQVEsU0FBUyxRQUFTLENBQUNDLHFCQUFhRCxRQUFNLElBQUksQ0FBQ0MscUJBQWEsTUFBTSxDQUNqRixRQUFPRCxZQUFVQSxXQUFTLFVBQVU7QUFFdEMsUUFBT0UseUJBQWdCRixTQUFPLE9BQU8sU0FBUyxZQUFZLGFBQWEsTUFBTTtBQUM5RTtBQUVELDJCQUFlOzs7OztBQ3ZCZixJQUFJRyx5QkFBdUIsR0FDdkJDLDJCQUF5Qjs7Ozs7Ozs7Ozs7QUFZN0IsU0FBUyxZQUFZLFFBQVEsUUFBUSxXQUFXLFlBQVk7Q0FDMUQsSUFBSSxRQUFRLFVBQVUsUUFDbEIsU0FBUyxPQUNULGVBQWUsQ0FBQztBQUVwQixLQUFJLFVBQVUsS0FDWixRQUFPLENBQUM7Q0FFVixTQUFTLE9BQU8sT0FBTztBQUN2QixRQUFPLFNBQVM7RUFDZCxJQUFJLE9BQU8sVUFBVTtBQUNyQixNQUFLLGdCQUFnQixLQUFLLEtBQ2xCLEtBQUssT0FBTyxPQUFPLEtBQUssTUFDeEIsRUFBRSxLQUFLLE1BQU0sUUFFbkIsUUFBTztDQUVWO0FBQ0QsUUFBTyxFQUFFLFFBQVEsUUFBUTtFQUN2QixPQUFPLFVBQVU7RUFDakIsSUFBSSxNQUFNLEtBQUssSUFDWCxXQUFXLE9BQU8sTUFDbEIsV0FBVyxLQUFLO0FBRXBCLE1BQUksZ0JBQWdCLEtBQUssSUFDdkI7T0FBSSxhQUFhLFVBQWEsRUFBRSxPQUFPLFFBQ3JDLFFBQU87RUFDUixPQUNJO0dBQ0wsSUFBSSxRQUFRLElBQUlDO0FBQ2hCLE9BQUksWUFDRixJQUFJLFNBQVMsV0FBVyxVQUFVLFVBQVUsS0FBSyxRQUFRLFFBQVEsTUFBTTtBQUV6RSxPQUFJLEVBQUUsV0FBVyxTQUNUQyxxQkFBWSxVQUFVLFVBQVVILHlCQUF1QkMsMEJBQXdCLFlBQVksTUFBTSxHQUNqRyxRQUVOLFFBQU87RUFFVjtDQUNGO0FBQ0QsUUFBTztBQUNSO0FBRUQsMkJBQWU7Ozs7Ozs7Ozs7OztBQ25EZixTQUFTLG1CQUFtQkcsU0FBTztBQUNqQyxRQUFPQSxZQUFVQSxXQUFTLENBQUNDLGlCQUFTRCxRQUFNO0FBQzNDO0FBRUQsa0NBQWU7Ozs7Ozs7Ozs7O0FDSmYsU0FBUyxhQUFhLFFBQVE7Q0FDNUIsSUFBSSxTQUFTRSxhQUFLLE9BQU8sRUFDckIsU0FBUyxPQUFPO0FBRXBCLFFBQU8sVUFBVTtFQUNmLElBQUksTUFBTSxPQUFPLFNBQ2JDLFVBQVEsT0FBTztFQUVuQixPQUFPLFVBQVU7R0FBQztHQUFLQTtHQUFPQyw0QkFBbUJELFFBQU07RUFBQztDQUN6RDtBQUNELFFBQU87QUFDUjtBQUVELDRCQUFlOzs7Ozs7Ozs7Ozs7O0FDZGYsU0FBUyx3QkFBd0IsS0FBSyxVQUFVO0FBQzlDLFFBQU8sU0FBUyxRQUFRO0FBQ3RCLE1BQUksVUFBVSxLQUNaLFFBQU87QUFFVCxTQUFPLE9BQU8sU0FBUyxhQUNwQixhQUFhLFVBQWMsT0FBTyxPQUFPLE9BQU87Q0FDcEQ7QUFDRjtBQUVELHVDQUFlOzs7Ozs7Ozs7OztBQ1JmLFNBQVMsWUFBWSxRQUFRO0NBQzNCLElBQUksWUFBWUUsc0JBQWEsT0FBTztBQUNwQyxLQUFJLFVBQVUsVUFBVSxLQUFLLFVBQVUsR0FBRyxHQUN4QyxRQUFPQyxpQ0FBd0IsVUFBVSxHQUFHLElBQUksVUFBVSxHQUFHLEdBQUc7QUFFbEUsUUFBTyxTQUFTLFFBQVE7QUFDdEIsU0FBTyxXQUFXLFVBQVVDLHFCQUFZLFFBQVEsUUFBUSxVQUFVO0NBQ25FO0FBQ0Y7QUFFRCwyQkFBZTs7Ozs7Ozs7Ozs7O0FDYmYsU0FBUyxVQUFVLFFBQVEsS0FBSztBQUM5QixRQUFPLFVBQVUsUUFBUSxPQUFPLE9BQU8sT0FBTztBQUMvQztBQUVELHlCQUFlOzs7Ozs7Ozs7Ozs7O0FDSWYsU0FBUyxRQUFRLFFBQVFDLFFBQU0sU0FBUztDQUN0Q0EsU0FBT0Msa0JBQVNELFFBQU0sT0FBTztDQUU3QixJQUFJLFFBQVEsSUFDUixTQUFTQSxPQUFLLFFBQ2QsU0FBUztBQUViLFFBQU8sRUFBRSxRQUFRLFFBQVE7RUFDdkIsSUFBSSxNQUFNRSxlQUFNRixPQUFLLE9BQU87QUFDNUIsTUFBSSxFQUFFLFNBQVMsVUFBVSxRQUFRLFFBQVEsUUFBUSxJQUFJLEVBQ25EO0VBRUYsU0FBUyxPQUFPO0NBQ2pCO0FBQ0QsS0FBSSxVQUFVLEVBQUUsU0FBUyxPQUN2QixRQUFPO0NBRVQsU0FBUyxVQUFVLE9BQU8sSUFBSSxPQUFPO0FBQ3JDLFFBQU8sQ0FBQyxDQUFDLFVBQVVHLGlCQUFTLE9BQU8sSUFBSUMsaUJBQVEsS0FBSyxPQUFPLEtBQ3hEQyxnQkFBUSxPQUFPLElBQUlDLG9CQUFZLE9BQU87QUFDMUM7QUFFRCx1QkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVGYsU0FBUyxNQUFNLFFBQVFDLFFBQU07QUFDM0IsUUFBTyxVQUFVLFFBQVFDLGlCQUFRLFFBQVFELFFBQU1FLG1CQUFVO0FBQzFEO0FBRUQsb0JBQWU7Ozs7O0FDeEJmLElBQUksdUJBQXVCLEdBQ3ZCLHlCQUF5Qjs7Ozs7Ozs7O0FBVTdCLFNBQVMsb0JBQW9CQyxRQUFNLFVBQVU7QUFDM0MsS0FBSUMsZUFBTUQsT0FBSyxJQUFJRSw0QkFBbUIsU0FBUyxDQUM3QyxRQUFPQyxpQ0FBd0JDLGVBQU1KLE9BQUssRUFBRSxTQUFTO0FBRXZELFFBQU8sU0FBUyxRQUFRO0VBQ3RCLElBQUksV0FBV0ssWUFBSSxRQUFRTCxPQUFLO0FBQ2hDLFNBQVEsYUFBYSxVQUFhLGFBQWEsV0FDM0NNLGNBQU0sUUFBUU4sT0FBSyxHQUNuQk8scUJBQVksVUFBVSxVQUFVLHVCQUF1Qix1QkFBdUI7Q0FDbkY7QUFDRjtBQUVELG1DQUFlOzs7Ozs7Ozs7OztBQ3pCZixTQUFTLGFBQWEsS0FBSztBQUN6QixRQUFPLFNBQVMsUUFBUTtBQUN0QixTQUFPLFVBQVUsT0FBTyxTQUFZLE9BQU87Q0FDNUM7QUFDRjtBQUVELDRCQUFlOzs7Ozs7Ozs7OztBQ0pmLFNBQVMsaUJBQWlCQyxRQUFNO0FBQzlCLFFBQU8sU0FBUyxRQUFRO0FBQ3RCLFNBQU9DLGlCQUFRLFFBQVFELE9BQUs7Q0FDN0I7QUFDRjtBQUVELGdDQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1lmLFNBQVMsU0FBU0UsUUFBTTtBQUN0QixRQUFPQyxlQUFNRCxPQUFLLEdBQUdFLHNCQUFhQyxlQUFNSCxPQUFLLENBQUMsR0FBR0ksMEJBQWlCSixPQUFLO0FBQ3hFO0FBRUQsdUJBQWU7Ozs7Ozs7Ozs7O0FDbEJmLFNBQVMsYUFBYUssU0FBTztBQUczQixLQUFJLE9BQU9BLFdBQVMsV0FDbEIsUUFBT0E7QUFFVCxLQUFJQSxXQUFTLEtBQ1gsUUFBT0M7QUFFVCxLQUFJLE9BQU9ELFdBQVMsU0FDbEIsUUFBT0UsZ0JBQVFGLFFBQU0sR0FDakJHLDZCQUFvQkgsUUFBTSxJQUFJQSxRQUFNLEdBQUcsR0FDdkNJLHFCQUFZSixRQUFNO0FBRXhCLFFBQU9LLGlCQUFTTCxRQUFNO0FBQ3ZCO0FBRUQsNEJBQWU7Ozs7Ozs7Ozs7O0FDdkJmLFNBQVMsY0FBYyxXQUFXO0FBQ2hDLFFBQU8sU0FBUyxRQUFRLFVBQVUsVUFBVTtFQUMxQyxJQUFJLFFBQVEsSUFDUixXQUFXLE9BQU8sT0FBTyxFQUN6QixRQUFRLFNBQVMsT0FBTyxFQUN4QixTQUFTLE1BQU07QUFFbkIsU0FBTyxVQUFVO0dBQ2YsSUFBSSxNQUFNLE1BQU0sWUFBWSxTQUFTLEVBQUU7QUFDdkMsT0FBSSxTQUFTLFNBQVMsTUFBTSxLQUFLLFNBQVMsS0FBSyxNQUM3QztFQUVIO0FBQ0QsU0FBTztDQUNSO0FBQ0Y7QUFFRCw2QkFBZTs7Ozs7Ozs7Ozs7Ozs7O0FDWGYsSUFBSSxVQUFVTSx3QkFBZTtBQUU3Qix1QkFBZTs7Ozs7Ozs7Ozs7O0FDSmYsU0FBUyxXQUFXLFFBQVEsVUFBVTtBQUNwQyxRQUFPLFVBQVVDLGlCQUFRLFFBQVEsVUFBVUMsYUFBSztBQUNqRDtBQUVELDBCQUFlOzs7Ozs7Ozs7Ozs7QUNMZixTQUFTLGVBQWUsVUFBVSxXQUFXO0FBQzNDLFFBQU8sU0FBUyxZQUFZLFVBQVU7QUFDcEMsTUFBSSxjQUFjLEtBQ2hCLFFBQU87QUFFVCxNQUFJLENBQUNDLG9CQUFZLFdBQVcsQ0FDMUIsUUFBTyxTQUFTLFlBQVksU0FBUztFQUV2QyxJQUFJLFNBQVMsV0FBVyxRQUNwQixRQUFRLFlBQVksU0FBUyxJQUM3QixXQUFXLE9BQU8sV0FBVztBQUVqQyxTQUFRLFlBQVksVUFBVSxFQUFFLFFBQVEsT0FDdEMsS0FBSSxTQUFTLFNBQVMsUUFBUSxPQUFPLFNBQVMsS0FBSyxNQUNqRDtBQUdKLFNBQU87Q0FDUjtBQUNGO0FBRUQsOEJBQWU7Ozs7Ozs7Ozs7OztBQ3BCZixJQUFJLFdBQVdDLHdCQUFlQyxvQkFBVztBQUV6Qyx3QkFBZTs7Ozs7Ozs7Ozs7OztBQ0RmLFNBQVMsaUJBQWlCLFFBQVEsS0FBS0MsU0FBTztBQUM1QyxLQUFLQSxZQUFVLFVBQWEsQ0FBQ0MsV0FBRyxPQUFPLE1BQU1ELFFBQU0sSUFDOUNBLFlBQVUsVUFBYSxFQUFFLE9BQU8sU0FDbkNFLHlCQUFnQixRQUFRLEtBQUtGLFFBQU07QUFFdEM7QUFFRCxnQ0FBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNTZixTQUFTLGtCQUFrQkcsU0FBTztBQUNoQyxRQUFPQyxxQkFBYUQsUUFBTSxJQUFJRSxvQkFBWUYsUUFBTTtBQUNqRDtBQUVELGdDQUFlOzs7Ozs7Ozs7Ozs7QUN4QmYsU0FBUyxRQUFRLFFBQVEsS0FBSztBQUM1QixLQUFJLFFBQVEsaUJBQWlCLE9BQU8sT0FBTyxTQUFTLFdBQ2xEO0FBR0YsS0FBSSxPQUFPLFlBQ1Q7QUFHRixRQUFPLE9BQU87QUFDZjtBQUVELHVCQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDT2YsU0FBUyxjQUFjRyxTQUFPO0FBQzVCLFFBQU9DLG9CQUFXRCxTQUFPRSxlQUFPRixRQUFNLENBQUM7QUFDeEM7QUFFRCw0QkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FmLFNBQVMsY0FBYyxRQUFRLFFBQVEsS0FBSyxVQUFVLFdBQVcsWUFBWSxPQUFPO0NBQ2xGLElBQUksV0FBV0csaUJBQVEsUUFBUSxJQUFJLEVBQy9CLFdBQVdBLGlCQUFRLFFBQVEsSUFBSSxFQUMvQixVQUFVLE1BQU0sSUFBSSxTQUFTO0FBRWpDLEtBQUksU0FBUztFQUNYQywwQkFBaUIsUUFBUSxLQUFLLFFBQVE7QUFDdEM7Q0FDRDtDQUNELElBQUksV0FBVyxhQUNYLFdBQVcsVUFBVSxVQUFXLE1BQU0sSUFBSyxRQUFRLFFBQVEsTUFBTSxHQUNqRTtDQUVKLElBQUksV0FBVyxhQUFhO0FBRTVCLEtBQUksVUFBVTtFQUNaLElBQUksUUFBUUMsZ0JBQVEsU0FBUyxFQUN6QixTQUFTLENBQUMsU0FBU0MsaUJBQVMsU0FBUyxFQUNyQyxVQUFVLENBQUMsU0FBUyxDQUFDLFVBQVVDLHFCQUFhLFNBQVM7RUFFekQsV0FBVztBQUNYLE1BQUksU0FBUyxVQUFVLFFBQ3JCLEtBQUlGLGdCQUFRLFNBQVMsRUFDbkIsV0FBVztXQUVKRywwQkFBa0IsU0FBUyxFQUNsQyxXQUFXQyxtQkFBVSxTQUFTO1dBRXZCLFFBQVE7R0FDZixXQUFXO0dBQ1gsV0FBV0MscUJBQVksVUFBVSxLQUFLO0VBQ3ZDLFdBQ1EsU0FBUztHQUNoQixXQUFXO0dBQ1gsV0FBV0MseUJBQWdCLFVBQVUsS0FBSztFQUMzQyxPQUVDLFdBQVcsQ0FBRTtXQUdSQyxzQkFBYyxTQUFTLElBQUlDLG9CQUFZLFNBQVMsRUFBRTtHQUN6RCxXQUFXO0FBQ1gsT0FBSUEsb0JBQVksU0FBUyxFQUN2QixXQUFXQyxzQkFBYyxTQUFTO1lBRTNCLENBQUNDLGlCQUFTLFNBQVMsSUFBSUMsbUJBQVcsU0FBUyxFQUNsRCxXQUFXQyx5QkFBZ0IsU0FBUztFQUV2QyxPQUVDLFdBQVc7Q0FFZDtBQUNELEtBQUksVUFBVTtFQUVaLE1BQU0sSUFBSSxVQUFVLFNBQVM7RUFDN0IsVUFBVSxVQUFVLFVBQVUsVUFBVSxZQUFZLE1BQU07RUFDMUQsTUFBTSxVQUFVLFNBQVM7Q0FDMUI7Q0FDRGIsMEJBQWlCLFFBQVEsS0FBSyxTQUFTO0FBQ3hDO0FBRUQsNkJBQWU7Ozs7Ozs7Ozs7Ozs7OztBQzFFZixTQUFTLFVBQVUsUUFBUSxRQUFRLFVBQVUsWUFBWSxPQUFPO0FBQzlELEtBQUksV0FBVyxPQUNiO0NBRUZjLGlCQUFRLFFBQVEsU0FBUyxVQUFVLEtBQUs7RUFDdEMsVUFBVSxRQUFRLElBQUlDO0FBQ3RCLE1BQUlDLGlCQUFTLFNBQVMsRUFDcEJDLHVCQUFjLFFBQVEsUUFBUSxLQUFLLFVBQVUsV0FBVyxZQUFZLE1BQU07T0FFdkU7R0FDSCxJQUFJLFdBQVcsYUFDWCxXQUFXQyxpQkFBUSxRQUFRLElBQUksRUFBRSxVQUFXLE1BQU0sSUFBSyxRQUFRLFFBQVEsTUFBTSxHQUM3RTtBQUVKLE9BQUksYUFBYSxRQUNmLFdBQVc7R0FFYkMsMEJBQWlCLFFBQVEsS0FBSyxTQUFTO0VBQ3hDO0NBQ0YsR0FBRUMsZUFBTztBQUNYO0FBRUQseUJBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCZixTQUFTLEtBQUssT0FBTztDQUNuQixJQUFJLFNBQVMsU0FBUyxPQUFPLElBQUksTUFBTTtBQUN2QyxRQUFPLFNBQVMsTUFBTSxTQUFTLEtBQUs7QUFDckM7QUFFRCxtQkFBZTs7Ozs7Ozs7Ozs7O0FDUmYsU0FBUyxRQUFRLFlBQVksVUFBVTtDQUNyQyxJQUFJLFFBQVEsSUFDUixTQUFTQyxvQkFBWSxXQUFXLEdBQUcsTUFBTSxXQUFXLE9BQU8sR0FBRyxDQUFFO0NBRXBFQyxrQkFBUyxZQUFZLFNBQVNDLFNBQU8sS0FBS0MsY0FBWTtFQUNwRCxPQUFPLEVBQUUsU0FBUyxTQUFTRCxTQUFPLEtBQUtDLGFBQVc7Q0FDbkQsRUFBQztBQUNGLFFBQU87QUFDUjtBQUVELHVCQUFlOzs7Ozs7Ozs7Ozs7QUNWZixTQUFTLE9BQU8sUUFBUUMsUUFBTTtBQUM1QixRQUFPQSxPQUFLLFNBQVMsSUFBSSxTQUFTQyxpQkFBUSxRQUFRQyxtQkFBVUYsUUFBTSxHQUFHLEdBQUcsQ0FBQztBQUMxRTtBQUVELHNCQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNLZixTQUFTLE1BQU1HLFNBQU87QUFDcEIsUUFBT0EsV0FBUztBQUNqQjtBQUVELG9CQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1VmLElBQUlDLFVBQVFDLHdCQUFlLFNBQVMsUUFBUSxRQUFRLFVBQVU7Q0FDNURDLG1CQUFVLFFBQVEsUUFBUSxTQUFTO0FBQ3BDLEVBQUM7QUFFRixvQkFBZUY7Ozs7O0FDckNmLElBQUksa0JBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQnRCLFNBQVMsT0FBTyxXQUFXO0FBQ3pCLEtBQUksT0FBTyxhQUFhLFdBQ3RCLE9BQU0sSUFBSSxVQUFVO0FBRXRCLFFBQU8sV0FBVztFQUNoQixJQUFJLE9BQU87QUFDWCxVQUFRLEtBQUssUUFBYjtHQUNFLEtBQUssRUFBRyxRQUFPLENBQUMsVUFBVSxLQUFLLEtBQUs7R0FDcEMsS0FBSyxFQUFHLFFBQU8sQ0FBQyxVQUFVLEtBQUssTUFBTSxLQUFLLEdBQUc7R0FDN0MsS0FBSyxFQUFHLFFBQU8sQ0FBQyxVQUFVLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxHQUFHO0dBQ3RELEtBQUssRUFBRyxRQUFPLENBQUMsVUFBVSxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLEdBQUc7RUFDaEU7QUFDRCxTQUFPLENBQUMsVUFBVSxNQUFNLE1BQU0sS0FBSztDQUNwQztBQUNGO0FBRUQscUJBQWU7Ozs7Ozs7Ozs7OztBQzFCZixTQUFTLFVBQVUsUUFBUUcsUUFBTTtDQUMvQkEsU0FBT0Msa0JBQVNELFFBQU0sT0FBTztDQUM3QixTQUFTRSxnQkFBTyxRQUFRRixPQUFLO0FBQzdCLFFBQU8sVUFBVSxRQUFRLE9BQU8sT0FBT0csZUFBTUMsYUFBS0osT0FBSyxDQUFDO0FBQ3pEO0FBRUQseUJBQWU7Ozs7Ozs7Ozs7Ozs7QUNSZixTQUFTLGdCQUFnQkssU0FBTztBQUM5QixRQUFPQyxzQkFBY0QsUUFBTSxHQUFHLFNBQVlBO0FBQzNDO0FBRUQsK0JBQWU7Ozs7O0FDTGYsSUFBSSxrQkFBa0IsR0FDbEIsa0JBQWtCLEdBQ2xCLHFCQUFxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0J6QixJQUFJRSxTQUFPQyxrQkFBUyxTQUFTLFFBQVEsT0FBTztDQUMxQyxJQUFJLFNBQVMsQ0FBRTtBQUNmLEtBQUksVUFBVSxLQUNaLFFBQU87Q0FFVCxJQUFJLFNBQVM7Q0FDYixRQUFRQyxrQkFBUyxPQUFPLFNBQVNDLFFBQU07RUFDckNBLFNBQU9DLGtCQUFTRCxRQUFNLE9BQU87RUFDN0IsV0FBVyxTQUFTQSxPQUFLLFNBQVM7QUFDbEMsU0FBT0E7Q0FDUixFQUFDO0NBQ0ZFLG9CQUFXLFFBQVFDLHNCQUFhLE9BQU8sRUFBRSxPQUFPO0FBQ2hELEtBQUksUUFDRixTQUFTQyxtQkFBVSxRQUFRLGtCQUFrQixrQkFBa0Isb0JBQW9CQyx5QkFBZ0I7Q0FFckcsSUFBSSxTQUFTLE1BQU07QUFDbkIsUUFBTyxVQUNMQyxtQkFBVSxRQUFRLE1BQU0sUUFBUTtBQUVsQyxRQUFPO0FBQ1IsRUFBQztBQUVGLG1CQUFlVDs7Ozs7Ozs7Ozs7Ozs7QUN4Q2YsU0FBUyxRQUFRLFFBQVFVLFFBQU1DLFNBQU8sWUFBWTtBQUNoRCxLQUFJLENBQUNDLGlCQUFTLE9BQU8sQ0FDbkIsUUFBTztDQUVURixTQUFPRyxrQkFBU0gsUUFBTSxPQUFPO0NBRTdCLElBQUksUUFBUSxJQUNSLFNBQVNBLE9BQUssUUFDZCxZQUFZLFNBQVMsR0FDckIsU0FBUztBQUViLFFBQU8sVUFBVSxRQUFRLEVBQUUsUUFBUSxRQUFRO0VBQ3pDLElBQUksTUFBTUksZUFBTUosT0FBSyxPQUFPLEVBQ3hCLFdBQVdDO0FBRWYsTUFBSSxRQUFRLGVBQWUsUUFBUSxpQkFBaUIsUUFBUSxZQUMxRCxRQUFPO0FBR1QsTUFBSSxTQUFTLFdBQVc7R0FDdEIsSUFBSSxXQUFXLE9BQU87R0FDdEIsV0FBVyxhQUFhLFdBQVcsVUFBVSxLQUFLLE9BQU8sR0FBRztBQUM1RCxPQUFJLGFBQWEsUUFDZixXQUFXQyxpQkFBUyxTQUFTLEdBQ3pCLFdBQ0NHLGlCQUFRTCxPQUFLLFFBQVEsR0FBRyxHQUFHLENBQUUsSUFBRyxDQUFFO0VBRTFDO0VBQ0RNLHFCQUFZLFFBQVEsS0FBSyxTQUFTO0VBQ2xDLFNBQVMsT0FBTztDQUNqQjtBQUNELFFBQU87QUFDUjtBQUVELHVCQUFlOzs7Ozs7Ozs7Ozs7O0FDckNmLFNBQVMsV0FBVyxRQUFRLE9BQU8sV0FBVztDQUM1QyxJQUFJLFFBQVEsSUFDUixTQUFTLE1BQU0sUUFDZixTQUFTLENBQUU7QUFFZixRQUFPLEVBQUUsUUFBUSxRQUFRO0VBQ3ZCLElBQUlDLFNBQU8sTUFBTSxRQUNiQyxVQUFRQyxpQkFBUSxRQUFRRixPQUFLO0FBRWpDLE1BQUksVUFBVUMsU0FBT0QsT0FBSyxFQUN4QkcsaUJBQVEsUUFBUUMsa0JBQVNKLFFBQU0sT0FBTyxFQUFFQyxRQUFNO0NBRWpEO0FBQ0QsUUFBTztBQUNSO0FBRUQsMEJBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOZixTQUFTLE9BQU8sUUFBUSxXQUFXO0FBQ2pDLEtBQUksVUFBVSxLQUNaLFFBQU8sQ0FBRTtDQUVYLElBQUksUUFBUUksa0JBQVNDLHNCQUFhLE9BQU8sRUFBRSxTQUFTLE1BQU07QUFDeEQsU0FBTyxDQUFDLElBQUs7Q0FDZCxFQUFDO0NBQ0YsWUFBWUMsc0JBQWEsVUFBVTtBQUNuQyxRQUFPQyxvQkFBVyxRQUFRLE9BQU8sU0FBU0MsU0FBT0MsUUFBTTtBQUNyRCxTQUFPLFVBQVVELFNBQU9DLE9BQUssR0FBRztDQUNqQyxFQUFDO0FBQ0g7QUFFRCxxQkFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWmYsU0FBUyxPQUFPLFFBQVEsV0FBVztBQUNqQyxRQUFPQyxlQUFPLFFBQVFDLGVBQU9DLHNCQUFhLFVBQVUsQ0FBQyxDQUFDO0FBQ3ZEO0FBRUQscUJBQWU7Ozs7Ozs7Ozs7Ozs7O0FDbEJmLFNBQVMsV0FBVyxPQUFPLFVBQVU7Q0FDbkMsSUFBSSxTQUFTLE1BQU07Q0FFbkIsTUFBTSxLQUFLLFNBQVM7QUFDcEIsUUFBTyxVQUNMLE1BQU0sVUFBVSxNQUFNLFFBQVE7QUFFaEMsUUFBTztBQUNSO0FBRUQsMEJBQWU7Ozs7Ozs7Ozs7OztBQ1ZmLFNBQVMsaUJBQWlCQyxTQUFPLE9BQU87QUFDdEMsS0FBSUEsWUFBVSxPQUFPO0VBQ25CLElBQUksZUFBZUEsWUFBVSxRQUN6QixZQUFZQSxZQUFVLE1BQ3RCLGlCQUFpQkEsWUFBVUEsU0FDM0IsY0FBY0MsaUJBQVNELFFBQU07RUFFakMsSUFBSSxlQUFlLFVBQVUsUUFDekIsWUFBWSxVQUFVLE1BQ3RCLGlCQUFpQixVQUFVLE9BQzNCLGNBQWNDLGlCQUFTLE1BQU07QUFFakMsTUFBSyxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsZUFBZUQsVUFBUSxTQUN0RCxlQUFlLGdCQUFnQixrQkFBa0IsQ0FBQyxhQUFhLENBQUMsZUFDaEUsYUFBYSxnQkFBZ0Isa0JBQzdCLENBQUMsZ0JBQWdCLGtCQUNsQixDQUFDLGVBQ0gsUUFBTztBQUVULE1BQUssQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLGVBQWVBLFVBQVEsU0FDdEQsZUFBZSxnQkFBZ0Isa0JBQWtCLENBQUMsYUFBYSxDQUFDLGVBQ2hFLGFBQWEsZ0JBQWdCLGtCQUM3QixDQUFDLGdCQUFnQixrQkFDbEIsQ0FBQyxlQUNILFFBQU87Q0FFVjtBQUNELFFBQU87QUFDUjtBQUVELGdDQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QmYsU0FBUyxnQkFBZ0IsUUFBUSxPQUFPLFFBQVE7Q0FDOUMsSUFBSSxRQUFRLElBQ1IsY0FBYyxPQUFPLFVBQ3JCLGNBQWMsTUFBTSxVQUNwQixTQUFTLFlBQVksUUFDckIsZUFBZSxPQUFPO0FBRTFCLFFBQU8sRUFBRSxRQUFRLFFBQVE7RUFDdkIsSUFBSSxTQUFTRSwwQkFBaUIsWUFBWSxRQUFRLFlBQVksT0FBTztBQUNyRSxNQUFJLFFBQVE7QUFDVixPQUFJLFNBQVMsYUFDWCxRQUFPO0dBRVQsSUFBSSxRQUFRLE9BQU87QUFDbkIsVUFBTyxVQUFVLFNBQVMsU0FBUyxLQUFLO0VBQ3pDO0NBQ0Y7QUFRRCxRQUFPLE9BQU8sUUFBUSxNQUFNO0FBQzdCO0FBRUQsK0JBQWU7Ozs7Ozs7Ozs7Ozs7QUN4QmYsU0FBUyxZQUFZLFlBQVksV0FBVyxRQUFRO0FBQ2xELEtBQUksVUFBVSxRQUNaLFlBQVlDLGtCQUFTLFdBQVcsU0FBUyxVQUFVO0FBQ2pELE1BQUlDLGdCQUFRLFNBQVMsQ0FDbkIsUUFBTyxTQUFTQyxTQUFPO0FBQ3JCLFVBQU9DLGlCQUFRRCxTQUFPLFNBQVMsV0FBVyxJQUFJLFNBQVMsS0FBSyxTQUFTO0VBQ3RFO0FBRUgsU0FBTztDQUNSLEVBQUM7TUFFRixZQUFZLENBQUNFLGdCQUFTO0NBR3hCLElBQUksUUFBUTtDQUNaLFlBQVlKLGtCQUFTLFdBQVdLLG1CQUFVQyxzQkFBYSxDQUFDO0NBRXhELElBQUksU0FBU0MsaUJBQVEsWUFBWSxTQUFTTCxTQUFPLEtBQUtNLGNBQVk7RUFDaEUsSUFBSSxXQUFXUixrQkFBUyxXQUFXLFNBQVMsVUFBVTtBQUNwRCxVQUFPLFNBQVNFLFFBQU07RUFDdkIsRUFBQztBQUNGLFNBQU87R0FBRSxZQUFZO0dBQVUsU0FBUyxFQUFFO0dBQU8sU0FBU0E7RUFBTztDQUNsRSxFQUFDO0FBRUYsUUFBT08sb0JBQVcsUUFBUSxTQUFTLFFBQVEsT0FBTztBQUNoRCxTQUFPQyx5QkFBZ0IsUUFBUSxPQUFPLE9BQU87Q0FDOUMsRUFBQztBQUNIO0FBRUQsMkJBQWU7Ozs7Ozs7Ozs7Ozs7QUNwQ2YsU0FBUyxTQUFTLFFBQVEsT0FBTztBQUMvQixRQUFPQyxvQkFBVyxRQUFRLE9BQU8sU0FBU0MsU0FBT0MsUUFBTTtBQUNyRCxTQUFPQyxjQUFNLFFBQVFELE9BQUs7Q0FDM0IsRUFBQztBQUNIO0FBRUQsd0JBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0VmLElBQUlFLFNBQU9DLGtCQUFTLFNBQVMsUUFBUSxPQUFPO0FBQzFDLFFBQU8sVUFBVSxPQUFPLENBQUUsSUFBR0Msa0JBQVMsUUFBUSxNQUFNO0FBQ3JELEVBQUM7QUFFRixtQkFBZUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1VmLElBQUksU0FBU0csa0JBQVMsU0FBUyxZQUFZLFdBQVc7QUFDcEQsS0FBSSxjQUFjLEtBQ2hCLFFBQU8sQ0FBRTtDQUVYLElBQUksU0FBUyxVQUFVO0FBQ3ZCLEtBQUksU0FBUyxLQUFLQyx3QkFBZSxZQUFZLFVBQVUsSUFBSSxVQUFVLEdBQUcsRUFDdEUsWUFBWSxDQUFFO1VBQ0wsU0FBUyxLQUFLQSx3QkFBZSxVQUFVLElBQUksVUFBVSxJQUFJLFVBQVUsR0FBRyxFQUMvRSxZQUFZLENBQUMsVUFBVSxFQUFHO0FBRTVCLFFBQU9DLHFCQUFZLFlBQVlDLHFCQUFZLFdBQVcsRUFBRSxFQUFFLENBQUUsRUFBQztBQUM5RCxFQUFDO0FBRUYscUJBQWU7Ozs7QUMrR2YsZUFBc0IsZUFDcEJDLFFBQ0FDLFlBQ3FCO0FBQ3JCLEtBQUksY0FBYyxDQUFFLE1BQU0sV0FBVyxXQUFXLENBQzlDLE9BQU0sSUFBSSxNQUFNLENBQUMsNEJBQTRCLEVBQUUsWUFBWTtBQUU3RCxLQUFJLENBQUUsTUFBTSxXQUFXQyxPQUFLLENBQzFCLE9BQU0sSUFBSSxNQUFNLENBQUMsMEJBQTBCLEVBQUVBLFFBQU07Q0FHckQsTUFBTSxVQUFVLE1BQU0sY0FBY0EsUUFBTSxPQUFPO0NBQ2pELElBQUk7QUFDSixLQUFJO0VBQ0YsVUFBVSxLQUFLLE1BQU0sUUFBUTtDQUM5QixTQUFRLEdBQUc7QUFDVixRQUFNLElBQUksTUFBTSxDQUFDLGdDQUFnQyxFQUFFQSxRQUFNLEVBQUUsRUFDekQsT0FBTyxFQUNSO0NBQ0Y7Q0FFRCxJQUFJQztBQUNKLEtBQUksWUFBWTtFQUNkLE1BQU0sZ0JBQWdCLE1BQU0sY0FBYyxZQUFZLE9BQU87QUFDN0QsTUFBSTtHQUNGLGtCQUFrQixLQUFLLE1BQU0sY0FBYztFQUM1QyxTQUFRLEdBQUc7QUFDVixTQUFNLElBQUksTUFBTSxDQUFDLGtDQUFrQyxFQUFFLFlBQVksRUFBRSxFQUNqRSxPQUFPLEVBQ1I7RUFDRjtDQUNGO0NBRUQsTUFBTSxpQkFBaUIsUUFBUSxRQUFRLENBQUU7QUFDekMsS0FBSSxRQUFRLFFBQVEsaUJBQWlCO0VBQ25DLE1BQU0sdUNBQXdCRCxPQUFLO0VBQ25DLE1BQU0sK0NBQWdDLFdBQVk7RUFDbEQsUUFBUSwyQkFFSixDQUFDLG1CQUFtQixFQUFFLFlBQVksc0JBQXNCLEVBQUUsb0JBQW9CLHVEQUF1RCxDQUFDLENBQ3ZJLENBQ0Y7RUFDRCxPQUFPLE9BQU8sZ0JBQWdCLGdCQUFnQjtDQUMvQztDQUNELE1BQU1FLGFBQXlCQyxjQUM3QjtFQUNFLFlBQVk7RUFDWixhQUFhLFFBQVE7RUFDckIsU0FBUyxDQUFFO0VBQ1gsYUFBYTtFQUNiLFdBQVc7Q0FDWixHQUNEQyxhQUFLLGdCQUFnQixVQUFVLENBQ2hDO0NBRUQsSUFBSUMsVUFBb0IsZUFBZSxXQUFXLENBQUU7QUFHcEQsS0FBSSxnQkFBZ0IsTUFBTTtFQUN4QixRQUFRLDJCQUVKLENBQUMsa0VBQWtFLENBQUMsQ0FDckUsQ0FDRjtFQUNELFdBQVcsYUFBYSxlQUFlO0NBQ3hDO0FBRUQsS0FBSSxDQUFDLFFBQVEsUUFBUTtFQUNuQixJQUFJLG1CQUFtQjtFQUN2QixNQUFNLGdDQUNKLENBQUMsa0VBQWtFLENBQUMsQ0FDckU7QUFDRCxNQUFJLGVBQWUsU0FBUyxVQUFVO0dBQ3BDLG1CQUFtQjtHQUNuQixRQUFRLEtBQUssUUFBUTtHQUNyQixVQUFVLFFBQVEsT0FBTyxnQkFBZ0I7RUFDMUM7QUFFRCxNQUFJLGVBQWUsU0FBUyxZQUFZLFFBQVE7R0FDOUMsVUFBVSxRQUFRLE9BQU8sZUFBZSxRQUFRLFdBQVc7QUFDM0QsT0FBSSxDQUFDLGtCQUNILFFBQVEsS0FBSyxRQUFRO0VBRXhCO0NBQ0Y7Q0FHRCxNQUFNLGdCQUFnQixJQUFJLElBQUk7QUFDOUIsS0FBSSxjQUFjLFNBQVMsUUFBUSxRQUFRO0VBQ3pDLE1BQU0sa0JBQWtCLFFBQVEsS0FDOUIsQ0FBQyxRQUFRLFVBQVUsUUFBUSxRQUFRLE9BQU8sS0FBSyxNQUNoRDtBQUNELFFBQU0sSUFBSSxNQUFNLENBQUMsbUNBQW1DLEVBQUUsaUJBQWlCO0NBQ3hFO0NBRUQsV0FBVyxVQUFVLFFBQVEsSUFBSSxZQUFZO0FBRTdDLFFBQU87QUFDUjs7OztBQzVQRCxTQUFnQixzQkFBc0JDLFFBQWNDLE9BQWE7QUFDL0QsS0FBSSxrQkFBa0JDLE1BQUksRUFBRTtFQUMxQkMsUUFBTSxzQ0FBc0NDLE9BQUs7QUFDakQ7Q0FDRDtBQUVELEtBQUk7RUFDRkQsUUFBTSwrQkFBK0JDLE9BQUs7bUNBQ2pDLENBQUMsY0FBYyxFQUFFQSxRQUFNLEVBQUUsRUFDaEMsT0FBTyxVQUNSLEVBQUM7Q0FDSCxTQUFRLEdBQUc7QUFDVixRQUFNLElBQUksTUFBTSxDQUFDLGdDQUFnQyxFQUFFQSxRQUFNLEVBQUUsRUFDekQsT0FBTyxFQUNSO0NBQ0Y7QUFDRjtBQUVELFNBQVMsa0JBQWtCSCxPQUFhO0NBQ3RDRSxRQUFNLDhCQUE4QkQsTUFBSTtBQUN4QyxLQUFJO21DQUNPLENBQUMsV0FBVyxFQUFFQSxPQUFLLEVBQUUsRUFDNUIsT0FBTyxTQUNSLEVBQUM7RUFDRkMsUUFBTSw2QkFBNkJELE1BQUk7QUFDdkMsU0FBTztDQUNSLFFBQU87RUFDTkMsUUFBTSxpQ0FBaUNELE1BQUk7QUFDM0MsU0FBTztDQUNSO0FBQ0Y7Ozs7QUM5QkQsTUFBTSxzQkFBc0I7QUFDNUIsTUFBYSwwQkFBMEIsQ0FBQzs7QUFFeEMsQ0FBQztBQUVELElBQUssc0RBQUw7Ozs7Ozs7Ozs7QUFTQyxFQVRJO0FBb0JMLFNBQVMsWUFDUEcsTUFDQUMsV0FDQUMsT0FDQSxVQUFVLE9BQ0Y7Q0FDUixJQUFJLElBQUksS0FBSyxVQUFVO0FBQ3ZCLFNBQVEsS0FBSyxNQUFiO0VBQ0UsS0FBSyxZQUFZO0dBQ2YsS0FBSyxDQUFDLGlCQUFpQixFQUFFLEtBQUssS0FBSyxJQUFJLEVBQUUsS0FBSyxJQUFJLEdBQUcsQ0FBQztBQUN0RDtFQUVGLEtBQUssWUFBWTtHQUNmLEtBQUssQ0FBQyxZQUFZLEVBQUUsS0FBSyxLQUFLLEtBQUssRUFBRSxLQUFLLEtBQUs7QUFDL0M7RUFFRixLQUFLLFlBQVk7R0FDZixNQUFNLFdBQVcsWUFBWSxlQUFlO0dBQzVDLEtBQUssR0FBRyxjQUFjLFFBQVEsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksRUFBRSxLQUFLLElBQUksR0FBRyxDQUFDO0FBQzNFO0VBRUYsS0FBSyxZQUFZO0FBQ2YsT0FBSSxXQUNGLEtBQUssR0FBRyxjQUFjLFFBQVEsQ0FBQyxZQUFZLEVBQUUsS0FBSyxLQUFLLElBQUksRUFBRSxLQUFLLElBQUksR0FBRyxDQUFDO1FBRTFFLEtBQUssQ0FBQyxZQUFZLEVBQUUsS0FBSyxLQUFLLEdBQUcsRUFBRSxLQUFLLElBQUksV0FBVyxRQUFRLEdBQUcsQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztBQUU1RjtFQUVGLEtBQUssWUFBWTtHQUNmLEtBQUssR0FBRyxjQUFjLFFBQVEsQ0FBQyxPQUFPLEVBQUUsS0FBSyxLQUFLLElBQUksRUFBRSxLQUFLLElBQUksR0FBRyxDQUFDO0FBQ3JFLE9BQUksS0FBSyxpQkFBaUIsS0FBSyxrQkFBa0IsS0FBSyxNQUNwRCxLQUFLLENBQUMsY0FBYyxFQUFFLEtBQUssY0FBYyxHQUFHLEVBQUUsS0FBSyxNQUFNO0FBRTNEO0VBRUYsS0FBSyxZQUFZO0dBQ2YsS0FBSyxHQUFHLGNBQWMsUUFBUSxDQUFDLENBQUMsRUFBRSxLQUFLLEtBQUs7QUFDNUM7RUFFRixTQUNFLEtBQUssS0FBSztDQUNiO0FBRUQsUUFBTyxtQkFBbUIsR0FBRyxNQUFNO0FBQ3BDO0FBRUQsU0FBUyxjQUFjQyxTQUEwQjtBQUMvQyxLQUFJLFFBQ0YsUUFBTztBQUdULFFBQU87QUFDUjtBQUVELGVBQXNCLGVBQ3BCQyxzQkFDQUgsV0FDQTtDQUNBLE1BQU1JLFlBQW9CLENBQUU7Q0FDNUIsTUFBTSxPQUFPLE1BQU0seUJBQXlCLHFCQUFxQjtDQUNqRSxNQUFNLGNBQWMsa0JBQWtCLEtBQUs7Q0FFM0MsTUFBTSxNQUNKQyxlQUFPLE1BQU0sS0FBSyxZQUFZLEVBQUUsQ0FBQyxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQ3hELElBQUksQ0FBQyxDQUFDLFdBQVdDLE9BQUssS0FBSztBQUMxQixNQUFJLGNBQWMsb0JBQ2hCLFFBQU9BLE9BQ0osSUFBSSxDQUFDLFFBQVE7QUFDWixXQUFRLElBQUksTUFBWjtJQUNFLEtBQUssWUFBWTtJQUNqQixLQUFLLFlBQVk7SUFDakIsS0FBSyxZQUFZO0lBQ2pCLEtBQUssWUFBWTtJQUNqQixLQUFLLFlBQVksUUFBUTtLQUN2QkMsVUFBUSxLQUFLLElBQUksS0FBSztBQUN0QixTQUFJLElBQUksaUJBQWlCLElBQUksa0JBQWtCLElBQUksTUFDakRBLFVBQVEsS0FBSyxJQUFJLGNBQWM7QUFFakM7SUFDRDtJQUNELFFBQ0U7R0FDSDtBQUNELFVBQU8sWUFBWSxLQUFLLFdBQVcsRUFBRTtFQUN0QyxFQUFDLENBQ0QsS0FBSyxPQUFPO09BQ1Y7R0FDTEEsVUFBUSxLQUFLLFVBQVU7R0FDdkIsSUFBSSxjQUFjO0dBQ2xCLGVBQWUsQ0FBQyx5QkFBeUIsRUFBRSxVQUFVLElBQUksQ0FBQztBQUMxRCxRQUFLLE1BQU0sT0FBT0QsUUFDaEIsZUFBZSxZQUFZLEtBQUssV0FBVyxHQUFHLEtBQUssR0FBRztHQUV4RCxlQUFlO0FBQ2YsVUFBTztFQUNSO0NBQ0YsRUFBQyxDQUNELEtBQUssT0FBTyxHQUFHO0FBRXBCLFFBQU87RUFDTDtFQUNBO0NBQ0Q7QUFDRjtBQUVELGVBQWUseUJBQXlCRSxNQUFjO0NBQ3BELE1BQU0sVUFBVSxNQUFNLGNBQWMsTUFBTSxPQUFPO0NBRWpELE1BQU0sT0FBTyxRQUNWLE1BQU0sS0FBSyxDQUNYLE9BQU8sUUFBUSxDQUNmLElBQUksQ0FBQyxTQUFTO0VBQ2IsT0FBTyxLQUFLLE1BQU07RUFDbEIsTUFBTSxTQUFTLEtBQUssTUFBTSxLQUFLO0FBRS9CLE1BQUksT0FBTyxRQUNULE9BQU8sU0FBUyxPQUFPLE9BQU8sUUFBUSxRQUFRLEtBQUs7QUFJckQsTUFBSSxPQUFPLEtBQ1QsT0FBTyxNQUFNLE9BQU8sSUFBSSxRQUFRLFFBQVEsS0FBSztBQUUvQyxTQUFPO0NBQ1IsRUFBQztBQUlKLFFBQU8sS0FBSyxLQUFLLENBQUMsR0FBRyxNQUFNO0FBQ3pCLE1BQUksRUFBRSxTQUFTLFlBQVksUUFBUTtBQUNqQyxPQUFJLEVBQUUsU0FBUyxZQUFZLE9BQ3pCLFFBQU8sRUFBRSxLQUFLLGNBQWMsRUFBRSxLQUFLO0FBRXJDLFVBQU87RUFDUixXQUFVLEVBQUUsU0FBUyxZQUFZLE9BQ2hDLFFBQU87TUFFUCxRQUFPLEVBQUUsS0FBSyxjQUFjLEVBQUUsS0FBSztDQUV0QyxFQUFDO0FBQ0g7QUFFRCxTQUFTLGtCQUFrQkMsTUFBaUQ7Q0FDMUUsTUFBTSxtQ0FBbUIsSUFBSTtDQUM3QixNQUFNLDRCQUFZLElBQUk7QUFFdEIsTUFBSyxNQUFNLE9BQU8sTUFBTTtFQUN0QixNQUFNLFlBQVksSUFBSSxVQUFVO0FBQ2hDLE1BQUksQ0FBQyxpQkFBaUIsSUFBSSxVQUFVLEVBQ2xDLGlCQUFpQixJQUFJLFdBQVcsQ0FBRSxFQUFDO0VBR3JDLE1BQU0sUUFBUSxpQkFBaUIsSUFBSSxVQUFVO0FBRTdDLE1BQUksSUFBSSxTQUFTLFlBQVksUUFBUTtHQUNuQyxNQUFNLEtBQUssSUFBSTtHQUNmLFVBQVUsSUFBSSxJQUFJLE1BQU0sSUFBSTtFQUM3QixXQUFVLElBQUksU0FBUyxZQUFZLE1BQU07R0FFeEMsTUFBTSxXQUFXLFVBQVUsSUFBSSxJQUFJLEtBQUs7QUFDeEMsT0FBSSxVQUFVO0FBQ1osUUFBSSxTQUFTLEtBQ1gsU0FBUyxPQUFPO0lBR2xCLFNBQVMsT0FBTyxJQUFJO0FBRXBCLFFBQUksU0FBUyxLQUNYLFNBQVMsTUFBTSxTQUFTLElBQUksUUFBUSxRQUFRLEtBQUs7R0FFcEQ7RUFDRixPQUNDLE1BQU0sS0FBSyxJQUFJO0NBRWxCO0FBRUQsUUFBTztBQUNSO0FBRUQsU0FBZ0IsbUJBQW1CQyxLQUFhVCxPQUF1QjtDQUNyRSxJQUFJLGVBQWU7Q0FDbkIsTUFBTSxTQUFTLElBQ1osTUFBTSxLQUFLLENBQ1gsSUFBSSxDQUFDLFNBQVM7RUFDYixPQUFPLEtBQUssTUFBTTtBQUNsQixNQUFJLFNBQVMsR0FDWCxRQUFPO0VBR1QsTUFBTSx1QkFBdUIsS0FBSyxXQUFXLElBQUk7RUFDakQsTUFBTSxtQkFBbUIsS0FBSyxTQUFTLElBQUk7RUFDM0MsTUFBTSxtQkFBbUIsS0FBSyxTQUFTLElBQUk7RUFDM0MsTUFBTSxvQkFBb0IsS0FBSyxTQUFTLElBQUk7RUFDNUMsTUFBTSxnQkFBZ0IsS0FBSyxXQUFXLElBQUk7RUFFMUMsSUFBSSxjQUFjO0FBQ2xCLE9BQUssb0JBQW9CLHNCQUFzQixDQUFDLHNCQUFzQjtHQUNwRSxnQkFBZ0I7R0FDaEIsZ0JBQWdCLGVBQWUsS0FBSztFQUNyQyxPQUFNO0FBQ0wsT0FDRSxvQkFDQSxlQUFlLEtBQ2YsQ0FBQyx3QkFDRCxDQUFDLGVBRUQsZ0JBQWdCO0dBRWxCLGVBQWUsZUFBZTtFQUMvQjtBQUVELE1BQUksc0JBQ0YsZUFBZTtFQUdqQixNQUFNLElBQUksR0FBRyxJQUFJLE9BQU8sWUFBWSxHQUFHLE1BQU07QUFFN0MsU0FBTztDQUNSLEVBQUMsQ0FDRCxLQUFLLEtBQUs7QUFFYixRQUFPO0FBQ1I7Ozs7QUNsUEQsZUFBc0IsV0FBV1UsU0FBNkI7Q0FDNUQsTUFBTSxjQUFjLENBQUMsR0FBRyxpQ0FBNEIsUUFBUSxLQUFLLEdBQUcsTUFBTTtDQUMxRSxNQUFNLFNBQVMsTUFBTSxlQUNuQixZQUNFLFFBQVEsY0FBYyxRQUFRLG1CQUFtQixlQUNsRCxFQUNELFFBQVEsYUFBYSxZQUFZLFFBQVEsV0FBVyxHQUFHLE9BQ3hEO0FBQ0QsUUFBTztBQUNSOzs7O0FDRkQsTUFBTUMsVUFBUSxhQUFhLFlBQVk7QUFFdkMsZUFBc0IsaUJBQWlCQyxhQUErQjtDQUNwRSxNQUFNLFVBQVUsNkJBQTZCLFlBQVk7Q0FFekQsTUFBTSxzQ0FBdUIsUUFBUSxLQUFLLFFBQVEsZ0JBQWdCO0NBQ2xFLE1BQU0sRUFBRSxTQUFTLFlBQVksYUFBYSxHQUN4QyxNQUFNLGVBQWUsZ0JBQWdCO0NBRXZDLE1BQU0sV0FBVyxRQUFRLElBQUksQ0FBQyxpQ0FDdkIsUUFBUSxLQUFLLFFBQVEsUUFBUSxTQUFTLGdCQUFnQixDQUM1RDtDQUVELE1BQU0sc0JBQXNCLElBQUksSUFDOUIsUUFDRyxPQUFPLENBQUMsYUFBYSxTQUFTLFNBQVMsWUFBWSxDQUNuRCxRQUFRLENBQUMsTUFDUixtQkFBbUIsRUFBRSxXQUFXLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FDakUsQ0FDQSxPQUFPLFFBQVE7Q0FHcEIsTUFBTSx3Q0FBeUIsUUFBUSxLQUFLLFFBQVEsVUFBVSxDQUFDLENBQUMsS0FDOUQsQ0FBQyxXQUNDLFFBQVEsSUFDTixPQUFPLElBQUksT0FBTyxhQUFhO0VBQzdCRCxRQUFNLEtBQUssQ0FBQyxNQUFNLEVBQUVFLFVBQU8sYUFBYSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDckQsTUFBTSxnQkFBZ0IsTUFBTSxjQUFjLFNBQVM7RUFDbkQsTUFBTSxrQ0FBbUIsU0FBUztFQUNsQyxNQUFNLFFBQVEsV0FBVyxLQUFLLE1BQU0sSUFBSTtFQUN4QyxNQUFNLGtCQUFrQixNQUFNLEtBQUs7RUFDbkMsTUFBTSxjQUFjLE1BQU0sS0FBSyxJQUFJO0FBRW5DLE1BQUksZ0JBQWdCLFlBQVk7R0FDOUJGLFFBQU0sS0FDSixDQUFDLENBQUMsRUFBRSxZQUFZLHVCQUF1QixFQUFFLFdBQVcsT0FBTyxDQUFDLENBQzdEO0FBQ0Q7RUFDRDtFQUNELE1BQU0sTUFBTSxTQUFTLEtBQUssQ0FBQ0csVUFBUUEsTUFBSSxTQUFTLGdCQUFnQixDQUFDO0FBQ2pFLE1BQUksQ0FBQyxPQUFPLG9CQUFvQixJQUFJLGdCQUFnQixFQUFFO0dBQ3BESCxRQUFNLEtBQ0osQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLCtEQUErRCxDQUFDLENBQ3JGO0FBQ0Q7RUFDRDtBQUNELE1BQUksQ0FBQyxJQUNILE9BQU0sSUFBSSxNQUFNLENBQUMsc0JBQXNCLEVBQUUsVUFBVTtFQUdyRCxNQUFNLG1DQUFvQixLQUFLLFdBQVcsS0FBSztFQUMvQ0EsUUFBTSxLQUNKLENBQUMsdUJBQXVCLEVBQUVFLFVBQU8sYUFBYSxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQy9EO0VBQ0QsTUFBTSxlQUFlLGNBQWMsY0FBYztFQUNqRCxNQUFNLDZEQUNFLGdCQUFnQixDQUFDLEtBQ3ZCLFdBQVcsS0FDWjtFQUNERixRQUFNLEtBQ0osQ0FBQyx1QkFBdUIsRUFBRUUsVUFBTyxhQUFhLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUNwRTtFQUNELE1BQU0sZUFBZSxtQkFBbUIsY0FBYztDQUN2RCxFQUFDLENBQ0gsQ0FDSjtDQUVELE1BQU0sYUFBYSxRQUFRLEtBQUssQ0FBQyxNQUFNLEVBQUUsYUFBYSxPQUFPO0FBQzdELEtBQUksWUFBWTtFQUNkLE1BQU0sOEJBQ0osUUFBUSxLQUNSLFFBQVEsUUFDUixXQUFXLGdCQUNaO0VBQ0QsTUFBTSw4QkFDSixRQUFRLGtCQUFrQixRQUFRLEtBQ2xDLEdBQUcsV0FBVyxTQUFTLENBQUMsQ0FDekI7RUFDRCxNQUFNLGlDQUNKLFFBQVEsa0JBQWtCLFFBQVEsS0FDbEMsQ0FBQyxlQUFlLENBQUMsQ0FDbEI7RUFDRCxNQUFNLG1DQUNKLFFBQVEsa0JBQWtCLFFBQVEsS0FDbEMsR0FBRyxXQUFXLGdCQUFnQixDQUFDLENBQ2hDO0VBQ0QsTUFBTSx3Q0FDSixRQUFRLGtCQUFrQixRQUFRLEtBQ2xDLENBQUMsdUJBQXVCLENBQUMsQ0FDMUI7RUFDREYsUUFBTSxLQUNKLENBQUMsd0JBQXdCLEVBQUVFLFVBQU8sYUFDaEMsUUFDRCxDQUFDLE1BQU0sRUFBRUEsVUFBTyxhQUFhLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FDMUM7RUFDRCxNQUFNLG1DQUNDLFNBQVMsR0FBRyxXQUFXLFNBQVMsQ0FBQyxDQUFDLEVBQ3ZDLE1BQU0sY0FBYyxRQUFRLENBQzdCO0VBQ0RGLFFBQU0sS0FDSixDQUFDLHVCQUF1QixFQUFFRSxVQUFPLGFBQy9CLFdBQ0QsQ0FBQyxNQUFNLEVBQUVBLFVBQU8sYUFBYSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQzFDO0VBQ0QsTUFBTSxtQ0FDQyxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUMsRUFDaEMsTUFBTSxjQUFjLFdBQVcsQ0FDaEM7RUFDREYsUUFBTSxLQUNKLENBQUMsOEJBQThCLEVBQUVFLFVBQU8sYUFDdEMsYUFDRCxDQUFDLE1BQU0sRUFBRUEsVUFBTyxhQUFhLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FDMUM7RUFDRCxNQUFNLG1DQUNDLFNBQVMsR0FBRyxXQUFXLGdCQUFnQixDQUFDLENBQUMsR0FFN0MsTUFBTSxjQUFjLGNBQWMsT0FBTyxFQUFFLFFBQzFDLENBQUMscURBQXFELENBQUMsRUFDdkQsQ0FBQyxTQUFTLEVBQUUsWUFBWSx1REFBdUQsQ0FBQyxDQUNqRixDQUNGO0VBQ0RGLFFBQU0sS0FDSixDQUFDLCtCQUErQixFQUFFRSxVQUFPLGFBQ3ZDLGtCQUNELENBQUMsTUFBTSxFQUFFQSxVQUFPLGFBQWEsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUMxQztFQUNELE1BQU0sbUNBQ0MsU0FBUyxDQUFDLHVCQUF1QixDQUFDLENBQUMsRUFDeEMsTUFBTSxjQUFjLGtCQUFrQixDQUN2QztDQUNGO0FBQ0Y7QUFFRCxlQUFlLG9CQUFvQkUsUUFBYztDQUMvQyxNQUFNQyxVQUFRLE1BQU0sYUFBYUMsUUFBTSxFQUFFLGVBQWUsS0FBTSxFQUFDO0NBQy9ELE1BQU0sZUFBZUQsUUFDbEIsT0FDQyxDQUFDLFNBQ0MsS0FBSyxRQUFRLEtBQ1osS0FBSyxLQUFLLFNBQVMsUUFBUSxJQUFJLEtBQUssS0FBSyxTQUFTLFFBQVEsRUFDOUQsQ0FDQSxJQUFJLENBQUMsNkJBQWNDLFFBQU0sS0FBSyxLQUFLLENBQUM7Q0FFdkMsTUFBTSxPQUFPRCxRQUFNLE9BQU8sQ0FBQyxTQUFTLEtBQUssYUFBYSxDQUFDO0FBQ3ZELE1BQUssTUFBTSxPQUFPLEtBQ2hCLEtBQUksSUFBSSxTQUFTLGdCQUNmLGFBQWEsS0FBSyxHQUFJLE1BQU0sd0NBQXlCQyxRQUFNLElBQUksS0FBSyxDQUFDLENBQUU7QUFHM0UsUUFBTztBQUNSOzs7O0FDdktELFNBQWdCLGlCQUNkQyxXQUNBQyxTQUNBQyxRQUNRO0FBQ1IsUUFBTyxHQUFHLGNBQWM7Ozs7QUFJMUIsRUFBRSxvQkFBb0IsV0FBVyxRQUFRLENBQUM7O0FBRTFDLEVBQUUsT0FDQyxJQUFJLENBQUMsVUFBVSxDQUFDLGVBQWUsRUFBRSxNQUFNLGlCQUFpQixFQUFFLE9BQU8sQ0FBQyxDQUNsRSxLQUFLLEtBQUssQ0FBQztBQUNkLENBQUM7QUFDQTtBQUVELFNBQWdCLGlCQUNkRixXQUNBQyxTQUNBQyxRQUNRO0FBQ1IsUUFBTyxHQUFHLGNBQWM7Ozs7O0FBSzFCLEVBQUUsb0JBQW9CLFdBQVcsUUFBUSxDQUFDO1FBQ2xDLEVBQUUsT0FBTyxLQUFLLEtBQUssQ0FBQztBQUM1QixFQUFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDO0FBQzFELENBQUM7QUFDQTtBQUVELE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFJdkIsQ0FBQztBQUVELFNBQVMsb0JBQW9CRixXQUFtQkMsU0FBeUI7Q0FDdkUsU0FBUyxhQUFhRSxPQUFlLFlBQVksR0FBRztFQUNsRCxNQUFNLFdBQVcsSUFBSSxPQUFPLFlBQVksRUFBRTtFQUMxQyxNQUFNLFFBQVEsSUFBSSxPQUFPLFVBQVU7QUFDbkMsU0FBTyxDQUFDO0FBQ1osRUFBRSxNQUFNLGtCQUFrQixFQUFFLFVBQVUsQ0FBQyxFQUFFLE1BQU07QUFDL0MsRUFBRSxTQUFTO0FBQ1gsRUFBRSxNQUFNO0FBQ1IsRUFBRSxTQUFTO0FBQ1gsRUFBRSxTQUFTO0FBQ1gsRUFBRSxNQUFNLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxFQUFFLE1BQU07QUFDM0MsRUFBRSxTQUFTO0FBQ1gsRUFBRSxNQUFNO0FBQ1IsRUFBRSxTQUFTLENBQUMsQ0FBQztDQUNWO0FBRUQsUUFBTyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFrRUosRUFBRSxhQUFhLGdCQUFnQixDQUFDOztNQUVoQyxFQUFFLGFBQWEsbUJBQW1CLENBQUM7Ozs7OztNQU1uQyxFQUFFLGFBQWEsaUJBQWlCLENBQUM7O01BRWpDLEVBQUUsYUFBYSxrQkFBa0IsQ0FBQzs7TUFFbEMsRUFBRSxhQUFhLG1CQUFtQixDQUFDOzs7OztJQUtyQyxFQUFFLGFBQWEsb0JBQW9CLEVBQUUsQ0FBQzs7TUFFcEMsRUFBRSxhQUFhLGFBQWEsQ0FBQzs7TUFFN0IsRUFBRSxhQUFhLGVBQWUsQ0FBQzs7Ozs7O01BTS9CLEVBQUUsYUFBYSxjQUFjLENBQUM7O01BRTlCLEVBQUUsYUFBYSxnQkFBZ0IsQ0FBQzs7Ozs7OztRQU85QixFQUFFLGFBQWEsa0JBQWtCLEdBQUcsQ0FBQzs7UUFFckMsRUFBRSxhQUFhLGlCQUFpQixHQUFHLENBQUM7Ozs7UUFJcEMsRUFBRSxhQUFhLG9CQUFvQixHQUFHLENBQUM7O1FBRXZDLEVBQUUsYUFBYSxtQkFBbUIsR0FBRyxDQUFDOzs7O1FBSXRDLEVBQUUsYUFBYSx3QkFBd0IsR0FBRyxDQUFDOztRQUUzQyxFQUFFLGFBQWEsdUJBQXVCLEdBQUcsQ0FBQzs7OztRQUkxQyxFQUFFLGFBQWEsc0JBQXNCLEdBQUcsQ0FBQzs7UUFFekMsRUFBRSxhQUFhLHFCQUFxQixHQUFHLENBQUM7OztNQUcxQyxFQUFFLGFBQWEsa0JBQWtCLENBQUM7O01BRWxDLEVBQUUsYUFBYSxrQkFBa0IsQ0FBQzs7Ozs7O01BTWxDLEVBQUUsYUFBYSxtQkFBbUIsQ0FBQzs7TUFFbkMsRUFBRSxhQUFhLGlCQUFpQixDQUFDOztNQUVqQyxFQUFFLGFBQWEsaUJBQWlCLENBQUM7Ozs7Ozs7Ozs7Ozs7K0JBYVIsRUFBRSxVQUFVOzs7Ozs7OzsrQkFRWixFQUFFLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0J6QyxDQUFDO0FBQ0E7Ozs7QUMxT0QsTUFBYSwyQkFBMkIsQ0FDdENDLGNBQ0EsZ0JBQWdCLEtBQ2hCLGdCQUFnQixPQUNoQkMsT0FBSyxPQUNMLFlBQVksT0FDWixTQUFTLFVBQ047Q0FDSCxNQUFNLFdBQVdBLE9BQ2IsU0FDRSxDQUFDLHdEQUF3RCxDQUFDLEdBQzFELENBQUMsZ0RBQWdELENBQUMsR0FDcEQ7Q0FDSixNQUFNLGVBQWUsVUFBVSxDQUFDQSxPQUFLLENBQUMsK0JBQStCLENBQUMsR0FBRztDQUN6RSxNQUFNLGVBQWVBLE9BQ2pCLENBQUM7Ozs7Ozs7OztFQVNMLENBQUMsR0FDRyxDQUFDOzs7RUFHTCxDQUFDO0NBRUQsTUFBTSxrQkFBa0JBLE9BQ3BCLENBQUMsK0VBQStFLENBQUMsR0FDakY7Q0FFSixNQUFNLHFCQUFxQixTQUN2Qiw0Q0FDQTtDQUNKLE1BQU0sMEJBQTBCLFlBQzVCLENBQUMsc0RBQXNELENBQUMsR0FDeEQsQ0FBQyw4REFBOEQsQ0FBQztDQUNwRSxNQUFNLHdCQUF3QixZQUMxQixDQUFDLG1DQUFtQyxDQUFDLEdBQ3JDLENBQUMsaUNBQWlDLENBQUM7QUFFdkMsUUFBTyxDQUFDOzs7RUFHUixFQUFFLHdCQUF3Qjs7O0FBRzVCLEVBQUUsU0FBUztBQUNYLEVBQUUsYUFBYTtBQUNmLEVBQUUsYUFBYTs7NkJBRWMsRUFBRSxhQUFhOztBQUU1QyxFQUFFLG1CQUFtQjs7O1dBR1YsRUFBRSxjQUFjO1dBQ2hCLEVBQUUsY0FBYzs7Ozs7Ozs7OztJQVV2QixFQUFFLHNCQUFzQjs7Ozs7Ozs7QUFRNUIsRUFBRSxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JsQixDQUFDO0FBQ0E7QUFFRCxNQUFhLG9CQUFvQixDQUMvQkMsY0FDQUMsYUFDQSxnQkFBZ0IsS0FDaEIsZ0JBQWdCLFVBQ2IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0E2QkssRUFBRSxjQUFjO1dBQ2hCLEVBQUUsY0FBYzs7OztpREFJc0IsRUFBRSxhQUFhO3dEQUNSLEVBQUUsYUFBYTs7Ozs7O3lDQU05QixFQUFFLFlBQVk7O2lDQUV0QixFQUFFLGFBQWEsZ0JBQWdCLEVBQUUsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0U5RSxDQUFDOzs7O0FDdk5ELE1BQWEsdUJBQXVCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStEckMsQ0FBQztBQUVELE1BQWEsaUNBQWlDLENBQUNDLFNBQWdCO0NBQzdELE1BQU0sV0FBV0MsT0FDYixDQUFDOzs7eUNBR2tDLENBQUMsR0FDcEMsQ0FBQyx1RkFBdUYsQ0FBQztDQUM3RixNQUFNLGVBQWVBLE9BQ2pCLENBQUM7Ozs7Ozs7Ozs7Ozs7TUFhRCxDQUFDLEdBQ0QsQ0FBQzs7Ozs7Ozs7O01BU0QsQ0FBQztBQUNMLFFBQU8sR0FBRyxTQUFTOzs7O0lBSWpCLEVBQUUsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CbkIsQ0FBQztBQUNBOzs7O0FDM0VELE1BQU1DLFVBQVEsYUFBYSxRQUFRO0FBQ25DLE1BQU1DLHlGQUF3QztBQVE5QyxlQUFzQixhQUFhQyxZQUEwQjtDQUMzREYsUUFBTSwwQ0FBMEMsV0FBVztDQUUzRCxNQUFNRyxVQUE4QjtFQUNsQyxVQUFVO0VBQ1YsR0FBRztFQUNILEtBQUssV0FBVyxPQUFPLFFBQVEsS0FBSztDQUNyQztDQUVELE1BQU0sY0FBYyxDQUFDLEdBQUcsaUNBQTRCLFFBQVEsS0FBSyxHQUFHLE1BQU07Q0FFMUUsTUFBTSxlQUFlLFlBQVksUUFBUSxnQkFBZ0IsYUFBYTtDQUN0RSxNQUFNLFdBQVcsTUFBTSxjQUFjLGFBQWE7Q0FFbEQsTUFBTSxRQUFRLFNBQVMsU0FBUyxLQUFLLENBQUMsTUFBTTtBQUUxQyxNQUFJLFFBQVEsUUFDVixRQUFPLEVBQUUsU0FBUyxRQUFRO01BRTFCLFFBQU8sRUFBRSxrQkFBa0I7Q0FFOUIsRUFBQztBQUVGLEtBQUksQ0FBQyxNQUNILE9BQU0sSUFBSSxNQUNSO0NBR0osTUFBTSxTQUFTLE1BQU0sZUFDbkIsWUFDRSxRQUFRLGNBQWMsUUFBUSxtQkFBbUIsZUFDbEQsRUFDRCxRQUFRLGFBQWEsWUFBWSxRQUFRLFdBQVcsR0FBRyxPQUN4RDtDQUVELE1BQU0sVUFBVSxJQUFJLFFBQVEsVUFBVSxPQUFPLFFBQVE7QUFFckQsUUFBTyxRQUFRLE9BQU87QUFDdkI7QUFFRCxJQUFNLFVBQU4sTUFBYztDQUNaLEFBQWlCLE9BQWlCLENBQUU7Q0FDcEMsQUFBaUIsT0FBK0IsQ0FBRTtDQUNsRCxBQUFpQixVQUFvQixDQUFFO0NBRXZDLEFBQWlCO0NBQ2pCLEFBQWlCO0NBQ2pCLEFBQWlCO0NBQ2pCLEFBQWlCO0NBQ2pCLEFBQWlCLGdCQUF5QjtDQUUxQyxZQUNtQkMsVUFDQUMsT0FDQUMsUUFDQUgsU0FDakI7RUFKaUI7RUFDQTtFQUNBO0VBQ0E7RUFFakIsS0FBSyxTQUFTLFFBQVEsU0FDbEIsWUFBWSxRQUFRLE9BQU8sR0FDM0IsUUFBUSxJQUFJLHFCQUNWLFlBQVksUUFBUSxJQUFJLG1CQUFtQixHQUMzQyx3QkFBd0I7RUFDOUIsS0FBSyxnQ0FBaUIsTUFBTSxjQUFjLENBQUM7RUFDM0MsS0FBSyxtQ0FDSCxLQUFLLFFBQVEsS0FDYixRQUFRLGFBQWEsS0FBSyxTQUMzQjtFQUNELEtBQUssWUFDSCxRQUFRLGFBQ1IsUUFBUSxJQUFJLDBCQUNaLFNBQVM7RUFDWCxLQUFLLGdCQUFnQixLQUFLLE1BQU0sYUFBYSxLQUMzQyxDQUFDLFFBQ0MsSUFBSSxTQUFTLGtCQUNaLElBQUkseUJBQXlCLElBQUksU0FBUyxTQUFTLFdBQVcsRUFDbEU7QUFFRCxNQUFJLENBQUMsS0FBSyxlQUFlO0dBQ3ZCLE1BQU0scUJBQ0o7R0FDRkgsUUFBTSxLQUNKLEdBQUcsbUJBQW1CLDRFQUE0RSxDQUFDLENBQ3BHO0FBRUQsT0FDRSxLQUFLLFFBQVEsT0FDYixLQUFLLFFBQVEsYUFDYixLQUFLLE9BQU8sYUFDWixLQUFLLE9BQU8sZUFFWkEsUUFBTSxLQUNKLEdBQUcsbUJBQW1CLDBEQUEwRCxDQUFDLENBQ2xGO0VBRUo7Q0FDRjtDQUVELElBQUksYUFBYTtBQUNmLFNBQU8sS0FBSyxNQUFNLFFBQVEsS0FBSyxDQUFDLE1BQU0sRUFBRSxZQUFZLFNBQVMsU0FBUyxDQUFDLEVBQ25FO0NBQ0w7Q0FFRCxJQUFJLFVBQVU7QUFDWixTQUNFLEtBQUssUUFBUSxRQUVaLEtBQUssYUFDRixPQUNBLEtBQUssTUFBTSxRQUFRLEtBQUssQ0FBQyxNQUFNLEVBQUUsWUFBWSxTQUFTLE1BQU0sQ0FBQyxFQUFFO0NBRXRFO0NBRUQsUUFBUTtBQUNOLE1BQUksQ0FBQyxLQUFLLFlBQVk7R0FDcEIsTUFBTSxVQUNKO0FBRUYsT0FBSSxLQUFLLFNBQ1BBLFFBQU0sS0FBSyxRQUFRO09BRW5CLE9BQU0sSUFBSSxNQUFNO0VBRW5CO0FBRUQsU0FBTyxLQUFLLFlBQVksQ0FDckIsWUFBWSxDQUNaLGFBQWEsQ0FDYixXQUFXLENBQ1gsb0JBQW9CLENBQ3BCLFNBQVMsQ0FDVCxlQUFlLENBQ2YsTUFBTTtDQUNWO0NBRUQsQUFBUSxxQkFBcUI7QUFDM0IsTUFBSSxDQUFDLEtBQUssUUFBUSxhQUNoQixRQUFPO0FBRVQsTUFBSSxLQUFLLFFBQVEsVUFDZkEsUUFBTSxLQUNKLHNHQUNEO0FBR0gsTUFBSSxLQUFLLFFBQVEsY0FDZkEsUUFBTSxLQUNKLGtIQUNEO0FBR0gsTUFBSTtHQUNGLE1BQU0sRUFBRSxvQkFBUyxVQUFVLEdBQUdDLFVBQVEsMkJBQTJCO0dBRWpFLE1BQU1NLFFBQWdDLEVBQ3BDLDJCQUEyQixzQkFDNUI7R0FFRCxNQUFNLDBEQUNLLEVBQ1QsWUFDQSxtQkFDQUMsV0FDQSxLQUFLLE9BQU8sT0FDYjswQkFDUyxlQUFlLEVBQUUsV0FBVyxLQUFNLEVBQUM7QUFDN0MsbURBQW9CLGVBQWUsZUFBZSxDQUFDLEVBQ2pEUixRQUFNLENBQUMsVUFBVSxFQUFFLGNBQWMsd0JBQXdCLENBQUMsQ0FBQztRQUN0RDtJQUNMLE1BQU0sYUFBYSxTQUFTLFFBQVEsTUFBTSxLQUFLLE9BQU8sT0FBTztJQUM3RCxXQUFXLE9BQU8sY0FBYztHQUNqQztHQUNELE1BQU0sa0JBQWtCLGVBQWUsS0FBSyxPQUFPLE9BQU87R0FDMUQsTUFBTSxrQkFBa0IsTUFBTSxLQUFLLE9BQU8sV0FBVyxLQUFLLE9BQU87R0FDakUsTUFBTSxZQUFZLENBQUMsYUFBYSxFQUFFLGdCQUFnQixPQUFPLENBQUM7R0FDMUQsS0FBSyxLQUFLLGlDQUNSLGVBQ0EsT0FDQSxHQUFHLGdCQUFnQixJQUFJLENBQUMsQ0FDekI7QUFDRCxPQUFJLENBQUMsUUFBUSxJQUFJLGdCQUNmLEtBQUssS0FBSyxDQUFDLGNBQWMsQ0FBQyx3QkFDeEIsZUFDQSxpQkFDQSxVQUNEO0FBRUgsT0FBSSxDQUFDLFFBQVEsSUFBSSxXQUNmLEtBQUssS0FBSyxDQUFDLFNBQVMsQ0FBQyx3QkFDbkIsZUFDQSxPQUNBLEdBQUcsZ0JBQWdCLEdBQUcsQ0FBQyxDQUN4QjtBQUVILE9BQUksQ0FBQyxRQUFRLElBQUksZUFDZixLQUFLLEtBQUssQ0FBQyxhQUFhLENBQUMsd0JBQ3ZCLGVBQ0EsT0FDQSxHQUFHLGdCQUFnQixPQUFPLENBQUMsQ0FDNUI7QUFFSCxPQUFJLENBQUMsUUFBUSxJQUFJLGdCQUNmLEtBQUssS0FBSyxDQUFDLGNBQWMsQ0FBQyx3QkFDeEIsZUFDQSxPQUNBLEdBQUcsZ0JBQWdCLFFBQVEsQ0FBQyxDQUM3QjtBQUVILE9BQUksQ0FBQyxRQUFRLElBQUksdUJBQ2YsS0FBSyxLQUFLLENBQUMscUJBQXFCLENBQUMsd0JBQy9CLGVBQ0EsaUJBQ0EsV0FDQSxPQUNBLFdBQ0Q7QUFFSCxPQUFJLENBQUMsUUFBUSxJQUFJLFdBQ2YsS0FBSyxLQUFLLENBQUMsU0FBUyxDQUFDLHdCQUNuQixlQUNBLE9BQ0EsR0FBRyxnQkFBZ0IsSUFBSSxDQUFDLENBQ3pCO0FBRUgsT0FBSSxDQUFDLFFBQVEsSUFBSSxZQUNmLEtBQUssS0FBSyxDQUFDLFVBQVUsQ0FBQyx3QkFDcEIsZUFDQSxPQUNBLEdBQUcsZ0JBQWdCLElBQUksQ0FBQyxDQUN6QjtBQUVILE9BQ0UsUUFBUSxJQUFJLFdBQVcsV0FBVyxRQUFRLElBQ3pDLFFBQVEsSUFBSSxJQUFJLFdBQVcsUUFBUSxJQUFJLENBQUMsUUFBUSxJQUFJLFdBQ3JEO0lBQ0EsTUFBTSxnQkFBZ0IsUUFBUSxJQUFJLGlCQUFpQjtJQUNuRCxLQUFLLEtBQUssZ0JBQWdCLENBQUMsVUFBVSxFQUFFLEtBQUssS0FBSyxlQUFlLGlCQUFpQixFQUFFLGNBQWMsQ0FBQyxFQUFFLGVBQWU7R0FDcEg7QUFDRCxPQUNHLFFBQVEsSUFBSSxLQUFLLFdBQVcsVUFBVSxJQUFJLENBQUMsUUFBUSxJQUFJLGNBQ3hELFFBQVEsSUFBSSxZQUFZLFdBQVcsVUFBVSxFQUM3QztJQUNBLE1BQU0sa0JBQWtCLFFBQVEsSUFBSSxtQkFBbUI7SUFDdkQsS0FBSyxLQUFLLGtCQUFrQixDQUFDLFVBQVUsRUFBRSxLQUFLLEtBQUssZUFBZSxpQkFBaUIsRUFBRSxjQUFjLENBQUMsRUFBRSxpQkFBaUI7R0FDeEg7R0FDRCxLQUFLLEtBQUssT0FBTyxLQUFLLEtBQUssT0FDdkIsR0FBRyxjQUFjLEtBQUssRUFBRSxLQUFLLEtBQUssS0FBSyxDQUFDLEVBQUUsUUFBUSxJQUFJLE1BQU0sR0FDNUQsR0FBRyxjQUFjLEtBQUssRUFBRSxRQUFRLElBQUksTUFBTTtFQUMvQyxTQUFRLEdBQUc7R0FDVkEsUUFBTSxLQUFLLCtCQUErQixFQUFXO0VBRXREO0FBQ0QsU0FBTztDQUNSO0NBRUQsQUFBUSxPQUFPO0VBQ2JBLFFBQU0sQ0FBQyxzQkFBc0IsRUFBRSxLQUFLLE1BQU0sTUFBTSxDQUFDO0VBQ2pEQSxRQUFNLFFBQVEsQ0FBQyxNQUFNLEVBQUUsS0FBSyxLQUFLLEtBQUssSUFBSSxFQUFFLENBQUM7RUFFN0MsTUFBTSxhQUFhLElBQUk7RUFFdkIsTUFBTSxRQUFRLEtBQUssUUFBUTtFQUMzQixNQUFNLFlBQVksSUFBSSxRQUFjLENBQUNTLFdBQVMsV0FBVztBQUN2RCxPQUFJLEtBQUssUUFBUSxZQUFZLEtBQUssUUFBUSxhQUN4QyxPQUFNLElBQUksTUFDUjtHQUdKLE1BQU0sVUFDSixRQUFRLElBQUksVUFBVSxLQUFLLFFBQVEsV0FBVyxVQUFVO0dBQzFELE1BQU0sNkNBQXFCLFNBQVMsS0FBSyxNQUFNO0lBQzdDLEtBQUs7S0FBRSxHQUFHLFFBQVE7S0FBSyxHQUFHLEtBQUs7SUFBTTtJQUNyQyxPQUFPLFFBQVE7S0FBQztLQUFXO0tBQVc7SUFBTyxJQUFHO0lBQ2hELEtBQUssS0FBSyxRQUFRO0lBQ2xCLFFBQVEsV0FBVztHQUNwQixFQUFDO0dBRUYsYUFBYSxLQUFLLFFBQVEsQ0FBQyxTQUFTO0FBQ2xDLFFBQUksU0FBUyxHQUFHO0tBQ2RULFFBQU0sTUFBTSxDQUFDLFlBQVksRUFBRSxLQUFLLE1BQU0sS0FBSyxjQUFjLENBQUMsQ0FBQztLQUMzRFMsV0FBUztJQUNWLE9BQ0MsdUJBQU8sSUFBSSxNQUFNLENBQUMsNEJBQTRCLEVBQUUsTUFBTSxFQUFFO0dBRTNELEVBQUM7R0FFRixhQUFhLEtBQUssU0FBUyxDQUFDLE1BQU07SUFDaEMsT0FBTyxJQUFJLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRSxFQUFFLFNBQVMsRUFBRSxFQUFFLE9BQU8sRUFBRyxHQUFFO0dBQ3pFLEVBQUM7R0FHRixhQUFhLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUztJQUN4QyxNQUFNLFNBQVMsS0FBSyxVQUFVO0lBQzlCLFFBQVEsTUFBTSxPQUFPO0FBQ3JCLFFBQUksOEJBQThCLEtBQUssT0FBTyxFQUM1QyxLQUFLLFdBQVcsQ0FBQyxNQUFNLE1BQU0sQ0FBRSxFQUFDO0dBRW5DLEVBQUM7RUFDSDtBQUVELFNBQU87R0FDTCxNQUFNLFVBQVUsS0FBSyxNQUFNLEtBQUssV0FBVyxDQUFDO0dBQzVDLE9BQU8sTUFBTSxXQUFXLE9BQU87RUFDaEM7Q0FDRjtDQUVELEFBQVEsYUFBYTtFQUNuQixJQUFJLE1BQU07QUFDVixNQUFJLEtBQUssUUFBUSxNQUNmLEtBQUksUUFBUSxJQUFJLElBQ2RULFFBQU0sS0FBSyxnREFBZ0Q7T0FDdEQ7R0FDTEEsUUFBTSxVQUFVLGNBQWM7R0FDOUIsc0JBQXNCLGVBQWUsUUFBUTtHQUs3QyxLQUFLLEtBQUssS0FDUixTQUNBLFNBQ0EsTUFDQSxrQkFDQSxNQUNBLEtBQUssVUFDTCxNQUNBLFNBQ0EsUUFDRDtHQUNELE1BQU07RUFDUDtBQUdILE1BQUksS0FBSyxRQUFRLGFBQ2YsS0FBSSxLQUFLLE9BQU8sYUFBYSxRQUMzQixLQUFJLFFBQVEsYUFBYSxTQUN2QkEsUUFBTSxLQUNKLDRGQUNEO09BQ0k7R0FFTEEsUUFBTSxVQUFVLGFBQWE7R0FDN0Isc0JBQXNCLGNBQWMsT0FBTztHQUMzQyxLQUFLLEtBQUssS0FBSyxRQUFRLFFBQVE7QUFDL0IsT0FBSSxLQUFLLE9BQU8sU0FBUyxRQUN2QixLQUFLLEtBQUssWUFBWTtHQUV4QixNQUFNO0VBQ1A7V0FHQyxLQUFLLE9BQU8sYUFBYSxXQUN6QixRQUFRLGFBQWEsV0FDckIsS0FBSyxPQUFPLFNBQVMsUUFBUSxRQUM1QixTQUFVVSxLQUFvQjtHQUM3QixNQUFNLHNCQUVKLFFBQVEsUUFBUSxXQUFXLEVBQUUsUUFBUTtHQUN2QyxNQUFNLE9BQU8sc0JBQXNCLFFBQVE7QUFDM0MsVUFBTyxRQUFRO0VBQ2hCLEVBQUUsS0FBSyxPQUFPLElBQUksRUFFbkJWLFFBQU0sS0FDSiwwRkFDRDtXQUVELEtBQUssT0FBTyxhQUFhLFlBQ3pCLFFBQVEsYUFBYSxVQUVyQkEsUUFBTSxLQUNKLDRGQUNEO09BQ0k7R0FFTEEsUUFBTSxVQUFVLGlCQUFpQjtHQUNqQyxzQkFBc0Isa0JBQWtCLFdBQVc7R0FDbkQsS0FBSyxLQUFLLEtBQUssV0FBVztHQUMxQixNQUFNO0VBQ1A7QUFJTCxNQUFJLENBQUMsS0FDSCxLQUFLLEtBQUssS0FBSyxRQUFRO0FBRXpCLFNBQU87Q0FDUjtDQUVELEFBQVEsYUFBYTtFQUNuQixNQUFNLE9BQU8sQ0FBRTtBQUVmLE1BQUksS0FBSyxRQUFRLFNBQ2YsS0FBSyxLQUFLLGFBQWEsS0FBSyxRQUFRLFFBQVE7QUFHOUMsTUFBSSxLQUFLLFNBQ1AsS0FBSyxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBR2xDLE1BQUksS0FBSyxRQUFRO0dBQ2ZBLFFBQU0sc0JBQXNCO0dBQzVCQSxRQUFNLFFBQVEsS0FBSztHQUNuQixLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUs7RUFDeEI7QUFFRCxTQUFPO0NBQ1I7Q0FFRCxBQUFRLFlBQVk7RUFDbEJBLFFBQU0sNEJBQTRCO0VBQ2xDQSxRQUFNLFFBQVEsS0FBSyxPQUFPLE9BQU87RUFFakMsS0FBSyxLQUFLLEtBQUssWUFBWSxLQUFLLE9BQU8sT0FBTztBQUU5QyxTQUFPO0NBQ1I7Q0FFRCxBQUFRLFVBQVU7QUFFaEIsTUFBSSxLQUFLLGVBQWU7R0FDdEIsS0FBSyxLQUFLLDJCQUNSLEtBQUssbUNBQW1DO0dBQzFDLEtBQUssa0JBQWtCLEtBQUssS0FBSyx5QkFBeUI7RUFDM0Q7RUFHRCxJQUFJLFlBQ0YsUUFBUSxJQUFJLGFBQWEsUUFBUSxJQUFJLHlCQUF5QjtBQUVoRSxNQUNFLEtBQUssT0FBTyxLQUFLLFNBQVMsT0FBTyxJQUNqQyxDQUFDLFVBQVUsU0FBUyw2QkFBNkIsRUFFakQsYUFBYTtBQUdmLE1BQUksS0FBSyxRQUFRLFNBQVMsQ0FBQyxVQUFVLFNBQVMsY0FBYyxFQUMxRCxhQUFhO0FBR2YsTUFBSSxVQUFVLFFBQ1osS0FBSyxLQUFLLFlBQVk7RUFLeEIsTUFBTSxTQUFTLEtBQUssUUFBUSxlQUN4QixLQUFLLElBQ0wsZ0JBQWdCLEtBQUssT0FBTyxPQUFPO0VBS3ZDLE1BQU0sWUFBWSxDQUFDLGFBQWEsRUFBRSxlQUNoQyxLQUFLLE9BQU8sT0FDYixDQUFDLE9BQU8sQ0FBQztBQUNWLE1BQUksVUFBVSxDQUFDLFFBQVEsSUFBSSxjQUFjLENBQUMsS0FBSyxLQUFLLFlBQ2xELEtBQUssS0FBSyxhQUFhO0FBR3pCLE1BQUksS0FBSyxPQUFPLGFBQWEsV0FDM0IsS0FBSyxlQUFlO0FBR3RCLE1BQUksS0FBSyxPQUFPLGFBQWEsUUFDM0IsS0FBSyxZQUFZO0FBR25CLE1BQUksS0FBSyxPQUFPLGFBQWEsZUFDM0IsS0FBSyxtQkFBbUI7RUFHMUJBLFFBQU0sYUFBYTtFQUNuQixPQUFPLFFBQVEsS0FBSyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUs7R0FDNUNBLFFBQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQztFQUMzQixFQUFDO0FBRUYsU0FBTztDQUNSO0NBRUQsQUFBUSxrQkFBa0JXLGtCQUEwQjtFQUVsRCxLQUFLLFNBQVMsU0FBUyxRQUFRLENBQUMsVUFBVTtBQUN4QyxPQUNFLE1BQU0sYUFBYSxLQUFLLENBQUMsTUFBTSxFQUFFLFNBQVMsY0FBYyxJQUN4RCw2Q0FBaUIsa0JBQWtCLE1BQU0sS0FBSyxDQUFDLEVBRS9DLEtBQUssS0FDSCxDQUFDLGlCQUFpQixFQUFFLE1BQU0sS0FBSyxRQUFRLE1BQU0sSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUMvRCxLQUFLLEtBQUssQ0FBQyxVQUFVO0VBRTVCLEVBQUM7Q0FDSDtDQUVELEFBQVEsZ0JBQWdCO0VBQ3RCLE1BQU0sRUFBRSx5QkFBeUIsR0FBRyxRQUFRO0FBQzVDLE1BQUksQ0FBQyx5QkFDSFgsUUFBTSxLQUNKLEdBQUdZLFVBQU8sSUFDUiwwQkFDRCxDQUFDLGdDQUFnQyxDQUFDLENBQ3BDO0FBSUgsTUFBSSxRQUFRLGFBQWEsVUFDdkI7RUFHRixNQUFNLGFBQWEsS0FBSyxPQUFPLFNBQVMsUUFBUSxXQUFXO0VBQzNELE1BQU0saUJBQ0osS0FBSyxPQUFPLFNBQVMsUUFBUSxrQkFBa0I7RUFDakQsTUFBTSxlQUNKLFFBQVEsYUFBYSxXQUNqQixXQUNBLFFBQVEsYUFBYSxVQUNuQixZQUNBO0VBQ1IsT0FBTyxPQUFPLEtBQUssTUFBTTtHQUN2QiwyQ0FBMkMsR0FBRyx3QkFBd0IsMEJBQTBCLEVBQUUsYUFBYSxZQUFZLEVBQUUsV0FBVyxzQkFBc0IsQ0FBQztHQUMvSiw2Q0FBNkMsR0FBRyx3QkFBd0IsMEJBQTBCLEVBQUUsYUFBYSxZQUFZLEVBQUUsV0FBVywwQkFBMEIsQ0FBQztHQUNySyxXQUFXLEdBQUcsd0JBQXdCLDBCQUEwQixFQUFFLGFBQWEsWUFBWSxFQUFFLFdBQVcsT0FBTyxFQUFFLGVBQWUsTUFBTSxDQUFDO0dBQ3ZJLFlBQVksR0FBRyx3QkFBd0IsMEJBQTBCLEVBQUUsYUFBYSxZQUFZLEVBQUUsV0FBVyxPQUFPLEVBQUUsZUFBZSxRQUFRLENBQUM7R0FDMUksV0FBVyxHQUFHLHdCQUF3QiwwQkFBMEIsRUFBRSxhQUFhLG1CQUFtQixDQUFDO0dBQ25HLGVBQWUsR0FBRyx3QkFBd0IsMEJBQTBCLEVBQUUsYUFBYSx1QkFBdUIsQ0FBQztHQUMzRyxhQUFhO0dBQ2IsTUFBTSxHQUFHLHdCQUF3QiwwQkFBMEIsRUFBRSxhQUFhLFdBQVcsRUFBRSxRQUFRLGFBQWEsVUFBVSxNQUFNLE1BQU0sUUFBUSxJQUFJLE1BQU07RUFDckosRUFBQztDQUNIO0NBRUQsQUFBUSxhQUFhO0VBQ25CLE1BQU0sNkJBQ0pYLFVBQVEsUUFBUSxTQUFTLEVBQ3pCLE1BQ0EsT0FDQSxzQkFDRDtFQUNELEtBQUssS0FBSyxrQkFBa0I7RUFDNUIsTUFBTSxFQUFFLGVBQWUsR0FBRyxRQUFRO0FBRWxDLE1BQUkseUNBQTRCLGNBQWMsRUFBRTtHQUM5QyxLQUFLLEtBQUssdUVBQ1IsZUFDQSxPQUNBLFVBQ0Q7R0FDRCxLQUFLLEtBQUssd0RBQ1IsZUFDQSxPQUNBLFVBQ0Q7R0FDRCxLQUFLLEtBQUssZ0VBQ1IsZUFDQSxPQUNBLFVBQ0Q7R0FDRCxLQUFLLEtBQUssd0RBQ1IsZUFDQSxPQUNBLFVBQ0Q7R0FDRCxLQUFLLGtCQUFrQixpQ0FBa0IsZUFBZSxPQUFPLFFBQVEsQ0FBQztHQUN4RSxLQUFLLGtCQUNILGtDQUNLLGVBQWUsT0FBTyxVQUFVLENBQ3RDO0dBQ0QsS0FBSyxrQkFBa0IsaUNBQWtCLGVBQWUsT0FBTyxLQUFLLENBQUM7R0FDckUsS0FBSyxrQkFDSCxxQ0FDSyxlQUFlLE9BQU8sU0FBUyxDQUNyQztHQUNELEtBQUssa0JBQ0gsaUJBQ0EsQ0FBQyx1Q0FBdUMsRUFBRSxjQUFjLHFEQUFxRCxDQUFDLENBQy9HO0dBQ0QsS0FBSyxrQkFDSCxtQkFDQSxDQUFDLHVDQUF1QyxFQUFFLGNBQWMscURBQXFELENBQUMsQ0FDL0c7R0FDRCxLQUFLLGtCQUNILENBQUMsY0FBYyxDQUFDLEVBQ2hCLENBQUMsU0FBUyxFQUFFLGNBQWMseUNBQXlDLENBQUMsQ0FDckU7RUFDRjtDQUNGO0NBRUQsQUFBUSxvQkFBb0I7RUFDMUIsTUFBTSxFQUFFLGVBQWUsaUJBQWlCLEdBQUcsUUFBUTtFQUNuRCxNQUFNLFVBQVUsZ0JBQ1osR0FBRyxnQkFBZ0IsT0FBTyxDQUFDLEdBQzNCO0FBRUosTUFBSSxDQUFDLFdBQVcsUUFBUSxhQUFhLGVBQWU7R0FDbERELFFBQU0sS0FDSixHQUFHWSxVQUFPLElBQUksZ0JBQWdCLENBQUMsSUFBSSxFQUFFQSxVQUFPLElBQUksa0JBQWtCLENBQUMsZ0NBQWdDLENBQUMsQ0FDckc7QUFDRDtFQUNEO0VBQ0QsTUFBTSxhQUFhLENBQUMsYUFBYSxFQUFFLEtBQUssT0FBTyxPQUFPLGFBQWEsQ0FBQyxRQUFRLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQztFQUMvRixNQUFNLFVBQVUsR0FBRyxRQUFRLHFCQUFxQixDQUFDO0VBQ2pELE1BQU0sU0FBUyxHQUFHLFFBQVEsaUJBQWlCLENBQUM7RUFDNUMsTUFBTSxTQUFTLEdBQUcsUUFBUSxVQUFVLEVBQUUsS0FBSyxPQUFPLE9BQU8sTUFBTSxDQUFDO0VBQ2hFLE1BQU0sVUFBVSxHQUFHLFFBQVEsVUFBVSxFQUFFLEtBQUssT0FBTyxPQUFPLFFBQVEsQ0FBQztFQUNuRSxNQUFNLFNBQVMsR0FBRyxRQUFRLGlCQUFpQixDQUFDO0VBQzVDLE1BQU0sU0FBUyxHQUFHLFFBQVEsZ0JBQWdCLENBQUM7RUFDM0MsTUFBTSxZQUFZLEdBQUcsUUFBUSxvQkFBb0IsQ0FBQztFQUNsRCxNQUFNLGNBQWMsR0FBRyxRQUFRLHNCQUFzQixDQUFDO0VBQ3RELE1BQU0sY0FBYyxHQUFHLFFBQVEsc0JBQXNCLENBQUM7RUFDdEQsTUFBTSxTQUFTLEdBQUcsUUFBUSxpQkFBaUIsQ0FBQztFQUM1QyxNQUFNLFVBQVUsR0FBRyxRQUFRLFNBQVMsQ0FBQztFQUNyQyxNQUFNLFVBQVUsR0FBRyxRQUFRLFNBQVMsQ0FBQztFQUVyQyxLQUFLLGtCQUFrQixpQkFBaUIsUUFBUTtFQUNoRCxLQUFLLGtCQUFrQixjQUFjLG9CQUFvQjtFQUN6RCxLQUFLLGtCQUFrQixZQUFZLE9BQU87RUFDMUMsS0FBSyxrQkFBa0IsYUFBYSxPQUFPO0VBQzNDLEtBQUssa0JBQWtCLGNBQWMsUUFBUTtFQUM3QyxLQUFLLGtCQUFrQixhQUFhLE9BQU87RUFDM0MsS0FBSyxrQkFBa0IsaUJBQWlCLFFBQVE7RUFDaEQsS0FBSyxrQkFBa0IsYUFBYSxPQUFPO0VBQzNDLEtBQUssa0JBQWtCLGFBQWEsT0FBTztFQUMzQyxLQUFLLGtCQUFrQixnQkFBZ0IsVUFBVTtFQUNqRCxLQUFLLGtCQUFrQixrQkFBa0IsWUFBWTtFQUNyRCxLQUFLLGtCQUFrQixrQkFBa0IsWUFBWTtFQUNyRCxLQUFLLGtCQUFrQixhQUFhLE9BQU87RUFDM0MsS0FBSyxLQUFLLE9BQU8sR0FBRyxVQUFVLFFBQVEsYUFBYSxVQUFVLE1BQU0sTUFBTSxRQUFRLElBQUksTUFBTTtDQUM1RjtDQUVELEFBQVEsY0FBYztFQUNwQixNQUFNLE9BQU8sQ0FBRTtBQUNmLE1BQUksS0FBSyxRQUFRLGVBQWUsS0FBSyxRQUFRLGtCQUMzQyxPQUFNLElBQUksTUFDUjtBQUdKLE1BQUksS0FBSyxRQUFRLGFBQ2YsS0FBSyxLQUFLLGlCQUFpQjtXQUNsQixLQUFLLFFBQVEsbUJBQ3RCLEtBQUssS0FBSyx3QkFBd0I7QUFFcEMsTUFBSSxLQUFLLFFBQVEsVUFDZixLQUFLLEtBQUssY0FBYyxHQUFHLEtBQUssUUFBUSxTQUFTO0VBR25EWixRQUFNLHVCQUF1QjtFQUM3QkEsUUFBTSxRQUFRLEtBQUs7RUFDbkIsS0FBSyxLQUFLLEtBQUssR0FBRyxLQUFLO0FBRXZCLFNBQU87Q0FDUjtDQUVELEFBQVEsZ0JBQWdCO0FBQ3RCLE1BQUksS0FBSyxRQUFRLFNBQ2YsS0FBSyxLQUFLLEtBQUssWUFBWTtBQUc3QixNQUFJLEtBQUssUUFBUSxTQUNmLEtBQUssS0FBSyxLQUFLLFlBQVk7QUFHN0IsTUFBSSxLQUFLLFFBQVEsV0FDZixLQUFLLEtBQUssS0FBSyxnQkFBZ0IsS0FBSyxRQUFRLFVBQVU7QUFHeEQsTUFBSSxLQUFLLFFBQVEsU0FDZixLQUFLLEtBQUssS0FBSyxhQUFhLEtBQUssUUFBUSxRQUFRO0FBR25ELE1BQUksS0FBSyxRQUFRLGNBQ2YsS0FBSyxLQUFLLEtBQUssbUJBQW1CLEtBQUssUUFBUSxhQUFhO0FBRzlELE1BQUksS0FBSyxRQUFRLGNBQWMsUUFDN0IsS0FBSyxLQUFLLEtBQUssR0FBRyxLQUFLLFFBQVEsYUFBYTtBQUc5QyxTQUFPO0NBQ1I7Q0FFRCxBQUFRLG9DQUFvQztFQUMxQyxJQUFJLDZCQUNGLEtBQUssV0FDTCxXQUNBLEdBQUcsS0FBSyxNQUFNLEtBQUssQ0FBQyw4QkFBYSxTQUFTLENBQ3ZDLE9BQU8sS0FBSyxNQUFNLGNBQWMsQ0FDaEMsT0FBTyxZQUFZLENBQ25CLE9BQU8sTUFBTSxDQUNiLFVBQVUsR0FBRyxFQUFFLEVBQUUsQ0FDckI7QUFFRCxNQUFJLENBQUMsS0FBSyxRQUFRLFVBQVU7dUJBQ25CLFFBQVE7SUFBRSxXQUFXO0lBQU0sT0FBTztHQUFNLEVBQUM7R0FDaEQsVUFBVSxDQUFDLENBQUMsRUFBRSxLQUFLLEtBQUssRUFBRTtFQUMzQjtFQUVELFdBQVcsUUFBUSxFQUFFLFdBQVcsS0FBTSxFQUFDO0FBRXZDLFNBQU87Q0FDUjtDQUVELE1BQWMsWUFBWTtBQUN4QixNQUFJO0dBQ0ZBLFFBQU0sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0dBQ3hDQSxRQUFNLFFBQVEsS0FBSyxVQUFVO0dBQzdCLE1BQU0sV0FBVyxLQUFLLFdBQVcsRUFBRSxXQUFXLEtBQU0sRUFBQztHQUNyREEsUUFBTSxDQUFDLHdCQUF3QixDQUFDLENBQUM7RUFDbEMsU0FBUSxHQUFHO0FBQ1YsU0FBTSxJQUFJLE1BQU0sQ0FBQyxrQ0FBa0MsRUFBRSxLQUFLLFdBQVcsRUFBRSxFQUNyRSxPQUFPLEVBQ1I7RUFDRjtFQUVELE1BQU0saUJBQWlCLE1BQU0sS0FBSyxjQUFjO0FBR2hELE1BQUksS0FBSyxZQUFZO0dBQ25CLE1BQU0sU0FBUyxNQUFNLEtBQUssaUJBQWlCO0dBQzNDLE1BQU0sV0FBVyxNQUFNLEtBQUssZUFBZSxPQUFPO0dBQ2xELE1BQU0scUJBQXFCLE1BQU0sS0FBSyxpQkFDcEMsZ0JBQ0EsT0FDRDtBQUNELE9BQUksVUFDRixLQUFLLFFBQVEsS0FBSyxTQUFTO0FBRTdCLE9BQUksb0JBQ0YsS0FBSyxRQUFRLEtBQUssR0FBRyxtQkFBbUI7RUFFM0M7QUFFRCxTQUFPLEtBQUs7Q0FDYjtDQUVELE1BQWMsZUFBZTtFQUMzQixNQUFNLENBQUMsU0FBUyxVQUFVLGVBQWUsR0FBRyxLQUFLLGtCQUFrQjtBQUNuRSxNQUFJLENBQUMsV0FBVyxDQUFDLFNBQ2Y7RUFHRixNQUFNLFVBQ0osS0FBSyxRQUFRLFlBQVksS0FBSyxRQUFRLFVBQVUsWUFBWTtFQUM5RCxNQUFNLDBCQUFXLEtBQUssV0FBVyxLQUFLLE9BQU8sUUFBUSxTQUFTLFFBQVE7RUFDdEVBLFFBQU0sQ0FBQyxxQkFBcUIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQ3JDLE1BQU0sMkJBQVksS0FBSyxXQUFXLFNBQVM7RUFDM0MsTUFBTSxTQUFTLEtBQUssU0FBUyxRQUFRO0FBRXJDLE1BQUk7QUFDRixPQUFJLE1BQU0sV0FBVyxLQUFLLEVBQUU7SUFDMUJBLFFBQU0sc0NBQXNDO0lBQzVDLE1BQU0sWUFBWSxLQUFLO0dBQ3hCO0dBQ0RBLFFBQU0sb0JBQW9CO0dBQzFCQSxRQUFNLFFBQVEsS0FBSztBQUNuQixPQUFJLFFBQVE7SUFDVixNQUFNLEVBQUUsY0FBYyxHQUFHLE1BQU0sT0FBTztJQUN0Q0EsUUFBTSw2QkFBNkI7QUFDbkMsUUFBSTtLQUNGLE1BQU0sa0JBQWtCLElBQUksZUFDekIsY0FBYyxLQUFLLENBQ25CLG9CQUFvQixLQUFLLENBQ3pCLHlCQUF5QixLQUFLLENBQzlCLHNCQUFzQixLQUFLLENBQzNCLGVBQWUsTUFBTSxDQUNyQixNQUFNLE1BQU0sY0FBYyxJQUFJLENBQUM7S0FDbEMsTUFBTSxrQkFBa0IsZ0JBQWdCLFNBQVMsS0FBSztLQUN0RCxNQUFNLGVBQ0osS0FBSyxRQUFRLFdBQVcsY0FBYyxFQUN0QyxnQkFDRDtLQUNEQSxRQUFNLCtCQUErQjtLQUNyQyxNQUFNLG9CQUFvQixJQUFJLGVBQzNCLGNBQWMsTUFBTSxDQUNwQixvQkFBb0IsTUFBTSxDQUMxQix5QkFBeUIsTUFBTSxDQUMvQixzQkFBc0IsTUFBTSxDQUM1QixlQUFlLE1BQU0sQ0FDckIsbUJBQW1CLE1BQU0sQ0FDekIsTUFBTSxnQkFBZ0I7S0FDekIsTUFBTSxvQkFBb0Isa0JBQWtCLFNBQVMsTUFBTTtLQUMzRCxNQUFNLGVBQWUsTUFBTSxrQkFBa0I7SUFDOUMsU0FBUSxHQUFHO0tBQ1ZBLFFBQU0sS0FDSixDQUFDLHNDQUFzQyxFQUFHLEVBQVUsV0FBVyxHQUFHLENBQ25FO0tBQ0QsTUFBTSxjQUFjLEtBQUssS0FBSztJQUMvQjtHQUNGLE9BQ0MsTUFBTSxjQUFjLEtBQUssS0FBSztHQUVoQyxLQUFLLFFBQVEsS0FBSztJQUNoQixNQUFNLEtBQUssU0FBUyxRQUFRLEdBQUcsU0FBUyxTQUFTLFNBQVM7SUFDMUQsTUFBTTtHQUNQLEVBQUM7QUFDRixVQUFPLHFDQUFzQixLQUFLLFdBQVcsZUFBZSxHQUFHO0VBQ2hFLFNBQVEsR0FBRztBQUNWLFNBQU0sSUFBSSxNQUFNLDJCQUEyQixFQUFFLE9BQU8sRUFBRztFQUN4RDtDQUNGO0NBRUQsQUFBUSxtQkFBbUI7QUFDekIsTUFBSSxLQUFLLFlBQVk7R0FDbkIsTUFBTSxTQUFTLEtBQUssV0FBVyxRQUFRLE1BQU0sSUFBSTtHQUNqRCxNQUFNLGFBQWEsS0FBSyxPQUFPLFFBQVEsS0FBSyxDQUFDLE1BQU0sRUFBRSxhQUFhLE9BQU87R0FFekUsTUFBTSxVQUNKLEtBQUssT0FBTyxhQUFhLFdBQ3JCLENBQUMsR0FBRyxFQUFFLE9BQU8sTUFBTSxDQUFDLEdBQ3BCLEtBQUssT0FBTyxhQUFhLFVBQ3ZCLEdBQUcsT0FBTyxJQUFJLENBQUMsR0FDZixLQUFLLE9BQU8sYUFBYSxVQUFVLEtBQUssT0FBTyxhQUFhLFNBQzFELEdBQUcsT0FBTyxLQUFLLENBQUMsR0FDaEIsQ0FBQyxHQUFHLEVBQUUsT0FBTyxHQUFHLENBQUM7R0FFM0IsSUFBSSxXQUFXLEtBQUssT0FBTztBQUkzQixPQUFJLEtBQUssUUFBUSxVQUNmLFlBQVksQ0FBQyxDQUFDLEVBQUUsS0FBSyxPQUFPLGlCQUFpQjtBQUUvQyxPQUFJLFFBQVEsU0FBUyxRQUFRLEVBQzNCLFlBQVk7UUFFWixZQUFZO0FBR2QsVUFBTztJQUNMO0lBQ0E7SUFDQSxhQUNJLEdBQUcsS0FBSyxPQUFPLFdBQVcsQ0FBQyxFQUFFLFdBQVcsZ0JBQWdCLEtBQUssQ0FBQyxHQUM5RDtHQUNMO0VBQ0YsV0FBVSxLQUFLLFNBQVM7R0FDdkIsTUFBTSxVQUNKLEtBQUssT0FBTyxhQUFhLFVBQVUsR0FBRyxLQUFLLFFBQVEsSUFBSSxDQUFDLEdBQUcsS0FBSztBQUVsRSxVQUFPLENBQUMsU0FBUyxPQUFRO0VBQzFCO0FBRUQsU0FBTyxDQUFFO0NBQ1Y7Q0FFRCxNQUFjLGtCQUFrQjtFQUM5QixNQUFNLGFBQWEsS0FBSyxLQUFLO0FBQzdCLE1BQUksQ0FBQyxLQUFLLGlCQUFpQixDQUFFLE1BQU0sZUFBZSxXQUFXLENBQzNELFFBQU8sQ0FBRTtFQUdYLE1BQU0sMkJBQVksS0FBSyxXQUFXLEtBQUssUUFBUSxPQUFPLGFBQWE7RUFFbkUsSUFBSSxTQUFTO0VBQ2IsSUFBSSxNQUFNO0VBQ1YsSUFBSWEsWUFBb0IsQ0FBRTtBQUUxQixNQUFJLENBQUMsS0FBSyxRQUFRLGFBQWE7R0FDN0IsTUFBTSxZQUFZLEtBQUssUUFBUSxhQUFhLEtBQUssT0FBTztBQUV4RCxPQUFJLEtBQUssT0FBTyxjQUNkLEtBQUk7SUFDRixTQUFTLE1BQU0sa0NBQ1IsS0FBSyxRQUFRLEtBQUssS0FBSyxPQUFPLGNBQWMsRUFDakQsUUFDRDtHQUNGLFNBQVEsR0FBRztJQUNWYixRQUFNLEtBQ0osQ0FBQywrQkFBK0IsRUFBRSxLQUFLLE9BQU8sZUFBZSxFQUM3RCxFQUNEO0dBQ0Y7WUFDUSxXQUNULFNBQVM7UUFFVCxTQUFTO0VBRVo7RUFFRCxNQUFNYyxVQUFRLE1BQU0sYUFBYSxZQUFZLEVBQUUsZUFBZSxLQUFNLEVBQUM7QUFFckUsTUFBSSxDQUFDQSxRQUFNLFFBQVE7R0FDakJkLFFBQU0scURBQXFEO0FBQzNELFVBQU8sQ0FBRTtFQUNWO0FBRUQsT0FBSyxNQUFNLFFBQVFjLFNBQU87QUFDeEIsT0FBSSxDQUFDLEtBQUssUUFBUSxDQUNoQjtHQUdGLE1BQU0sRUFBRSxLQUFLLFNBQVMsU0FBUyxhQUFhLEdBQUcsTUFBTSxtQ0FDOUMsWUFBWSxLQUFLLEtBQUssRUFDM0IsS0FBSyxRQUFRLGFBQWEsS0FBSyxPQUFPLGFBQWEsS0FDcEQ7R0FFRCxPQUFPO0dBQ1BDLFVBQVEsS0FBSyxHQUFHLFlBQVk7RUFDN0I7QUFFRCxNQUFJLElBQUksUUFBUSxrQkFBa0IsR0FBRyxJQUNuQyxVQUFVLENBQUM7Ozs7Ozs7QUFPakIsQ0FBQztBQUdHLE1BQUksSUFBSSxRQUFRLGFBQWEsR0FBRyxJQUM5QixVQUFVLENBQUM7O0FBRWpCLENBQUM7RUFHRyxNQUFNLFNBQVM7QUFFZixNQUFJO0dBQ0ZmLFFBQU0sdUJBQXVCO0dBQzdCQSxRQUFNLFFBQVEsS0FBSztHQUNuQixNQUFNLGVBQWUsTUFBTSxLQUFLLFFBQVE7R0FDeEMsS0FBSyxRQUFRLEtBQUs7SUFBRSxNQUFNO0lBQU8sTUFBTTtHQUFNLEVBQUM7RUFDL0MsU0FBUSxHQUFHO0dBQ1ZBLFFBQU0sTUFBTSxnQ0FBZ0M7R0FDNUNBLFFBQU0sTUFBTSxFQUFXO0VBQ3hCO0FBRUQsU0FBT2U7Q0FDUjtDQUVELE1BQWMsZUFBZUMsUUFBa0I7QUFDN0MsTUFDRSxDQUFDLEtBQUssUUFBUSxZQUVkLEtBQUssUUFBUSxlQUNiLE9BQU8sV0FBVyxFQUVsQjtFQUdGLE1BQU1DLFNBQU8sS0FBSyxRQUFRLGFBQWE7RUFFdkMsTUFBTSxnQkFBZ0IsS0FBSyxRQUFRLE1BQU0sbUJBQW1CO0VBQzVELE1BQU0sVUFBVSxjQUNkLEtBQUssT0FBTyxZQUNaLEtBQUssT0FBTyxhQUNaLE9BQ0Q7QUFFRCxNQUFJO0dBQ0YsTUFBTSwyQkFBWSxLQUFLLFdBQVdBLE9BQUs7R0FDdkNqQixRQUFNLHlCQUF5QjtHQUMvQkEsUUFBTSxRQUFRLEtBQUs7R0FDbkIsTUFBTSxlQUFlLE1BQU0sU0FBUyxRQUFRO0FBQzVDLFVBQU87SUFBRSxNQUFNO0lBQU0sTUFBTTtHQUFNO0VBQ2xDLFNBQVEsR0FBRztBQUNWLFNBQU0sSUFBSSxNQUFNLG1DQUFtQyxFQUFFLE9BQU8sRUFBRztFQUNoRTtDQUNGO0NBRUQsTUFBYyxpQkFDWmtCLGNBQ0FGLFFBQ0E7QUFDQSxNQUFJLGNBQWM7R0FDaEIsTUFBTSxFQUFFLGNBQU0sS0FBSyx3QkFBUyxhQUFhO0dBQ3pDLE1BQU0sa0NBQW1CLEtBQUssR0FBRyxLQUFLLE9BQU8sV0FBVyxTQUFTLENBQUMsQ0FBQztHQUNuRSxNQUFNLHlDQUNKLEtBQ0EsR0FBRyxLQUFLLE9BQU8sV0FBVyxnQkFBZ0IsQ0FBQyxDQUM1QztHQUNELE1BQU0saUNBQWtCLEtBQUssa0JBQWtCO0dBQy9DLE1BQU0sd0NBQXlCLEtBQUssMEJBQTBCO0dBQzlELE1BQU0sdUNBQXdCLEtBQUssYUFBYTtHQUNoRCxNQUFNLGNBQ0osQ0FBQyx1Q0FBdUMsQ0FBQyxHQUN6QyxPQUNHLElBQ0MsQ0FBQyxVQUNDLENBQUMsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLEVBQUUsT0FBTyxDQUM1RCxDQUNBLEtBQUssS0FBSztHQUNmLE1BQU0sZUFDSixhQUNBLGtCQUNFQyxRQUNBLEtBQUssT0FBTyxhQUNaLEtBQUssT0FBTyxNQUFNLGVBQ2xCLEtBQUssT0FBTyxNQUFNLGNBQ25CLEdBQ0MsY0FDQSxNQUNGLE9BQ0Q7R0FDRCxNQUFNLGVBQ0osb0JBQ0EseUJBQ0VBLFFBQ0EsS0FBSyxPQUFPLE1BQU0sZUFDbEIsS0FBSyxPQUFPLE1BQU0sZUFDbEIsS0FBSyxPQUFPLE1BQU0sU0FBUyxJQUMzQixLQUFLLE9BQU8sTUFBTSxTQUFTLFdBQzNCLEtBQUssT0FBTyxNQUFNLFNBQVMsT0FDNUIsR0FDQyxDQUFDLHFDQUFxQyxDQUFDLEdBQ3ZDLE9BQ0csSUFDQyxDQUFDLFVBQ0MsQ0FBQyxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsRUFBRSxPQUFPLENBQzFELENBQ0EsS0FBSyxLQUFLLEdBQ2IsTUFDRixPQUNEO0dBQ0QsTUFBTSxlQUFlLFlBQVksc0JBQXNCLE9BQU87R0FDOUQsTUFBTSxlQUNKLG1CQUNBLCtCQUErQixLQUFLLE9BQU8sTUFBTSxTQUFTLE1BQU0sTUFBTSxFQUN0RSxPQUNEO0dBQ0QsTUFBTSxlQUNKLGtCQUNBLENBQUMsZUFBZSxFQUFFLEtBQUssT0FBTyxZQUFZLGVBQWUsQ0FBQyxDQUMzRDtBQUNELFVBQU87SUFDTDtLQUFFLE1BQU07S0FBTSxNQUFNO0lBQWE7SUFDakM7S0FBRSxNQUFNO0tBQU0sTUFBTTtJQUFvQjtJQUN4QztLQUFFLE1BQU07S0FBTSxNQUFNO0lBQVk7SUFDaEM7S0FBRSxNQUFNO0tBQU0sTUFBTTtJQUFtQjtJQUN2QztLQUFFLE1BQU07S0FBTSxNQUFNO0lBQWtCO0dBQ3ZDO0VBQ0Y7QUFDRCxTQUFPLENBQUU7Q0FDVjtDQUVELEFBQVEsa0JBQWtCRSxLQUFhQyxTQUFlO0FBQ3BELE1BQUksQ0FBQyxRQUFRLElBQUksTUFDZixLQUFLLEtBQUssT0FBT0M7Q0FFcEI7QUFDRjs7OztBQ2xrQ0QsSUFBc0IsMkJBQXRCLGNBQXVEQyxrQkFBUTtDQUM3RCxPQUFPLFFBQVEsQ0FBQyxDQUFDLGlCQUFrQixDQUFDO0NBRXBDLE9BQU8sUUFBUUEsa0JBQVEsTUFBTSxFQUMzQixhQUFhLGtEQUNkLEVBQUM7Q0FFRixNQUFNQyxpQkFBTyxPQUFPLFNBQVMsUUFBUSxLQUFLLEVBQUUsRUFDMUMsYUFDRSxxSEFDSCxFQUFDO0NBRUYsYUFBc0JBLGlCQUFPLE9BQU8sb0JBQW9CLEVBQ3RELGFBQWEsa0NBQ2QsRUFBQztDQUVGLGtCQUFrQkEsaUJBQU8sT0FBTyx1QkFBdUIsZ0JBQWdCLEVBQ3JFLGFBQWEseUJBQ2QsRUFBQztDQUVGLFNBQVNBLGlCQUFPLE9BQU8sYUFBYSxPQUFPLEVBQ3pDLGFBQWEsZ0RBQ2QsRUFBQztDQUVGLFNBQVNBLGlCQUFPLFFBQVEsYUFBYSxPQUFPLEVBQzFDLGFBQWEsdUNBQ2QsRUFBQztDQUVGLGFBQWE7QUFDWCxTQUFPO0dBQ0wsS0FBSyxLQUFLO0dBQ1YsWUFBWSxLQUFLO0dBQ2pCLGlCQUFpQixLQUFLO0dBQ3RCLFFBQVEsS0FBSztHQUNiLFFBQVEsS0FBSztFQUNkO0NBQ0Y7QUFDRjtBQW9DRCxTQUFnQixpQ0FDZEMsU0FDQTtBQUNBLFFBQU87RUFDTCxLQUFLLFFBQVEsS0FBSztFQUNsQixpQkFBaUI7RUFDakIsUUFBUTtFQUNSLFFBQVE7RUFDUixHQUFHO0NBQ0o7QUFDRjs7OztBQ3JFRCxNQUFNQyxVQUFRLGFBQWEsa0JBQWtCO0FBTTdDLGVBQXNCLGNBQWNDLGFBQW1DO0NBQ3JFLE1BQU0sVUFBVSxpQ0FBaUMsWUFBWTtDQUU3RCxlQUFlQyxhQUFXQyxLQUFhO0VBQ3JDSCxRQUFNLHlCQUF5QixJQUFJO0FBQ25DLE1BQUksUUFBUSxPQUNWO0VBR0YsTUFBTUksV0FBYyxLQUFLLEVBQ3ZCLFdBQVcsS0FDWixFQUFDO0NBQ0g7Q0FFRCxlQUFlQyxpQkFBZUMsTUFBY0MsU0FBaUI7RUFDM0RQLFFBQU0sbUJBQW1CLEtBQUs7QUFFOUIsTUFBSSxRQUFRLFFBQVE7R0FDbEJBLFFBQU0sUUFBUTtBQUNkO0VBQ0Q7RUFFRCxNQUFNUSxlQUFrQixNQUFNLFFBQVE7Q0FDdkM7Q0FFRCxNQUFNLHlDQUEwQixRQUFRLEtBQUssUUFBUSxnQkFBZ0I7Q0FDckUsTUFBTSxpQ0FBa0IsUUFBUSxLQUFLLFFBQVEsT0FBTztDQUVwRFIsUUFBTSxDQUFDLG1CQUFtQixFQUFFLFFBQVEsY0FBYyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7Q0FFckUsTUFBTSxFQUFFLFNBQVMsWUFBWSxhQUFhLGFBQWEsR0FDckQsTUFBTSxlQUNKLGlCQUNBLFFBQVEsb0NBQXFCLFFBQVEsS0FBSyxRQUFRLFdBQVcsR0FBRyxPQUNqRTtBQUVILE1BQUssTUFBTSxVQUFVLFNBQVM7RUFDNUIsTUFBTSxnQ0FBaUIsU0FBUyxHQUFHLE9BQU8saUJBQWlCLENBQUM7RUFDNUQsTUFBTUUsYUFBVyxVQUFVO0VBRTNCLE1BQU0saUJBQ0osT0FBTyxTQUFTLFdBQ1osR0FBRyxXQUFXLENBQUMsRUFBRSxPQUFPLGdCQUFnQixLQUFLLENBQUMsR0FDOUMsR0FBRyxXQUFXLENBQUMsRUFBRSxPQUFPLGdCQUFnQixLQUFLLENBQUM7RUFDcEQsTUFBTU8sb0JBQTZDO0dBQ2pELE1BQU0sR0FBRyxZQUFZLENBQUMsRUFBRSxPQUFPLGlCQUFpQjtHQUNoRCxTQUFTLFlBQVk7R0FDckIsS0FBSyxPQUFPLFNBQVMsY0FBYyxDQUFDLE9BQU8sSUFBSyxJQUFHO0dBQ25ELE1BQU07R0FDTixPQUFPLENBQUMsY0FBZTtHQUN2QixHQUFHLEtBQ0QsYUFDQSxlQUNBLFlBQ0EsVUFDQSxXQUNBLFlBQ0EsV0FDQSxXQUNBLGNBQ0EsT0FDRDtFQUNGO0FBQ0QsTUFBSSxZQUFZLGVBQ2Qsa0JBQWtCLGdCQUFnQixLQUNoQyxZQUFZLGVBQ1osWUFDQSxTQUNEO0FBRUgsTUFBSSxPQUFPLFNBQVMsVUFDbEIsa0JBQWtCLEtBQUssQ0FBQyxPQUFPLFFBQVM7T0FDbkM7R0FDTCxNQUFNLFFBQVEsR0FBRyxXQUFXLFNBQVMsQ0FBQztHQUN0QyxrQkFBa0IsT0FBTztHQUN6QixrQkFBa0IsVUFBVSxHQUFHLFdBQVcsZ0JBQWdCLENBQUM7R0FDM0Qsa0JBQWtCLE9BQU8sS0FDdkIsT0FDQSxrQkFBa0IsU0FDbEIsQ0FBQyxlQUFlLENBQUMsRUFDakIsQ0FBQyx1QkFBdUIsQ0FBQyxDQUMxQjtHQUNELElBQUksMEJBQTBCO0FBQzlCLE9BQUksa0JBQWtCLFNBQVMsS0FDN0IsS0FBSTtJQUNGLE1BQU0sRUFBRSxPQUFPLHFCQUFTLGtCQUFrQixRQUFRLEtBQUssSUFBSSxFQUN6RCxPQUFPLEVBQ1I7QUFDRCxRQUFJLFNBQVMsSUFDWCwwQkFBMEI7R0FFN0IsUUFBTyxDQUVQO0FBRUgsT0FBSSx5QkFDRixrQkFBa0IsVUFBVSxFQUMxQixNQUFNLFdBQ1A7R0FFSCxNQUFNLGNBQWMsTUFBTSxNQUN4QixDQUFDLGdEQUFnRCxDQUFDLENBQ25ELENBQUMsS0FBSyxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQXlCO0dBQ25ELGtCQUFrQixlQUFlLEVBQy9CLHlCQUF5QixDQUFDLENBQUMsRUFBRSxZQUFZLGFBQWEsUUFBUSxDQUMvRDtFQUNGO0FBRUQsTUFBSSxPQUFPLFFBQVEsT0FDakIsa0JBQWtCLE9BQU8sQ0FBQyxPQUFRO1dBQ3pCLE9BQU8sUUFBUSxRQUN4QixrQkFBa0IsT0FBTyxDQUFDLE1BQU87RUFHbkMsTUFBTSx3Q0FBeUIsV0FBVyxlQUFlO0VBQ3pELE1BQU1KLGlCQUNKLG1CQUNBLEtBQUssVUFBVSxtQkFBbUIsTUFBTSxFQUFFLEdBQUcsS0FDOUM7RUFDRCxNQUFNLG1DQUFvQixXQUFXLFlBQVk7RUFDakQsTUFBTUEsaUJBQWUsY0FBYyxPQUFPLGFBQWEsT0FBTyxDQUFDO0VBRS9ETCxRQUFNLEtBQUssR0FBRyxZQUFZLEVBQUUsRUFBRSxPQUFPLGdCQUFnQixRQUFRLENBQUMsQ0FBQztDQUNoRTtBQUNGO0FBRUQsU0FBUyxPQUFPVSxhQUFxQkMsUUFBZ0I7QUFDbkQsUUFBTyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsRUFBRSxPQUFPLGdCQUFnQjs7Y0FFeEMsRUFBRSxPQUFPLE9BQU8sZ0JBQWdCLEVBQUUsWUFBWTtBQUM1RCxDQUFDO0FBQ0E7Ozs7QUN0SkQsSUFBc0IsaUJBQXRCLGNBQTZDQyxrQkFBUTtDQUNuRCxPQUFPLFFBQVEsQ0FBQyxDQUFDLEtBQU0sQ0FBQztDQUV4QixPQUFPLFFBQVFBLGtCQUFRLE1BQU0sRUFDM0IsYUFBYSx1REFDZCxFQUFDO0NBRUYsU0FBU0MsaUJBQU8sT0FBTyxFQUFFLFVBQVUsTUFBTyxFQUFDO0NBRTNDLFNBQWtCQSxpQkFBTyxPQUFPLGFBQWEsRUFDM0MsYUFDRSxnRkFDSCxFQUFDO0NBRUYsb0JBQW9CQSxpQkFBTyxPQUFPLHFCQUFxQixLQUFLO0VBQzFELFdBQVcsU0FBUyxVQUFVO0VBQzlCLGFBQWE7Q0FDZCxFQUFDO0NBRUYsaUJBQWlCQSxpQkFBTyxPQUFPLHFCQUFxQixRQUFRLEVBQzFELGFBQWEsNkRBQ2QsRUFBQztDQUVGLFVBQVVBLGlCQUFPLE9BQU8sZ0JBQWdCLE9BQU8sRUFDN0MsYUFBYSxtQ0FDZCxFQUFDO0NBRUYsVUFBVUEsaUJBQU8sTUFBTSxnQkFBZ0IsQ0FBRSxHQUFFLEVBQ3pDLGFBQWEsOENBQ2QsRUFBQztDQUVGLHVCQUF1QkEsaUJBQU8sUUFBUSw0QkFBNEIsTUFBTSxFQUN0RSxhQUFhLGlDQUNkLEVBQUM7Q0FFRixtQkFBbUJBLGlCQUFPLFFBQVEsd0JBQXdCLE9BQU8sRUFDL0QsYUFBYSw2QkFDZCxFQUFDO0NBRUYsZ0JBQWdCQSxpQkFBTyxRQUFRLHFCQUFxQixNQUFNLEVBQ3hELGFBQ0UsbUZBQ0gsRUFBQztDQUVGLHNCQUFzQkEsaUJBQU8sUUFBUSwyQkFBMkIsTUFBTSxFQUNwRSxhQUFhLHlEQUNkLEVBQUM7Q0FFRixnQkFBZ0JBLGlCQUFPLE9BQU8sb0JBQW9CLE9BQU8sRUFDdkQsYUFDRSxtRUFDSCxFQUFDO0NBRUYsU0FBU0EsaUJBQU8sUUFBUSxhQUFhLE9BQU8sRUFDMUMsYUFBYSw2Q0FDZCxFQUFDO0NBRUYsYUFBYTtBQUNYLFNBQU87R0FDTCxNQUFNLEtBQUs7R0FDWCxNQUFNLEtBQUs7R0FDWCxtQkFBbUIsS0FBSztHQUN4QixnQkFBZ0IsS0FBSztHQUNyQixTQUFTLEtBQUs7R0FDZCxTQUFTLEtBQUs7R0FDZCxzQkFBc0IsS0FBSztHQUMzQixrQkFBa0IsS0FBSztHQUN2QixlQUFlLEtBQUs7R0FDcEIscUJBQXFCLEtBQUs7R0FDMUIsZUFBZSxLQUFLO0dBQ3BCLFFBQVEsS0FBSztFQUNkO0NBQ0Y7QUFDRjtBQTRFRCxTQUFnQix1QkFBdUJDLFNBQXFCO0FBQzFELFFBQU87RUFDTCxtQkFBbUI7RUFDbkIsZ0JBQWdCO0VBQ2hCLFNBQVM7RUFDVCxTQUFTLENBQUU7RUFDWCxzQkFBc0I7RUFDdEIsa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixxQkFBcUI7RUFDckIsZUFBZTtFQUNmLFFBQVE7RUFDUixHQUFHO0NBQ0o7QUFDRjs7OztBQ3BLRCxTQUFTLFNBQVNDLFFBQU07QUFHdEIsUUFBT0EsT0FBSyxJQUFJLENBQUMsUUFBTTtBQUNyQixTQUFPLElBQUksV0FBVyxLQUFLLElBQUksTUFBTSxpQkFBaUIsR0FBRyxLQUFLLFVBQVUsSUFBSSxHQUFHO0NBQ2hGLEVBQUMsQ0FBQyxLQUFLLElBQUk7QUFDYjtBQUNELElBQU0sU0FBTixNQUFhO0NBQ1gsU0FBUztDQUNUO0NBQ0EsU0FBUyxDQUFFO0NBQ1gsa0NBQWtCLElBQUk7Q0FDdEIsWUFBWSxTQUFRO0VBQ2xCLEtBQUssWUFBWTtDQUNsQjtDQUNELEtBQUssYUFBYSxDQUFFLEdBQUU7RUFFcEIsS0FBSyxTQUFTLEtBQUtDLGFBQWEsS0FBSyxVQUFVO0VBQy9DLEtBQUssU0FBUyxLQUFLQyxRQUFRLFdBQVc7QUFDdEMsU0FBTyxLQUFLO0NBQ2I7Q0FDRCxhQUFhLEtBQUtGLFNBQU8sQ0FBRSxHQUFFO0VBQzNCLE1BQU0sTUFBTSxDQUFFO0VBQ2QsTUFBTSxRQUFRLE9BQU8sS0FBSyxJQUFJO0VBQzlCLE1BQU0sY0FBYyxDQUFFO0VBQ3RCLE1BQU0saUJBQWlCLENBQUU7QUFDekIsT0FBSyxNQUFNLFFBQVEsTUFDakIsS0FBSSxLQUFLRyxzQkFBc0IsSUFBSSxNQUFNLEVBQ3ZDLFlBQVksS0FBSyxLQUFLO09BRXRCLGVBQWUsS0FBSyxLQUFLO0VBRzdCLE1BQU0sY0FBYyxZQUFZLE9BQU8sZUFBZTtBQUN0RCxPQUFLLE1BQU0sUUFBUSxhQUFZO0dBQzdCLE1BQU1DLFVBQVEsSUFBSTtBQUNsQixPQUFJQSxtQkFBaUIsTUFDbkIsSUFBSSxLQUFLLEtBQUtDLGlCQUFpQixDQUM3QixJQUNELEdBQUVELFFBQU0sQ0FBQztZQUNELE9BQU9BLFlBQVUsWUFBWUEsbUJBQWlCLFFBQ3ZELElBQUksS0FBSyxLQUFLRSxnQkFBZ0IsQ0FDNUIsSUFDRCxHQUFFRixRQUFNLFVBQVUsQ0FBQyxDQUFDO1lBQ1osT0FBT0EsWUFBVSxVQUMxQixJQUFJLEtBQUssS0FBS0csbUJBQW1CLENBQy9CLElBQ0QsR0FBRUgsUUFBTSxDQUFDO1lBQ0QsT0FBT0EsWUFBVSxXQUMxQixJQUFJLEtBQUssS0FBS0ksaUJBQWlCLENBQzdCLElBQ0QsR0FBRUosUUFBTSxDQUFDO1lBQ0RBLG1CQUFpQixPQUFPO0lBQ2pDLE1BQU0sWUFBWSxLQUFLSyxnQkFBZ0JMLFFBQU07QUFDN0MsUUFBSSxjQUFjLGtCQUNoQixJQUFJLEtBQUssS0FBS00sa0JBQWtCLENBQzlCLElBQ0QsR0FBRU4sUUFBTSxDQUFDO2FBQ0QsY0FBYyw4QkFFdkIsTUFBSSxJQUFJLElBQUksR0FBRyxJQUFJQSxRQUFNLFFBQVEsS0FBSTtLQUNuQyxJQUFJLEtBQUssR0FBRztLQUNaLElBQUksS0FBSyxLQUFLTyxhQUFhLENBQ3pCLEdBQUdYLFFBQ0gsSUFDRCxFQUFDLENBQUM7S0FDSCxJQUFJLEtBQUssR0FBRyxLQUFLQyxhQUFhRyxRQUFNLElBQUksQ0FDdEMsR0FBR0osUUFDSCxJQUNELEVBQUMsQ0FBQztJQUNKO1NBQ0k7S0FFTCxNQUFNLE1BQU1JLFFBQU0sSUFBSSxDQUFDLE1BQUksS0FBS1Esb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLEtBQUssSUFBSTtLQUNqRSxJQUFJLEtBQUssR0FBRyxLQUFLQyxhQUFhLENBQzVCLElBQ0QsRUFBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2Q7R0FDRixXQUFVLE9BQU9ULFlBQVUsVUFBVTtJQUNwQyxJQUFJLEtBQUssR0FBRztJQUNaLElBQUksS0FBSyxLQUFLVSxRQUFRLENBQ3BCLEdBQUdkLFFBQ0gsSUFDRCxFQUFDLENBQUM7QUFDSCxRQUFJSSxTQUFPO0tBQ1QsTUFBTSxVQUFVQTtLQUNoQixJQUFJLEtBQUssR0FBRyxLQUFLSCxhQUFhLFNBQVMsQ0FDckMsR0FBR0QsUUFDSCxJQUNELEVBQUMsQ0FBQztJQUNKO0dBRUY7RUFDRjtFQUNELElBQUksS0FBSyxHQUFHO0FBQ1osU0FBTztDQUNSO0NBQ0QsYUFBYUksU0FBTztBQUNsQixTQUFPQSxtQkFBaUIsUUFBUUEsbUJBQWlCLFVBQVU7R0FDekQ7R0FDQTtHQUNBO0VBQ0QsRUFBQyxTQUFTLE9BQU9BLFFBQU07Q0FDekI7Q0FDRCxnQkFBZ0IsS0FBSztBQUNuQixNQUFJLEtBQUtXLGdCQUFnQixJQUFJLElBQUksQ0FDL0IsUUFBTyxLQUFLQSxnQkFBZ0IsSUFBSSxJQUFJO0VBRXRDLE1BQU1DLFNBQU8sS0FBS0Msa0JBQWtCLElBQUk7RUFDeEMsS0FBS0YsZ0JBQWdCLElBQUksS0FBS0MsT0FBSztBQUNuQyxTQUFPQTtDQUNSO0NBQ0Qsa0JBQWtCLEtBQUs7QUFDckIsTUFBSSxDQUFDLElBQUksT0FFUCxRQUFPO0VBRVQsTUFBTSxnQkFBZ0IsS0FBS0UsYUFBYSxJQUFJLEdBQUc7QUFDL0MsTUFBSSxJQUFJLGNBQWMsTUFDcEIsUUFBTztBQUVULE9BQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsSUFDN0IsS0FBSSxrQkFBa0IsS0FBS0EsYUFBYSxJQUFJLEdBQUcsSUFBSSxJQUFJLGNBQWMsTUFDbkUsUUFBTztBQUdYLFNBQU8sZ0JBQWdCLG1CQUFtQjtDQUMzQztDQUNELG9CQUFvQmQsU0FBTztBQUN6QixNQUFJQSxtQkFBaUIsS0FDbkIsUUFBTyxDQUFDLENBQUMsRUFBRSxLQUFLZSxXQUFXZixRQUFNLENBQUMsQ0FBQyxDQUFDO1dBQzNCLE9BQU9BLFlBQVUsWUFBWUEsbUJBQWlCLE9BQ3ZELFFBQU8sS0FBSyxVQUFVQSxRQUFNLFVBQVUsQ0FBQztXQUM5QixPQUFPQSxZQUFVLFNBQzFCLFFBQU9BO1dBQ0UsT0FBT0EsWUFBVSxVQUMxQixRQUFPQSxRQUFNLFVBQVU7V0FDZEEsbUJBQWlCLE9BQU87R0FDakMsTUFBTSxNQUFNQSxRQUFNLElBQUksQ0FBQyxNQUFJLEtBQUtRLG9CQUFvQixFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUk7QUFDakUsVUFBTyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztFQUNsQixXQUFVLE9BQU9SLFlBQVUsVUFBVTtBQUNwQyxPQUFJLENBQUNBLFFBQ0gsT0FBTSxJQUFJLE1BQU07R0FFbEIsTUFBTSxNQUFNLE9BQU8sS0FBS0EsUUFBTSxDQUFDLElBQUksQ0FBQyxRQUFNO0FBQ3hDLFdBQU8sR0FBRyxTQUFTLENBQ2pCLEdBQ0QsRUFBQyxDQUFDLEdBQUcsRUFDTixLQUFLUSxvQkFBb0JSLFFBQU0sS0FBSyxFQUFFO0dBQ3ZDLEVBQUMsQ0FBQyxLQUFLLElBQUk7QUFDWixVQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0VBQ2xCO0FBQ0QsUUFBTSxJQUFJLE1BQU07Q0FDakI7Q0FDRCxzQkFBc0JBLFNBQU87QUFDM0IsU0FBTyxPQUFPQSxZQUFVLFlBQVksT0FBT0EsWUFBVSxZQUFZLE9BQU9BLFlBQVUsYUFBYUEsbUJBQWlCLFVBQVVBLG1CQUFpQixRQUFRQSxtQkFBaUIsU0FBUyxLQUFLSyxnQkFBZ0JMLFFBQU0sS0FBSztDQUM5TTtDQUNELFFBQVFKLFFBQU07QUFDWixTQUFPLENBQUMsQ0FBQyxFQUFFLFNBQVNBLE9BQUssQ0FBQyxDQUFDLENBQUM7Q0FDN0I7Q0FDRCxhQUFhQSxRQUFNO0FBQ2pCLFNBQU8sQ0FBQyxFQUFFLEVBQUUsU0FBU0EsT0FBSyxDQUFDLEVBQUUsQ0FBQztDQUMvQjtDQUNELGFBQWFBLFFBQU07RUFDakIsTUFBTSxRQUFRLFNBQVNBLE9BQUs7QUFDNUIsTUFBSSxNQUFNLFNBQVMsS0FBSyxRQUN0QixLQUFLLFNBQVMsTUFBTTtBQUV0QixTQUFPLEdBQUcsTUFBTSxHQUFHLENBQUM7Q0FDckI7Q0FDRCxrQkFBa0JBLFFBQU1JLFNBQU87QUFDN0IsU0FBTyxHQUFHLEtBQUtTLGFBQWFiLE9BQUssR0FBRyxLQUFLLFVBQVVJLFFBQU0sRUFBRTtDQUM1RDtDQUNELGdCQUFnQkosUUFBTUksU0FBTztBQUMzQixTQUFPLEdBQUcsS0FBS1MsYUFBYWIsT0FBSyxHQUFHLEtBQUssVUFBVUksUUFBTSxFQUFFO0NBQzVEO0NBQ0QsbUJBQW1CSixRQUFNSSxTQUFPO0FBQzlCLE1BQUksT0FBTyxNQUFNQSxRQUFNLENBQ3JCLFFBQU8sR0FBRyxLQUFLUyxhQUFhYixPQUFLLENBQUMsR0FBRyxDQUFDO0FBRXhDLFVBQU9JLFNBQVA7R0FDRSxLQUFLLFNBQ0gsUUFBTyxHQUFHLEtBQUtTLGFBQWFiLE9BQUssQ0FBQyxHQUFHLENBQUM7R0FDeEMsS0FBSyxVQUNILFFBQU8sR0FBRyxLQUFLYSxhQUFhYixPQUFLLENBQUMsSUFBSSxDQUFDO0dBQ3pDLFFBQ0UsUUFBTyxHQUFHLEtBQUthLGFBQWFiLE9BQUssR0FBR0ksU0FBTztFQUM5QztDQUNGO0NBQ0QsaUJBQWlCSixRQUFNSSxTQUFPO0FBQzVCLFNBQU8sR0FBRyxLQUFLUyxhQUFhYixPQUFLLEdBQUdJLFNBQU87Q0FDNUM7Q0FDRCxXQUFXQSxTQUFPO0VBQ2hCLFNBQVMsTUFBTSxHQUFHLE9BQU8sR0FBRztBQUMxQixVQUFPLEVBQUUsU0FBUyxNQUFNLElBQUk7RUFDN0I7RUFDRCxNQUFNLElBQUksT0FBT0EsUUFBTSxhQUFhLEdBQUcsR0FBRyxVQUFVLENBQUM7RUFDckQsTUFBTSxJQUFJLE1BQU1BLFFBQU0sWUFBWSxDQUFDLFVBQVUsQ0FBQztFQUM5QyxNQUFNLElBQUksTUFBTUEsUUFBTSxhQUFhLENBQUMsVUFBVSxDQUFDO0VBQy9DLE1BQU0sTUFBTSxNQUFNQSxRQUFNLGVBQWUsQ0FBQyxVQUFVLENBQUM7RUFDbkQsTUFBTSxJQUFJLE1BQU1BLFFBQU0sZUFBZSxDQUFDLFVBQVUsQ0FBQztFQUNqRCxNQUFNLEtBQUssTUFBTUEsUUFBTSxvQkFBb0IsQ0FBQyxVQUFVLEVBQUUsRUFBRTtFQUUxRCxNQUFNLFFBQVEsR0FBR0EsUUFBTSxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSTtBQUMxRSxTQUFPO0NBQ1I7Q0FDRCxpQkFBaUJKLFFBQU1JLFNBQU87QUFDNUIsU0FBTyxHQUFHLEtBQUtTLGFBQWFiLE9BQUssR0FBRyxLQUFLbUIsV0FBV2YsUUFBTSxFQUFFO0NBQzdEO0NBQ0QsUUFBUSxVQUFVLENBQUUsR0FBRTtFQUNwQixNQUFNLEVBQUUsZUFBZSxPQUFPLEdBQUc7RUFDakMsTUFBTSxlQUFlO0VBQ3JCLE1BQU0sTUFBTSxDQUFFO0FBQ2QsT0FBSSxJQUFJLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxRQUFRLEtBQUk7R0FDekMsTUFBTSxJQUFJLEtBQUssT0FBTztBQUV0QixPQUFJLEVBQUUsT0FBTyxPQUFPLEVBQUUsT0FBTyxLQUFLO0FBRWhDLFFBQUksS0FBSyxPQUFPLElBQUksT0FBTyxNQUFNLEtBQUssT0FBTyxJQUFJLElBQUksTUFBTSxHQUFHLEVBQUUsT0FBTyxLQUFLLEVBQUUsTUFBTSxHQUFHLEdBQUcsR0FBRyxLQUFLO0tBQ2hHLEtBQUs7QUFDTDtJQUNEO0lBQ0QsSUFBSSxLQUFLLEVBQUU7R0FDWixXQUNLLGNBQWM7SUFDaEIsTUFBTSxJQUFJLGFBQWEsS0FBSyxFQUFFO0FBQzlCLFFBQUksS0FBSyxFQUFFLElBQ1QsSUFBSSxLQUFLLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxHQUFHLE9BQU8sS0FBSyxPQUFPLENBQUMsQ0FBQztTQUVuRCxJQUFJLEtBQUssRUFBRTtHQUVkLE9BQ0MsSUFBSSxLQUFLLEVBQUU7RUFHaEI7RUFFRCxNQUFNLGdCQUFnQixDQUFFO0FBQ3hCLE9BQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSTtHQUNqQyxNQUFNLElBQUksSUFBSTtBQUNkLE9BQUksRUFBRSxNQUFNLE1BQU0sSUFBSSxJQUFJLE9BQU8sS0FDL0IsY0FBYyxLQUFLLEVBQUU7RUFFeEI7QUFDRCxTQUFPO0NBQ1I7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRyxTQUFnQixVQUFVLEtBQUssU0FBUztBQUMxQyxRQUFPLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssS0FBSztBQUNoRDs7Ozs7OztHQzdRRyxTQUFnQixjQUFjLE9BQU8sV0FBVztDQUNsRCxJQUFJLGNBQWM7QUFDbEIsTUFBSyxNQUFNLE9BQU8sT0FBTTtBQUN0QixNQUFJLENBQUMsVUFBVSxJQUFJLENBQ2pCO0VBRUYsTUFBTSxlQUFlO0VBQ3JCLGVBQWU7Q0FDaEI7Q0FDRCxNQUFNLE9BQU8sWUFBWTtBQUN6QixRQUFPO0FBQ1I7Ozs7QUNiRCxTQUFnQixVQUFVLFFBQVEsT0FBTyxTQUFTO0FBQ2hELFFBQU8sa0JBQWtCLFFBQVEsdUJBQU8sSUFBSSxPQUFPLFFBQVE7QUFDNUQ7QUFDRCxTQUFTLGtCQUFrQixRQUFRLE9BQU8sTUFBTSxTQUFTO0NBQ3ZELE1BQU0sU0FBUyxDQUFFO0NBQ2pCLE1BQU1nQixTQUFPLElBQUksSUFBSSxDQUNuQixHQUFHLFFBQVEsT0FBTyxFQUNsQixHQUFHLFFBQVEsTUFBTSxBQUNsQjtBQUVELE1BQUssTUFBTSxPQUFPQSxRQUFLO0FBRXJCLE1BQUksUUFBUSxZQUNWO0VBRUYsTUFBTSxJQUFJLE9BQU87QUFDakIsTUFBSSxDQUFDLE9BQU8sT0FBTyxPQUFPLElBQUksRUFBRTtHQUM5QixPQUFPLE9BQU87QUFDZDtFQUNEO0VBQ0QsTUFBTSxJQUFJLE1BQU07QUFDaEIsTUFBSSxnQkFBZ0IsRUFBRSxJQUFJLGdCQUFnQixFQUFFLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsRUFBRTtHQUM1RSxLQUFLLElBQUksRUFBRTtHQUNYLEtBQUssSUFBSSxFQUFFO0dBQ1gsT0FBTyxPQUFPLGFBQWEsR0FBRyxHQUFHLE1BQU0sUUFBUTtBQUMvQztFQUNEO0VBRUQsT0FBTyxPQUFPO0NBQ2Y7QUFDRCxRQUFPO0FBQ1I7QUFDRCxTQUFTLGFBQWEsTUFBTSxPQUFPLE1BQU0sVUFBVTtDQUNqRCxRQUFRO0NBQ1IsTUFBTTtDQUNOLE1BQU07QUFDUCxHQUFFO0FBRUQsS0FBSSxZQUFZLEtBQUssSUFBSSxZQUFZLE1BQU0sQ0FDekMsUUFBTyxrQkFBa0IsTUFBTSxPQUFPLE1BQU0sUUFBUTtBQUV0RCxLQUFJLFdBQVcsS0FBSyxJQUFJLFdBQVcsTUFBTSxFQUFFO0FBRXpDLE1BQUksTUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLFFBQVEsTUFBTSxFQUFFO0FBQy9DLE9BQUksUUFBUSxXQUFXLFFBQ3JCLFFBQU8sS0FBSyxPQUFPLE1BQU07QUFFM0IsVUFBTztFQUNSO0FBRUQsTUFBSSxnQkFBZ0IsT0FBTyxpQkFBaUIsS0FBSztBQUMvQyxPQUFJLFFBQVEsU0FBUyxRQUNuQixRQUFPLElBQUksSUFBSSxDQUNiLEdBQUcsTUFDSCxHQUFHLEtBQ0o7QUFFSCxVQUFPO0VBQ1I7QUFFRCxNQUFJLGdCQUFnQixPQUFPLGlCQUFpQixLQUFLO0FBQy9DLE9BQUksUUFBUSxTQUFTLFFBQ25CLFFBQU8sSUFBSSxJQUFJLENBQ2IsR0FBRyxNQUNILEdBQUcsS0FDSjtBQUVILFVBQU87RUFDUjtDQUNGO0FBQ0QsUUFBTztBQUNSOzs7OztHQUtHLFNBQVMsWUFBWUMsU0FBTztBQUM5QixRQUFPLE9BQU8sZUFBZUEsUUFBTSxLQUFLLE9BQU87QUFDaEQ7QUFDRCxTQUFTLFdBQVdBLFNBQU87QUFDekIsUUFBTyxPQUFPQSxRQUFNLE9BQU8sY0FBYztBQUMxQztBQUNELFNBQVMsZ0JBQWdCQSxTQUFPO0FBQzlCLFFBQU9BLFlBQVUsUUFBUSxPQUFPQSxZQUFVO0FBQzNDO0FBQ0QsU0FBUyxRQUFRLFFBQVE7Q0FDdkIsTUFBTSxTQUFTLE9BQU8sc0JBQXNCLE9BQU87Q0FDbkQsY0FBYyxRQUFRLENBQUMsUUFBTSxPQUFPLFVBQVUscUJBQXFCLEtBQUssUUFBUSxJQUFJLENBQUM7Q0FDckYsT0FBTyxLQUFLLEdBQUcsT0FBTyxLQUFLLE9BQU8sQ0FBQztBQUNuQyxRQUFPO0FBQ1I7Ozs7OztHQ3hGRyxTQUFTLE9BQU8sWUFBWTtBQUM5QixRQUFPLGFBQWEsTUFBTSxLQUFLLGFBQWEsUUFBUSxLQUFLLGFBQWEsUUFBUTtBQUMvRTtBQUNELElBQWEsVUFBYixNQUFxQjtDQUNuQixjQUFjO0NBQ2QsWUFBWTtDQUNaO0NBQ0EsWUFBWSxRQUFPO0VBQ2pCLEtBQUtDLFVBQVU7Q0FDaEI7Q0FDRCxJQUFJLFdBQVc7QUFDYixTQUFPLEtBQUtDO0NBQ2I7Q0FDRCxJQUFJLFNBQVM7QUFDWCxTQUFPLEtBQUtEO0NBQ2I7Ozs7SUFJRyxLQUFLLFFBQVEsR0FBRztBQUNsQixTQUFPLEtBQUtBLFFBQVEsS0FBS0MsWUFBWSxVQUFVO0NBQ2hEOzs7OztJQUtHLE1BQU0sT0FBTyxLQUFLO0FBQ3BCLFNBQU8sS0FBS0QsUUFBUSxNQUFNLEtBQUtDLFlBQVksT0FBTyxLQUFLQSxZQUFZLElBQUk7Q0FDeEU7OztJQUdHLEtBQUssUUFBUSxHQUFHO0VBQ2xCLEtBQUtBLGFBQWE7Q0FDbkI7Q0FDRCxrQkFBa0I7QUFDaEIsU0FBTSxLQUFLQyxZQUFZLEtBQUssS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxFQUNyRCxLQUFLLE1BQU07QUFHYixNQUFJLENBQUMsS0FBSyxrQkFBa0IsSUFBSSxLQUFLLEtBQUssS0FBSyxNQUFNLENBQUMsRUFBRTtHQUN0RCxNQUFNLFVBQVUsUUFBUSxLQUFLLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxTQUFTLEdBQUc7R0FDOUQsTUFBTSxXQUFXLEtBQUtEO0FBQ3RCLFNBQU0sSUFBSSxZQUFZLENBQUMsbUVBQW1FLEVBQUUsU0FBUyxLQUFLLEVBQUUsUUFBUSxFQUFFLENBQUM7RUFDeEg7Q0FDRjtDQUNELGNBQWMsVUFBVSxFQUN0QixjQUFjLEtBQ2YsR0FBRTtBQUNELFNBQU0sQ0FBQyxLQUFLLEtBQUssRUFBQztHQUNoQixNQUFNLE9BQU8sS0FBSyxNQUFNO0FBQ3hCLE9BQUksS0FBS0MsWUFBWSxLQUFLLEtBQUssSUFBSSxLQUFLLGtCQUFrQixFQUN4RCxLQUFLLE1BQU07WUFDRixRQUFRLGdCQUFnQixLQUFLLE1BQU0sS0FBSyxJQUVqRCxRQUFNLENBQUMsS0FBSyxrQkFBa0IsSUFBSSxDQUFDLEtBQUssS0FBSyxFQUMzQyxLQUFLLE1BQU07T0FHYjtFQUVIO0NBQ0Y7OztJQUdHLE1BQU07QUFDUixTQUFPLEtBQUtELGFBQWEsS0FBS0QsUUFBUTtDQUN2QztDQUNELG1CQUFtQjtBQUNqQixTQUFPLEtBQUssTUFBTSxLQUFLLFFBQVEsS0FBSyxXQUFXLE9BQU87Q0FDdkQ7Q0FDRCxXQUFXLGNBQWM7QUFDdkIsU0FBTyxLQUFLQSxRQUFRLFdBQVcsY0FBYyxLQUFLQyxVQUFVO0NBQzdEO0NBQ0QsTUFBTSxRQUFRO0FBQ1osTUFBSSxDQUFDLE9BQU8sT0FDVixPQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLGdDQUFnQyxDQUFDO0VBRXBFLE9BQU8sWUFBWSxLQUFLQTtBQUN4QixTQUFPLEtBQUtELFFBQVEsTUFBTSxPQUFPO0NBQ2xDO0FBQ0Y7QUFJRCxTQUFTLFFBQVEsTUFBTTtBQUNyQixRQUFPO0VBQ0wsSUFBSTtFQUNKO0NBQ0Q7QUFDRjtBQUNELFNBQVMsVUFBVTtBQUNqQixRQUFPLEVBQ0wsSUFBSSxNQUNMO0FBQ0Y7Ozs7O0dBS0csU0FBZ0IsT0FBT0csUUFBTSxTQUFTLENBQUUsR0FBRTtBQUM1QyxRQUFPQSxPQUFLLFlBQVksQ0FBQyxLQUFLLFNBQU8sR0FDaEMsTUFBTSxJQUNSLElBQUcsT0FBTztBQUNkO0FBQ0QsU0FBUyxTQUFTQyxTQUFPO0FBQ3ZCLFFBQU8sT0FBT0EsWUFBVSxZQUFZQSxZQUFVO0FBQy9DO0FBQ0QsU0FBUyxlQUFlLFFBQVFELFFBQU07Q0FDcEMsTUFBTSxNQUFNQSxPQUFLO0FBQ2pCLEtBQUksQ0FBQyxJQUNILE9BQU0sSUFBSSxNQUFNO0FBRWxCLFFBQU8sT0FBTztBQUNmO0FBQ0QsU0FBUyxnQkFBZ0IsUUFBUUUsU0FBTztDQUN0QyxNQUFNLEVBQUUsY0FBTSxjQUFNLGdCQUFPLEdBQUdBO0NBQzlCLE1BQU0sZUFBZSxlQUFlLFFBQVFGLE9BQUs7QUFDakQsS0FBSSxpQkFBaUIsT0FDbkIsUUFBTyxPQUFPLE9BQU8sUUFBUSxPQUFPQSxRQUFNQyxRQUFNLENBQUM7QUFFbkQsS0FBSSxNQUFNLFFBQVEsYUFBYSxFQUFFO0VBQy9CLE1BQU1FLFNBQU8sYUFBYSxHQUFHLEdBQUc7RUFDaEMsV0FBV0EsUUFBTTtHQUNmO0dBQ0EsTUFBTUgsT0FBSyxNQUFNLEVBQUU7R0FDbkI7RUFDRCxFQUFDO0FBQ0YsU0FBTztDQUNSO0FBQ0QsS0FBSSxTQUFTLGFBQWEsRUFBRTtFQUMxQixXQUFXLGNBQWM7R0FDdkI7R0FDQSxNQUFNQSxPQUFLLE1BQU0sRUFBRTtHQUNuQjtFQUNELEVBQUM7QUFDRixTQUFPO0NBQ1I7QUFDRCxPQUFNLElBQUksTUFBTTtBQUNqQjtBQUNELFNBQVMscUJBQXFCLFFBQVFFLFNBQU87Q0FDM0MsTUFBTSxFQUFFLGNBQU0sY0FBTSxnQkFBTyxHQUFHQTtDQUM5QixNQUFNLGVBQWUsZUFBZSxRQUFRRixPQUFLO0FBQ2pELEtBQUksaUJBQWlCLE9BQ25CLFFBQU8sT0FBTyxPQUFPLFFBQVEsT0FBT0EsUUFBTSxDQUN4Q0MsT0FDRCxFQUFDLENBQUM7QUFFTCxLQUFJLE1BQU0sUUFBUSxhQUFhLEVBQUU7RUFDL0IsYUFBYSxLQUFLQSxRQUFNO0FBQ3hCLFNBQU87Q0FDUjtBQUNELEtBQUksU0FBUyxhQUFhLEVBQUU7RUFDMUIsV0FBVyxjQUFjO0dBQ3ZCO0dBQ0EsTUFBTUQsT0FBSyxNQUFNLEVBQUU7R0FDbkI7RUFDRCxFQUFDO0FBQ0YsU0FBTztDQUNSO0FBQ0QsT0FBTSxJQUFJLE1BQU07QUFDakI7QUFDRCxTQUFnQixXQUFXLFFBQVEsTUFBTTtBQUN2QyxTQUFPLEtBQUssTUFBWjtFQUNFLEtBQUssUUFDSCxRQUFPLFVBQVUsUUFBUSxLQUFLLE1BQU07RUFDdEMsS0FBSyxRQUNILFFBQU8sZ0JBQWdCLFFBQVEsS0FBSztFQUN0QyxLQUFLLGFBQ0gsUUFBTyxxQkFBcUIsUUFBUSxLQUFLO0NBQzVDO0FBQ0Y7QUFLRCxTQUFTLEdBQUcsU0FBUztBQUNuQixRQUFPLENBQUMsWUFBVTtBQUNoQixPQUFLLE1BQU1JLFdBQVMsU0FBUTtHQUMxQixNQUFNLFNBQVNBLFFBQU0sUUFBUTtBQUM3QixPQUFJLE9BQU8sR0FBSSxRQUFPO0VBQ3ZCO0FBQ0QsU0FBTyxTQUFTO0NBQ2pCO0FBQ0Y7Ozs7R0FJRyxTQUFTQyxPQUFLLFFBQVEsV0FBVztDQUNuQyxNQUFNLFlBQVksVUFBVSxVQUFVO0FBQ3RDLFFBQU8sQ0FBQyxZQUFVO0VBQ2hCLE1BQU0sTUFBTSxDQUFFO0VBQ2QsTUFBTSxRQUFRLE9BQU8sUUFBUTtBQUM3QixNQUFJLENBQUMsTUFBTSxHQUFJLFFBQU8sUUFBUSxJQUFJO0VBQ2xDLElBQUksS0FBSyxNQUFNLEtBQUs7QUFDcEIsU0FBTSxDQUFDLFFBQVEsS0FBSyxFQUFDO0FBQ25CLE9BQUksQ0FBQyxVQUFVLFFBQVEsQ0FBQyxHQUFJO0dBQzVCLE1BQU0sU0FBUyxPQUFPLFFBQVE7QUFDOUIsT0FBSSxDQUFDLE9BQU8sR0FDVixPQUFNLElBQUksWUFBWSxDQUFDLHFCQUFxQixFQUFFLFVBQVUsQ0FBQyxDQUFDO0dBRTVELElBQUksS0FBSyxPQUFPLEtBQUs7RUFDdEI7QUFDRCxTQUFPLFFBQVEsSUFBSTtDQUNwQjtBQUNGOzs7O0dBSUcsU0FBUyxNQUFNLFFBQVEsV0FBVztDQUNwQyxNQUFNLFlBQVksVUFBVSxVQUFVO0FBQ3RDLFFBQU8sQ0FBQyxZQUFVO0VBQ2hCLE1BQU0sUUFBUSxPQUFPLFFBQVE7QUFDN0IsTUFBSSxDQUFDLE1BQU0sR0FBSSxRQUFPLFNBQVM7RUFDL0IsTUFBTSxNQUFNLENBQ1YsTUFBTSxJQUNQO0FBQ0QsU0FBTSxDQUFDLFFBQVEsS0FBSyxFQUFDO0FBQ25CLE9BQUksQ0FBQyxVQUFVLFFBQVEsQ0FBQyxHQUFJO0dBQzVCLE1BQU0sU0FBUyxPQUFPLFFBQVE7QUFDOUIsT0FBSSxDQUFDLE9BQU8sR0FDVixPQUFNLElBQUksWUFBWSxDQUFDLHFCQUFxQixFQUFFLFVBQVUsQ0FBQyxDQUFDO0dBRTVELElBQUksS0FBSyxPQUFPLEtBQUs7RUFDdEI7QUFDRCxTQUFPLFFBQVEsSUFBSTtDQUNwQjtBQUNGO0FBQ0QsU0FBUyxHQUFHLFdBQVcsV0FBVyxhQUFhO0NBQzdDLE1BQU0sWUFBWSxVQUFVLFVBQVU7QUFDdEMsUUFBTyxDQUFDLFlBQVU7RUFDaEIsTUFBTSxXQUFXLFFBQVE7RUFDekIsTUFBTSxNQUFNLFVBQVUsUUFBUTtBQUM5QixNQUFJLENBQUMsSUFBSSxHQUFJLFFBQU8sU0FBUztFQUM3QixNQUFNQyxRQUFNLFVBQVUsUUFBUTtBQUM5QixNQUFJLENBQUNBLE1BQUksR0FDUCxPQUFNLElBQUksWUFBWSxDQUFDLDZCQUE2QixFQUFFLFVBQVUsQ0FBQyxDQUFDO0VBRXBFLE1BQU1MLFVBQVEsWUFBWSxRQUFRO0FBQ2xDLE1BQUksQ0FBQ0EsUUFBTSxJQUFJO0dBQ2IsTUFBTSxlQUFlLFFBQVEsT0FBTyxRQUFRLE1BQU0sUUFBUSxTQUFTO0dBQ25FLE1BQU0sY0FBYyxlQUFlLElBQUksZUFBZSxRQUFRLE9BQU87R0FDckUsTUFBTSxPQUFPLFFBQVEsT0FBTyxNQUFNLFVBQVUsWUFBWTtBQUN4RCxTQUFNLElBQUksWUFBWSxDQUFDLDRCQUE0QixFQUFFLEtBQUssQ0FBQyxDQUFDO0VBQzdEO0FBQ0QsU0FBTyxRQUFRLE9BQU8sSUFBSSxNQUFNQSxRQUFNLEtBQUssQ0FBQztDQUM3QztBQUNGO0FBQ0QsU0FBU00sUUFBTSxRQUFRO0FBQ3JCLFFBQU8sQ0FBQyxZQUFVO0VBQ2hCLE1BQU0sU0FBUyxPQUFPLFFBQVE7QUFDOUIsTUFBSSxDQUFDLE9BQU8sR0FBSSxRQUFPLFNBQVM7RUFDaEMsSUFBSSxPQUFPLENBQUU7QUFDYixPQUFLLE1BQU0sVUFBVSxPQUFPLEtBQzFCLEtBQUksT0FBTyxXQUFXLFlBQVksV0FBVyxNQUMzQyxPQUFPLFVBQVUsTUFBTSxPQUFPO0FBR2xDLFNBQU8sUUFBUSxLQUFLO0NBQ3JCO0FBQ0Y7QUFDRCxTQUFTLE9BQU8sUUFBUTtBQUN0QixRQUFPLENBQUMsWUFBVTtFQUNoQixNQUFNLE9BQU8sQ0FBRTtBQUNmLFNBQU0sQ0FBQyxRQUFRLEtBQUssRUFBQztHQUNuQixNQUFNLFNBQVMsT0FBTyxRQUFRO0FBQzlCLE9BQUksQ0FBQyxPQUFPLEdBQUk7R0FDaEIsS0FBSyxLQUFLLE9BQU8sS0FBSztHQUN0QixRQUFRLGVBQWU7RUFDeEI7QUFDRCxNQUFJLEtBQUssV0FBVyxFQUFHLFFBQU8sU0FBUztBQUN2QyxTQUFPLFFBQVEsS0FBSztDQUNyQjtBQUNGO0FBQ0QsU0FBUyxTQUFTLE1BQU0sUUFBUSxPQUFPO0NBQ3JDLE1BQU0sT0FBTyxVQUFVLEtBQUs7Q0FDNUIsTUFBTSxRQUFRLFVBQVUsTUFBTTtBQUM5QixRQUFPLENBQUMsWUFBVTtBQUNoQixNQUFJLENBQUMsS0FBSyxRQUFRLENBQUMsR0FDakIsUUFBTyxTQUFTO0VBRWxCLE1BQU0sU0FBUyxPQUFPLFFBQVE7QUFDOUIsTUFBSSxDQUFDLE9BQU8sR0FDVixPQUFNLElBQUksWUFBWSxDQUFDLHFCQUFxQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRXZELE1BQUksQ0FBQyxNQUFNLFFBQVEsQ0FBQyxHQUNsQixPQUFNLElBQUksWUFBWSxDQUFDLGVBQWUsRUFBRSxNQUFNLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRS9FLFNBQU8sUUFBUSxPQUFPLEtBQUs7Q0FDNUI7QUFDRjtBQUNELFNBQVMsVUFBVSxLQUFLO0FBQ3RCLFFBQU8sQ0FBQyxZQUFVO0VBQ2hCLFFBQVEsaUJBQWlCO0FBQ3pCLE1BQUksQ0FBQyxRQUFRLFdBQVcsSUFBSSxDQUFFLFFBQU8sU0FBUztFQUM5QyxRQUFRLEtBQUssSUFBSSxPQUFPO0VBQ3hCLFFBQVEsaUJBQWlCO0FBQ3pCLFNBQU8sUUFBUSxPQUFVO0NBQzFCO0FBQ0Y7QUFJRCxNQUFNLGtCQUFrQjtBQUN4QixTQUFnQixRQUFRLFNBQVM7Q0FDL0IsUUFBUSxpQkFBaUI7Q0FDekIsTUFBTSxNQUFNLFFBQVEsTUFBTSxnQkFBZ0IsR0FBRztBQUM3QyxLQUFJLENBQUMsSUFBSyxRQUFPLFNBQVM7Q0FDMUIsUUFBUSxLQUFLLElBQUksT0FBTztBQUN4QixRQUFPLFFBQVEsSUFBSTtBQUNwQjtBQUNELFNBQVMsZUFBZSxTQUFTO0FBQy9CLEtBQUksUUFBUSxNQUFNLEtBQUssS0FBTSxRQUFPLFNBQVM7Q0FDN0MsUUFBUSxNQUFNO0FBRWQsU0FBTyxRQUFRLE1BQU0sRUFBckI7RUFDRSxLQUFLO0dBQ0gsUUFBUSxNQUFNO0FBQ2QsVUFBTyxRQUFRLEtBQUs7RUFDdEIsS0FBSztHQUNILFFBQVEsTUFBTTtBQUNkLFVBQU8sUUFBUSxJQUFLO0VBQ3RCLEtBQUs7R0FDSCxRQUFRLE1BQU07QUFDZCxVQUFPLFFBQVEsS0FBSztFQUN0QixLQUFLO0dBQ0gsUUFBUSxNQUFNO0FBQ2QsVUFBTyxRQUFRLEtBQUs7RUFDdEIsS0FBSztHQUNILFFBQVEsTUFBTTtBQUNkLFVBQU8sUUFBUSxLQUFLO0VBQ3RCLEtBQUs7RUFDTCxLQUFLLEtBQ0g7R0FFRSxNQUFNLGVBQWUsUUFBUSxNQUFNLEtBQUssTUFBTSxJQUFJO0dBQ2xELE1BQU0sWUFBWSxTQUFTLE9BQU8sUUFBUSxNQUFNLEdBQUcsSUFBSSxhQUFhLEVBQUUsR0FBRztHQUN6RSxNQUFNLE1BQU0sT0FBTyxjQUFjLFVBQVU7R0FDM0MsUUFBUSxLQUFLLGVBQWUsRUFBRTtBQUM5QixVQUFPLFFBQVEsSUFBSTtFQUNwQjtFQUNILEtBQUs7R0FDSCxRQUFRLE1BQU07QUFDZCxVQUFPLFFBQVEsS0FBSTtFQUNyQixLQUFLO0dBQ0gsUUFBUSxNQUFNO0FBQ2QsVUFBTyxRQUFRLEtBQUs7RUFDdEIsUUFDRSxPQUFNLElBQUksWUFBWSxDQUFDLDJCQUEyQixFQUFFLFFBQVEsTUFBTSxFQUFFO0NBQ3ZFO0FBQ0Y7QUFDRCxTQUFnQixZQUFZLFNBQVM7Q0FDbkMsUUFBUSxpQkFBaUI7QUFDekIsS0FBSSxRQUFRLE1BQU0sS0FBSyxLQUFLLFFBQU8sU0FBUztDQUM1QyxRQUFRLE1BQU07Q0FDZCxNQUFNLE1BQU0sQ0FBRTtBQUNkLFFBQU0sUUFBUSxNQUFNLEtBQUssUUFBTyxDQUFDLFFBQVEsS0FBSyxFQUFDO0FBQzdDLE1BQUksUUFBUSxNQUFNLEtBQUssS0FDckIsT0FBTSxJQUFJLFlBQVk7RUFFeEIsTUFBTSxjQUFjLGVBQWUsUUFBUTtBQUMzQyxNQUFJLFlBQVksSUFDZCxJQUFJLEtBQUssWUFBWSxLQUFLO09BQ3JCO0dBQ0wsSUFBSSxLQUFLLFFBQVEsTUFBTSxDQUFDO0dBQ3hCLFFBQVEsTUFBTTtFQUNmO0NBQ0Y7QUFDRCxLQUFJLFFBQVEsS0FBSyxDQUNmLE9BQU0sSUFBSSxZQUFZLENBQUMsbUNBQW1DLEVBQUUsSUFBSSxLQUFLLEdBQUcsRUFBRTtDQUU1RSxRQUFRLE1BQU07QUFDZCxRQUFPLFFBQVEsSUFBSSxLQUFLLEdBQUcsQ0FBQztBQUM3QjtBQUNELFNBQWdCLGNBQWMsU0FBUztDQUNyQyxRQUFRLGlCQUFpQjtBQUN6QixLQUFJLFFBQVEsTUFBTSxLQUFLLElBQUssUUFBTyxTQUFTO0NBQzVDLFFBQVEsTUFBTTtDQUNkLE1BQU0sTUFBTSxDQUFFO0FBQ2QsUUFBTSxRQUFRLE1BQU0sS0FBSyxPQUFPLENBQUMsUUFBUSxLQUFLLEVBQUM7QUFDN0MsTUFBSSxRQUFRLE1BQU0sS0FBSyxLQUNyQixPQUFNLElBQUksWUFBWTtFQUV4QixJQUFJLEtBQUssUUFBUSxNQUFNLENBQUM7RUFDeEIsUUFBUSxNQUFNO0NBQ2Y7QUFDRCxLQUFJLFFBQVEsS0FBSyxDQUNmLE9BQU0sSUFBSSxZQUFZLENBQUMsbUNBQW1DLEVBQUUsSUFBSSxLQUFLLEdBQUcsRUFBRTtDQUU1RSxRQUFRLE1BQU07QUFDZCxRQUFPLFFBQVEsSUFBSSxLQUFLLEdBQUcsQ0FBQztBQUM3QjtBQUNELFNBQWdCLHFCQUFxQixTQUFTO0NBQzVDLFFBQVEsaUJBQWlCO0FBQ3pCLEtBQUksQ0FBQyxRQUFRLFdBQVcsU0FBTSxDQUFFLFFBQU8sU0FBUztDQUNoRCxRQUFRLEtBQUssRUFBRTtBQUNmLEtBQUksUUFBUSxNQUFNLEtBQUssTUFFckIsUUFBUSxNQUFNO1VBQ0wsUUFBUSxXQUFXLE9BQU8sRUFFbkMsUUFBUSxLQUFLLEVBQUU7Q0FFakIsTUFBTSxNQUFNLENBQUU7QUFDZCxRQUFNLENBQUMsUUFBUSxXQUFXLFNBQU0sSUFBSSxDQUFDLFFBQVEsS0FBSyxFQUFDO0FBRWpELE1BQUksUUFBUSxXQUFXLE9BQU8sRUFBRTtHQUM5QixRQUFRLE1BQU07R0FDZCxRQUFRLGNBQWMsRUFDcEIsY0FBYyxNQUNmLEVBQUM7QUFDRjtFQUNELFdBQVUsUUFBUSxXQUFXLFNBQVMsRUFBRTtHQUN2QyxRQUFRLE1BQU07R0FDZCxRQUFRLGNBQWMsRUFDcEIsY0FBYyxNQUNmLEVBQUM7QUFDRjtFQUNEO0VBQ0QsTUFBTSxjQUFjLGVBQWUsUUFBUTtBQUMzQyxNQUFJLFlBQVksSUFDZCxJQUFJLEtBQUssWUFBWSxLQUFLO09BQ3JCO0dBQ0wsSUFBSSxLQUFLLFFBQVEsTUFBTSxDQUFDO0dBQ3hCLFFBQVEsTUFBTTtFQUNmO0NBQ0Y7QUFDRCxLQUFJLFFBQVEsS0FBSyxDQUNmLE9BQU0sSUFBSSxZQUFZLENBQUMsa0NBQWtDLEVBQUUsSUFBSSxLQUFLLEdBQUcsRUFBRTtBQUczRSxLQUFJLFFBQVEsS0FBSyxFQUFFLEtBQUssTUFBSztFQUMzQixJQUFJLEtBQUssS0FBSTtFQUNiLFFBQVEsTUFBTTtDQUNmO0NBQ0QsUUFBUSxLQUFLLEVBQUU7QUFDZixRQUFPLFFBQVEsSUFBSSxLQUFLLEdBQUcsQ0FBQztBQUM3QjtBQUNELFNBQWdCLHVCQUF1QixTQUFTO0NBQzlDLFFBQVEsaUJBQWlCO0FBQ3pCLEtBQUksQ0FBQyxRQUFRLFdBQVcsTUFBTSxDQUFFLFFBQU8sU0FBUztDQUNoRCxRQUFRLEtBQUssRUFBRTtBQUNmLEtBQUksUUFBUSxNQUFNLEtBQUssTUFFckIsUUFBUSxNQUFNO1VBQ0wsUUFBUSxXQUFXLE9BQU8sRUFFbkMsUUFBUSxLQUFLLEVBQUU7Q0FFakIsTUFBTSxNQUFNLENBQUU7QUFDZCxRQUFNLENBQUMsUUFBUSxXQUFXLE1BQU0sSUFBSSxDQUFDLFFBQVEsS0FBSyxFQUFDO0VBQ2pELElBQUksS0FBSyxRQUFRLE1BQU0sQ0FBQztFQUN4QixRQUFRLE1BQU07Q0FDZjtBQUNELEtBQUksUUFBUSxLQUFLLENBQ2YsT0FBTSxJQUFJLFlBQVksQ0FBQyxrQ0FBa0MsRUFBRSxJQUFJLEtBQUssR0FBRyxFQUFFO0FBRzNFLEtBQUksUUFBUSxLQUFLLEVBQUUsS0FBSyxLQUFLO0VBQzNCLElBQUksS0FBSyxJQUFJO0VBQ2IsUUFBUSxNQUFNO0NBQ2Y7Q0FDRCxRQUFRLEtBQUssRUFBRTtBQUNmLFFBQU8sUUFBUSxJQUFJLEtBQUssR0FBRyxDQUFDO0FBQzdCO0FBQ0QsTUFBTSxpQkFBaUI7QUFDdkIsU0FBZ0IsUUFBUSxTQUFTO0NBQy9CLFFBQVEsaUJBQWlCO0NBQ3pCLE1BQU0sUUFBUSxRQUFRLE1BQU0sZUFBZTtBQUMzQyxLQUFJLENBQUMsTUFBTyxRQUFPLFNBQVM7Q0FDNUIsTUFBTSxTQUFTLE1BQU07Q0FDckIsUUFBUSxLQUFLLE9BQU8sT0FBTztDQUMzQixNQUFNTixVQUFRLFdBQVc7QUFDekIsUUFBTyxRQUFRQSxRQUFNO0FBQ3RCO0FBQ0QsTUFBTSxlQUFlLElBQUksSUFBSTtDQUMzQixDQUNFLE9BQ0EsUUFDRDtDQUNELENBQ0UsUUFDQSxRQUNEO0NBQ0QsQ0FDRSxRQUNBLFNBQ0Q7QUFDRjtBQUNELE1BQU0sa0JBQWtCO0FBQ3hCLFNBQWdCLFNBQVMsU0FBUztDQUNoQyxRQUFRLGlCQUFpQjtDQUN6QixNQUFNLFFBQVEsUUFBUSxNQUFNLGdCQUFnQjtBQUM1QyxLQUFJLENBQUMsTUFBTyxRQUFPLFNBQVM7Q0FDNUIsTUFBTSxTQUFTLE1BQU07Q0FDckIsUUFBUSxLQUFLLE9BQU8sT0FBTztDQUMzQixNQUFNQSxVQUFRLGFBQWEsSUFBSSxPQUFPO0FBQ3RDLFFBQU8sUUFBUUEsUUFBTTtBQUN0QjtBQUNELE1BQU0sYUFBYTtBQUNuQixTQUFnQixJQUFJLFNBQVM7Q0FDM0IsUUFBUSxpQkFBaUI7Q0FDekIsTUFBTSxRQUFRLFFBQVEsTUFBTSxXQUFXO0FBQ3ZDLEtBQUksQ0FBQyxNQUFPLFFBQU8sU0FBUztDQUM1QixNQUFNLFNBQVMsTUFBTTtDQUNyQixRQUFRLEtBQUssT0FBTyxPQUFPO0NBQzNCLE1BQU1BLFVBQVE7QUFDZCxRQUFPLFFBQVFBLFFBQU07QUFDdEI7QUFDRCxNQUFhLFlBQVksTUFBTSxHQUFHO0NBQ2hDO0NBQ0E7Q0FDQTtBQUNELEVBQUMsRUFBRSxJQUFJO0FBQ1IsTUFBTSxnQkFBZ0I7QUFDdEIsU0FBZ0IsT0FBTyxTQUFTO0NBQzlCLFFBQVEsaUJBQWlCO0NBQ3pCLE1BQU0sUUFBUSxRQUFRLE1BQU0sY0FBYyxHQUFHO0FBQzdDLEtBQUksQ0FBQyxNQUFPLFFBQU8sU0FBUztDQUM1QixRQUFRLEtBQUssTUFBTSxPQUFPO0NBQzFCLE1BQU1BLFVBQVEsTUFBTSxNQUFNLEVBQUUsQ0FBQyxXQUFXLEtBQUssR0FBRztDQUNoRCxNQUFNLFNBQVMsU0FBU0EsU0FBTyxFQUFFO0FBQ2pDLFFBQU8sTUFBTSxPQUFPLEdBQUcsU0FBUyxHQUFHLFFBQVEsT0FBTztBQUNuRDtBQUNELE1BQU0sZUFBZTtBQUNyQixTQUFnQixNQUFNLFNBQVM7Q0FDN0IsUUFBUSxpQkFBaUI7Q0FDekIsTUFBTSxRQUFRLFFBQVEsTUFBTSxhQUFhLEdBQUc7QUFDNUMsS0FBSSxDQUFDLE1BQU8sUUFBTyxTQUFTO0NBQzVCLFFBQVEsS0FBSyxNQUFNLE9BQU87Q0FDMUIsTUFBTUEsVUFBUSxNQUFNLE1BQU0sRUFBRSxDQUFDLFdBQVcsS0FBSyxHQUFHO0NBQ2hELE1BQU0sU0FBUyxTQUFTQSxTQUFPLEVBQUU7QUFDakMsUUFBTyxNQUFNLE9BQU8sR0FBRyxTQUFTLEdBQUcsUUFBUSxPQUFPO0FBQ25EO0FBQ0QsTUFBTSxhQUFhO0FBQ25CLFNBQWdCLElBQUksU0FBUztDQUMzQixRQUFRLGlCQUFpQjtDQUN6QixNQUFNLFFBQVEsUUFBUSxNQUFNLFdBQVcsR0FBRztBQUMxQyxLQUFJLENBQUMsTUFBTyxRQUFPLFNBQVM7Q0FDNUIsUUFBUSxLQUFLLE1BQU0sT0FBTztDQUMxQixNQUFNQSxVQUFRLE1BQU0sTUFBTSxFQUFFLENBQUMsV0FBVyxLQUFLLEdBQUc7Q0FDaEQsTUFBTSxTQUFTLFNBQVNBLFNBQU8sR0FBRztBQUNsQyxRQUFPLE1BQU0sT0FBTyxHQUFHLFNBQVMsR0FBRyxRQUFRLE9BQU87QUFDbkQ7QUFDRCxNQUFNLGlCQUFpQjtBQUN2QixTQUFnQixRQUFRLFNBQVM7Q0FDL0IsUUFBUSxpQkFBaUI7Q0FDekIsTUFBTSxRQUFRLFFBQVEsTUFBTSxlQUFlLEdBQUc7QUFDOUMsS0FBSSxDQUFDLE1BQU8sUUFBTyxTQUFTO0NBQzVCLFFBQVEsS0FBSyxNQUFNLE9BQU87Q0FDMUIsTUFBTUEsVUFBUSxNQUFNLFdBQVcsS0FBSyxHQUFHO0NBQ3ZDLE1BQU0sTUFBTSxTQUFTQSxTQUFPLEdBQUc7QUFDL0IsUUFBTyxRQUFRLElBQUk7QUFDcEI7QUFDRCxNQUFNLGVBQWU7QUFDckIsU0FBZ0IsTUFBTSxTQUFTO0NBQzdCLFFBQVEsaUJBQWlCO0NBQ3pCLE1BQU0sUUFBUSxRQUFRLE1BQU0sYUFBYSxHQUFHO0FBQzVDLEtBQUksQ0FBQyxNQUFPLFFBQU8sU0FBUztDQUM1QixRQUFRLEtBQUssTUFBTSxPQUFPO0NBQzFCLE1BQU1BLFVBQVEsTUFBTSxXQUFXLEtBQUssR0FBRztDQUN2QyxNQUFNTyxVQUFRLFdBQVdQLFFBQU07QUFDL0IsS0FBSSxNQUFNTyxRQUFNLENBQUUsUUFBTyxTQUFTO0FBQ2xDLFFBQU8sUUFBUUEsUUFBTTtBQUN0QjtBQUNELE1BQU0sbUJBQW1CO0FBQ3pCLFNBQWdCLFNBQVMsU0FBUztDQUNoQyxRQUFRLGlCQUFpQjtDQUN6QixNQUFNLFFBQVEsUUFBUSxNQUFNLGlCQUFpQjtBQUM3QyxLQUFJLENBQUMsTUFBTyxRQUFPLFNBQVM7Q0FDNUIsTUFBTSxTQUFTLE1BQU07Q0FDckIsUUFBUSxLQUFLLE9BQU8sT0FBTztDQUMzQixNQUFNLFNBQVMsTUFBTTtBQUVyQixLQUFJLE9BQU8sU0FBUyxNQUFNO0VBQ3hCLE1BQU0sT0FBTyxTQUFTLE9BQU8sSUFBSTtBQUNqQyxNQUFJLE9BQU8sR0FDVCxPQUFNLElBQUksWUFBWSxDQUFDLHFCQUFxQixFQUFFLE1BQU0sQ0FBQyxDQUFDO0VBRXhELE1BQU0sT0FBTyxTQUFTLE9BQU8sS0FBSztBQUNsQyxNQUFJLE9BQU8sTUFBTSxDQUFDLE9BQU8sS0FBSyxDQUM1QixPQUFNLElBQUksWUFBWSxDQUFDLHFCQUFxQixFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBRXpEO0NBQ0QsTUFBTSxPQUFPLElBQUksS0FBSyxPQUFPLE1BQU07QUFFbkMsS0FBSSxNQUFNLEtBQUssU0FBUyxDQUFDLENBQ3ZCLE9BQU0sSUFBSSxZQUFZLENBQUMscUJBQXFCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFFeEQsUUFBTyxRQUFRLEtBQUs7QUFDckI7QUFDRCxNQUFNLG9CQUFvQjtBQUMxQixTQUFnQixVQUFVLFNBQVM7Q0FDakMsUUFBUSxpQkFBaUI7Q0FDekIsTUFBTSxRQUFRLFFBQVEsTUFBTSxrQkFBa0IsR0FBRztBQUNqRCxLQUFJLENBQUMsTUFBTyxRQUFPLFNBQVM7Q0FDNUIsUUFBUSxLQUFLLE1BQU0sT0FBTztBQUMxQixRQUFPLFFBQVEsTUFBTTtBQUN0QjtBQUNELFNBQWdCLFdBQVcsU0FBUztDQUNsQyxRQUFRLGlCQUFpQjtBQUN6QixLQUFJLFFBQVEsTUFBTSxLQUFLLElBQUssUUFBTyxTQUFTO0NBQzVDLFFBQVEsTUFBTTtDQUNkLE1BQU0sUUFBUSxDQUFFO0FBQ2hCLFFBQU0sQ0FBQyxRQUFRLEtBQUssRUFBQztFQUNuQixRQUFRLGVBQWU7RUFDdkIsTUFBTSxTQUFTLE1BQU0sUUFBUTtBQUM3QixNQUFJLENBQUMsT0FBTyxHQUFJO0VBQ2hCLE1BQU0sS0FBSyxPQUFPLEtBQUs7RUFDdkIsUUFBUSxpQkFBaUI7QUFFekIsTUFBSSxRQUFRLE1BQU0sS0FBSyxJQUFLO0VBQzVCLFFBQVEsTUFBTTtDQUNmO0NBQ0QsUUFBUSxlQUFlO0FBQ3ZCLEtBQUksUUFBUSxNQUFNLEtBQUssSUFBSyxPQUFNLElBQUksWUFBWTtDQUNsRCxRQUFRLE1BQU07QUFDZCxRQUFPLFFBQVEsTUFBTTtBQUN0QjtBQUNELFNBQWdCLFlBQVksU0FBUztDQUNuQyxRQUFRLGVBQWU7QUFDdkIsS0FBSSxRQUFRLEtBQUssRUFBRSxLQUFLLEtBQUs7RUFDM0IsUUFBUSxLQUFLLEVBQUU7QUFDZixTQUFPLFFBQVEsQ0FBRSxFQUFDO0NBQ25CO0NBQ0QsTUFBTSxRQUFRLFNBQVMsS0FBS0gsT0FBSyxNQUFNLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUTtBQUMxRCxLQUFJLENBQUMsTUFBTSxHQUFJLFFBQU8sU0FBUztDQUMvQixJQUFJSCxVQUFRLENBQUU7QUFDZCxNQUFLLE1BQU1PLFVBQVEsTUFBTSxNQUN2QlAsVUFBUSxVQUFVQSxTQUFPTyxPQUFLO0FBRWhDLFFBQU8sUUFBUVAsUUFBTTtBQUN0QjtBQUNELE1BQWEsUUFBUSxHQUFHO0NBQ3RCO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0FBQ0QsRUFBQztBQUNGLE1BQWEsT0FBTyxHQUFHLFdBQVcsS0FBSyxNQUFNO0FBQzdDLFNBQWdCLE1BQU0sU0FBUztDQUM3QixRQUFRLGVBQWU7Q0FDdkIsTUFBTSxTQUFTSyxRQUFNLE9BQU8sS0FBSyxDQUFDLENBQUMsUUFBUTtBQUMzQyxLQUFJLE9BQU8sR0FBSSxRQUFPLFFBQVE7RUFDNUIsTUFBTTtFQUNOLE9BQU8sT0FBTztDQUNmLEVBQUM7QUFDRixRQUFPLFNBQVM7QUFDakI7QUFDRCxNQUFhLGNBQWMsU0FBUyxLQUFLLFdBQVcsSUFBSTtBQUN4RCxTQUFnQixNQUFNLFNBQVM7Q0FDN0IsUUFBUSxlQUFlO0NBQ3ZCLE1BQU0sU0FBUyxZQUFZLFFBQVE7QUFDbkMsS0FBSSxDQUFDLE9BQU8sR0FBSSxRQUFPLFNBQVM7Q0FDaEMsUUFBUSxlQUFlO0NBQ3ZCLE1BQU0sSUFBSSxNQUFNLFFBQVE7QUFDeEIsUUFBTyxRQUFRO0VBQ2IsTUFBTTtFQUNOLE1BQU0sT0FBTztFQUNiLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxRQUFRLENBQUU7Q0FDaEMsRUFBQztBQUNIO0FBQ0QsTUFBYSxtQkFBbUIsU0FBUyxNQUFNLFdBQVcsS0FBSztBQUMvRCxTQUFnQixXQUFXLFNBQVM7Q0FDbEMsUUFBUSxlQUFlO0NBQ3ZCLE1BQU0sU0FBUyxpQkFBaUIsUUFBUTtBQUN4QyxLQUFJLENBQUMsT0FBTyxHQUFJLFFBQU8sU0FBUztDQUNoQyxRQUFRLGVBQWU7Q0FDdkIsTUFBTSxJQUFJLE1BQU0sUUFBUTtBQUN4QixRQUFPLFFBQVE7RUFDYixNQUFNO0VBQ04sTUFBTSxPQUFPO0VBQ2IsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLFFBQVEsQ0FBRTtDQUNoQyxFQUFDO0FBQ0g7QUFDRCxTQUFnQixLQUFLLFNBQVM7Q0FDNUIsTUFBTSxTQUFTLE9BQU8sR0FBRztFQUN2QjtFQUNBO0VBQ0E7Q0FDRCxFQUFDLENBQUMsQ0FBQyxRQUFRO0FBQ1osS0FBSSxDQUFDLE9BQU8sR0FBSSxRQUFPLFFBQVEsQ0FBRSxFQUFDO0NBQ2xDLE1BQU0sT0FBTyxPQUFPLEtBQUssT0FBTyxZQUFZLENBQUUsRUFBQztBQUMvQyxRQUFPLFFBQVEsS0FBSztBQUNyQjtBQUNELFNBQVMsd0JBQXdCLFNBQVMsU0FBUztDQUNqRCxNQUFNLFNBQVMsUUFBUSxPQUFPLE1BQU0sR0FBRyxRQUFRLFNBQVM7Q0FDeEQsTUFBTSxRQUFRLE9BQU8sTUFBTSxLQUFLO0NBQ2hDLE1BQU0sTUFBTSxNQUFNO0NBQ2xCLE1BQU0sU0FBUyxNQUFNLEdBQUcsR0FBRyxFQUFFLFVBQVU7QUFDdkMsUUFBTyxDQUFDLG9CQUFvQixFQUFFLElBQUksU0FBUyxFQUFFLE9BQU8sRUFBRSxFQUFFLFNBQVM7QUFDbEU7QUFDRCxTQUFnQixjQUFjLFFBQVE7QUFDcEMsUUFBTyxDQUFDLGVBQWE7RUFDbkIsTUFBTSxVQUFVLElBQUksUUFBUTtBQUM1QixNQUFJO0dBQ0YsTUFBTSxTQUFTLE9BQU8sUUFBUTtBQUM5QixPQUFJLE9BQU8sTUFBTSxRQUFRLEtBQUssQ0FBRSxRQUFPLE9BQU87R0FDOUMsTUFBTSxVQUFVLENBQUMsdUJBQXVCLEVBQUUsUUFBUSxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzNELFNBQU0sSUFBSSxZQUFZLHdCQUF3QixTQUFTLFFBQVE7RUFDaEUsU0FBUSxPQUFPO0FBQ2QsT0FBSSxpQkFBaUIsTUFDbkIsT0FBTSxJQUFJLFlBQVksd0JBQXdCLFNBQVMsTUFBTSxRQUFRO0dBRXZFLE1BQU0sVUFBVTtBQUNoQixTQUFNLElBQUksWUFBWSx3QkFBd0IsU0FBUyxRQUFRO0VBQ2hFO0NBQ0Y7QUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQy9yQkcsU0FBZ0JHLFFBQU0sWUFBWTtBQUNwQyxRQUFPLGNBQWMsS0FBSyxDQUFDLFdBQVc7QUFDdkM7Ozs7QUNuQkQsSUFBc0Isb0JBQXRCLGNBQWdEQyxrQkFBUTtDQUN0RCxPQUFPLFFBQVEsQ0FBQyxDQUFDLFFBQVMsQ0FBQztDQUUzQixPQUFPLFFBQVFBLGtCQUFRLE1BQU0sRUFDM0IsYUFBYSw2QkFDZCxFQUFDO0NBRUYsTUFBTUMsaUJBQU8sT0FBTyxTQUFTLFFBQVEsS0FBSyxFQUFFLEVBQzFDLGFBQ0UscUhBQ0gsRUFBQztDQUVGLGFBQXNCQSxpQkFBTyxPQUFPLG9CQUFvQixFQUN0RCxhQUFhLGtDQUNkLEVBQUM7Q0FFRixrQkFBa0JBLGlCQUFPLE9BQU8sdUJBQXVCLGdCQUFnQixFQUNyRSxhQUFhLHlCQUNkLEVBQUM7Q0FFRixTQUFTQSxpQkFBTyxPQUFPLGFBQWEsT0FBTyxFQUN6QyxhQUFhLGdEQUNkLEVBQUM7Q0FFRixTQUFrQkEsaUJBQU8sT0FBTyxhQUFhLEVBQzNDLGFBQWEsOEJBQ2QsRUFBQztDQUVGLGFBQXNCQSxpQkFBTyxPQUFPLG9CQUFvQixFQUN0RCxhQUFhLG1DQUNkLEVBQUM7Q0FFRixjQUF1QkEsaUJBQU8sT0FBTyxrQkFBa0IsRUFDckQsYUFBYSxzQ0FDZCxFQUFDO0NBRUYsZUFBZUEsaUJBQU8sT0FBTyxtQkFBbUIsY0FBYyxFQUM1RCxhQUFhLHVCQUNkLEVBQUM7Q0FFRixhQUFzQkEsaUJBQU8sT0FBTyxnQkFBZ0IsRUFDbEQsYUFBYSxvQ0FDZCxFQUFDO0NBRUYsY0FBdUJBLGlCQUFPLE9BQU8saUJBQWlCLEVBQ3BELGFBQWEscUNBQ2QsRUFBQztDQUVGLGFBQWE7QUFDWCxTQUFPO0dBQ0wsS0FBSyxLQUFLO0dBQ1YsWUFBWSxLQUFLO0dBQ2pCLGlCQUFpQixLQUFLO0dBQ3RCLFFBQVEsS0FBSztHQUNiLE1BQU0sS0FBSztHQUNYLFlBQVksS0FBSztHQUNqQixhQUFhLEtBQUs7R0FDbEIsY0FBYyxLQUFLO0dBQ25CLFlBQVksS0FBSztHQUNqQixhQUFhLEtBQUs7RUFDbkI7Q0FDRjtBQUNGO0FBd0RELFNBQWdCLDBCQUEwQkMsU0FBd0I7QUFDaEUsUUFBTztFQUNMLEtBQUssUUFBUSxLQUFLO0VBQ2xCLGlCQUFpQjtFQUNqQixRQUFRO0VBQ1IsY0FBYztFQUNkLEdBQUc7Q0FDSjtBQUNGOzs7O0FDdEhELGVBQXNCLGNBQWNDLGFBQTRCO0NBQzlELE1BQU0sVUFBVSwwQkFBMEIsWUFBWTtDQUN0RCxNQUFNLGFBQWEsTUFBTSxXQUFXLFFBQVE7Q0FDNUMsTUFBTSxVQUFVLFdBQVc7Q0FFM0IsTUFBTSx5Q0FBMEIsUUFBUSxLQUFLLFFBQVEsZ0JBQWdCO0NBQ3JFLE1BQU0sdUNBQXdCLFFBQVEsS0FBSyxRQUFRLGFBQWE7Q0FFaEUsTUFBTSxxQkFBcUIsTUFBTSxjQUFjLGlCQUFpQixPQUFPO0NBQ3ZFLE1BQU0sa0JBQWtCLEtBQUssTUFBTSxtQkFBbUI7Q0FFdERDLGNBQ0UsaUJBQ0FDLGVBQU9DLGFBQUssU0FBUztFQUFDO0VBQVE7RUFBZTtFQUFVO0NBQVUsRUFBQyxFQUFFQyxjQUFNLEVBQzFFLEVBQ0UsTUFBTUYsZUFDSjtFQUNFLFlBQVksUUFBUTtFQUNwQixhQUFhLFFBQVE7Q0FDdEIsR0FDREUsY0FDRCxDQUNGLEVBQ0Y7QUFFRCxLQUFJLFFBQVEsWUFBWTtFQUN0QixNQUFNLG9DQUFxQixRQUFRLEtBQUssUUFBUSxXQUFXO0VBQzNELE1BQU0sZ0JBQWdCLE1BQU0sY0FBYyxZQUFZLE9BQU87RUFDN0QsTUFBTSxhQUFhLEtBQUssTUFBTSxjQUFjO0VBQzVDLFdBQVcsYUFBYSxRQUFRO0VBQ2hDLFdBQVcsY0FBYyxRQUFRO0VBQ2pDLE1BQU0sZUFBZSxZQUFZLEtBQUssVUFBVSxZQUFZLE1BQU0sRUFBRSxDQUFDO0NBQ3RFO0NBRUQsTUFBTSxlQUNKLGlCQUNBLEtBQUssVUFBVSxpQkFBaUIsTUFBTSxFQUFFLENBQ3pDO0NBRUQsTUFBTSxjQUFjLE1BQU0sY0FBYyxlQUFlLE9BQU87Q0FDOUQsTUFBTSxZQUFZQyxRQUFVLFlBQVk7QUFHeEMsS0FBSSxVQUFVLFdBQVcsUUFBUSxZQUFZO0VBRTNDLE1BQU0sZ0JBQWdCLFFBQVEsV0FDM0IsUUFBUSxLQUFLLEdBQUcsQ0FDaEIsUUFBUSxLQUFLLElBQUksQ0FDakIsUUFBUSxNQUFNLElBQUksQ0FDbEIsYUFBYTtFQUNoQixVQUFVLFFBQVEsT0FBTztDQUMxQjtDQUdELE1BQU0scUJBQXFCQyxVQUFjLFVBQVU7Q0FFbkQsTUFBTSxlQUFlLGVBQWUsbUJBQW1CO0FBQ3ZELEtBQUksWUFBWSxRQUFRLFlBQVk7RUFDbEMsTUFBTSxvQkFBb0IsMEJBQWEsV0FBVztHQUNoRCxLQUFLLFFBQVE7R0FDYixNQUFNO0VBQ1AsRUFBQztBQUNGLE1BQUksbUJBQW1CO0dBQ3JCLE1BQU0sNkNBQ0osbUJBQ0EsYUFDQSxTQUNEO0FBQ0QsK0JBQWUsdUJBQXVCLEVBQUU7SUFDdEMsTUFBTSx1QkFBdUIsTUFBTSxjQUNqQyx3QkFDQSxPQUNEO0lBQ0QsTUFBTSxzQ0FBOEIscUJBQXFCO0FBQ3pELFFBQUksa0JBQWtCLEtBQUssVUFBVTtLQUNuQyxrQkFBa0IsSUFBSSxXQUFXLFFBQVE7S0FDekMsTUFBTSxlQUNKLDBDQUNjLG1CQUFtQjtNQUMvQixXQUFXO01BQ1gsUUFBUTtNQUNSLFVBQVU7S0FDWCxFQUFDLENBQ0g7SUFDRjtHQUNGO0VBQ0Y7RUFDRCxNQUFNLGdEQUNKLFFBQVEsS0FDUixHQUFHLFFBQVEsZ0JBQWdCLENBQUMsQ0FDN0I7QUFDRCw4QkFBZSwwQkFBMEIsRUFDdkMsbUNBQ0UsK0NBQ0ssUUFBUSxLQUFLLEdBQUcsUUFBUSxXQUFXLGdCQUFnQixDQUFDLENBQUMsQ0FDM0Q7RUFFSCxNQUFNLHlDQUEwQixRQUFRLEtBQUssR0FBRyxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQ25FLDhCQUFlLG1CQUFtQixFQUNoQyxtQ0FDRSx3Q0FDSyxRQUFRLEtBQUssR0FBRyxRQUFRLFdBQVcsU0FBUyxDQUFDLENBQUMsQ0FDcEQ7RUFFSCxNQUFNLHdDQUF5QixRQUFRLEtBQUssaUJBQWlCO0FBQzdELDhCQUFlLGtCQUFrQixFQUFFO0dBQ2pDLE1BQU0sdUJBQXVCLE1BQU0sY0FDakMsbUJBQ0EsT0FDRDtHQUNELE1BQU0sb0JBQW9CLHFCQUN2QixNQUFNLEtBQUssQ0FDWCxJQUFJLENBQUMsU0FBUztBQUNiLFdBQU8sS0FDSixRQUNDLEdBQUcsUUFBUSxnQkFBZ0IsQ0FBQyxFQUM1QixHQUFHLFFBQVEsV0FBVyxnQkFBZ0IsQ0FBQyxDQUN4QyxDQUNBLFFBQVEsR0FBRyxRQUFRLFNBQVMsQ0FBQyxFQUFFLEdBQUcsUUFBUSxXQUFXLFNBQVMsQ0FBQyxDQUFDO0dBQ3BFLEVBQUMsQ0FDRCxLQUFLLEtBQUs7R0FDYixNQUFNLGVBQWUsbUJBQW1CLGtCQUFrQjtFQUMzRDtDQUNGO0FBQ0Y7Ozs7QUM5R0QsTUFBTUMsVUFBUSxhQUFhLE1BQU07QUFJakMsTUFBTSxpQkFBaUI7Q0FDckIsTUFBTTtDQUNOLE1BQU07QUFDUDtBQUVELGVBQWUsa0JBQW9DO0FBQ2pELEtBQUk7RUFDRixNQUFNLElBQUksUUFBUSxDQUFDQyxjQUFZO0dBQzdCLE1BQU0sa0NBQVUsZ0JBQWdCO0dBQ2hDLEdBQUcsR0FBRyxTQUFTLE1BQU07SUFDbkJBLFVBQVEsTUFBTTtHQUNmLEVBQUM7R0FDRixHQUFHLEdBQUcsUUFBUSxDQUFDLFNBQVM7QUFDdEIsUUFBSSxTQUFTLEdBQ1hBLFVBQVEsS0FBSztTQUViQSxVQUFRLE1BQU07R0FFakIsRUFBQztFQUNIO0FBQ0QsU0FBTztDQUNSLFFBQU87QUFDTixTQUFPO0NBQ1I7QUFDRjtBQUVELGVBQWUsZUFDYkMsZ0JBQ2lCO0NBQ2pCLE1BQU0sV0FBV0Msa0JBQUssMkJBQWMsRUFBRSxZQUFZLFlBQVksZUFBZTtDQUM3RSxNQUFNLFdBQVcsVUFBVSxFQUFFLFdBQVcsS0FBTSxFQUFDO0FBQy9DLFFBQU87QUFDUjtBQUVELGVBQWUsaUJBQ2JELGdCQUNBRSxVQUNlO0NBQ2YsTUFBTSxVQUFVLGVBQWU7Q0FDL0IsTUFBTSxlQUFlRCxrQkFBSyxLQUFLLFVBQVUsT0FBTztBQUVoRCw2QkFBZSxhQUFhLEVBQUU7RUFDNUJILFFBQU0sQ0FBQyx3QkFBd0IsRUFBRSxhQUFhLGFBQWEsQ0FBQyxDQUFDO0FBQzdELE1BQUk7R0FFRixNQUFNLElBQUksUUFBYyxDQUFDQyxXQUFTLFdBQVc7SUFDM0MsTUFBTSxrQ0FBVSxvQkFBb0IsRUFBRSxLQUFLLGFBQWMsRUFBQztJQUMxRCxHQUFHLEdBQUcsU0FBUyxPQUFPO0lBQ3RCLEdBQUcsR0FBRyxRQUFRLENBQUMsU0FBUztBQUN0QixTQUFJLFNBQVMsR0FDWEEsV0FBUztVQUVULHVCQUNFLElBQUksTUFDRixDQUFDLDZEQUE2RCxFQUFFLE1BQU0sRUFFekU7SUFFSixFQUFDO0dBQ0g7b0NBQ1EsZ0NBQWdDO0lBQ3ZDLEtBQUs7SUFDTCxPQUFPO0dBQ1IsRUFBQztHQUNGRCxRQUFNLGdDQUFnQztFQUN2QyxTQUFRLE9BQU87R0FDZEEsUUFBTSxDQUFDLDJCQUEyQixFQUFFLE9BQU8sQ0FBQztBQUM1QyxTQUFNLElBQUksTUFBTSxDQUFDLCtCQUErQixFQUFFLFFBQVEsRUFBRSxFQUFFLE9BQU87RUFDdEU7Q0FDRixPQUFNO0VBQ0xBLFFBQU0sQ0FBQyxzQkFBc0IsRUFBRSxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQzVDLE1BQUk7b0NBQ08sQ0FBQyxVQUFVLEVBQUUsUUFBUSxLQUFLLENBQUMsRUFBRTtJQUFFLEtBQUs7SUFBVSxPQUFPO0dBQVcsRUFBQztHQUMxRUEsUUFBTSwrQkFBK0I7RUFDdEMsU0FBUSxPQUFPO0FBQ2QsU0FBTSxJQUFJLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRSxRQUFRLEVBQUUsRUFBRSxPQUFPO0VBQ3JFO0NBQ0Y7QUFDRjtBQUVELGVBQWUsY0FDYkssS0FDQUMsTUFDQUMscUJBQ2U7Q0FDZixNQUFNLFdBQVcsTUFBTSxFQUFFLFdBQVcsS0FBTSxFQUFDO0NBQzNDLE1BQU0sVUFBVSxNQUFNQyxpQkFBRyxRQUFRLEtBQUssRUFBRSxlQUFlLEtBQU0sRUFBQztBQUU5RCxNQUFLLE1BQU0sU0FBUyxTQUFTO0VBQzNCLE1BQU0sVUFBVUwsa0JBQUssS0FBSyxLQUFLLE1BQU0sS0FBSztFQUMxQyxNQUFNLFdBQVdBLGtCQUFLLEtBQUssTUFBTSxNQUFNLEtBQUs7QUFHNUMsTUFBSSxNQUFNLFNBQVMsT0FDakI7QUFHRixNQUFJLE1BQU0sYUFBYSxFQUNyQixNQUFNLGNBQWMsU0FBUyxVQUFVLG9CQUFvQjtPQUN0RDtBQUNMLE9BQ0UsQ0FBQyx3QkFDQSxNQUFNLEtBQUssU0FBUyxtQkFBbUIsSUFDdEMsTUFBTSxLQUFLLFNBQVMsWUFBWSxJQUNoQyxNQUFNLEtBQUssU0FBUywyQkFBMkIsSUFDL0MsTUFBTSxLQUFLLFNBQVMsa0JBQWtCLElBQ3RDLE1BQU0sS0FBSyxTQUFTLGFBQWEsRUFFbkM7R0FFRixNQUFNSyxpQkFBRyxTQUFTLFNBQVMsU0FBUztFQUNyQztDQUNGO0FBQ0Y7QUFFRCxlQUFlLDJCQUNiQyxVQUNBQyxnQkFDZTtDQUNmLE1BQU0sVUFBVSxNQUFNRixpQkFBRyxTQUFTLFVBQVUsUUFBUTtDQUNwRCxNQUFNLGNBQWMsS0FBSyxNQUFNLFFBQVE7QUFHdkMsS0FBSSxZQUFZLE1BQU0sU0FDcEIsWUFBWSxLQUFLLFVBQVUsWUFBWSxLQUFLLFFBQVEsT0FDbEQsQ0FBQ0csV0FBbUIsZUFBZSxTQUFTLE9BQU8sQ0FDcEQ7Q0FHSCxNQUFNSCxpQkFBRyxVQUFVLFVBQVUsS0FBSyxVQUFVLGFBQWEsTUFBTSxFQUFFLEdBQUcsS0FBSztBQUMxRTtBQUVELGVBQWUsNkJBQ2JDLFVBQ0FDLGdCQUNlO0NBQ2YsTUFBTSxVQUFVLE1BQU1GLGlCQUFHLFNBQVMsVUFBVSxRQUFRO0NBQ3BELE1BQU0seUJBQWdCLFFBQVE7Q0FFOUIsTUFBTSx5QkFBeUIsSUFBSSxJQUFJO0VBQ3JDO0VBQ0E7RUFDQTtDQUNEO0NBRUQsTUFBTSxlQUFlLElBQUksSUFBSTtFQUMzQjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0NBQ0Q7Q0FHRCxNQUFNLGtCQUFrQixlQUFlLEtBQUssQ0FBQyxXQUMzQyxhQUFhLElBQUksT0FBTyxDQUN6QjtBQUdELEtBQUksTUFBTSxNQUFNLE9BQU8sVUFBVSxRQUFRLFVBQ3ZDLEtBQUssS0FBSyxNQUFNLFNBQVMsT0FBTyxXQUM5QixLQUFLLEtBQUssTUFBTSxTQUFTLE9BQU8sU0FBUyxPQUFPLENBQUNJLFlBQWlCO0FBQ2hFLE1BQUksUUFBUSxPQUNWLFFBQU8sZUFBZSxTQUFTLFFBQVEsT0FBTztBQUVoRCxTQUFPO0NBQ1IsRUFBQztDQUdOLE1BQU1DLGVBQXlCLENBQUU7QUFFakMsS0FBSSxlQUFlLE1BQU0sQ0FBQyxXQUFXLENBQUMsdUJBQXVCLElBQUksT0FBTyxDQUFDLEVBQ3ZFLGFBQWEsS0FBSyw2QkFBNkI7VUFJN0MsTUFBTSxPQUFPLCtCQUErQixVQUFVLFFBQVEsVUFFOUQsS0FBSyxLQUFLLDhCQUE4QixTQUFTLE9BQU8sV0FDdEQsS0FBSyxLQUFLLDhCQUE4QixTQUFTLE9BQU8sU0FBUyxPQUMvRCxDQUFDRCxZQUFpQjtBQUNoQixNQUFJLFFBQVEsT0FDVixRQUFPLGVBQWUsU0FBUyxRQUFRLE9BQU87QUFFaEQsU0FBTztDQUNSLEVBQ0Y7QUFLUCxLQUFJLENBQUMsaUJBRUg7TUFBSSxNQUFNLE9BQU8sdUJBQ2YsYUFBYSxLQUFLLHFCQUFxQjtDQUN4QyxXQUdHLE1BQU0sT0FBTyx1QkFBdUIsVUFBVSxRQUFRLFFBQ3hELEtBQUssS0FBSyxzQkFBc0IsU0FBUyxPQUFPLFNBQVMsS0FBSyxLQUM1RCxzQkFDQSxTQUFTLE9BQU8sT0FBTyxPQUFPLENBQUNELFdBQW1CO0FBQ2xELE1BQUksT0FDRixRQUFPLGVBQWUsU0FBUyxPQUFPO0FBRXhDLFNBQU87Q0FDUixFQUFDO0FBSU4sS0FBSSxDQUFDLGVBQWUsU0FBUyx3QkFBd0IsRUFDbkQsYUFBYSxLQUFLLFlBQVk7QUFHaEMsS0FBSSxDQUFDLGVBQWUsU0FBUyx5QkFBeUIsRUFDcEQsYUFBYSxLQUFLLGdCQUFnQjtBQUlwQyxNQUFLLE1BQU0sQ0FBQyxTQUFTLFVBQVUsSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLENBQUUsRUFBQyxDQUNoRSxLQUNFLFFBQVEsV0FBVyxRQUFRLElBQzNCLFlBQVksZ0NBQ1osWUFBWSw4QkFDWjtFQUVBLE1BQU0sTUFBTTtBQUNaLE1BQUksSUFBSSxVQUFVLFFBQVEsV0FBVyxJQUFJLFFBQVE7R0FDL0MsTUFBTSxTQUFTLElBQUksU0FBUyxPQUFPLFNBQVMsR0FBRztBQUMvQyxPQUFJLENBQUMsZUFBZSxTQUFTLE9BQU8sRUFDbEMsYUFBYSxLQUFLLFFBQVE7RUFFN0I7Q0FDRjtBQUlILE1BQUssTUFBTSxXQUFXLGNBQ3BCLE9BQU8sS0FBSyxLQUFLO0FBR25CLEtBQUksTUFBTSxRQUFRLEtBQUssTUFBTSxTQUFTLE1BQU0sRUFDMUMsS0FBSyxLQUFLLFFBQVEsUUFBUSxLQUFLLEtBQUssUUFBUSxNQUFNLE9BQ2hELENBQUNHLFNBQWlCLENBQUMsYUFBYSxTQUFTLEtBQUssQ0FDL0M7Q0FJSCxNQUFNLGdDQUF1QixNQUFNO0VBQ2pDLFdBQVc7RUFDWCxRQUFRO0VBQ1IsVUFBVTtDQUNYLEVBQUM7Q0FDRixNQUFNTixpQkFBRyxVQUFVLFVBQVUsWUFBWTtBQUMxQztBQUVELFNBQVMsZUFBZU8sU0FBd0I7Q0FDOUNmLFFBQU0sd0JBQXdCO0FBQzlCLEtBQUksQ0FBQyxRQUFRLEtBQ1gsT0FBTSxJQUFJLE1BQU07Q0FFbEIsUUFBUSxPQUFPRyxrQkFBSyxRQUFRLFFBQVEsS0FBSyxFQUFFLFFBQVEsS0FBSztDQUN4REgsUUFBTSxDQUFDLHlCQUF5QixFQUFFLFFBQVEsTUFBTSxDQUFDO0FBRWpELEtBQUksQ0FBQyxRQUFRLE1BQU07RUFDakIsUUFBUSxPQUFPRyxrQkFBSyxNQUFNLFFBQVEsS0FBSyxDQUFDO0VBQ3hDSCxRQUFNLENBQUMsOENBQThDLEVBQUUsUUFBUSxNQUFNLENBQUM7Q0FDdkU7QUFFRCxLQUFJLENBQUMsUUFBUSxTQUFTLE9BQ3BCLEtBQUksUUFBUSxrQkFBa0I7RUFDNUIsUUFBUSxVQUFVLGtCQUFrQixRQUFRO0VBQzVDQSxRQUFNLHFCQUFxQjtDQUM1QixXQUFVLFFBQVEsc0JBQXNCO0VBQ3ZDLFFBQVEsVUFBVSxnQkFBZ0IsUUFBUTtFQUMxQ0EsUUFBTSx5QkFBeUI7Q0FDaEMsTUFDQyxPQUFNLElBQUksTUFBTTtBQUdwQixLQUNFLFFBQVEsUUFBUSxLQUFLLENBQUMsV0FBVyxXQUFXLCtCQUErQixFQUMzRTtFQUNBLE1BQU0sdUNBQWUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLEVBQ3pDLFVBQVUsT0FDWCxFQUFDO0FBQ0YsTUFBSSxJQUFJLFNBQVMsd0JBQXdCLEVBQ3ZDLFFBQVEsVUFBVSxRQUFRLFFBQVEsSUFBSSxDQUFDLFdBQ3JDLFdBQVcsaUNBQ1AsMEJBQ0EsT0FDTDtDQUVKO0FBRUQsUUFBTyx1QkFBdUIsUUFBUTtBQUN2QztBQUVELGVBQXNCLFdBQVdnQixhQUE0QjtDQUMzRGhCLFFBQU0sa0RBQWtEO0NBQ3hEQSxRQUFNLFlBQVk7Q0FFbEIsTUFBTSxVQUFVLGVBQWUsWUFBWTtDQUUzQ0EsUUFBTSx5QkFBeUI7Q0FDL0JBLFFBQU0sUUFBUSxRQUFRO0FBR3RCLEtBQUksQ0FBRSxNQUFNLGlCQUFpQixDQUMzQixPQUFNLElBQUksTUFDUjtDQUlKLE1BQU0saUJBQWlCLFFBQVE7Q0FHL0IsTUFBTSxXQUFXLFFBQVEsTUFBTSxRQUFRLE9BQU87QUFFOUMsS0FBSSxDQUFDLFFBQVEsT0FDWCxLQUFJO0VBRUYsTUFBTSxXQUFXLE1BQU0sZUFBZSxlQUFlO0VBQ3JELE1BQU0saUJBQWlCLGdCQUFnQixTQUFTO0VBR2hELE1BQU0sZUFBZUcsa0JBQUssS0FBSyxVQUFVLE9BQU87RUFDaEQsTUFBTSxjQUNKLGNBQ0EsUUFBUSxNQUNSLFFBQVEsUUFBUSxTQUFTLHdCQUF3QixDQUNsRDtFQUdELE1BQU0sY0FBYztHQUNsQixLQUFLLFFBQVE7R0FDYixNQUFNLFFBQVE7R0FDZCxZQUFZLGNBQWMsUUFBUSxLQUFLO0VBQ3hDLEVBQUM7RUFHRixNQUFNLGtCQUFrQkEsa0JBQUssS0FBSyxRQUFRLE1BQU0sZUFBZTtBQUMvRCw4QkFBZSxnQkFBZ0IsRUFDN0IsTUFBTSwyQkFBMkIsaUJBQWlCLFFBQVEsUUFBUTtFQUlwRSxNQUFNLFNBQVNBLGtCQUFLLEtBQUssUUFBUSxNQUFNLFdBQVcsYUFBYSxTQUFTO0FBQ3hFLDhCQUFlLE9BQU8sSUFBSSxRQUFRLHFCQUNoQyxNQUFNLDZCQUE2QixRQUFRLFFBQVEsUUFBUTtXQUUzRCxDQUFDLFFBQVEsK0NBQ0VBLGtCQUFLLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQyxFQUc5QyxNQUFNSyxpQkFBRyxHQUFHTCxrQkFBSyxLQUFLLFFBQVEsTUFBTSxVQUFVLEVBQUU7R0FDOUMsV0FBVztHQUNYLE9BQU87RUFDUixFQUFDO0VBSUosTUFBTSxpQkFBaUIsTUFBTUssaUJBQUcsU0FBUyxpQkFBaUIsUUFBUTtFQUNsRSxNQUFNLFVBQVUsS0FBSyxNQUFNLGVBQWU7QUFHMUMsTUFBSSxDQUFDLFFBQVEsU0FDWCxRQUFRLFVBQVUsQ0FBRTtFQUV0QixRQUFRLFFBQVEsT0FBTyxzQkFBc0IsUUFBUSxrQkFBa0I7QUFHdkUsTUFBSSxRQUFRLFdBQVcsUUFBUSxZQUFZLFFBQVEsU0FDakQsUUFBUSxVQUFVLFFBQVE7QUFJNUIsTUFBSSxRQUFRLGtCQUFrQixPQUU1QlIsUUFDRSxDQUFDLGVBQWUsRUFBRSxRQUFRLGNBQWMsa0NBQWtDLENBQUMsQ0FDNUU7RUFHSCxNQUFNUSxpQkFBRyxVQUNQLGlCQUNBLEtBQUssVUFBVSxTQUFTLE1BQU0sRUFBRSxHQUFHLEtBQ3BDO0NBQ0YsU0FBUSxPQUFPO0FBQ2QsUUFBTSxJQUFJLE1BQU0sQ0FBQywwQkFBMEIsRUFBRSxPQUFPO0NBQ3JEO0NBR0hSLFFBQU0sQ0FBQyxvQkFBb0IsRUFBRSxRQUFRLE1BQU0sQ0FBQztBQUM3QztBQUVELGVBQWUsV0FBV2lCLFFBQWMsU0FBUyxPQUFPO0NBQ3RELE1BQU1DLFNBQU8sTUFBTSxVQUFVZixRQUFNLENBQUUsRUFBQyxDQUFDLE1BQU0sTUFBTSxPQUFVO0FBRzdELEtBQUllLFFBQ0Y7TUFBSUEsT0FBSyxRQUFRLENBQ2YsT0FBTSxJQUFJLE1BQ1IsQ0FBQyxLQUFLLEVBQUVmLE9BQUssMEVBQTBFLENBQUM7V0FFakZlLE9BQUssYUFBYSxFQUFFO0dBQzdCLE1BQU1DLFVBQVEsTUFBTSxhQUFhaEIsT0FBSztBQUN0QyxPQUFJZ0IsUUFBTSxPQUNSLE9BQU0sSUFBSSxNQUNSLENBQUMsS0FBSyxFQUFFaEIsT0FBSyxvRUFBb0UsQ0FBQztFQUd2Rjs7QUFHSCxLQUFJLENBQUMsT0FDSCxLQUFJO0VBQ0ZILFFBQU0sQ0FBQyxnQ0FBZ0MsRUFBRUcsUUFBTSxDQUFDO0FBQ2hELE1BQUksQ0FBQyxRQUNILE1BQU0sV0FBV0EsUUFBTSxFQUFFLFdBQVcsS0FBTSxFQUFDO0NBRTlDLFNBQVEsR0FBRztBQUNWLFFBQU0sSUFBSSxNQUFNLENBQUMsbUNBQW1DLEVBQUVBLFFBQU0sRUFBRSxFQUM1RCxPQUFPLEVBQ1I7Q0FDRjtBQUVKO0FBRUQsU0FBUyxjQUFjaUIsUUFBc0I7QUFDM0MsUUFBT0MsT0FBSyxNQUFNLElBQUksQ0FBQyxLQUFLO0FBQzdCOzs7O0FDbmRELFNBQWdCLGVBQWU7QUFDN0IsS0FBSSxPQUFPLGNBQWMsWUFBWSxlQUFlLFVBQ2xELFFBQU8sVUFBVTtBQUduQixLQUFJLE9BQU8sWUFBWSxZQUFZLFFBQVEsWUFBWSxPQUNyRCxRQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsUUFBUSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUUsUUFBUSxTQUFTLEVBQUUsRUFDakUsUUFBUSxLQUNULENBQUMsQ0FBQztBQUdMLFFBQU87QUFDUjs7OztBQ1ZELFNBQWdCLFNBQVMsT0FBT0MsUUFBTSxRQUFRLFNBQVM7QUFDckQsS0FBSSxPQUFPLFdBQVcsV0FDcEIsT0FBTSxJQUFJLE1BQU07QUFHbEIsS0FBSSxDQUFDLFNBQ0gsVUFBVSxDQUFFO0FBR2QsS0FBSSxNQUFNLFFBQVFBLE9BQUssQ0FDckIsUUFBT0EsT0FBSyxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQVVBLFdBQVM7QUFDL0MsU0FBTyxTQUFTLEtBQUssTUFBTSxPQUFPQSxRQUFNLFVBQVUsUUFBUTtDQUMzRCxHQUFFLE9BQU8sRUFBRTtBQUdkLFFBQU8sUUFBUSxTQUFTLENBQUMsS0FBSyxNQUFNO0FBQ2xDLE1BQUksQ0FBQyxNQUFNLFNBQVNBLFFBQ2xCLFFBQU8sT0FBTyxRQUFRO0FBR3hCLFNBQU8sTUFBTSxTQUFTQSxRQUFNLE9BQU8sQ0FBQ0MsVUFBUSxlQUFlO0FBQ3pELFVBQU8sV0FBVyxLQUFLLEtBQUssTUFBTUEsVUFBUSxRQUFRO0VBQ25ELEdBQUUsT0FBTyxFQUFFO0NBQ2IsRUFBQztBQUNIOzs7O0FDeEJELFNBQWdCLFFBQVEsT0FBTyxNQUFNQyxRQUFNQyxRQUFNO0NBQy9DLE1BQU0sT0FBT0E7QUFDYixLQUFJLENBQUMsTUFBTSxTQUFTRCxTQUNsQixNQUFNLFNBQVNBLFVBQVEsQ0FBRTtBQUczQixLQUFJLFNBQVMsVUFDWEMsU0FBTyxDQUFDLFFBQVEsWUFBWTtBQUMxQixTQUFPLFFBQVEsU0FBUyxDQUNyQixLQUFLLEtBQUssS0FBSyxNQUFNLFFBQVEsQ0FBQyxDQUM5QixLQUFLLE9BQU8sS0FBSyxNQUFNLFFBQVEsQ0FBQztDQUNwQztBQUdILEtBQUksU0FBUyxTQUNYQSxTQUFPLENBQUMsUUFBUSxZQUFZO0VBQzFCLElBQUk7QUFDSixTQUFPLFFBQVEsU0FBUyxDQUNyQixLQUFLLE9BQU8sS0FBSyxNQUFNLFFBQVEsQ0FBQyxDQUNoQyxLQUFLLENBQUMsWUFBWTtHQUNqQixTQUFTO0FBQ1QsVUFBTyxLQUFLLFFBQVEsUUFBUTtFQUM3QixFQUFDLENBQ0QsS0FBSyxNQUFNO0FBQ1YsVUFBTztFQUNSLEVBQUM7Q0FDTDtBQUdILEtBQUksU0FBUyxTQUNYQSxTQUFPLENBQUMsUUFBUSxZQUFZO0FBQzFCLFNBQU8sUUFBUSxTQUFTLENBQ3JCLEtBQUssT0FBTyxLQUFLLE1BQU0sUUFBUSxDQUFDLENBQ2hDLE1BQU0sQ0FBQyxVQUFVO0FBQ2hCLFVBQU8sS0FBSyxPQUFPLFFBQVE7RUFDNUIsRUFBQztDQUNMO0NBR0gsTUFBTSxTQUFTRCxRQUFNLEtBQUs7RUFDeEIsTUFBTUM7RUFDQTtDQUNQLEVBQUM7QUFDSDs7OztBQzNDRCxTQUFnQixXQUFXLE9BQU9DLFFBQU0sUUFBUTtBQUM5QyxLQUFJLENBQUMsTUFBTSxTQUFTQSxRQUNsQjtDQUdGLE1BQU0sUUFBUSxNQUFNLFNBQVNBLFFBQzFCLElBQUksQ0FBQyxlQUFlO0FBQ25CLFNBQU8sV0FBVztDQUNuQixFQUFDLENBQ0QsUUFBUSxPQUFPO0FBRWxCLEtBQUksVUFBVSxHQUNaO0NBR0YsTUFBTSxTQUFTQSxRQUFNLE9BQU8sT0FBTyxFQUFFO0FBQ3RDOzs7O0FDWEQsTUFBTSxPQUFPLFNBQVM7QUFDdEIsTUFBTSxXQUFXLEtBQUssS0FBSyxLQUFLO0FBRWhDLFNBQVMsUUFBUUMsUUFBTSxPQUFPQyxRQUFNO0NBQ2xDLE1BQU0sZ0JBQWdCLFNBQVMsWUFBWSxLQUFLLENBQUMsTUFDL0MsTUFDQUEsU0FBTyxDQUFDLE9BQU9BLE1BQUssSUFBRyxDQUFDLEtBQU0sRUFDL0I7Q0FDREQsT0FBSyxNQUFNLEVBQUUsUUFBUSxjQUFlO0NBQ3BDQSxPQUFLLFNBQVM7Q0FDZDtFQUFDO0VBQVU7RUFBUztFQUFTO0NBQU8sRUFBQyxRQUFRLENBQUMsU0FBUztFQUNyRCxNQUFNLE9BQU9DLFNBQU87R0FBQztHQUFPO0dBQU1BO0VBQUssSUFBRyxDQUFDLE9BQU8sSUFBSztFQUN2REQsT0FBSyxRQUFRQSxPQUFLLElBQUksUUFBUSxTQUFTLFNBQVMsS0FBSyxDQUFDLE1BQU0sTUFBTSxLQUFLO0NBQ3hFLEVBQUM7QUFDSDtBQUVELFNBQVMsV0FBVztDQUNsQixNQUFNLG1CQUFtQixPQUFPLFdBQVc7Q0FDM0MsTUFBTSxvQkFBb0IsRUFDeEIsVUFBVSxDQUFFLEVBQ2I7Q0FDRCxNQUFNLGVBQWUsU0FBUyxLQUFLLE1BQU0sbUJBQW1CLGlCQUFpQjtDQUM3RSxRQUFRLGNBQWMsbUJBQW1CLGlCQUFpQjtBQUMxRCxRQUFPO0FBQ1I7QUFFRCxTQUFTLGFBQWE7Q0FDcEIsTUFBTSxRQUFRLEVBQ1osVUFBVSxDQUFFLEVBQ2I7Q0FFRCxNQUFNQSxTQUFPLFNBQVMsS0FBSyxNQUFNLE1BQU07Q0FDdkMsUUFBUUEsUUFBTSxNQUFNO0FBRXBCLFFBQU9BO0FBQ1I7QUFFRCxnQ0FBZTtDQUFFO0NBQVU7QUFBWTs7OztBQ3hDdkMsSUFBSUUsWUFBVTtBQUdkLElBQUksWUFBWSxDQUFDLG9CQUFvQixFQUFFQSxVQUFRLENBQUMsRUFBRSxjQUFjLEVBQUU7QUFDbEUsSUFBSSxXQUFXO0NBQ2IsUUFBUTtDQUNSLFNBQVM7Q0FDVCxTQUFTO0VBQ1AsUUFBUTtFQUNSLGNBQWM7Q0FDZjtDQUNELFdBQVcsRUFDVCxRQUFRLEdBQ1Q7QUFDRjtBQUdELFNBQVMsY0FBYyxRQUFRO0FBQzdCLEtBQUksQ0FBQyxPQUNILFFBQU8sQ0FBRTtBQUVYLFFBQU8sT0FBTyxLQUFLLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxRQUFRO0VBQ2pELE9BQU8sSUFBSSxhQUFhLElBQUksT0FBTztBQUNuQyxTQUFPO0NBQ1IsR0FBRSxDQUFFLEVBQUM7QUFDUDtBQUdELFNBQVNDLGdCQUFjQyxTQUFPO0FBQzVCLEtBQUksT0FBT0EsWUFBVSxZQUFZQSxZQUFVLEtBQU0sUUFBTztBQUN4RCxLQUFJLE9BQU8sVUFBVSxTQUFTLEtBQUtBLFFBQU0sS0FBSyxrQkFBbUIsUUFBTztDQUN4RSxNQUFNLFFBQVEsT0FBTyxlQUFlQSxRQUFNO0FBQzFDLEtBQUksVUFBVSxLQUFNLFFBQU87Q0FDM0IsTUFBTSxPQUFPLE9BQU8sVUFBVSxlQUFlLEtBQUssT0FBTyxjQUFjLElBQUksTUFBTTtBQUNqRixRQUFPLE9BQU8sU0FBUyxjQUFjLGdCQUFnQixRQUFRLFNBQVMsVUFBVSxLQUFLLEtBQUssS0FBSyxTQUFTLFVBQVUsS0FBS0EsUUFBTTtBQUM5SDtBQUdELFNBQVMsVUFBVSxVQUFVLFNBQVM7Q0FDcEMsTUFBTSxTQUFTLE9BQU8sT0FBTyxDQUFFLEdBQUUsU0FBUztDQUMxQyxPQUFPLEtBQUssUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRO0FBQ3BDLE1BQUlELGdCQUFjLFFBQVEsS0FBSyxDQUM3QixLQUFJLEVBQUUsT0FBTyxXQUFXLE9BQU8sT0FBTyxRQUFRLEdBQUcsTUFBTSxRQUFRLEtBQU0sRUFBQztPQUNqRSxPQUFPLE9BQU8sVUFBVSxTQUFTLE1BQU0sUUFBUSxLQUFLO09BRXpELE9BQU8sT0FBTyxRQUFRLEdBQUcsTUFBTSxRQUFRLEtBQU0sRUFBQztDQUVqRCxFQUFDO0FBQ0YsUUFBTztBQUNSO0FBR0QsU0FBUywwQkFBMEIsS0FBSztBQUN0QyxNQUFLLE1BQU0sT0FBTyxJQUNoQixLQUFJLElBQUksU0FBUyxLQUFLLEdBQ3BCLE9BQU8sSUFBSTtBQUdmLFFBQU87QUFDUjtBQUdELFNBQVMsTUFBTSxVQUFVLE9BQU8sU0FBUztBQUN2QyxLQUFJLE9BQU8sVUFBVSxVQUFVO0VBQzdCLElBQUksQ0FBQyxRQUFRLElBQUksR0FBRyxNQUFNLE1BQU0sSUFBSTtFQUNwQyxVQUFVLE9BQU8sT0FBTyxNQUFNO0dBQUU7R0FBUTtFQUFLLElBQUcsRUFBRSxLQUFLLE9BQVEsR0FBRSxRQUFRO0NBQzFFLE9BQ0MsVUFBVSxPQUFPLE9BQU8sQ0FBRSxHQUFFLE1BQU07Q0FFcEMsUUFBUSxVQUFVLGNBQWMsUUFBUSxRQUFRO0NBQ2hELDBCQUEwQixRQUFRO0NBQ2xDLDBCQUEwQixRQUFRLFFBQVE7Q0FDMUMsTUFBTSxnQkFBZ0IsVUFBVSxZQUFZLENBQUUsR0FBRSxRQUFRO0FBQ3hELEtBQUksUUFBUSxRQUFRLFlBQVk7QUFDOUIsTUFBSSxZQUFZLFNBQVMsVUFBVSxVQUFVLFFBQzNDLGNBQWMsVUFBVSxXQUFXLFNBQVMsVUFBVSxTQUFTLE9BQzdELENBQUMsWUFBWSxDQUFDLGNBQWMsVUFBVSxTQUFTLFNBQVMsUUFBUSxDQUNqRSxDQUFDLE9BQU8sY0FBYyxVQUFVLFNBQVM7RUFFNUMsY0FBYyxVQUFVLFlBQVksY0FBYyxVQUFVLFlBQVksQ0FBRSxHQUFFLElBQUksQ0FBQyxZQUFZLFFBQVEsUUFBUSxZQUFZLEdBQUcsQ0FBQztDQUM5SDtBQUNELFFBQU87QUFDUjtBQUdELFNBQVMsbUJBQW1CLEtBQUssWUFBWTtDQUMzQyxNQUFNLFlBQVksS0FBSyxLQUFLLElBQUksR0FBRyxNQUFNO0NBQ3pDLE1BQU0sUUFBUSxPQUFPLEtBQUssV0FBVztBQUNyQyxLQUFJLE1BQU0sV0FBVyxFQUNuQixRQUFPO0FBRVQsUUFBTyxNQUFNLFlBQVksTUFBTSxJQUFJLENBQUNFLFdBQVM7QUFDM0MsTUFBSUEsV0FBUyxJQUNYLFFBQU8sT0FBTyxXQUFXLEVBQUUsTUFBTSxJQUFJLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxLQUFLLElBQUk7QUFFekUsU0FBTyxHQUFHQSxPQUFLLENBQUMsRUFBRSxtQkFBbUIsV0FBV0EsUUFBTSxFQUFFO0NBQ3pELEVBQUMsQ0FBQyxLQUFLLElBQUk7QUFDYjtBQUdELElBQUksbUJBQW1CO0FBQ3ZCLFNBQVMsZUFBZSxjQUFjO0FBQ3BDLFFBQU8sYUFBYSxRQUFRLDZCQUE2QixHQUFHLENBQUMsTUFBTSxJQUFJO0FBQ3hFO0FBQ0QsU0FBUyx3QkFBd0IsS0FBSztDQUNwQyxNQUFNLFVBQVUsSUFBSSxNQUFNLGlCQUFpQjtBQUMzQyxLQUFJLENBQUMsUUFDSCxRQUFPLENBQUU7QUFFWCxRQUFPLFFBQVEsSUFBSSxlQUFlLENBQUMsT0FBTyxDQUFDLEdBQUcsTUFBTSxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUUsRUFBQztBQUNyRTtBQUdELFNBQVMsS0FBSyxRQUFRLFlBQVk7Q0FDaEMsTUFBTSxTQUFTLEVBQUUsV0FBVyxLQUFNO0FBQ2xDLE1BQUssTUFBTSxPQUFPLE9BQU8sS0FBSyxPQUFPLENBQ25DLEtBQUksV0FBVyxRQUFRLElBQUksS0FBSyxJQUM5QixPQUFPLE9BQU8sT0FBTztBQUd6QixRQUFPO0FBQ1I7QUFHRCxTQUFTLGVBQWUsS0FBSztBQUMzQixRQUFPLElBQUksTUFBTSxxQkFBcUIsQ0FBQyxJQUFJLFNBQVMsTUFBTTtBQUN4RCxNQUFJLENBQUMsZUFBZSxLQUFLLEtBQUssRUFDNUIsT0FBTyxVQUFVLEtBQUssQ0FBQyxRQUFRLFFBQVEsSUFBSSxDQUFDLFFBQVEsUUFBUSxJQUFJO0FBRWxFLFNBQU87Q0FDUixFQUFDLENBQUMsS0FBSyxHQUFHO0FBQ1o7QUFDRCxTQUFTLGlCQUFpQixLQUFLO0FBQzdCLFFBQU8sbUJBQW1CLElBQUksQ0FBQyxRQUFRLFlBQVksU0FBUyxHQUFHO0FBQzdELFNBQU8sTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDLFNBQVMsR0FBRyxDQUFDLGFBQWE7Q0FDeEQsRUFBQztBQUNIO0FBQ0QsU0FBUyxZQUFZLFVBQVVELFNBQU8sS0FBSztDQUN6Q0EsVUFBUSxhQUFhLE9BQU8sYUFBYSxNQUFNLGVBQWVBLFFBQU0sR0FBRyxpQkFBaUJBLFFBQU07QUFDOUYsS0FBSSxJQUNGLFFBQU8saUJBQWlCLElBQUksR0FBRyxNQUFNQTtLQUVyQyxRQUFPQTtBQUVWO0FBQ0QsU0FBUyxVQUFVQSxTQUFPO0FBQ3hCLFFBQU9BLFlBQVUsS0FBSyxLQUFLQSxZQUFVO0FBQ3RDO0FBQ0QsU0FBUyxjQUFjLFVBQVU7QUFDL0IsUUFBTyxhQUFhLE9BQU8sYUFBYSxPQUFPLGFBQWE7QUFDN0Q7QUFDRCxTQUFTLFVBQVUsU0FBUyxVQUFVLEtBQUssVUFBVTtDQUNuRCxJQUFJQSxVQUFRLFFBQVEsTUFBTSxTQUFTLENBQUU7QUFDckMsS0FBSSxVQUFVQSxRQUFNLElBQUlBLFlBQVUsR0FDaEMsS0FBSSxPQUFPQSxZQUFVLFlBQVksT0FBT0EsWUFBVSxZQUFZLE9BQU9BLFlBQVUsV0FBVztFQUN4RkEsVUFBUUEsUUFBTSxVQUFVO0FBQ3hCLE1BQUksWUFBWSxhQUFhLEtBQzNCQSxVQUFRQSxRQUFNLFVBQVUsR0FBRyxTQUFTLFVBQVUsR0FBRyxDQUFDO0VBRXBELE9BQU8sS0FDTCxZQUFZLFVBQVVBLFNBQU8sY0FBYyxTQUFTLEdBQUcsTUFBTSxHQUFHLENBQ2pFO0NBQ0YsV0FDSyxhQUFhLElBQ2YsS0FBSSxNQUFNLFFBQVFBLFFBQU0sRUFDdEJBLFFBQU0sT0FBTyxVQUFVLENBQUMsUUFBUSxTQUFTLFFBQVE7RUFDL0MsT0FBTyxLQUNMLFlBQVksVUFBVSxRQUFRLGNBQWMsU0FBUyxHQUFHLE1BQU0sR0FBRyxDQUNsRTtDQUNGLEVBQUM7TUFFRixPQUFPLEtBQUtBLFFBQU0sQ0FBQyxRQUFRLFNBQVMsR0FBRztBQUNyQyxNQUFJLFVBQVVBLFFBQU0sR0FBRyxFQUNyQixPQUFPLEtBQUssWUFBWSxVQUFVQSxRQUFNLElBQUksRUFBRSxDQUFDO0NBRWxELEVBQUM7TUFFQztFQUNMLE1BQU0sTUFBTSxDQUFFO0FBQ2QsTUFBSSxNQUFNLFFBQVFBLFFBQU0sRUFDdEJBLFFBQU0sT0FBTyxVQUFVLENBQUMsUUFBUSxTQUFTLFFBQVE7R0FDL0MsSUFBSSxLQUFLLFlBQVksVUFBVSxPQUFPLENBQUM7RUFDeEMsRUFBQztPQUVGLE9BQU8sS0FBS0EsUUFBTSxDQUFDLFFBQVEsU0FBUyxHQUFHO0FBQ3JDLE9BQUksVUFBVUEsUUFBTSxHQUFHLEVBQUU7SUFDdkIsSUFBSSxLQUFLLGlCQUFpQixFQUFFLENBQUM7SUFDN0IsSUFBSSxLQUFLLFlBQVksVUFBVUEsUUFBTSxHQUFHLFVBQVUsQ0FBQyxDQUFDO0dBQ3JEO0VBQ0YsRUFBQztBQUVKLE1BQUksY0FBYyxTQUFTLEVBQ3pCLE9BQU8sS0FBSyxpQkFBaUIsSUFBSSxHQUFHLE1BQU0sSUFBSSxLQUFLLElBQUksQ0FBQztXQUMvQyxJQUFJLFdBQVcsR0FDeEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJLENBQUM7Q0FFN0I7VUFHQyxhQUFhLEtBQ2Y7TUFBSSxVQUFVQSxRQUFNLEVBQ2xCLE9BQU8sS0FBSyxpQkFBaUIsSUFBSSxDQUFDO0NBQ25DLFdBQ1FBLFlBQVUsT0FBTyxhQUFhLE9BQU8sYUFBYSxNQUMzRCxPQUFPLEtBQUssaUJBQWlCLElBQUksR0FBRyxJQUFJO1VBQy9CQSxZQUFVLElBQ25CLE9BQU8sS0FBSyxHQUFHO0FBR25CLFFBQU87QUFDUjtBQUNELFNBQVMsU0FBUyxVQUFVO0FBQzFCLFFBQU8sRUFDTCxRQUFRLE9BQU8sS0FBSyxNQUFNLFNBQVMsQ0FDcEM7QUFDRjtBQUNELFNBQVMsT0FBTyxVQUFVLFNBQVM7Q0FDakMsSUFBSSxZQUFZO0VBQUM7RUFBSztFQUFLO0VBQUs7RUFBSztFQUFLO0VBQUs7Q0FBSTtDQUNuRCxXQUFXLFNBQVMsUUFDbEIsOEJBQ0EsU0FBUyxHQUFHLFlBQVksU0FBUztBQUMvQixNQUFJLFlBQVk7R0FDZCxJQUFJLFdBQVc7R0FDZixNQUFNLFNBQVMsQ0FBRTtBQUNqQixPQUFJLFVBQVUsUUFBUSxXQUFXLE9BQU8sRUFBRSxDQUFDLEtBQUssSUFBSTtJQUNsRCxXQUFXLFdBQVcsT0FBTyxFQUFFO0lBQy9CLGFBQWEsV0FBVyxPQUFPLEVBQUU7R0FDbEM7R0FDRCxXQUFXLE1BQU0sS0FBSyxDQUFDLFFBQVEsU0FBUyxVQUFVO0lBQ2hELElBQUksTUFBTSw0QkFBNEIsS0FBSyxTQUFTO0lBQ3BELE9BQU8sS0FBSyxVQUFVLFNBQVMsVUFBVSxJQUFJLElBQUksSUFBSSxNQUFNLElBQUksR0FBRyxDQUFDO0dBQ3BFLEVBQUM7QUFDRixPQUFJLFlBQVksYUFBYSxLQUFLO0lBQ2hDLElBQUksWUFBWTtBQUNoQixRQUFJLGFBQWEsS0FDZixZQUFZO2FBQ0gsYUFBYSxLQUN0QixZQUFZO0FBRWQsWUFBUSxPQUFPLFdBQVcsSUFBSSxXQUFXLE1BQU0sT0FBTyxLQUFLLFVBQVU7R0FDdEUsTUFDQyxRQUFPLE9BQU8sS0FBSyxJQUFJO0VBRTFCLE1BQ0MsUUFBTyxlQUFlLFFBQVE7Q0FFakMsRUFDRjtBQUNELEtBQUksYUFBYSxJQUNmLFFBQU87S0FFUCxRQUFPLFNBQVMsUUFBUSxPQUFPLEdBQUc7QUFFckM7QUFHRCxTQUFTRSxRQUFNLFNBQVM7Q0FDdEIsSUFBSSxTQUFTLFFBQVEsT0FBTyxhQUFhO0NBQ3pDLElBQUksT0FBTyxRQUFRLE9BQU8sS0FBSyxRQUFRLGdCQUFnQixPQUFPO0NBQzlELElBQUksVUFBVSxPQUFPLE9BQU8sQ0FBRSxHQUFFLFFBQVEsUUFBUTtDQUNoRCxJQUFJO0NBQ0osSUFBSSxhQUFhLEtBQUssU0FBUztFQUM3QjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7Q0FDRCxFQUFDO0NBQ0YsTUFBTSxtQkFBbUIsd0JBQXdCLElBQUk7Q0FDckQsTUFBTSxTQUFTLElBQUksQ0FBQyxPQUFPLFdBQVc7QUFDdEMsS0FBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQ3BCLE1BQU0sUUFBUSxVQUFVO0NBRTFCLE1BQU0sb0JBQW9CLE9BQU8sS0FBSyxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsaUJBQWlCLFNBQVMsT0FBTyxDQUFDLENBQUMsT0FBTyxVQUFVO0NBQ3RILE1BQU0sc0JBQXNCLEtBQUssWUFBWSxrQkFBa0I7Q0FDL0QsTUFBTSxrQkFBa0IsNkJBQTZCLEtBQUssUUFBUSxPQUFPO0FBQ3pFLEtBQUksQ0FBQyxpQkFBaUI7QUFDcEIsTUFBSSxRQUFRLFVBQVUsUUFDcEIsUUFBUSxTQUFTLFFBQVEsT0FBTyxNQUFNLElBQUksQ0FBQyxJQUN6QyxDQUFDLFdBQVcsT0FBTyxRQUNqQixvREFDQSxDQUFDLG9CQUFvQixFQUFFLFFBQVEsVUFBVSxRQUFRLENBQ2xELENBQ0YsQ0FBQyxLQUFLLElBQUk7QUFFYixNQUFJLElBQUksU0FBUyxXQUFXLEVBQzFCO09BQUksUUFBUSxVQUFVLFVBQVUsUUFBUTtJQUN0QyxNQUFNLDJCQUEyQixRQUFRLE9BQU8sTUFBTSxnQ0FBZ0MsSUFBSSxDQUFFO0lBQzVGLFFBQVEsU0FBUyx5QkFBeUIsT0FBTyxRQUFRLFVBQVUsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZO0tBQzVGLE1BQU0sU0FBUyxRQUFRLFVBQVUsU0FBUyxDQUFDLENBQUMsRUFBRSxRQUFRLFVBQVUsUUFBUSxHQUFHO0FBQzNFLFlBQU8sQ0FBQyx1QkFBdUIsRUFBRSxRQUFRLFFBQVEsRUFBRSxRQUFRO0lBQzVELEVBQUMsQ0FBQyxLQUFLLElBQUk7R0FDYjs7Q0FFSjtBQUNELEtBQUksQ0FBQyxPQUFPLE1BQU8sRUFBQyxTQUFTLE9BQU8sRUFDbEMsTUFBTSxtQkFBbUIsS0FBSyxvQkFBb0I7VUFFOUMsVUFBVSxxQkFDWixPQUFPLG9CQUFvQjtVQUV2QixPQUFPLEtBQUssb0JBQW9CLENBQUMsUUFDbkMsT0FBTztBQUliLEtBQUksQ0FBQyxRQUFRLG1CQUFtQixPQUFPLFNBQVMsYUFDOUMsUUFBUSxrQkFBa0I7QUFFNUIsS0FBSSxDQUFDLFNBQVMsS0FBTSxFQUFDLFNBQVMsT0FBTyxJQUFJLE9BQU8sU0FBUyxhQUN2RCxPQUFPO0FBRVQsUUFBTyxPQUFPLE9BQ1o7RUFBRTtFQUFRO0VBQUs7Q0FBUyxHQUN4QixPQUFPLFNBQVMsY0FBYyxFQUFFLEtBQU0sSUFBRyxNQUN6QyxRQUFRLFVBQVUsRUFBRSxTQUFTLFFBQVEsUUFBUyxJQUFHLEtBQ2xEO0FBQ0Y7QUFHRCxTQUFTLHFCQUFxQixVQUFVLE9BQU8sU0FBUztBQUN0RCxRQUFPQSxRQUFNLE1BQU0sVUFBVSxPQUFPLFFBQVEsQ0FBQztBQUM5QztBQUdELFNBQVNDLGVBQWEsYUFBYSxhQUFhO0NBQzlDLE1BQU0sWUFBWSxNQUFNLGFBQWEsWUFBWTtDQUNqRCxNQUFNLFlBQVkscUJBQXFCLEtBQUssTUFBTSxVQUFVO0FBQzVELFFBQU8sT0FBTyxPQUFPLFdBQVc7RUFDOUIsVUFBVTtFQUNWLFVBQVVBLGVBQWEsS0FBSyxNQUFNLFVBQVU7RUFDNUMsT0FBTyxNQUFNLEtBQUssTUFBTSxVQUFVO0VBQ2xDO0NBQ0QsRUFBQztBQUNIO0FBR0QsSUFBSSxXQUFXQSxlQUFhLE1BQU0sU0FBUzs7Ozs7Q0NwVjNDLE1BQU0sYUFBYSxTQUFTQyxlQUFjLENBQUc7Q0FDN0MsV0FBVyxZQUFZLE9BQU8sT0FBTyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Q0FnQjFDLE1BQU0sVUFBVTs7Ozs7OztDQVFoQixNQUFNLGVBQWU7Ozs7Ozs7O0NBU3JCLE1BQU0sY0FBYztDQUdwQixNQUFNLHFCQUFxQjtFQUFFLE1BQU07RUFBSSxZQUFZLElBQUk7Q0FBYztDQUNyRSxPQUFPLE9BQU8sbUJBQW1CLFdBQVc7Q0FDNUMsT0FBTyxPQUFPLG1CQUFtQjs7Ozs7Ozs7Q0FVakMsU0FBUyxNQUFPLFFBQVE7QUFDdEIsTUFBSSxPQUFPLFdBQVcsU0FDcEIsT0FBTSxJQUFJLFVBQVU7RUFHdEIsSUFBSSxRQUFRLE9BQU8sUUFBUSxJQUFJO0VBQy9CLE1BQU1DLFNBQU8sVUFBVSxLQUNuQixPQUFPLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxHQUM3QixPQUFPLE1BQU07QUFFakIsTUFBSSxZQUFZLEtBQUtBLE9BQUssS0FBSyxNQUM3QixPQUFNLElBQUksVUFBVTtFQUd0QixNQUFNLFNBQVM7R0FDYixNQUFNQSxPQUFLLGFBQWE7R0FDeEIsWUFBWSxJQUFJO0VBQ2pCO0FBR0QsTUFBSSxVQUFVLEdBQ1osUUFBTztFQUdULElBQUk7RUFDSixJQUFJO0VBQ0osSUFBSUM7RUFFSixRQUFRLFlBQVk7QUFFcEIsU0FBUSxRQUFRLFFBQVEsS0FBSyxPQUFPLEVBQUc7QUFDckMsT0FBSSxNQUFNLFVBQVUsTUFDbEIsT0FBTSxJQUFJLFVBQVU7R0FHdEIsU0FBUyxNQUFNLEdBQUc7R0FDbEIsTUFBTSxNQUFNLEdBQUcsYUFBYTtHQUM1QkEsVUFBUSxNQUFNO0FBRWQsT0FBSUEsUUFBTSxPQUFPLE1BQUs7SUFFcEJBLFVBQVFBLFFBQ0wsTUFBTSxHQUFHQSxRQUFNLFNBQVMsRUFBRTtJQUU3QixhQUFhLEtBQUtBLFFBQU0sS0FBS0EsVUFBUUEsUUFBTSxRQUFRLGNBQWMsS0FBSztHQUN2RTtHQUVELE9BQU8sV0FBVyxPQUFPQTtFQUMxQjtBQUVELE1BQUksVUFBVSxPQUFPLE9BQ25CLE9BQU0sSUFBSSxVQUFVO0FBR3RCLFNBQU87Q0FDUjtDQUVELFNBQVNDLFlBQVcsUUFBUTtBQUMxQixNQUFJLE9BQU8sV0FBVyxTQUNwQixRQUFPO0VBR1QsSUFBSSxRQUFRLE9BQU8sUUFBUSxJQUFJO0VBQy9CLE1BQU1GLFNBQU8sVUFBVSxLQUNuQixPQUFPLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxHQUM3QixPQUFPLE1BQU07QUFFakIsTUFBSSxZQUFZLEtBQUtBLE9BQUssS0FBSyxNQUM3QixRQUFPO0VBR1QsTUFBTSxTQUFTO0dBQ2IsTUFBTUEsT0FBSyxhQUFhO0dBQ3hCLFlBQVksSUFBSTtFQUNqQjtBQUdELE1BQUksVUFBVSxHQUNaLFFBQU87RUFHVCxJQUFJO0VBQ0osSUFBSTtFQUNKLElBQUlDO0VBRUosUUFBUSxZQUFZO0FBRXBCLFNBQVEsUUFBUSxRQUFRLEtBQUssT0FBTyxFQUFHO0FBQ3JDLE9BQUksTUFBTSxVQUFVLE1BQ2xCLFFBQU87R0FHVCxTQUFTLE1BQU0sR0FBRztHQUNsQixNQUFNLE1BQU0sR0FBRyxhQUFhO0dBQzVCQSxVQUFRLE1BQU07QUFFZCxPQUFJQSxRQUFNLE9BQU8sTUFBSztJQUVwQkEsVUFBUUEsUUFDTCxNQUFNLEdBQUdBLFFBQU0sU0FBUyxFQUFFO0lBRTdCLGFBQWEsS0FBS0EsUUFBTSxLQUFLQSxVQUFRQSxRQUFNLFFBQVEsY0FBYyxLQUFLO0dBQ3ZFO0dBRUQsT0FBTyxXQUFXLE9BQU9BO0VBQzFCO0FBRUQsTUFBSSxVQUFVLE9BQU8sT0FDbkIsUUFBTztBQUdULFNBQU87Q0FDUjtDQUVELE9BQU8sUUFBUSxVQUFVO0VBQUU7RUFBTztDQUFXO0NBQzdDLE9BQU8sUUFBUSxRQUFRO0NBQ3ZCLE9BQU8sUUFBUSxZQUFZQztDQUMzQixPQUFPLFFBQVEscUJBQXFCOzs7OztBQ3hLcEMsSUFBTSxlQUFOLGNBQTJCLE1BQU07Q0FDL0I7Ozs7Q0FJQTs7OztDQUlBOzs7O0NBSUE7Q0FDQSxZQUFZLFNBQVMsWUFBWSxTQUFTO0VBQ3hDLE1BQU0sUUFBUTtFQUNkLEtBQUssT0FBTztFQUNaLEtBQUssU0FBUyxPQUFPLFNBQVMsV0FBVztBQUN6QyxNQUFJLE9BQU8sTUFBTSxLQUFLLE9BQU8sRUFDM0IsS0FBSyxTQUFTO0FBRWhCLE1BQUksY0FBYyxTQUNoQixLQUFLLFdBQVcsUUFBUTtFQUUxQixNQUFNLGNBQWMsT0FBTyxPQUFPLENBQUUsR0FBRSxRQUFRLFFBQVE7QUFDdEQsTUFBSSxRQUFRLFFBQVEsUUFBUSxlQUMxQixZQUFZLFVBQVUsT0FBTyxPQUFPLENBQUUsR0FBRSxRQUFRLFFBQVEsU0FBUyxFQUMvRCxlQUFlLFFBQVEsUUFBUSxRQUFRLGNBQWMsUUFDbkQsY0FDQSxjQUNELENBQ0YsRUFBQztFQUVKLFlBQVksTUFBTSxZQUFZLElBQUksUUFBUSx3QkFBd0IsMkJBQTJCLENBQUMsUUFBUSx1QkFBdUIsMEJBQTBCO0VBQ3ZKLEtBQUssVUFBVTtDQUNoQjtBQUNGOzs7OztBQzdCRCxJQUFJQyxZQUFVO0FBR2QsSUFBSSxtQkFBbUIsRUFDckIsU0FBUyxFQUNQLGNBQWMsQ0FBQyxtQkFBbUIsRUFBRUEsVUFBUSxDQUFDLEVBQUUsY0FBYyxFQUFFLENBQ2hFLEVBQ0Y7QUFNRCxTQUFTLGNBQWNDLFNBQU87QUFDNUIsS0FBSSxPQUFPQSxZQUFVLFlBQVlBLFlBQVUsS0FBTSxRQUFPO0FBQ3hELEtBQUksT0FBTyxVQUFVLFNBQVMsS0FBS0EsUUFBTSxLQUFLLGtCQUFtQixRQUFPO0NBQ3hFLE1BQU0sUUFBUSxPQUFPLGVBQWVBLFFBQU07QUFDMUMsS0FBSSxVQUFVLEtBQU0sUUFBTztDQUMzQixNQUFNLE9BQU8sT0FBTyxVQUFVLGVBQWUsS0FBSyxPQUFPLGNBQWMsSUFBSSxNQUFNO0FBQ2pGLFFBQU8sT0FBTyxTQUFTLGNBQWMsZ0JBQWdCLFFBQVEsU0FBUyxVQUFVLEtBQUssS0FBSyxLQUFLLFNBQVMsVUFBVSxLQUFLQSxRQUFNO0FBQzlIO0FBSUQsZUFBZSxhQUFhLGdCQUFnQjtDQUMxQyxNQUFNQyxVQUFRLGVBQWUsU0FBUyxTQUFTLFdBQVc7QUFDMUQsS0FBSSxDQUFDQSxRQUNILE9BQU0sSUFBSSxNQUNSO0NBR0osTUFBTSxNQUFNLGVBQWUsU0FBUyxPQUFPO0NBQzNDLE1BQU0sMkJBQTJCLGVBQWUsU0FBUyw2QkFBNkI7Q0FDdEYsTUFBTSxPQUFPLGNBQWMsZUFBZSxLQUFLLElBQUksTUFBTSxRQUFRLGVBQWUsS0FBSyxHQUFHLEtBQUssVUFBVSxlQUFlLEtBQUssR0FBRyxlQUFlO0NBQzdJLE1BQU0saUJBQWlCLE9BQU8sWUFDNUIsT0FBTyxRQUFRLGVBQWUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDQyxRQUFNRixRQUFNLEtBQUssQ0FDNURFLFFBQ0EsT0FBT0YsUUFBTSxBQUNkLEVBQUMsQ0FDSDtDQUNELElBQUk7QUFDSixLQUFJO0VBQ0YsZ0JBQWdCLE1BQU1DLFFBQU0sZUFBZSxLQUFLO0dBQzlDLFFBQVEsZUFBZTtHQUN2QjtHQUNBLFVBQVUsZUFBZSxTQUFTO0dBQ2xDLFNBQVM7R0FDVCxRQUFRLGVBQWUsU0FBUztHQUdoQyxHQUFHLGVBQWUsUUFBUSxFQUFFLFFBQVEsT0FBUTtFQUM3QyxFQUFDO0NBQ0gsU0FBUSxPQUFPO0VBQ2QsSUFBSSxVQUFVO0FBQ2QsTUFBSSxpQkFBaUIsT0FBTztBQUMxQixPQUFJLE1BQU0sU0FBUyxjQUFjO0lBQy9CLE1BQU0sU0FBUztBQUNmLFVBQU07R0FDUDtHQUNELFVBQVUsTUFBTTtBQUNoQixPQUFJLE1BQU0sU0FBUyxlQUFlLFdBQVcsT0FDM0M7UUFBSSxNQUFNLGlCQUFpQixPQUN6QixVQUFVLE1BQU0sTUFBTTthQUNiLE9BQU8sTUFBTSxVQUFVLFVBQ2hDLFVBQVUsTUFBTTtHQUNqQjtFQUVKO0VBQ0QsTUFBTSxlQUFlLElBQUksYUFBYSxTQUFTLEtBQUssRUFDbEQsU0FBUyxlQUNWO0VBQ0QsYUFBYSxRQUFRO0FBQ3JCLFFBQU07Q0FDUDtDQUNELE1BQU0sU0FBUyxjQUFjO0NBQzdCLE1BQU0sTUFBTSxjQUFjO0NBQzFCLE1BQU0sa0JBQWtCLENBQUU7QUFDMUIsTUFBSyxNQUFNLENBQUMsS0FBS0QsUUFBTSxJQUFJLGNBQWMsU0FDdkMsZ0JBQWdCLE9BQU9BO0NBRXpCLE1BQU0sa0JBQWtCO0VBQ3RCO0VBQ0E7RUFDQSxTQUFTO0VBQ1QsTUFBTTtDQUNQO0FBQ0QsS0FBSSxpQkFBaUIsaUJBQWlCO0VBQ3BDLE1BQU0sVUFBVSxnQkFBZ0IsUUFBUSxnQkFBZ0IsS0FBSyxNQUFNLGdDQUFnQztFQUNuRyxNQUFNLGtCQUFrQixXQUFXLFFBQVEsS0FBSztFQUNoRCxJQUFJLEtBQ0YsQ0FBQyxvQkFBb0IsRUFBRSxlQUFlLE9BQU8sQ0FBQyxFQUFFLGVBQWUsSUFBSSxrREFBa0QsRUFBRSxnQkFBZ0IsU0FBUyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsaUJBQWlCLEdBQUcsSUFBSSxDQUNwTTtDQUNGO0FBQ0QsS0FBSSxXQUFXLE9BQU8sV0FBVyxJQUMvQixRQUFPO0FBRVQsS0FBSSxlQUFlLFdBQVcsUUFBUTtBQUNwQyxNQUFJLFNBQVMsSUFDWCxRQUFPO0FBRVQsUUFBTSxJQUFJLGFBQWEsY0FBYyxZQUFZLFFBQVE7R0FDdkQsVUFBVTtHQUNWLFNBQVM7RUFDVjtDQUNGO0FBQ0QsS0FBSSxXQUFXLEtBQUs7RUFDbEIsZ0JBQWdCLE9BQU8sTUFBTSxnQkFBZ0IsY0FBYztBQUMzRCxRQUFNLElBQUksYUFBYSxnQkFBZ0IsUUFBUTtHQUM3QyxVQUFVO0dBQ1YsU0FBUztFQUNWO0NBQ0Y7QUFDRCxLQUFJLFVBQVUsS0FBSztFQUNqQixnQkFBZ0IsT0FBTyxNQUFNLGdCQUFnQixjQUFjO0FBQzNELFFBQU0sSUFBSSxhQUFhLGVBQWUsZ0JBQWdCLEtBQUssRUFBRSxRQUFRO0dBQ25FLFVBQVU7R0FDVixTQUFTO0VBQ1Y7Q0FDRjtDQUNELGdCQUFnQixPQUFPLDJCQUEyQixNQUFNLGdCQUFnQixjQUFjLEdBQUcsY0FBYztBQUN2RyxRQUFPO0FBQ1I7QUFDRCxlQUFlLGdCQUFnQixVQUFVO0NBQ3ZDLE1BQU0sY0FBYyxTQUFTLFFBQVEsSUFBSSxlQUFlO0FBQ3hELEtBQUksQ0FBQyxZQUNILFFBQU8sU0FBUyxNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUc7Q0FFeEMsTUFBTSx5REFBcUIsWUFBWTtBQUN2QyxLQUFJLGVBQWUsU0FBUyxFQUFFO0VBQzVCLElBQUksT0FBTztBQUNYLE1BQUk7R0FDRixPQUFPLE1BQU0sU0FBUyxNQUFNO0FBQzVCLFVBQU8sS0FBSyxNQUFNLEtBQUs7RUFDeEIsU0FBUSxLQUFLO0FBQ1osVUFBTztFQUNSO0NBQ0YsV0FBVSxTQUFTLEtBQUssV0FBVyxRQUFRLElBQUksU0FBUyxXQUFXLFNBQVMsYUFBYSxLQUFLLFFBQzdGLFFBQU8sU0FBUyxNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUc7S0FFdEMsUUFBTyxTQUFTLGFBQWEsQ0FBQyxNQUFNLHNCQUFNLElBQUksWUFBWSxHQUFHO0FBRWhFO0FBQ0QsU0FBUyxlQUFlLFVBQVU7QUFDaEMsUUFBTyxTQUFTLFNBQVMsc0JBQXNCLFNBQVMsU0FBUztBQUNsRTtBQUNELFNBQVMsZUFBZSxNQUFNO0FBQzVCLEtBQUksT0FBTyxTQUFTLFNBQ2xCLFFBQU87QUFFVCxLQUFJLGdCQUFnQixZQUNsQixRQUFPO0FBRVQsS0FBSSxhQUFhLE1BQU07RUFDckIsTUFBTSxTQUFTLHVCQUF1QixPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssbUJBQW1CLEdBQUc7QUFDOUUsU0FBTyxNQUFNLFFBQVEsS0FBSyxPQUFPLEdBQUcsR0FBRyxLQUFLLFFBQVEsRUFBRSxFQUFFLEtBQUssT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLFVBQVUsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLEdBQUcsUUFBUSxHQUFHLEdBQUcsS0FBSyxVQUFVLFFBQVE7Q0FDcko7QUFDRCxRQUFPLENBQUMsZUFBZSxFQUFFLEtBQUssVUFBVSxLQUFLLEVBQUU7QUFDaEQ7QUFHRCxTQUFTRyxlQUFhLGFBQWEsYUFBYTtDQUM5QyxNQUFNLFlBQVksWUFBWSxTQUFTLFlBQVk7Q0FDbkQsTUFBTSxTQUFTLFNBQVMsT0FBTyxZQUFZO0VBQ3pDLE1BQU0sa0JBQWtCLFVBQVUsTUFBTSxPQUFPLFdBQVc7QUFDMUQsTUFBSSxDQUFDLGdCQUFnQixXQUFXLENBQUMsZ0JBQWdCLFFBQVEsS0FDdkQsUUFBTyxhQUFhLFVBQVUsTUFBTSxnQkFBZ0IsQ0FBQztFQUV2RCxNQUFNLFdBQVcsQ0FBQyxRQUFRLGdCQUFnQjtBQUN4QyxVQUFPLGFBQ0wsVUFBVSxNQUFNLFVBQVUsTUFBTSxRQUFRLFlBQVksQ0FBQyxDQUN0RDtFQUNGO0VBQ0QsT0FBTyxPQUFPLFVBQVU7R0FDdEIsVUFBVTtHQUNWLFVBQVVBLGVBQWEsS0FBSyxNQUFNLFVBQVU7RUFDN0MsRUFBQztBQUNGLFNBQU8sZ0JBQWdCLFFBQVEsS0FBSyxVQUFVLGdCQUFnQjtDQUMvRDtBQUNELFFBQU8sT0FBTyxPQUFPLFFBQVE7RUFDM0IsVUFBVTtFQUNWLFVBQVVBLGVBQWEsS0FBSyxNQUFNLFVBQVU7Q0FDN0MsRUFBQztBQUNIO0FBR0QsSUFBSSxVQUFVQSxlQUFhLFVBQVUsaUJBQWlCOzs7O0FDM0x0RCxJQUFJQyxZQUFVO0FBU2QsU0FBUywrQkFBK0IsTUFBTTtBQUM1QyxRQUFPLENBQUM7QUFDVixDQUFDLEdBQUcsS0FBSyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUMsS0FBSyxLQUFLO0FBQ3ZEO0FBQ0QsSUFBSSx1QkFBdUIsY0FBYyxNQUFNO0NBQzdDLFlBQVksVUFBVSxTQUFTLFVBQVU7RUFDdkMsTUFBTSwrQkFBK0IsU0FBUyxDQUFDO0VBQy9DLEtBQUssVUFBVTtFQUNmLEtBQUssVUFBVTtFQUNmLEtBQUssV0FBVztFQUNoQixLQUFLLFNBQVMsU0FBUztFQUN2QixLQUFLLE9BQU8sU0FBUztBQUNyQixNQUFJLE1BQU0sbUJBQ1IsTUFBTSxrQkFBa0IsTUFBTSxLQUFLLFlBQVk7Q0FFbEQ7Q0FDRCxPQUFPO0NBQ1A7Q0FDQTtBQUNEO0FBR0QsSUFBSSx1QkFBdUI7Q0FDekI7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtBQUNEO0FBQ0QsSUFBSSw2QkFBNkI7Q0FBQztDQUFTO0NBQVU7QUFBTTtBQUMzRCxJQUFJLHVCQUF1QjtBQUMzQixTQUFTLFFBQVEsVUFBVSxPQUFPLFNBQVM7QUFDekMsS0FBSSxTQUFTO0FBQ1gsTUFBSSxPQUFPLFVBQVUsWUFBWSxXQUFXLFFBQzFDLFFBQU8sUUFBUSx1QkFDYixJQUFJLE1BQU0sQ0FBQywwREFBMEQsQ0FBQyxFQUN2RTtBQUVILE9BQUssTUFBTSxPQUFPLFNBQVM7QUFDekIsT0FBSSxDQUFDLDJCQUEyQixTQUFTLElBQUksQ0FBRTtBQUMvQyxVQUFPLFFBQVEsdUJBQ2IsSUFBSSxNQUNGLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxpQ0FBaUMsQ0FBQyxFQUVoRTtFQUNGO0NBQ0Y7Q0FDRCxNQUFNLGdCQUFnQixPQUFPLFVBQVUsV0FBVyxPQUFPLE9BQU8sRUFBRSxNQUFPLEdBQUUsUUFBUSxHQUFHO0NBQ3RGLE1BQU0saUJBQWlCLE9BQU8sS0FDNUIsY0FDRCxDQUFDLE9BQU8sQ0FBQyxRQUFRLFFBQVE7QUFDeEIsTUFBSSxxQkFBcUIsU0FBUyxJQUFJLEVBQUU7R0FDdEMsT0FBTyxPQUFPLGNBQWM7QUFDNUIsVUFBTztFQUNSO0FBQ0QsTUFBSSxDQUFDLE9BQU8sV0FDVixPQUFPLFlBQVksQ0FBRTtFQUV2QixPQUFPLFVBQVUsT0FBTyxjQUFjO0FBQ3RDLFNBQU87Q0FDUixHQUFFLENBQUUsRUFBQztDQUNOLE1BQU0sVUFBVSxjQUFjLFdBQVcsU0FBUyxTQUFTLFNBQVM7QUFDcEUsS0FBSSxxQkFBcUIsS0FBSyxRQUFRLEVBQ3BDLGVBQWUsTUFBTSxRQUFRLFFBQVEsc0JBQXNCLGVBQWU7QUFFNUUsUUFBTyxTQUFTLGVBQWUsQ0FBQyxLQUFLLENBQUMsYUFBYTtBQUNqRCxNQUFJLFNBQVMsS0FBSyxRQUFRO0dBQ3hCLE1BQU0sVUFBVSxDQUFFO0FBQ2xCLFFBQUssTUFBTSxPQUFPLE9BQU8sS0FBSyxTQUFTLFFBQVEsRUFDN0MsUUFBUSxPQUFPLFNBQVMsUUFBUTtBQUVsQyxTQUFNLElBQUkscUJBQ1IsZ0JBQ0EsU0FDQSxTQUFTO0VBRVo7QUFDRCxTQUFPLFNBQVMsS0FBSztDQUN0QixFQUFDO0FBQ0g7QUFHRCxTQUFTLGFBQWEsVUFBVSxhQUFhO0NBQzNDLE1BQU0sYUFBYSxTQUFTLFNBQVMsWUFBWTtDQUNqRCxNQUFNLFNBQVMsQ0FBQyxPQUFPLFlBQVk7QUFDakMsU0FBTyxRQUFRLFlBQVksT0FBTyxRQUFRO0NBQzNDO0FBQ0QsUUFBTyxPQUFPLE9BQU8sUUFBUTtFQUMzQixVQUFVLGFBQWEsS0FBSyxNQUFNLFdBQVc7RUFDN0MsVUFBVSxXQUFXO0NBQ3RCLEVBQUM7QUFDSDtBQUdELElBQUksV0FBVyxhQUFhLFNBQVM7Q0FDbkMsU0FBUyxFQUNQLGNBQWMsQ0FBQyxtQkFBbUIsRUFBRUEsVUFBUSxDQUFDLEVBQUUsY0FBYyxFQUFFLENBQ2hFO0NBQ0QsUUFBUTtDQUNSLEtBQUs7QUFDTixFQUFDO0FBQ0YsU0FBUyxrQkFBa0IsZUFBZTtBQUN4QyxRQUFPLGFBQWEsZUFBZTtFQUNqQyxRQUFRO0VBQ1IsS0FBSztDQUNOLEVBQUM7QUFDSDs7OztBQzFIRCxJQUFJLFNBQVM7QUFDYixJQUFJLE1BQU07QUFDVixJQUFJLHdCQUFRLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxTQUFTLE1BQU0sU0FBUyxNQUFNLE9BQU8sQ0FBQyxDQUFDO0FBQ2xFLElBQUksUUFBUSxNQUFNLEtBQUssS0FBSyxNQUFNO0FBR2xDLGVBQWUsS0FBSyxPQUFPO0NBQ3pCLE1BQU0sUUFBUSxNQUFNLE1BQU07Q0FDMUIsTUFBTSxpQkFBaUIsTUFBTSxXQUFXLE1BQU0sSUFBSSxNQUFNLFdBQVcsT0FBTztDQUMxRSxNQUFNLGlCQUFpQixNQUFNLFdBQVcsT0FBTztDQUMvQyxNQUFNLFlBQVksUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsaUJBQWlCLG1CQUFtQjtBQUN4RyxRQUFPO0VBQ0wsTUFBTTtFQUNOO0VBQ0E7Q0FDRDtBQUNGO0FBR0QsU0FBUyx3QkFBd0IsT0FBTztBQUN0QyxLQUFJLE1BQU0sTUFBTSxLQUFLLENBQUMsV0FBVyxFQUMvQixRQUFPLENBQUMsT0FBTyxFQUFFLE9BQU87QUFFMUIsUUFBTyxDQUFDLE1BQU0sRUFBRSxPQUFPO0FBQ3hCO0FBR0QsZUFBZSxLQUFLLE9BQU9DLFdBQVMsT0FBTyxZQUFZO0NBQ3JELE1BQU1DLGFBQVdELFVBQVEsU0FBUyxNQUNoQyxPQUNBLFdBQ0Q7Q0FDREMsV0FBUyxRQUFRLGdCQUFnQix3QkFBd0IsTUFBTTtBQUMvRCxRQUFPRCxVQUFRQyxXQUFTO0FBQ3pCO0FBR0QsSUFBSSxrQkFBa0IsU0FBUyxpQkFBaUIsT0FBTztBQUNyRCxLQUFJLENBQUMsTUFDSCxPQUFNLElBQUksTUFBTTtBQUVsQixLQUFJLE9BQU8sVUFBVSxTQUNuQixPQUFNLElBQUksTUFDUjtDQUdKLFFBQVEsTUFBTSxRQUFRLHNCQUFzQixHQUFHO0FBQy9DLFFBQU8sT0FBTyxPQUFPLEtBQUssS0FBSyxNQUFNLE1BQU0sRUFBRSxFQUMzQyxNQUFNLEtBQUssS0FBSyxNQUFNLE1BQU0sQ0FDN0IsRUFBQztBQUNIOzs7O0FDbkRELE1BQU1DLFlBQVU7Ozs7QUNNaEIsTUFBTSxPQUFPLE1BQU0sQ0FDbEI7QUFDRCxNQUFNLGNBQWMsUUFBUSxLQUFLLEtBQUssUUFBUTtBQUM5QyxNQUFNLGVBQWUsUUFBUSxNQUFNLEtBQUssUUFBUTtBQUNoRCxTQUFTLGFBQWEsU0FBUyxDQUFFLEdBQUU7QUFDakMsS0FBSSxPQUFPLE9BQU8sVUFBVSxZQUMxQixPQUFPLFFBQVE7QUFFakIsS0FBSSxPQUFPLE9BQU8sU0FBUyxZQUN6QixPQUFPLE9BQU87QUFFaEIsS0FBSSxPQUFPLE9BQU8sU0FBUyxZQUN6QixPQUFPLE9BQU87QUFFaEIsS0FBSSxPQUFPLE9BQU8sVUFBVSxZQUMxQixPQUFPLFFBQVE7QUFFakIsUUFBTztBQUNSO0FBQ0QsTUFBTSxpQkFBaUIsQ0FBQyxnQkFBZ0IsRUFBRUMsVUFBUSxDQUFDLEVBQUUsY0FBYyxFQUFFO0FBQ3JFLElBQU1DLFlBQU4sTUFBYztDQUNaLE9BQU8sVUFBVUQ7Q0FDakIsT0FBTyxTQUFTLFVBQVU7RUFDeEIsTUFBTSxzQkFBc0IsY0FBYyxLQUFLO0dBQzdDLFlBQVksR0FBRyxNQUFNO0lBQ25CLE1BQU0sVUFBVSxLQUFLLE1BQU0sQ0FBRTtBQUM3QixRQUFJLE9BQU8sYUFBYSxZQUFZO0tBQ2xDLE1BQU0sU0FBUyxRQUFRLENBQUM7QUFDeEI7SUFDRDtJQUNELE1BQ0UsT0FBTyxPQUNMLENBQUUsR0FDRixVQUNBLFNBQ0EsUUFBUSxhQUFhLFNBQVMsWUFBWSxFQUN4QyxXQUFXLEdBQUcsUUFBUSxVQUFVLENBQUMsRUFBRSxTQUFTLFdBQVcsQ0FDeEQsSUFBRyxLQUNMLENBQ0Y7R0FDRjtFQUNGO0FBQ0QsU0FBTztDQUNSO0NBQ0QsT0FBTyxVQUFVLENBQUU7Ozs7Ozs7Q0FPbkIsT0FBTyxPQUFPLEdBQUcsWUFBWTtFQUMzQixNQUFNLGlCQUFpQixLQUFLO0VBQzVCLE1BQU0sYUFBYSxjQUFjLEtBQUs7R0FDcEMsT0FBTyxVQUFVLGVBQWUsT0FDOUIsV0FBVyxPQUFPLENBQUMsV0FBVyxDQUFDLGVBQWUsU0FBUyxPQUFPLENBQUMsQ0FDaEU7RUFDRjtBQUNELFNBQU87Q0FDUjtDQUNELFlBQVksVUFBVSxDQUFFLEdBQUU7RUFDeEIsTUFBTUUsU0FBTyxJQUFJQywwQkFBSztFQUN0QixNQUFNLGtCQUFrQjtHQUN0QixTQUFTLFFBQVEsU0FBUyxTQUFTO0dBQ25DLFNBQVMsQ0FBRTtHQUNYLFNBQVMsT0FBTyxPQUFPLENBQUUsR0FBRSxRQUFRLFNBQVMsRUFFMUMsTUFBTUQsT0FBSyxLQUFLLE1BQU0sVUFBVSxDQUNqQyxFQUFDO0dBQ0YsV0FBVztJQUNULFVBQVUsQ0FBRTtJQUNaLFFBQVE7R0FDVDtFQUNGO0VBQ0QsZ0JBQWdCLFFBQVEsZ0JBQWdCLFFBQVEsWUFBWSxHQUFHLFFBQVEsVUFBVSxDQUFDLEVBQUUsZ0JBQWdCLEdBQUc7QUFDdkcsTUFBSSxRQUFRLFNBQ1YsZ0JBQWdCLFVBQVUsUUFBUTtBQUVwQyxNQUFJLFFBQVEsVUFDVixnQkFBZ0IsVUFBVSxXQUFXLFFBQVE7QUFFL0MsTUFBSSxRQUFRLFVBQ1YsZ0JBQWdCLFFBQVEsZUFBZSxRQUFRO0VBRWpELEtBQUssVUFBVSxRQUFRLFNBQVMsZ0JBQWdCO0VBQ2hELEtBQUssVUFBVSxrQkFBa0IsS0FBSyxRQUFRLENBQUMsU0FBUyxnQkFBZ0I7RUFDeEUsS0FBSyxNQUFNLGFBQWEsUUFBUSxJQUFJO0VBQ3BDLEtBQUssT0FBT0E7QUFDWixNQUFJLENBQUMsUUFBUSxhQUNYLEtBQUksQ0FBQyxRQUFRLE1BQ1gsS0FBSyxPQUFPLGFBQWEsRUFDdkIsTUFBTSxrQkFDUDtPQUNJO0dBQ0wsTUFBTUUsU0FBTyxnQkFBZ0IsUUFBUSxLQUFLO0dBQzFDRixPQUFLLEtBQUssV0FBV0UsT0FBSyxLQUFLO0dBQy9CLEtBQUssT0FBT0E7RUFDYjtPQUNJO0dBQ0wsTUFBTSxFQUFFLGFBQWMsR0FBRyxjQUFjLEdBQUc7R0FDMUMsTUFBTUEsU0FBTyxhQUNYLE9BQU8sT0FDTDtJQUNFLFNBQVMsS0FBSztJQUNkLEtBQUssS0FBSztJQU1WLFNBQVM7SUFDVCxnQkFBZ0I7R0FDakIsR0FDRCxRQUFRLEtBQ1QsQ0FDRjtHQUNERixPQUFLLEtBQUssV0FBV0UsT0FBSyxLQUFLO0dBQy9CLEtBQUssT0FBT0E7RUFDYjtFQUNELE1BQU0sbUJBQW1CLEtBQUs7QUFDOUIsT0FBSyxJQUFJLElBQUksR0FBRyxJQUFJLGlCQUFpQixRQUFRLFFBQVEsRUFBRSxHQUNyRCxPQUFPLE9BQU8sTUFBTSxpQkFBaUIsUUFBUSxHQUFHLE1BQU0sUUFBUSxDQUFDO0NBRWxFO0NBRUQ7Q0FDQTtDQUNBO0NBQ0E7Q0FFQTtBQUNEOzs7O0FDeklELE1BQU1DLFlBQVU7Ozs7QUNDaEIsU0FBUyxXQUFXLFNBQVM7Q0FDM0IsUUFBUSxLQUFLLEtBQUssV0FBVyxDQUFDQyxXQUFTLFlBQVk7RUFDakQsUUFBUSxJQUFJLE1BQU0sV0FBVyxRQUFRO0VBQ3JDLE1BQU0sUUFBUSxLQUFLLEtBQUs7RUFDeEIsTUFBTSxpQkFBaUIsUUFBUSxRQUFRLFNBQVMsTUFBTSxRQUFRO0VBQzlELE1BQU1DLFNBQU8sZUFBZSxJQUFJLFFBQVEsUUFBUSxTQUFTLEdBQUc7QUFDNUQsU0FBT0QsVUFBUSxRQUFRLENBQUMsS0FBSyxDQUFDLGFBQWE7R0FDekMsTUFBTSxZQUFZLFNBQVMsUUFBUTtHQUNuQyxRQUFRLElBQUksS0FDVixHQUFHLGVBQWUsT0FBTyxDQUFDLEVBQUVDLE9BQUssR0FBRyxFQUFFLFNBQVMsT0FBTyxTQUFTLEVBQUUsVUFBVSxJQUFJLEVBQUUsS0FBSyxLQUFLLEdBQUcsTUFBTSxFQUFFLENBQUMsQ0FDeEc7QUFDRCxVQUFPO0VBQ1IsRUFBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVO0dBQ2xCLE1BQU0sWUFBWSxNQUFNLFVBQVUsUUFBUSwwQkFBMEI7R0FDcEUsUUFBUSxJQUFJLE1BQ1YsR0FBRyxlQUFlLE9BQU8sQ0FBQyxFQUFFQSxPQUFLLEdBQUcsRUFBRSxNQUFNLE9BQU8sU0FBUyxFQUFFLFVBQVUsSUFBSSxFQUFFLEtBQUssS0FBSyxHQUFHLE1BQU0sRUFBRSxDQUFDLENBQ3JHO0FBQ0QsU0FBTTtFQUNQLEVBQUM7Q0FDSCxFQUFDO0FBQ0g7QUFDRCxXQUFXLFVBQVVDOzs7O0FDckJyQixJQUFJQyxZQUFVO0FBR2QsU0FBUywrQkFBK0IsVUFBVTtBQUNoRCxLQUFJLENBQUMsU0FBUyxLQUNaLFFBQU87RUFDTCxHQUFHO0VBQ0gsTUFBTSxDQUFFO0NBQ1Q7Q0FFSCxNQUFNLDhCQUE4QixpQkFBaUIsU0FBUyxRQUFRLG1CQUFtQixTQUFTLFNBQVMsRUFBRSxTQUFTLFNBQVM7QUFDL0gsS0FBSSxDQUFDLDJCQUE0QixRQUFPO0NBQ3hDLE1BQU0sb0JBQW9CLFNBQVMsS0FBSztDQUN4QyxNQUFNLHNCQUFzQixTQUFTLEtBQUs7Q0FDMUMsTUFBTSxhQUFhLFNBQVMsS0FBSztDQUNqQyxNQUFNLGVBQWUsU0FBUyxLQUFLO0NBQ25DLE9BQU8sU0FBUyxLQUFLO0NBQ3JCLE9BQU8sU0FBUyxLQUFLO0NBQ3JCLE9BQU8sU0FBUyxLQUFLO0NBQ3JCLE9BQU8sU0FBUyxLQUFLO0NBQ3JCLE1BQU0sZUFBZSxPQUFPLEtBQUssU0FBUyxLQUFLLENBQUM7Q0FDaEQsTUFBTSxPQUFPLFNBQVMsS0FBSztDQUMzQixTQUFTLE9BQU87QUFDaEIsS0FBSSxPQUFPLHNCQUFzQixhQUMvQixTQUFTLEtBQUsscUJBQXFCO0FBRXJDLEtBQUksT0FBTyx3QkFBd0IsYUFDakMsU0FBUyxLQUFLLHVCQUF1QjtDQUV2QyxTQUFTLEtBQUssY0FBYztDQUM1QixTQUFTLEtBQUssZ0JBQWdCO0FBQzlCLFFBQU87QUFDUjtBQUdELFNBQVMsU0FBUyxTQUFTLE9BQU8sWUFBWTtDQUM1QyxNQUFNLFVBQVUsT0FBTyxVQUFVLGFBQWEsTUFBTSxTQUFTLFdBQVcsR0FBRyxRQUFRLFFBQVEsU0FBUyxPQUFPLFdBQVc7Q0FDdEgsTUFBTSxnQkFBZ0IsT0FBTyxVQUFVLGFBQWEsUUFBUSxRQUFRO0NBQ3BFLE1BQU0sU0FBUyxRQUFRO0NBQ3ZCLE1BQU0sVUFBVSxRQUFRO0NBQ3hCLElBQUksTUFBTSxRQUFRO0FBQ2xCLFFBQU8sR0FDSixPQUFPLGdCQUFnQixPQUFPLEVBQzdCLE1BQU0sT0FBTztBQUNYLE1BQUksQ0FBQyxJQUFLLFFBQU8sRUFBRSxNQUFNLEtBQU07QUFDL0IsTUFBSTtHQUNGLE1BQU0sV0FBVyxNQUFNLGNBQWM7SUFBRTtJQUFRO0lBQUs7R0FBUyxFQUFDO0dBQzlELE1BQU0scUJBQXFCLCtCQUErQixTQUFTO0dBQ25FLFFBQVEsbUJBQW1CLFFBQVEsUUFBUSxJQUFJLE1BQzdDLDJCQUNELElBQUksQ0FBRSxHQUFFO0FBQ1QsT0FBSSxDQUFDLE9BQU8sbUJBQW1CLG1CQUFtQixNQUFNO0lBQ3RELE1BQU0sWUFBWSxJQUFJLElBQUksbUJBQW1CO0lBQzdDLE1BQU0sU0FBUyxVQUFVO0lBQ3pCLE1BQU0sT0FBTyxTQUFTLE9BQU8sSUFBSSxPQUFPLElBQUksS0FBSyxHQUFHO0lBQ3BELE1BQU0sV0FBVyxTQUFTLE9BQU8sSUFBSSxXQUFXLElBQUksT0FBTyxHQUFHO0FBQzlELFFBQUksT0FBTyxXQUFXLG1CQUFtQixLQUFLLGVBQWU7S0FDM0QsT0FBTyxJQUFJLFFBQVEsT0FBTyxPQUFPLEVBQUUsQ0FBQztLQUNwQyxNQUFNLFVBQVUsVUFBVTtJQUMzQjtHQUNGO0FBQ0QsVUFBTyxFQUFFLE9BQU8sbUJBQW9CO0VBQ3JDLFNBQVEsT0FBTztBQUNkLE9BQUksTUFBTSxXQUFXLElBQUssT0FBTTtHQUNoQyxNQUFNO0FBQ04sVUFBTyxFQUNMLE9BQU87SUFDTCxRQUFRO0lBQ1IsU0FBUyxDQUFFO0lBQ1gsTUFBTSxDQUFFO0dBQ1QsRUFDRjtFQUNGO0NBQ0YsRUFDRixHQUNGO0FBQ0Y7QUFHRCxTQUFTLFNBQVMsU0FBUyxPQUFPLFlBQVksT0FBTztBQUNuRCxLQUFJLE9BQU8sZUFBZSxZQUFZO0VBQ3BDLFFBQVE7RUFDUixhQUFhLEtBQUs7Q0FDbkI7QUFDRCxRQUFPLE9BQ0wsU0FDQSxDQUFFLEdBQ0YsU0FBUyxTQUFTLE9BQU8sV0FBVyxDQUFDLE9BQU8sZ0JBQWdCLEVBQzVELE1BQ0Q7QUFDRjtBQUNELFNBQVMsT0FBTyxTQUFTLFNBQVMsV0FBVyxPQUFPO0FBQ2xELFFBQU8sVUFBVSxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVc7QUFDdkMsTUFBSSxPQUFPLEtBQ1QsUUFBTztFQUVULElBQUksWUFBWTtFQUNoQixTQUFTLE9BQU87R0FDZCxZQUFZO0VBQ2I7RUFDRCxVQUFVLFFBQVEsT0FDaEIsUUFBUSxNQUFNLE9BQU8sT0FBTyxLQUFLLEdBQUcsT0FBTyxNQUFNLEtBQ2xEO0FBQ0QsTUFBSSxVQUNGLFFBQU87QUFFVCxTQUFPLE9BQU8sU0FBUyxTQUFTLFdBQVcsTUFBTTtDQUNsRCxFQUFDO0FBQ0g7QUFHRCxJQUFJLHNCQUFzQixPQUFPLE9BQU8sVUFBVSxFQUNoRCxTQUNELEVBQUM7QUFtUkYsU0FBUyxhQUFhLFNBQVM7QUFDN0IsUUFBTyxFQUNMLFVBQVUsT0FBTyxPQUFPLFNBQVMsS0FBSyxNQUFNLFFBQVEsRUFBRSxFQUNwRCxVQUFVLFNBQVMsS0FBSyxNQUFNLFFBQVEsQ0FDdkMsRUFBQyxDQUNIO0FBQ0Y7QUFDRCxhQUFhLFVBQVVBOzs7O0FDNVl2QixNQUFNQyxZQUFVOzs7O0FDQWhCLE1BQU0sWUFBWTtDQUNoQixTQUFTO0VBQ1AseUNBQXlDLENBQ3ZDLHFEQUNEO0VBQ0QsMENBQTBDLENBQ3hDLCtEQUNEO0VBQ0QsMkNBQTJDLENBQ3pDLHNGQUNEO0VBQ0QsNEJBQTRCLENBQzFCLDRFQUNEO0VBQ0QsOEJBQThCLENBQzVCLHVFQUNEO0VBQ0Qsb0JBQW9CLENBQ2xCLDBEQUNEO0VBQ0QsbUJBQW1CLENBQ2pCLHlEQUNEO0VBQ0QsMkJBQTJCLENBQ3pCLHNFQUNEO0VBQ0QsMEJBQTBCLENBQUMseUNBQTBDO0VBQ3JFLGlDQUFpQyxDQUMvQixpRkFDRDtFQUNELHlCQUF5QixDQUFDLCtDQUFnRDtFQUMxRSwwQkFBMEIsQ0FDeEIseURBQ0Q7RUFDRCxtQkFBbUIsQ0FBQyxvQ0FBcUM7RUFDekQsK0JBQStCLENBQzdCLHFEQUNEO0VBQ0QsZ0NBQWdDLENBQzlCLCtEQUNEO0VBQ0QseUJBQXlCLENBQUMsK0NBQWdEO0VBQzFFLDBCQUEwQixDQUN4Qix5REFDRDtFQUNELG9CQUFvQixDQUFDLDhDQUErQztFQUNwRSx3QkFBd0IsQ0FDdEIsdUVBQ0Q7RUFDRCx3QkFBd0IsQ0FDdEIsd0RBQ0Q7RUFDRCx5QkFBeUIsQ0FDdkIsdURBQ0Q7RUFDRCxnQkFBZ0IsQ0FDZCw4REFDRDtFQUNELHlCQUF5QixDQUN2QixvRkFDRDtFQUNELDJCQUEyQixDQUN6QiwrRUFDRDtFQUNELDBCQUEwQixDQUN4Qiw4REFDRDtFQUNELGlCQUFpQixDQUFDLGtEQUFtRDtFQUNyRSxtQkFBbUIsQ0FBQyw2Q0FBOEM7RUFDbEUsa0JBQWtCLENBQ2hCLDREQUNEO0VBQ0Qsb0JBQW9CLENBQ2xCLHVEQUNEO0VBQ0QsK0JBQStCLENBQzdCLGdEQUNEO0VBQ0QsZ0NBQWdDLENBQzlCLDBEQUNEO0VBQ0QsbUJBQW1CLENBQUMsb0RBQXFEO0VBQ3pFLHVCQUF1QixDQUNyQix5REFDRDtFQUNELG9EQUFvRCxDQUNsRCxxRUFDRDtFQUNELGlCQUFpQixDQUNmLG1FQUNEO0VBQ0Qsa0JBQWtCLENBQ2hCLDRFQUNEO0VBQ0QsK0JBQStCLENBQzdCLHNEQUNEO0VBQ0QsZ0NBQWdDLENBQzlCLGdGQUNEO0VBQ0QseUJBQXlCLENBQ3ZCLHNEQUNEO0VBQ0QsbURBQW1ELENBQ2pELGtFQUNEO0VBQ0QsZ0JBQWdCLENBQ2Qsa0VBQ0Q7RUFDRCx3QkFBd0IsQ0FDdEIsK0RBQ0Q7RUFDRCwrQkFBK0IsQ0FDN0IscURBQ0Q7RUFDRCxnQ0FBZ0MsQ0FDOUIsK0RBQ0Q7RUFDRCxxQkFBcUIsQ0FBQywwQ0FBMkM7RUFDakUsc0JBQXNCLENBQUMsK0NBQWdEO0VBQ3ZFLGtDQUFrQyxDQUNoQyxtREFDRDtFQUNELDRCQUE0QixDQUFDLHFDQUFzQztFQUNuRSwrQkFBK0IsQ0FDN0Isc0RBQ0Q7RUFDRCw2QkFBNkIsQ0FDM0IsZ0VBQ0Q7RUFDRCxhQUFhLENBQUMsMkRBQTREO0VBQzFFLDhCQUE4QixDQUM1QiwwREFDRDtFQUNELHlCQUF5QixDQUN2Qiw4RUFDRDtFQUNELHNCQUFzQixDQUNwQixpRkFDRDtFQUNELHdCQUF3QixDQUN0Qiw0RUFDRDtFQUNELHdEQUF3RCxDQUN0RCw4Q0FDRDtFQUNELHNEQUFzRCxDQUNwRCx3REFDRDtFQUNELHlDQUF5QyxDQUN2QyxxQ0FDRDtFQUNELHVDQUF1QyxDQUNyQywrQ0FDRDtFQUNELHVCQUF1QixDQUNyQiwyREFDRDtFQUNELHlDQUF5QyxDQUN2Qyw0REFDRDtFQUNELDhCQUE4QixDQUM1QiwrQ0FDRDtFQUNELG9DQUFvQyxDQUNsQyxzREFDRDtFQUNELHFDQUFxQyxDQUNuQyx1REFDRDtFQUNELGlDQUFpQyxDQUMvQixrREFDRDtFQUNELHNCQUFzQixDQUFDLGlEQUFrRDtFQUN6RSxpQkFBaUIsQ0FBQyw0Q0FBNkM7RUFDL0QsY0FBYyxDQUFDLCtDQUFnRDtFQUMvRCxnQkFBZ0IsQ0FBQywwQ0FBMkM7RUFDNUQsNkJBQTZCLENBQzNCLHFFQUNEO0VBQ0Qsb0JBQW9CO0dBQ2xCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLFdBQVcsdUNBQXdDLEVBQUU7RUFDbEU7RUFDRCxrQkFBa0IsQ0FBQyxzREFBdUQ7RUFDMUUsZUFBZSxDQUFDLHlEQUEwRDtFQUMxRSxpQkFBaUIsQ0FBQyxvREFBcUQ7RUFDdkUsa0JBQWtCLENBQ2hCLDJEQUNEO0VBQ0QsMkJBQTJCLENBQUMsNkNBQThDO0VBQzFFLDRCQUE0QixDQUMxQix1REFDRDtFQUNELGFBQWEsQ0FBQywyREFBNEQ7RUFDMUUsK0JBQStCLENBQzdCLHNEQUNEO0VBQ0QsZ0JBQWdCLENBQUMsaURBQWtEO0VBQ25FLHVCQUF1QixDQUNyQiwyRUFDRDtFQUNELHFCQUFxQixDQUNuQix3REFDRDtFQUNELGtCQUFrQixDQUNoQixrRUFDRDtFQUNELHNCQUFzQixDQUFDLDZDQUE4QztFQUNyRSx3QkFBd0IsQ0FDdEIsbUVBQ0Q7RUFDRCwwQkFBMEIsQ0FDeEIscUVBQ0Q7RUFDRCxzQ0FBc0MsQ0FDcEMsd0VBQ0Q7RUFDRCx5QkFBeUIsQ0FBQyx3Q0FBeUM7RUFDbkUsd0JBQXdCLENBQ3RCLHNEQUNEO0VBQ0QsK0JBQStCLENBQzdCLGdGQUNEO0VBQ0QscUNBQXFDLENBQ25DLG9EQUNEO0VBQ0Qsc0NBQXNDLENBQ3BDLDhEQUNEO0VBQ0QsZ0JBQWdCLENBQUMsaUNBQWtDO0VBQ25ELGtCQUFrQixDQUFDLG1DQUFvQztFQUN2RCw2QkFBNkIsQ0FDM0Isd0RBQ0Q7RUFDRCwrQkFBK0IsQ0FDN0IsMERBQ0Q7RUFDRCxpQkFBaUIsQ0FBQywyQ0FBNEM7RUFDOUQsbUJBQW1CLENBQUMsNkNBQThDO0VBQ2xFLG1CQUFtQixDQUFDLDZDQUE4QztFQUNsRSw4QkFBOEIsQ0FBQywyQ0FBNEM7RUFDM0UsK0JBQStCLENBQzdCLHFEQUNEO0VBQ0QsK0JBQStCLENBQzdCLDREQUNEO0VBQ0QsaUNBQWlDLENBQy9CLHVEQUNEO0VBQ0QsMERBQTBELENBQ3hELGtEQUNEO0VBQ0QsNkJBQTZCLENBQUMsaUNBQWtDO0VBQ2hFLDhCQUE4QixDQUFDLDJDQUE0QztFQUMzRSwwQkFBMEIsQ0FDeEIsMkRBQ0Q7RUFDRCxrQkFBa0IsQ0FDaEIsZ0VBQ0Q7RUFDRCx5QkFBeUIsQ0FBQyx3Q0FBeUM7RUFDbkUsd0JBQXdCLENBQ3RCLHdEQUNEO0VBQ0QsZUFBZSxDQUFDLHdEQUF5RDtFQUN6RSx5QkFBeUIsQ0FDdkIsb0VBQ0Q7RUFDRCxpREFBaUQsQ0FDL0MsdURBQ0Q7RUFDRCxrREFBa0QsQ0FDaEQsaUVBQ0Q7RUFDRCw2Q0FBNkMsQ0FDM0MsOERBQ0Q7RUFDRCw4Q0FBOEMsQ0FDNUMsd0VBQ0Q7RUFDRCxpQ0FBaUMsQ0FDL0IsK0VBQ0Q7RUFDRCxtQ0FBbUMsQ0FDakMsMEVBQ0Q7RUFDRCx5QkFBeUIsQ0FDdkIsNkVBQ0Q7RUFDRCxnQ0FBZ0MsQ0FDOUIsc0VBQ0Q7RUFDRCwrQkFBK0IsQ0FDN0Isc0RBQ0Q7RUFDRCw2QkFBNkIsQ0FDM0IsZ0VBQ0Q7RUFDRCwwQ0FBMEMsQ0FDeEMsb0RBQ0Q7RUFDRCwyQ0FBMkMsQ0FDekMsOERBQ0Q7RUFDRCw4QkFBOEIsQ0FDNUIsMERBQ0Q7RUFDRCx3REFBd0QsQ0FDdEQsOENBQ0Q7RUFDRCxzREFBc0QsQ0FDcEQsd0RBQ0Q7RUFDRCx5Q0FBeUMsQ0FDdkMscUNBQ0Q7RUFDRCx1Q0FBdUMsQ0FDckMsK0NBQ0Q7RUFDRCw4QkFBOEIsQ0FDNUIsNERBQ0Q7RUFDRCxnQ0FBZ0MsQ0FDOUIsdURBQ0Q7RUFDRCx5REFBeUQsQ0FDdkQsa0RBQ0Q7RUFDRCwrQkFBK0IsQ0FDN0Isc0RBQ0Q7RUFDRCwyQkFBMkIsQ0FDekIsOEVBQ0Q7RUFDRCwwQkFBMEIsQ0FDeEIsNkRBQ0Q7RUFDRCxtQkFBbUIsQ0FBQyw0Q0FBNkM7RUFDakUsb0JBQW9CLENBQ2xCLHNEQUNEO0NBQ0Y7Q0FDRCxVQUFVO0VBQ1IsdUNBQXVDLENBQUMsa0NBQW1DO0VBQzNFLHdCQUF3QixDQUFDLDJDQUE0QztFQUNyRSwwQkFBMEIsQ0FDeEIsd0RBQ0Q7RUFDRCxVQUFVLENBQUMsWUFBYTtFQUN4QixxQkFBcUIsQ0FBQyx3Q0FBeUM7RUFDL0QsV0FBVyxDQUFDLHdDQUF5QztFQUNyRCwyQ0FBMkMsQ0FDekMscURBQ0Q7RUFDRCxnQ0FBZ0MsQ0FBQyw4QkFBK0I7RUFDaEUsdUNBQXVDLENBQUMsb0JBQXFCO0VBQzdELG1DQUFtQyxDQUNqQyx5Q0FDRDtFQUNELGtCQUFrQixDQUFDLGFBQWM7RUFDakMsZ0NBQWdDLENBQUMscUNBQXNDO0VBQ3ZFLHlCQUF5QixDQUFDLHFDQUFzQztFQUNoRSxxQkFBcUIsQ0FBQyx3QkFBeUI7RUFDL0MsMkJBQTJCLENBQUMsdUNBQXdDO0VBQ3BFLGlDQUFpQyxDQUMvQiw4Q0FDRDtFQUNELGdCQUFnQixDQUFDLGtDQUFtQztFQUNwRCwyQ0FBMkMsQ0FDekMseUNBQ0Q7RUFDRCxxQ0FBcUMsQ0FBQyxtQkFBb0I7RUFDMUQsd0JBQXdCLENBQUMsK0JBQWdDO0VBQ3pELHdCQUF3QixDQUFDLHFDQUFzQztFQUMvRCx1QkFBdUIsQ0FBQyxzQ0FBdUM7RUFDL0Qsc0NBQXNDLENBQUMseUJBQTBCO0VBQ2pFLHFCQUFxQixDQUFDLHVDQUF3QztFQUM5RCx5QkFBeUIsQ0FBQyxvQkFBcUI7RUFDL0MsNkJBQTZCLENBQUMseUNBQTBDO0VBQ3hFLGtCQUFrQixDQUFDLDJDQUE0QztFQUMvRCxrQkFBa0IsQ0FBQywwQ0FBMkM7RUFDOUQscUJBQXFCLENBQUMsd0NBQXlDO0VBQy9ELHVCQUF1QixDQUNyQixxREFDRDtFQUNELDhCQUE4QixDQUFDLGtDQUFtQztFQUNsRSxnQ0FBZ0MsQ0FBQyxxQ0FBc0M7Q0FDeEU7Q0FDRCxNQUFNO0VBQ0osdUJBQXVCO0dBQ3JCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLFFBQVEsMkNBQTRDLEVBQUU7RUFDbkU7RUFDRCwyQ0FBMkMsQ0FDekMsd0VBQ0Q7RUFDRCxZQUFZLENBQUMsc0NBQXVDO0VBQ3BELG9CQUFvQixDQUFDLHdDQUF5QztFQUM5RCwrQkFBK0IsQ0FDN0IseURBQ0Q7RUFDRCxxQkFBcUIsQ0FBQyx3Q0FBeUM7RUFDL0Qsb0JBQW9CLENBQUMsNkNBQThDO0VBQ25FLGFBQWEsQ0FBQyx3Q0FBeUM7RUFDdkQsa0JBQWtCLENBQUMsVUFBVztFQUM5QixXQUFXLENBQUMsc0JBQXVCO0VBQ25DLGlCQUFpQixDQUFDLDBDQUEyQztFQUM3RCxvQkFBb0IsQ0FBQyw4QkFBK0I7RUFDcEQscUJBQXFCLENBQUMsd0NBQXlDO0VBQy9ELCtCQUErQixDQUM3QixnREFDRDtFQUNELHNDQUFzQyxDQUNwQyx3REFDRDtFQUNELHFCQUFxQixDQUFDLG9DQUFxQztFQUMzRCx3QkFBd0IsQ0FBQyxzQkFBdUI7RUFDaEQsb0JBQW9CLENBQUMsd0NBQXlDO0VBQzlELHFCQUFxQixDQUFDLG1EQUFvRDtFQUMxRSw0QkFBNEIsQ0FDMUIsMkRBQ0Q7RUFDRCwyQ0FBMkMsQ0FDekMsd0RBQ0Q7RUFDRCw2Q0FBNkMsQ0FDM0MsZ0NBQ0Q7RUFDRCxtQkFBbUIsQ0FBQyx3QkFBeUI7RUFDN0MsdUNBQXVDLENBQUMseUJBQTBCO0VBQ2xFLFdBQVcsQ0FBQyxnQ0FBaUM7RUFDN0Msa0JBQWtCLENBQUMsd0NBQXlDO0VBQzVELG1DQUFtQyxDQUFDLGdDQUFpQztFQUNyRSx1Q0FBdUMsQ0FBQyxpQ0FBa0M7RUFDMUUsOENBQThDLENBQzVDLHlDQUNEO0VBQ0QsdUJBQXVCLENBQUMsMEJBQTJCO0VBQ25ELDBCQUEwQixDQUN4QixrREFDRDtFQUNELDRCQUE0QjtHQUMxQjtHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxRQUFRLGdEQUFpRCxFQUFFO0VBQ3hFO0VBQ0QsZ0RBQWdELENBQzlDLDJFQUNEO0VBQ0QsWUFBWSxDQUFDLHVDQUF3QztFQUNyRCwrQkFBK0IsQ0FBQyw0QkFBNkI7RUFDN0QsWUFBWSxDQUFDLDZDQUE4QztFQUMzRCxxQkFBcUIsQ0FBQyxvREFBcUQ7RUFDM0UsdUJBQXVCLENBQ3JCLHVEQUNEO0VBQ0QsMkJBQTJCLENBQUMsd0JBQXlCO0NBQ3REO0NBQ0QsU0FBUztFQUNQLDRCQUE0QixDQUFDLDBDQUEyQztFQUN4RSw2QkFBNkIsQ0FDM0IsZ0RBQ0Q7RUFDRCxnQ0FBZ0MsQ0FDOUIsaURBQ0Q7RUFDRCxpQ0FBaUMsQ0FDL0IsOENBQ0Q7RUFDRCw2QkFBNkIsQ0FBQywyQ0FBNEM7RUFDMUUsOEJBQThCLENBQzVCLGlEQUNEO0VBQ0QsNEJBQTRCLENBQzFCLGlEQUNEO0VBQ0QsNkJBQTZCLENBQzNCLHVEQUNEO0NBQ0Y7Q0FDRCxXQUFXO0VBQ1QsZ0JBQWdCLENBQUMsNEJBQTZCO0VBQzlDLGdCQUFnQixDQUFDLGdEQUFpRDtFQUNsRSxvQkFBb0IsQ0FBQyw2Q0FBOEM7RUFDbkUsa0JBQWtCLENBQUMsMkJBQTRCO0VBQy9DLGdCQUFnQixDQUFDLCtDQUFnRDtDQUNsRTtDQUNELFFBQVE7RUFDTixRQUFRLENBQUMsdUNBQXdDO0VBQ2pELGFBQWEsQ0FBQyx5Q0FBMEM7RUFDeEQsS0FBSyxDQUFDLHFEQUFzRDtFQUM1RCxVQUFVLENBQUMseURBQTBEO0VBQ3JFLGlCQUFpQixDQUNmLGlFQUNEO0VBQ0QsWUFBWSxDQUFDLG9EQUFxRDtFQUNsRSxjQUFjLENBQ1osb0VBQ0Q7RUFDRCxrQkFBa0IsQ0FBQyxzREFBdUQ7RUFDMUUsY0FBYyxDQUNaLGdFQUNEO0VBQ0QsZ0JBQWdCLENBQ2Qsb0VBQ0Q7RUFDRCxzQkFBc0IsQ0FDcEIsc0RBQ0Q7RUFDRCxRQUFRLENBQUMsdURBQXdEO0NBQ2xFO0NBQ0QsY0FBYztFQUNaLGVBQWUsQ0FDYixnRkFDRDtFQUNELGVBQWUsQ0FDYix3RUFDRDtFQUNELHVCQUF1QixDQUNyQixrRUFDRDtFQUNELGdCQUFnQixDQUNkLG9GQUNEO0VBQ0Qsc0JBQXNCLENBQ3BCLHdFQUNEO0VBQ0QsVUFBVTtHQUNSO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsbUJBQW1CLEVBQUUsVUFBVSxlQUFnQixFQUFFO0VBQ3BEO0VBQ0QsYUFBYSxDQUNYLGdFQUNEO0VBQ0QsWUFBWSxDQUNWLHVFQUNEO0VBQ0QsbUJBQW1CLENBQ2pCLHFFQUNEO0VBQ0QsaUJBQWlCLENBQUMsdURBQXdEO0VBQzFFLFVBQVUsQ0FBQywyREFBNEQ7RUFDdkUsb0JBQW9CLENBQ2xCLDhGQUNEO0VBQ0QsNEJBQTRCLENBQzFCLDZIQUNEO0VBQ0Qsb0JBQW9CLENBQ2xCLHlFQUNEO0VBQ0Qsa0JBQWtCLENBQUMsc0NBQXVDO0VBQzFELG1CQUFtQixDQUFDLGdEQUFpRDtFQUNyRSxxQkFBcUI7R0FDbkI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsZ0JBQWdCLG9CQUFxQixFQUFFO0VBQ3BEO0VBQ0QscUJBQXFCLENBQ25CLDBEQUNEO0VBQ0Qsb0JBQW9CLENBQUMsa0RBQW1EO0VBQ3hFLGFBQWEsQ0FDWCxpRUFDRDtFQUNELG9CQUFvQixDQUNsQix5REFDRDtFQUNELGFBQWEsQ0FBQyxpREFBa0Q7Q0FDakU7Q0FDRCxjQUFjO0VBQ1oscUJBQXFCLENBQ25CLHlFQUNEO0VBQ0QsK0JBQStCLENBQzdCLHVGQUNEO0VBQ0QscUJBQXFCLENBQUMsK0NBQWdEO0VBQ3RFLGtDQUFrQyxDQUNoQyw2REFDRDtFQUNELHFCQUFxQixDQUNuQixvRUFDRDtFQUNELGtDQUFrQyxDQUNoQyxrRkFDRDtFQUNELHFCQUFxQixDQUNuQix3REFDRDtFQUNELGtCQUFrQixDQUNoQixpRUFDRDtFQUNELCtCQUErQixDQUM3Qix1REFDRDtFQUNELGdDQUFnQyxDQUM5Qiw0REFDRDtFQUNELHlCQUF5QixDQUFDLDhDQUErQztFQUN6RSwwQkFBMEIsQ0FDeEIsdURBQ0Q7RUFDRCx1Q0FBdUMsQ0FDckMscUVBQ0Q7RUFDRCxpQ0FBaUMsQ0FDL0IsOEVBQ0Q7RUFDRCwyQ0FBMkMsQ0FDekMsNEZBQ0Q7RUFDRCxxQ0FBcUMsQ0FDbkMsK0VBQ0Q7RUFDRCwyQkFBMkIsQ0FDekIsMEVBQ0Q7RUFDRCx3Q0FBd0MsQ0FDdEMsd0ZBQ0Q7RUFDRCxxQkFBcUIsQ0FDbkIsbUVBQ0Q7RUFDRCwrQkFBK0IsQ0FDN0IsaUZBQ0Q7Q0FDRjtDQUNELGdCQUFnQjtFQUNkLHNCQUFzQixDQUFDLHVCQUF3QjtFQUMvQyxnQkFBZ0IsQ0FBQyw2QkFBOEI7Q0FDaEQ7Q0FDRCxZQUFZO0VBQ1YsNENBQTRDLENBQzFDLHlFQUNEO0VBQ0QsNEJBQTRCLENBQzFCLCtFQUNEO0VBQ0QsaUNBQWlDLENBQy9CLHdEQUNEO0VBQ0QsdUNBQXVDLENBQ3JDLGdEQUNEO0VBQ0QsNEJBQTRCLENBQUMsdUJBQXdCO0VBQ3JELHlCQUF5QixDQUN2QixrREFDRDtFQUNELDBCQUEwQixDQUN4Qiw0REFDRDtFQUNELDBDQUEwQyxDQUN4Qyw0Q0FDRDtFQUNELGtDQUFrQyxDQUNoQywyREFDRDtFQUNELG9DQUFvQyxDQUNsQyx1Q0FDRDtFQUNELDRCQUE0QixDQUFDLDBDQUEyQztFQUN4RSx3QkFBd0IsQ0FDdEIsbUVBQ0Q7RUFDRCxpQkFBaUIsQ0FBQyxxREFBc0Q7RUFDeEUsa0JBQWtCLENBQ2hCLCtEQUNEO0VBQ0Qsa0NBQWtDLENBQ2hDLCtDQUNEO0VBQ0QsNEJBQTRCLENBQzFCLGdEQUNEO0VBQ0QsMkJBQTJCLENBQ3pCLCtDQUNEO0VBQ0Qsc0NBQXNDLENBQ3BDLDJEQUNEO0VBQ0QseUJBQXlCLENBQUMsdUNBQXdDO0VBQ2xFLGlCQUFpQixDQUFDLCtDQUFnRDtFQUNsRSxjQUFjLENBQUMsa0RBQW1EO0VBQ2xFLGtDQUFrQyxDQUNoQyx5Q0FDRDtFQUNELGtCQUFrQixDQUNoQix5REFDRDtFQUNELGVBQWUsQ0FDYiw0REFDRDtFQUNELCtCQUErQixDQUM3Qiw0Q0FDRDtFQUNELG1EQUFtRCxDQUNqRCxvREFDRDtFQUNELDBCQUEwQixDQUFDLHNCQUF1QjtFQUNsRCxvQkFBb0I7R0FDbEI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxtQkFBbUIsRUFBRSxRQUFRLE1BQU8sRUFBRTtFQUN6QztFQUNELHNDQUFzQyxDQUNwQyxzQ0FDRDtFQUNELGdCQUFnQixDQUFDLG9DQUFxQztFQUN0RCxpQkFBaUIsQ0FBQyw4Q0FBK0M7RUFDakUsK0NBQStDLENBQzdDLHlEQUNEO0VBQ0QsaUNBQWlDLENBQUMsOEJBQStCO0VBQ2pFLCtCQUErQixDQUM3QiwrREFDRDtFQUNELHVDQUF1QyxDQUNyQywwQ0FDRDtFQUNELDZCQUE2QixDQUMzQixnREFDRDtFQUNELCtDQUErQyxDQUM3Qyw0RUFDRDtFQUNELGlDQUFpQyxDQUMvQixrRkFDRDtFQUNELGtDQUFrQyxDQUNoQywrQ0FDRDtFQUNELDhDQUE4QyxDQUM1Qyx5REFDRDtFQUNELDhCQUE4QixDQUM1QiwrREFDRDtFQUNELDJCQUEyQixDQUFDLDhDQUErQztFQUMzRSwwQkFBMEIsQ0FBQyw2Q0FBOEM7RUFDekUsb0JBQW9CLENBQ2xCLHNFQUNEO0VBQ0QsNEJBQTRCLENBQUMseUNBQTBDO0NBQ3hFO0NBQ0QsU0FBUztFQUNQLHlCQUF5QixDQUN2QixpREFDRDtFQUNELHlCQUF5QixDQUN2QixpREFDRDtFQUNELHFDQUFxQyxDQUNuQyxtREFDRDtFQUNELHFDQUFxQyxDQUNuQyxtREFDRDtFQUNELCtCQUErQixDQUFDLGlDQUFrQztFQUNsRSx1QkFBdUIsQ0FBQyxrREFBbUQ7RUFDM0UsK0JBQStCLENBQUMsaUNBQWtDO0VBQ2xFLDhCQUE4QixDQUM1Qiw0Q0FDRDtFQUNELGtCQUFrQixDQUFDLHVDQUF3QztDQUM1RDtDQUNELGFBQWEsRUFBRSxRQUFRLENBQUMsMEJBQTJCLEVBQUU7Q0FDckQsWUFBWTtFQUNWLDRCQUE0QixDQUMxQiwrRUFDRDtFQUNELHlCQUF5QixDQUN2QixrREFDRDtFQUNELDBCQUEwQixDQUN4Qiw0REFDRDtFQUNELGlCQUFpQixDQUFDLHFEQUFzRDtFQUN4RSxrQkFBa0IsQ0FDaEIsK0RBQ0Q7RUFDRCxVQUFVLENBQUMsNERBQTZEO0VBQ3hFLGlCQUFpQixDQUFDLCtDQUFnRDtFQUNsRSxjQUFjLENBQUMsa0RBQW1EO0VBQ2xFLGtCQUFrQixDQUNoQix5REFDRDtFQUNELGVBQWUsQ0FDYiw0REFDRDtFQUNELHlCQUF5QixDQUN2QixpREFDRDtFQUNELGtCQUFrQixDQUFDLG1DQUFvQztFQUN2RCxtQkFBbUIsQ0FBQyw2Q0FBOEM7RUFDbEUsZ0JBQWdCLENBQUMsb0NBQXFDO0VBQ3RELGlCQUFpQixDQUFDLDhDQUErQztFQUNqRSwrQkFBK0IsQ0FDN0IsK0RBQ0Q7RUFDRCxpQ0FBaUMsQ0FDL0Isa0ZBQ0Q7RUFDRCw4QkFBOEIsQ0FDNUIsK0RBQ0Q7RUFDRCxhQUFhLENBQ1gsOERBQ0Q7Q0FDRjtDQUNELGlCQUFpQjtFQUNmLDBCQUEwQixDQUN4Qix1REFDRDtFQUNELFdBQVcsQ0FDVCwrREFDRDtFQUNELFlBQVksQ0FBQyxpREFBa0Q7Q0FDaEU7Q0FDRCxRQUFRLEVBQUUsS0FBSyxDQUFDLGFBQWMsRUFBRTtDQUNoQyxPQUFPO0VBQ0wsZ0JBQWdCLENBQUMsMkJBQTRCO0VBQzdDLFFBQVEsQ0FBQyxhQUFjO0VBQ3ZCLGVBQWUsQ0FBQyxnQ0FBaUM7RUFDakQsUUFBUSxDQUFDLHlCQUEwQjtFQUNuQyxlQUFlLENBQUMsK0NBQWdEO0VBQ2hFLE1BQU0sQ0FBQyw2QkFBOEI7RUFDckMsS0FBSyxDQUFDLHNCQUF1QjtFQUM3QixZQUFZLENBQUMsNENBQTZDO0VBQzFELGFBQWEsQ0FBQyw0QkFBNkI7RUFDM0MsTUFBTSxDQUFDLFlBQWE7RUFDcEIsY0FBYyxDQUFDLCtCQUFnQztFQUMvQyxhQUFhLENBQUMsOEJBQStCO0VBQzdDLGFBQWEsQ0FBQyw2QkFBOEI7RUFDNUMsV0FBVyxDQUFDLDRCQUE2QjtFQUN6QyxZQUFZLENBQUMsbUJBQW9CO0VBQ2pDLGFBQWEsQ0FBQyxvQkFBcUI7RUFDbkMsTUFBTSxDQUFDLDJCQUE0QjtFQUNuQyxRQUFRLENBQUMsOEJBQStCO0VBQ3hDLFFBQVEsQ0FBQyx3QkFBeUI7RUFDbEMsZUFBZSxDQUFDLDhDQUErQztDQUNoRTtDQUNELEtBQUs7RUFDSCxZQUFZLENBQUMsc0NBQXVDO0VBQ3BELGNBQWMsQ0FBQyx3Q0FBeUM7RUFDeEQsV0FBVyxDQUFDLHFDQUFzQztFQUNsRCxXQUFXLENBQUMscUNBQXNDO0VBQ2xELFlBQVksQ0FBQyxzQ0FBdUM7RUFDcEQsV0FBVyxDQUFDLDZDQUE4QztFQUMxRCxTQUFTLENBQUMsZ0RBQWlEO0VBQzNELFdBQVcsQ0FBQyxvREFBcUQ7RUFDakUsUUFBUSxDQUFDLHlDQUEwQztFQUNuRCxRQUFRLENBQUMsOENBQStDO0VBQ3hELFNBQVMsQ0FBQyxnREFBaUQ7RUFDM0Qsa0JBQWtCLENBQUMsbURBQW9EO0VBQ3ZFLFdBQVcsQ0FBQyw0Q0FBNkM7Q0FDMUQ7Q0FDRCxXQUFXO0VBQ1QsaUJBQWlCLENBQUMsMEJBQTJCO0VBQzdDLGFBQWEsQ0FBQyxpQ0FBa0M7Q0FDakQ7Q0FDRCxlQUFlO0VBQ2Isa0NBQWtDLENBQ2hDLGtEQUNEO0VBQ0QsbUNBQW1DLENBQ2pDLCtFQUNEO0VBQ0QsK0JBQStCLENBQzdCLDRFQUNEO0VBQ0QsMEJBQTBCLENBQ3hCLGlFQUNEO0VBQ0QsaUNBQWlDLENBQy9CLGlEQUNEO0VBQ0Qsa0NBQWtDLENBQ2hDLDhFQUNEO0NBQ0Y7Q0FDRCxjQUFjO0VBQ1oscUNBQXFDLENBQUMsOEJBQStCO0VBQ3JFLHVCQUF1QixDQUFDLG9DQUFxQztFQUM3RCx3QkFBd0IsQ0FBQyw4Q0FBK0M7RUFDeEUsbUNBQW1DO0dBQ2pDO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLGdCQUFnQixxQ0FBc0MsRUFBRTtFQUNyRTtFQUNELHdDQUF3QyxDQUFDLGlDQUFrQztFQUMzRSwwQkFBMEIsQ0FBQyx1Q0FBd0M7RUFDbkUsMkJBQTJCLENBQ3pCLGlEQUNEO0VBQ0Qsc0NBQXNDO0dBQ3BDO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLGdCQUFnQix3Q0FBeUMsRUFBRTtFQUN4RTtFQUNELHFDQUFxQyxDQUFDLDhCQUErQjtFQUNyRSx1QkFBdUIsQ0FBQyxvQ0FBcUM7RUFDN0Qsd0JBQXdCLENBQUMsOENBQStDO0VBQ3hFLG1DQUFtQztHQUNqQztHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxnQkFBZ0IscUNBQXNDLEVBQUU7RUFDckU7Q0FDRjtDQUNELFFBQVE7RUFDTixjQUFjLENBQ1osNERBQ0Q7RUFDRCxXQUFXLENBQUMseURBQTBEO0VBQ3RFLGFBQWEsQ0FDWCw2REFDRDtFQUNELHdCQUF3QixDQUFDLGdEQUFpRDtFQUMxRSwrQkFBK0IsQ0FDN0Isc0VBQ0Q7RUFDRCxRQUFRLENBQUMsbUNBQW9DO0VBQzdDLGVBQWUsQ0FDYiwyREFDRDtFQUNELGFBQWEsQ0FBQyxtQ0FBb0M7RUFDbEQsaUJBQWlCLENBQUMsdUNBQXdDO0VBQzFELGVBQWUsQ0FDYiwyREFDRDtFQUNELGFBQWEsQ0FBQyw0Q0FBNkM7RUFDM0QsaUJBQWlCLENBQ2YsNERBQ0Q7RUFDRCxLQUFLLENBQUMsaURBQWtEO0VBQ3hELFlBQVksQ0FBQyx3REFBeUQ7RUFDdEUsVUFBVSxDQUFDLG9EQUFxRDtFQUNoRSxVQUFVLENBQUMseUNBQTBDO0VBQ3JELGNBQWMsQ0FBQyx5REFBMEQ7RUFDekUsTUFBTSxDQUFDLGFBQWM7RUFDckIsZUFBZSxDQUFDLHFDQUFzQztFQUN0RCxjQUFjLENBQUMsMERBQTJEO0VBQzFFLHFCQUFxQixDQUFDLDJDQUE0QztFQUNsRSxZQUFZLENBQUMsd0RBQXlEO0VBQ3RFLG1CQUFtQixDQUFDLHlDQUEwQztFQUM5RCx1QkFBdUIsQ0FDckIsMERBQ0Q7RUFDRCwwQkFBMEIsQ0FBQyxrQkFBbUI7RUFDOUMsWUFBWSxDQUFDLHdCQUF5QjtFQUN0QyxhQUFhLENBQUMsa0NBQW1DO0VBQ2pELHdCQUF3QixDQUN0QixnRUFDRDtFQUNELG1CQUFtQixDQUFDLGtDQUFtQztFQUN2RCxtQkFBbUIsQ0FDakIsd0RBQ0Q7RUFDRCxnQkFBZ0IsQ0FBQyxzQ0FBdUM7RUFDeEQsZUFBZSxDQUNiLDREQUNEO0VBQ0QsTUFBTSxDQUFDLHNEQUF1RDtFQUM5RCxpQkFBaUIsQ0FDZiwyREFDRDtFQUNELGlCQUFpQixDQUNmLDhEQUNEO0VBQ0QsYUFBYSxDQUNYLGtFQUNEO0VBQ0QsZ0JBQWdCLENBQ2QsOERBQ0Q7RUFDRCxzQkFBc0IsQ0FDcEIsdUVBQ0Q7RUFDRCxXQUFXLENBQUMsd0RBQXlEO0VBQ3JFLFFBQVEsQ0FBQyx5REFBMEQ7RUFDbkUsUUFBUSxDQUFDLG1EQUFvRDtFQUM3RCxlQUFlLENBQUMsMERBQTJEO0VBQzNFLGFBQWEsQ0FBQywyQ0FBNEM7RUFDMUQsaUJBQWlCLENBQ2YsMkRBQ0Q7Q0FDRjtDQUNELFVBQVU7RUFDUixLQUFLLENBQUMseUJBQTBCO0VBQ2hDLG9CQUFvQixDQUFDLGVBQWdCO0VBQ3JDLFlBQVksQ0FBQyxtQ0FBb0M7Q0FDbEQ7Q0FDRCxVQUFVO0VBQ1IsUUFBUSxDQUFDLGdCQUFpQjtFQUMxQixXQUFXLENBQ1Qsc0JBQ0EsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLDRCQUE2QixFQUFFLENBQzdEO0NBQ0Y7Q0FDRCxNQUFNO0VBQ0osS0FBSyxDQUFDLFdBQVk7RUFDbEIsZ0JBQWdCLENBQUMsZUFBZ0I7RUFDakMsWUFBWSxDQUFDLGNBQWU7RUFDNUIsUUFBUSxDQUFDLFVBQVc7RUFDcEIsTUFBTSxDQUFDLE9BQVE7Q0FDaEI7Q0FDRCxZQUFZO0VBQ1YsbUNBQW1DLENBQ2pDLGdEQUNEO0VBQ0QscUJBQXFCLENBQ25CLHNEQUNEO0VBQ0QsdUJBQXVCLENBQ3JCLG1EQUNEO0VBQ0QsZ0NBQWdDLENBQzlCLDZDQUNEO0VBQ0QsK0JBQStCLENBQUMscUNBQXNDO0VBQ3RFLGlCQUFpQixDQUFDLDJDQUE0QztFQUM5RCwwQkFBMEIsQ0FBQyxzQkFBdUI7RUFDbEQsWUFBWSxDQUFDLDRCQUE2QjtFQUMxQywrQkFBK0IsQ0FDN0Isa0RBQ0Q7RUFDRCxpQkFBaUIsQ0FBQyx3REFBeUQ7RUFDM0Usa0JBQWtCO0dBQ2hCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLGNBQWMsK0JBQWdDLEVBQUU7RUFDN0Q7RUFDRCwyQkFBMkIsQ0FBQyx1QkFBd0I7RUFDcEQsYUFBYSxDQUFDLDZCQUE4QjtFQUM1QyxnQ0FBZ0MsQ0FDOUIsK0RBQ0Q7RUFDRCxrQkFBa0IsQ0FDaEIscUVBQ0Q7Q0FDRjtDQUNELE1BQU07RUFDSixnQ0FBZ0MsQ0FDOUIsZ0RBQ0Q7RUFDRCxtQ0FBbUMsQ0FDakMsZ0RBQ0Q7Q0FDRjtDQUNELE1BQU07RUFDSix3QkFBd0I7R0FDdEI7R0FDQSxDQUFFO0dBQ0YsRUFDRSxZQUFZLGdKQUNiO0VBQ0Y7RUFDRCxxQkFBcUIsQ0FDbkIsZ0VBQ0Q7RUFDRCxxQkFBcUIsQ0FDbkIsK0RBQ0Q7RUFDRCxXQUFXLENBQUMsbUNBQW9DO0VBQ2hELGtCQUFrQixDQUFDLGdEQUFpRDtFQUNwRSxrQkFBa0IsQ0FBQyxtQ0FBb0M7RUFDdkQsd0JBQXdCLENBQUMsb0NBQXFDO0VBQzlELDhCQUE4QixDQUFDLDJDQUE0QztFQUMzRSxvQ0FBb0MsQ0FDbEMsa0RBQ0Q7RUFDRCxrQkFBa0IsQ0FBQyw4QkFBK0I7RUFDbEQsaUJBQWlCLENBQUMsOEJBQStCO0VBQ2pELGdDQUFnQyxDQUFDLHFDQUFzQztFQUN2RSw4Q0FBOEMsQ0FDNUMscUNBQ0Q7RUFDRCw4QkFBOEIsQ0FDNUIsMERBQ0Q7RUFDRCxlQUFlLENBQUMsd0JBQXlCO0VBQ3pDLFFBQVEsQ0FBQyxvQkFBcUI7RUFDOUIsaUJBQWlCLENBQUMsZ0RBQWlEO0VBQ25FLGVBQWUsQ0FBQyxvQ0FBcUM7RUFDckQsNkNBQTZDO0dBQzNDO0dBQ0EsQ0FBRTtHQUNGLEVBQ0UsWUFBWSxxTEFDYjtFQUNGO0VBQ0QsS0FBSyxDQUFDLGlCQUFrQjtFQUN4Qix3QkFBd0IsQ0FBQyxtQ0FBb0M7RUFDN0QsbUJBQW1CLENBQ2pCLDBEQUNEO0VBQ0QsbUNBQW1DLENBQUMsa0NBQW1DO0VBQ3ZFLHNCQUFzQixDQUFDLHdDQUF5QztFQUNoRSxZQUFZLENBQUMsOENBQStDO0VBQzVELHNCQUFzQixDQUFDLCtDQUFnRDtFQUN2RSxzQkFBc0IsQ0FDcEIsNERBQ0Q7RUFDRCxZQUFZLENBQUMsaUNBQWtDO0VBQy9DLHdCQUF3QixDQUFDLHdDQUF5QztFQUNsRSxvQkFBb0IsQ0FDbEIsMERBQ0Q7RUFDRCxNQUFNLENBQUMsb0JBQXFCO0VBQzVCLHNCQUFzQixDQUFDLCtCQUFnQztFQUN2RCxrQkFBa0IsQ0FBQywrQ0FBZ0Q7RUFDbkUsa0JBQWtCLENBQUMsd0JBQXlCO0VBQzVDLG9DQUFvQyxDQUFDLG1DQUFvQztFQUN6RSx1QkFBdUIsQ0FBQyxvQ0FBcUM7RUFDN0QsMEJBQTBCLENBQUMsZ0JBQWlCO0VBQzVDLGFBQWEsQ0FBQyw0QkFBNkI7RUFDM0MscUJBQXFCLENBQUMsbURBQW9EO0VBQzFFLGdCQUFnQixDQUFDLDZCQUE4QjtFQUMvQyxhQUFhLENBQUMseUJBQTBCO0VBQ3hDLHFDQUFxQyxDQUFDLDRCQUE2QjtFQUNuRSxrQkFBa0IsQ0FBQyxvREFBcUQ7RUFDeEUsa0JBQWtCLENBQUMsb0RBQXFEO0VBQ3hFLGNBQWMsQ0FBQyxvQ0FBcUM7RUFDcEQsd0NBQXdDLENBQ3RDLHVEQUNEO0VBQ0QsMEJBQTBCLENBQUMsdUNBQXdDO0VBQ25FLDBCQUEwQixDQUN4Qiw4REFDRDtFQUNELGlDQUFpQyxDQUMvQiw4RUFDRDtFQUNELHNCQUFzQixDQUFDLGdEQUFpRDtFQUN4RSxlQUFlLENBQUMsd0NBQXlDO0VBQ3pELHdCQUF3QixDQUFDLDZCQUE4QjtFQUN2RCxtQkFBbUIsQ0FBQyxnQ0FBaUM7RUFDckQsMEJBQTBCO0dBQ3hCO0dBQ0EsQ0FBRTtHQUNGLEVBQ0UsWUFBWSxrSkFDYjtFQUNGO0VBQ0QsdUJBQXVCLENBQUMsNENBQTZDO0VBQ3JFLGNBQWMsQ0FBQyx1QkFBd0I7RUFDdkMsYUFBYSxDQUFDLHdDQUF5QztFQUN2RCwwQkFBMEIsQ0FDeEIsb0VBQ0Q7RUFDRCxzQkFBc0IsQ0FDcEIsNkRBQ0Q7RUFDRCxjQUFjLENBQUMsdUNBQXdDO0VBQ3ZELHlCQUF5QixDQUFDLDJDQUE0QztFQUN0RSwyQkFBMkIsQ0FDekIscURBQ0Q7RUFDRCw0Q0FBNEMsQ0FDMUMsOENBQ0Q7RUFDRCwyQkFBMkI7R0FDekI7R0FDQSxDQUFFO0dBQ0YsRUFDRSxZQUFZLHNKQUNiO0VBQ0Y7RUFDRCx1QkFBdUIsQ0FDckIsa0VBQ0Q7RUFDRCw4QkFBOEIsQ0FDNUIsaURBQ0Q7RUFDRCx1QkFBdUIsQ0FDckIseURBQ0Q7RUFDRCx1QkFBdUIsQ0FDckIsd0RBQ0Q7RUFDRCxtQkFBbUIsQ0FDakIsbUVBQ0Q7RUFDRCxtQkFBbUIsQ0FDakIsa0VBQ0Q7RUFDRCxzQkFBc0IsQ0FBQyx3Q0FBeUM7RUFDaEUseUNBQXlDLENBQ3ZDLDJDQUNEO0VBQ0QsYUFBYSxDQUFDLHNDQUF1QztFQUNyRCxRQUFRLENBQUMsbUJBQW9CO0VBQzdCLGlCQUFpQixDQUFDLDZDQUE4QztFQUNoRSxzQ0FBc0MsQ0FDcEMsb0NBQ0Q7RUFDRCxpQkFBaUIsQ0FBQyxrREFBbUQ7RUFDckUsbUJBQW1CLENBQUMseUNBQTBDO0VBQzlELGVBQWUsQ0FBQyxtQ0FBb0M7RUFDcEQsMkJBQTJCLENBQUMsMENBQTJDO0NBQ3hFO0NBQ0QsVUFBVTtFQUNSLG1DQUFtQyxDQUNqQyxxREFDRDtFQUNELHFCQUFxQixDQUNuQiwyREFDRDtFQUNELHNCQUFzQixDQUNwQixpRUFDRDtFQUNELDBDQUEwQyxDQUN4QyxtRkFDRDtFQUNELDRCQUE0QixDQUMxQix5RkFDRDtFQUNELDZCQUE2QixDQUMzQiwrRkFDRDtFQUNELDhDQUE4QztHQUM1QztHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxZQUFZLDJDQUE0QyxFQUFFO0VBQ3ZFO0VBQ0QsNkRBQTZEO0dBQzNEO0dBQ0EsQ0FBRTtHQUNGLEVBQ0UsU0FBUyxDQUNQLFlBQ0EseURBQ0QsRUFDRjtFQUNGO0VBQ0QseURBQXlELENBQ3ZELDJEQUNEO0VBQ0QsMkNBQTJDLENBQ3pDLGlFQUNEO0VBQ0QsNENBQTRDLENBQzFDLHVFQUNEO0VBQ0QsZ0NBQWdDLENBQzlCLGtEQUNEO0VBQ0QsMkJBQTJCLENBQ3pCLHdEQUNEO0VBQ0QsbUJBQW1CLENBQ2pCLDhEQUNEO0VBQ0QsdUNBQXVDLENBQ3JDLGdGQUNEO0VBQ0Qsa0NBQWtDLENBQ2hDLHNGQUNEO0VBQ0QsMEJBQTBCLENBQ3hCLDRGQUNEO0VBQ0QsNERBQTRELENBQzFELDRCQUNEO0VBQ0QsdURBQXVELENBQ3JELGtDQUNEO0VBQ0QsK0NBQStDLENBQzdDLHdDQUNEO0VBQ0Qsa0NBQWtDLENBQUMsb0JBQXFCO0VBQ3hELDZCQUE2QixDQUFDLDBCQUEyQjtFQUN6RCxxQkFBcUIsQ0FBQyxnQ0FBaUM7RUFDdkQsb0NBQW9DLENBQ2xDLG1FQUNEO0VBQ0Qsc0JBQXNCLENBQ3BCLHlFQUNEO0VBQ0QsdUJBQXVCLENBQ3JCLCtFQUNEO0VBQ0QsMkNBQTJDLENBQ3pDLHlGQUNEO0VBQ0QsNkJBQTZCLENBQzNCLCtGQUNEO0VBQ0QsOEJBQThCLENBQzVCLHFHQUNEO0NBQ0Y7Q0FDRCxtQkFBbUI7RUFDakIsMEJBQTBCLENBQUMscUNBQXNDO0VBQ2pFLDBCQUEwQixDQUN4QixxREFDRDtFQUNELHVCQUF1QixDQUFDLGtEQUFtRDtFQUMzRSxpQkFBaUIsQ0FBQywrQ0FBZ0Q7RUFDbEUsMEJBQTBCLENBQUMsb0NBQXFDO0VBQ2hFLDBCQUEwQixDQUN4QixvREFDRDtDQUNGO0NBQ0QsT0FBTztFQUNMLGVBQWUsQ0FBQyxxREFBc0Q7RUFDdEUsUUFBUSxDQUFDLGtDQUFtQztFQUM1Qyw2QkFBNkIsQ0FDM0IsOEVBQ0Q7RUFDRCxjQUFjLENBQUMsd0RBQXlEO0VBQ3hFLHFCQUFxQixDQUNuQix5REFDRDtFQUNELHFCQUFxQixDQUNuQixzRUFDRDtFQUNELHFCQUFxQixDQUNuQiwwREFDRDtFQUNELGVBQWUsQ0FDYiw4RUFDRDtFQUNELEtBQUssQ0FBQywrQ0FBZ0Q7RUFDdEQsV0FBVyxDQUNULG1FQUNEO0VBQ0Qsa0JBQWtCLENBQUMsdURBQXdEO0VBQzNFLE1BQU0sQ0FBQyxpQ0FBa0M7RUFDekMsdUJBQXVCLENBQ3JCLDRFQUNEO0VBQ0QsYUFBYSxDQUFDLHVEQUF3RDtFQUN0RSxXQUFXLENBQUMscURBQXNEO0VBQ2xFLHdCQUF3QixDQUN0QixtRUFDRDtFQUNELG9CQUFvQixDQUNsQix3REFDRDtFQUNELDJCQUEyQixDQUFDLDBDQUEyQztFQUN2RSxhQUFhLENBQUMsdURBQXdEO0VBQ3RFLE9BQU8sQ0FBQyxxREFBc0Q7RUFDOUQsMEJBQTBCLENBQ3hCLHNFQUNEO0VBQ0Qsa0JBQWtCLENBQ2hCLG9FQUNEO0VBQ0QsY0FBYyxDQUNaLDJFQUNEO0VBQ0QsUUFBUSxDQUFDLGlEQUFrRDtFQUMzRCxjQUFjLENBQ1osNkRBQ0Q7RUFDRCxjQUFjLENBQ1osbUVBQ0Q7RUFDRCxxQkFBcUIsQ0FDbkIseURBQ0Q7Q0FDRjtDQUNELFdBQVcsRUFBRSxLQUFLLENBQUMsaUJBQWtCLEVBQUU7Q0FDdkMsV0FBVztFQUNULHdCQUF3QixDQUN0Qiw0REFDRDtFQUNELGdCQUFnQixDQUNkLDREQUNEO0VBQ0QsdUJBQXVCLENBQ3JCLG1FQUNEO0VBQ0QsbUNBQW1DLENBQ2pDLGtFQUNEO0VBQ0Qsa0JBQWtCLENBQ2hCLDREQUNEO0VBQ0QscUNBQXFDLENBQ25DLHdHQUNEO0VBQ0QsOEJBQThCLENBQzVCLDhFQUNEO0VBQ0Qsd0JBQXdCLENBQ3RCLDRFQUNEO0VBQ0QsZ0JBQWdCLENBQ2QsNEVBQ0Q7RUFDRCx1QkFBdUIsQ0FDckIsbUZBQ0Q7RUFDRCw2QkFBNkIsQ0FDM0Isa0ZBQ0Q7RUFDRCxrQkFBa0IsQ0FDaEIsNEVBQ0Q7RUFDRCx5QkFBeUIsQ0FDdkIsOEZBQ0Q7RUFDRCxnQ0FBZ0MsQ0FDOUIsd0hBQ0Q7RUFDRCxzQkFBc0IsQ0FDcEIsMkRBQ0Q7RUFDRCxjQUFjLENBQUMsMkRBQTREO0VBQzNFLHFCQUFxQixDQUNuQixrRUFDRDtFQUNELGlDQUFpQyxDQUMvQixpRUFDRDtFQUNELGdCQUFnQixDQUNkLDJEQUNEO0VBQ0QsbUNBQW1DLENBQ2pDLHVHQUNEO0VBQ0QsNEJBQTRCLENBQzFCLDZFQUNEO0NBQ0Y7Q0FDRCxPQUFPO0VBQ0wsa0JBQWtCO0dBQ2hCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLFNBQVMsc0NBQXVDLEVBQUU7RUFDL0Q7RUFDRCxzQ0FBc0MsQ0FDcEMsb0RBQ0Q7RUFDRCwwQkFBMEI7R0FDeEI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxXQUFXLE9BQVE7RUFDdEI7RUFDRCxpQkFBaUIsQ0FBQyxvREFBcUQ7RUFDdkUsd0JBQXdCO0dBQ3RCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsV0FBVyxXQUFZO0VBQzFCO0VBQ0QsMkJBQTJCO0dBQ3pCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsV0FBVyxRQUFTO0VBQ3ZCO0VBQ0QsMkJBQTJCO0dBQ3pCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsV0FBVyxRQUFTO0VBQ3ZCO0VBQ0QsdUJBQXVCLENBQ3JCLDJFQUNEO0VBQ0QsNkJBQTZCLENBQzNCLG9EQUNEO0VBQ0QsbUJBQW1CLENBQUMsb0RBQXFEO0VBQ3pFLG9DQUFvQyxDQUNsQywyREFDRDtFQUNELDBCQUEwQixDQUN4QixnREFDRDtFQUNELGtCQUFrQixDQUFDLDZDQUE4QztFQUNqRSxnQkFBZ0IsQ0FBQyxtREFBb0Q7RUFDckUsNEJBQTRCLENBQzFCLDhDQUNEO0VBQ0QsbUJBQW1CLENBQUMseUNBQTBDO0VBQzlELGdCQUFnQixDQUFDLHNDQUF1QztFQUN4RCxxQkFBcUIsQ0FDbkIsMERBQ0Q7RUFDRCxpQ0FBaUMsQ0FDL0IsNkVBQ0Q7RUFDRCxvQkFBb0IsQ0FBQywyQ0FBNEM7RUFDakUsaUJBQWlCLENBQUMsaUNBQWtDO0VBQ3BELGtCQUFrQixDQUFDLHdDQUF5QztFQUM1RCw4QkFBOEIsQ0FDNUIsdUZBQ0Q7RUFDRCxnQ0FBZ0MsQ0FDOUIsd0ZBQ0Q7RUFDRCx3QkFBd0IsQ0FDdEIsaUVBQ0Q7RUFDRCxxQkFBcUIsQ0FBQyx1Q0FBd0M7RUFDOUQsNEJBQTRCLENBQUMsa0JBQW1CO0VBQ2hELFlBQVksQ0FBQyxrQ0FBbUM7RUFDaEQsYUFBYSxDQUFDLHdCQUF5QjtFQUN2QyxzQ0FBc0MsQ0FDcEMsK0NBQ0Q7RUFDRCwyQkFBMkIsQ0FDekIsMkRBQ0Q7RUFDRCw0QkFBNEIsQ0FBQywyQ0FBNEM7RUFDekUsa0JBQWtCLENBQUMsMkJBQTRCO0VBQy9DLHVCQUF1QixDQUFDLDhDQUErQztFQUN2RSxpQkFBaUIsQ0FBQyxrQ0FBbUM7RUFDckQsZUFBZSxDQUFDLHFDQUFzQztFQUN0RCxtQkFBbUIsQ0FBQyxxQ0FBc0M7RUFDMUQscUJBQXFCLENBQ25CLHVEQUNEO0VBQ0QsZUFBZSxDQUFDLGtDQUFtQztFQUNuRCxtQkFBbUI7R0FDakI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyx1Q0FBd0MsRUFBRTtFQUNoRTtFQUNELHVDQUF1QyxDQUNyQyxxREFDRDtFQUNELFFBQVEsQ0FBQyw4QkFBK0I7RUFDeEMsMEJBQTBCLENBQ3hCLHdFQUNEO0VBQ0QsNkJBQTZCLENBQzNCLDBFQUNEO0VBQ0QscUJBQXFCLENBQ25CLDhEQUNEO0VBQ0QsZ0JBQWdCLENBQUMsc0RBQXVEO0VBQ3hFLHdCQUF3QixDQUN0QiwyREFDRDtFQUNELHFCQUFxQixDQUFDLG9EQUFxRDtFQUMzRSxpQ0FBaUMsQ0FDL0IsK0VBQ0Q7RUFDRCxpQkFBaUIsQ0FBQyw0Q0FBNkM7RUFDL0Qsa0JBQWtCLENBQ2hCLDBEQUNEO0VBQ0QsOEJBQThCLENBQzVCLDRHQUNEO0VBQ0QsWUFBWSxDQUFDLDhDQUErQztFQUM1RCxrQkFBa0IsQ0FDaEIsMERBQ0Q7RUFDRCxrQkFBa0IsQ0FBQywwQ0FBMkM7RUFDOUQsaUJBQWlCLENBQUMsb0NBQXFDO0VBQ3ZELG1DQUFtQyxDQUNqQyx5RkFDRDtFQUNELGVBQWUsQ0FBQyxvREFBcUQ7RUFDckUsb0JBQW9CLENBQ2xCLHlEQUNEO0VBQ0QsbUJBQW1CLENBQUMsb0RBQXFEO0VBQ3pFLGVBQWUsQ0FBQyw4Q0FBK0M7RUFDL0QsK0JBQStCLENBQzdCLHVEQUNEO0VBQ0QsaUNBQWlDLENBQy9CLCtHQUNEO0VBQ0Qsc0NBQXNDLENBQ3BDLDhEQUNEO0VBQ0QsNEJBQTRCLENBQzFCLG1EQUNEO0VBQ0QsaUJBQWlCO0dBQ2Y7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyx3QkFBeUIsRUFBRTtFQUNqRDtFQUNELHdCQUF3QixDQUFDLHlDQUEwQztFQUNuRSx3QkFBd0IsQ0FBQyx5Q0FBMEM7RUFDbkUsOEJBQThCLENBQzVCLG9EQUNEO0VBQ0QscUNBQXFDLENBQ25DLDJEQUNEO0VBQ0QsMkJBQTJCLENBQ3pCLGdEQUNEO0VBQ0Qsc0JBQXNCLENBQ3BCLG9EQUNEO0VBQ0QsS0FBSyxDQUFDLDJCQUE0QjtFQUNsQyx1QkFBdUIsQ0FDckIscUVBQ0Q7RUFDRCwwQkFBMEIsQ0FDeEIsdUVBQ0Q7RUFDRCxpQ0FBaUMsQ0FDL0IsdUZBQ0Q7RUFDRCxvQkFBb0IsQ0FBQyx3Q0FBeUM7RUFDOUQsMkJBQTJCLENBQ3pCLHdGQUNEO0VBQ0QsY0FBYyxDQUFDLGtDQUFtQztFQUNsRCxvQ0FBb0MsQ0FDbEMsMEVBQ0Q7RUFDRCxhQUFhLENBQUMsbURBQW9EO0VBQ2xFLFdBQVcsQ0FBQyw2Q0FBOEM7RUFDMUQscUJBQXFCLENBQ25CLHdEQUNEO0VBQ0QsZ0JBQWdCLENBQUMsbURBQW9EO0VBQ3JFLFdBQVcsQ0FBQywwQ0FBMkM7RUFDdkQsdUJBQXVCLENBQUMsZ0RBQWlEO0VBQ3pFLGdDQUFnQyxDQUM5QiwrREFDRDtFQUNELHlCQUF5QixDQUFDLGdEQUFpRDtFQUMzRSxXQUFXLENBQUMseUNBQTBDO0VBQ3RELHdCQUF3QixDQUFDLGlEQUFrRDtFQUMzRSxrQkFBa0IsQ0FBQyxpREFBa0Q7RUFDckUsOEJBQThCLENBQzVCLDRFQUNEO0VBQ0QsNEJBQTRCLENBQUMsNkNBQThDO0VBQzNFLFlBQVksQ0FBQywyQ0FBNEM7RUFDekQsc0JBQXNCLENBQUMsOENBQStDO0VBQ3RFLG1DQUFtQyxDQUNqQyw0R0FDRDtFQUNELDJCQUEyQixDQUFDLDZDQUE4QztFQUMxRSxjQUFjLENBQUMseUNBQTBDO0VBQ3pELGVBQWUsQ0FBQyx1REFBd0Q7RUFDeEUsMkJBQTJCLENBQ3pCLHlHQUNEO0VBQ0QscUJBQXFCLENBQ25CLDRFQUNEO0VBQ0QsZ0JBQWdCLENBQ2QsMkRBQ0Q7RUFDRCxxQkFBcUIsQ0FBQywrQ0FBZ0Q7RUFDdEUsa0JBQWtCLENBQUMsMkNBQTRDO0VBQy9ELGlCQUFpQixDQUFDLHNEQUF1RDtFQUN6RSxrQkFBa0IsQ0FBQyxzQ0FBdUM7RUFDMUQsZUFBZSxDQUFDLHVDQUF3QztFQUN4RCxnQkFBZ0IsQ0FBQywwQkFBMkI7RUFDNUMsVUFBVSxDQUFDLGlDQUFrQztFQUM3QyxlQUFlLENBQUMsbURBQW9EO0VBQ3BFLG9CQUFvQixDQUNsQixtRUFDRDtFQUNELHFCQUFxQixDQUFDLHdDQUF5QztFQUMvRCx1QkFBdUIsQ0FBQywrQ0FBZ0Q7RUFDeEUsZ0NBQWdDLENBQzlCLHNGQUNEO0VBQ0QsbUJBQW1CLENBQUMsNENBQTZDO0VBQ2pFLFdBQVcsQ0FBQyxrQ0FBbUM7RUFDL0Msc0JBQXNCLENBQUMsd0NBQXlDO0VBQ2hFLFlBQVksQ0FBQyxpREFBa0Q7RUFDL0QsaUJBQWlCLENBQUMsc0RBQXVEO0VBQ3pFLGlCQUFpQixDQUFDLCtDQUFnRDtFQUNsRSxrQkFBa0IsQ0FDaEIsZ0VBQ0Q7RUFDRCxtQkFBbUIsQ0FBQyxnREFBaUQ7RUFDckUsZ0JBQWdCLENBQUMsaURBQWtEO0VBQ25FLHVCQUF1QixDQUNyQix5REFDRDtFQUNELHVCQUF1QixDQUNyQixzRUFDRDtFQUNELGlCQUFpQixDQUFDLG9DQUFxQztFQUN2RCwyQkFBMkIsQ0FDekIsK0VBQ0Q7RUFDRCxxQ0FBcUMsQ0FDbkMsMkVBQ0Q7RUFDRCxhQUFhLENBQUMsaURBQWtEO0VBQ2hFLGlCQUFpQixDQUFDLHFEQUFzRDtFQUN4RSxxQ0FBcUMsQ0FDbkMsMkVBQ0Q7RUFDRCxVQUFVLENBQUMseUNBQTBDO0VBQ3JELFlBQVksQ0FBQywyQ0FBNEM7RUFDekQseUJBQXlCLENBQ3ZCLGtEQUNEO0VBQ0Qsb0JBQW9CLENBQ2xCLG9FQUNEO0VBQ0QsZ0JBQWdCLENBQUMsb0NBQXFDO0VBQ3RELGtCQUFrQixDQUNoQix5REFDRDtFQUNELGVBQWUsQ0FBQyxxQ0FBc0M7RUFDdEQsY0FBYyxDQUFDLG9DQUFxQztFQUNwRCwyQkFBMkIsQ0FDekIsb0VBQ0Q7RUFDRCxtQkFBbUIsQ0FBQyx5Q0FBMEM7RUFDOUQsdUJBQXVCLENBQ3JCLHlEQUNEO0VBQ0QsMkJBQTJCLENBQUMsb0NBQXFDO0VBQ2pFLDBCQUEwQixDQUN4QixrREFDRDtFQUNELGFBQWEsQ0FBQyxtQ0FBb0M7RUFDbEQsa0JBQWtCLENBQUMsd0NBQXlDO0VBQzVELHNDQUFzQyxDQUNwQyw0RkFDRDtFQUNELGdCQUFnQixDQUFDLGdDQUFpQztFQUNsRCw4QkFBOEIsQ0FDNUIsc0ZBQ0Q7RUFDRCx3QkFBd0IsQ0FDdEIsZ0VBQ0Q7RUFDRCxpQkFBaUIsQ0FBQyx1Q0FBd0M7RUFDMUQsMEJBQTBCLENBQUMsaUJBQWtCO0VBQzdDLFlBQVksQ0FBQyx1QkFBd0I7RUFDckMsYUFBYSxDQUFDLDZCQUE4QjtFQUM1QyxXQUFXLENBQUMsaUNBQWtDO0VBQzlDLGlCQUFpQixDQUFDLHVDQUF3QztFQUMxRCxxQ0FBcUMsQ0FBQyxrQ0FBbUM7RUFDekUsZUFBZSxDQUFDLHFDQUFzQztFQUN0RCxpQkFBaUIsQ0FBQyx3Q0FBeUM7RUFDM0QsWUFBWSxDQUFDLG1CQUFvQjtFQUNqQyxzQ0FBc0MsQ0FDcEMsc0RBQ0Q7RUFDRCxtQkFBbUIsQ0FDakIsd0RBQ0Q7RUFDRCxjQUFjLENBQUMsb0NBQXFDO0VBQ3BELFVBQVUsQ0FBQyxnQ0FBaUM7RUFDNUMsV0FBVyxDQUFDLGlDQUFrQztFQUM5Qyx1QkFBdUIsQ0FDckIsc0RBQ0Q7RUFDRCxjQUFjLENBQUMsaUNBQWtDO0VBQ2pELE9BQU8sQ0FBQyxtQ0FBb0M7RUFDNUMsZUFBZSxDQUFDLDJDQUE0QztFQUM1RCxhQUFhLENBQUMsa0RBQW1EO0VBQ2pFLDBCQUEwQixDQUN4Qiw4RUFDRDtFQUNELDZCQUE2QjtHQUMzQjtHQUNBLENBQUU7R0FDRixFQUFFLFdBQVcsT0FBUTtFQUN0QjtFQUNELG9CQUFvQixDQUNsQix1REFDRDtFQUNELDJCQUEyQjtHQUN6QjtHQUNBLENBQUU7R0FDRixFQUFFLFdBQVcsV0FBWTtFQUMxQjtFQUNELDZCQUE2QixDQUMzQixrRkFDRDtFQUNELDhCQUE4QjtHQUM1QjtHQUNBLENBQUU7R0FDRixFQUFFLFdBQVcsUUFBUztFQUN2QjtFQUNELDhCQUE4QjtHQUM1QjtHQUNBLENBQUU7R0FDRixFQUFFLFdBQVcsUUFBUztFQUN2QjtFQUNELGNBQWMsQ0FBQyxxREFBc0Q7RUFDckUsa0JBQWtCLENBQUMsa0NBQW1DO0VBQ3RELG1CQUFtQixDQUFDLHlDQUEwQztFQUM5RCwwQkFBMEIsQ0FDeEIsd0VBQ0Q7RUFDRCwwQkFBMEI7R0FDeEI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxXQUFXLE9BQVE7RUFDdEI7RUFDRCx3QkFBd0I7R0FDdEI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxXQUFXLFdBQVk7RUFDMUI7RUFDRCwyQkFBMkI7R0FDekI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxXQUFXLFFBQVM7RUFDdkI7RUFDRCwyQkFBMkI7R0FDekI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxXQUFXLFFBQVM7RUFDdkI7RUFDRCxpQkFBaUIsQ0FBQyxrREFBbUQ7RUFDckUsVUFBVSxDQUFDLHFDQUFzQztFQUNqRCxRQUFRLENBQUMsNkJBQThCO0VBQ3ZDLHdCQUF3QixDQUN0Qix3REFDRDtFQUNELHFCQUFxQixDQUFDLG1EQUFvRDtFQUMxRSw4QkFBOEIsQ0FDNUIseUdBQ0Q7RUFDRCxpQ0FBaUMsQ0FBQyxpQ0FBa0M7RUFDcEUsa0JBQWtCLENBQ2hCLHlEQUNEO0VBQ0Qsa0JBQWtCLENBQUMsdUNBQXdDO0VBQzNELG1DQUFtQyxDQUNqQyx3RkFDRDtFQUNELGVBQWUsQ0FBQyxtREFBb0Q7RUFDcEUsb0JBQW9CLENBQ2xCLHdEQUNEO0VBQ0QsbUJBQW1CLENBQUMsaURBQWtEO0VBQ3RFLDRCQUE0QjtHQUMxQjtHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxTQUFTLDZCQUE4QixFQUFFO0VBQ3REO0VBQ0QsNkJBQTZCLENBQzNCLGlGQUNEO0VBQ0QsZUFBZSxDQUFDLDZDQUE4QztFQUM5RCw0QkFBNEIsQ0FDMUIsb0RBQ0Q7RUFDRCxvQkFBb0IsQ0FDbEIsd0VBQ0EsRUFBRSxTQUFTLDZCQUE4QixDQUMxQztDQUNGO0NBQ0QsUUFBUTtFQUNOLE1BQU0sQ0FBQyxrQkFBbUI7RUFDMUIsU0FBUyxDQUFDLHFCQUFzQjtFQUNoQyx1QkFBdUI7R0FDckI7R0FDQSxDQUFFO0dBQ0YsRUFDRSxZQUFZLDRJQUNiO0VBQ0Y7RUFDRCxRQUFRLENBQUMsb0JBQXFCO0VBQzlCLE9BQU8sQ0FBQywwQkFBMkI7RUFDbkMsUUFBUSxDQUFDLG9CQUFxQjtFQUM5QixPQUFPLENBQUMsbUJBQW9CO0NBQzdCO0NBQ0QsZ0JBQWdCO0VBQ2QsNEJBQTRCLENBQzFCLHFFQUNEO0VBQ0QsVUFBVSxDQUNSLGlFQUNEO0VBQ0QsZ0JBQWdCLENBQUMsd0RBQXlEO0VBQzFFLHlCQUF5QixDQUN2QixzREFDRDtFQUNELGtCQUFrQixDQUFDLHdDQUF5QztFQUM1RCxtQkFBbUIsQ0FBQyxrREFBbUQ7RUFDdkUsdUJBQXVCLENBQ3JCLDJFQUNEO0VBQ0QsYUFBYSxDQUNYLG1FQUNEO0NBQ0Y7Q0FDRCxvQkFBb0I7RUFDbEIsWUFBWSxDQUNWLGdFQUNEO0VBQ0Qsa0NBQWtDLENBQ2hDLHdEQUNEO0VBQ0QsMEJBQTBCLENBQ3hCLGdEQUNEO0VBQ0Qsb0NBQW9DLENBQ2xDLDhEQUNEO0VBQ0QsbUJBQW1CLENBQUMsMkJBQTRCO0VBQ2hELHVCQUF1QixDQUNyQix5REFDRDtFQUNELHNCQUFzQixDQUFDLGlCQUFrQjtFQUN6Qyw2QkFBNkIsQ0FBQyxxQ0FBc0M7RUFDcEUsMEJBQTBCLENBQUMsK0NBQWdEO0VBQzNFLDBCQUEwQixDQUN4QiwyREFDRDtDQUNGO0NBQ0QsT0FBTztFQUNMLG1DQUFtQyxDQUNqQywwREFDRDtFQUNELGlDQUFpQyxDQUMvQix3REFDRDtFQUNELDhCQUE4QixDQUM1Qix3REFDRDtFQUNELFFBQVEsQ0FBQyx3QkFBeUI7RUFDbEMsOEJBQThCLENBQzVCLDZFQUNEO0VBQ0QsdUJBQXVCLENBQUMsZ0RBQWlEO0VBQ3pFLDhCQUE4QixDQUM1QixnR0FDRDtFQUNELHVCQUF1QixDQUNyQixzRUFDRDtFQUNELGFBQWEsQ0FBQyxzQ0FBdUM7RUFDckQsV0FBVyxDQUFDLG1DQUFvQztFQUNoRCwyQkFBMkIsQ0FDekIsNkZBQ0Q7RUFDRCxvQkFBb0IsQ0FDbEIsbUVBQ0Q7RUFDRCwyQkFBMkIsQ0FDekIsMERBQ0Q7RUFDRCxNQUFNLENBQUMsdUJBQXdCO0VBQy9CLGdCQUFnQixDQUFDLHlDQUEwQztFQUMzRCw2QkFBNkIsQ0FDM0IsNEVBQ0Q7RUFDRCxzQkFBc0IsQ0FBQywrQ0FBZ0Q7RUFDdkUsMEJBQTBCLENBQUMsaUJBQWtCO0VBQzdDLGtCQUFrQixDQUFDLDJDQUE0QztFQUMvRCw2QkFBNkIsQ0FDM0IsK0NBQ0Q7RUFDRCxnQkFBZ0IsQ0FBQyx5Q0FBMEM7RUFDM0QsOEJBQThCLENBQzVCLDZEQUNEO0VBQ0QsaUJBQWlCLENBQ2YsMkRBQ0Q7RUFDRCw4QkFBOEIsQ0FDNUIsK0ZBQ0Q7RUFDRCx1QkFBdUIsQ0FDckIscUVBQ0Q7RUFDRCxhQUFhLENBQUMscUNBQXNDO0NBQ3JEO0NBQ0QsT0FBTztFQUNMLDBCQUEwQjtHQUN4QjtHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxTQUFTLDhCQUErQixFQUFFO0VBQ3ZEO0VBQ0QsOEJBQThCLENBQUMsbUJBQW9CO0VBQ25ELHNDQUFzQyxDQUFDLDRCQUE2QjtFQUNwRSxPQUFPLENBQUMsNkJBQThCO0VBQ3RDLGNBQWMsQ0FBQyw2QkFBOEI7RUFDN0MsdUJBQXVCLENBQUMsK0NBQWdEO0VBQ3hFLHNDQUFzQyxDQUFDLGdDQUFpQztFQUN4RSw4QkFBOEI7R0FDNUI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyxrQ0FBbUMsRUFBRTtFQUMzRDtFQUNELGtDQUFrQyxDQUFDLHFCQUFzQjtFQUN6RCxvQ0FBb0M7R0FDbEM7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyx3Q0FBeUMsRUFBRTtFQUNqRTtFQUNELHdDQUF3QyxDQUFDLGlCQUFrQjtFQUMzRCx5Q0FBeUMsQ0FBQyw2QkFBOEI7RUFDeEUsNkJBQTZCO0dBQzNCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLFNBQVMsaUNBQWtDLEVBQUU7RUFDMUQ7RUFDRCxpQ0FBaUMsQ0FBQyxxQkFBc0I7RUFDeEQsOEJBQThCO0dBQzVCO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLFNBQVMsa0NBQW1DLEVBQUU7RUFDM0Q7RUFDRCxrQ0FBa0MsQ0FBQyxvQ0FBcUM7RUFDeEUsb0NBQW9DO0dBQ2xDO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLFNBQVMsd0NBQXlDLEVBQUU7RUFDakU7RUFDRCx3Q0FBd0MsQ0FBQyw0QkFBNkI7RUFDdEUseUNBQXlDLENBQUMsOEJBQStCO0VBQ3pFLHlDQUF5QyxDQUN2QyxvREFDRDtFQUNELFFBQVEsQ0FBQyxnQ0FBaUM7RUFDMUMsa0JBQWtCLENBQUMsV0FBWTtFQUMvQixTQUFTLENBQUMsd0JBQXlCO0VBQ25DLGVBQWUsQ0FBQyx1QkFBd0I7RUFDeEMsbUJBQW1CLENBQUMsaUNBQWtDO0VBQ3RELDJCQUEyQjtHQUN6QjtHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxTQUFTLCtCQUFnQyxFQUFFO0VBQ3hEO0VBQ0QsK0JBQStCLENBQUMsaUNBQWtDO0VBQ2xFLGlDQUFpQztHQUMvQjtHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxTQUFTLHFDQUFzQyxFQUFFO0VBQzlEO0VBQ0QscUNBQXFDLENBQUMseUJBQTBCO0VBQ2hFLHNDQUFzQyxDQUNwQyxpREFDRDtFQUNELE1BQU0sQ0FBQyxZQUFhO0VBQ3BCLGtCQUFrQixDQUFDLHFEQUFzRDtFQUN6RSw0QkFBNEI7R0FDMUI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyxnQ0FBaUMsRUFBRTtFQUN6RDtFQUNELGdDQUFnQyxDQUFDLGtCQUFtQjtFQUNwRCw0QkFBNEI7R0FDMUI7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyxnQ0FBaUMsRUFBRTtFQUN6RDtFQUNELGdDQUFnQyxDQUFDLGtCQUFtQjtFQUNwRCw2QkFBNkI7R0FDM0I7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyxpQ0FBa0MsRUFBRTtFQUMxRDtFQUNELGlDQUFpQyxDQUFDLHFCQUFzQjtFQUN4RCxtQ0FBbUMsQ0FBQyxxQkFBc0I7RUFDMUQsc0JBQXNCLENBQUMsaUNBQWtDO0VBQ3pELHNCQUFzQixDQUFDLGlDQUFrQztFQUN6RCw2QkFBNkI7R0FDM0I7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUyxpQ0FBa0MsRUFBRTtFQUMxRDtFQUNELGlDQUFpQyxDQUFDLG9CQUFxQjtFQUN2RCxvQkFBb0IsQ0FBQyxnQ0FBaUM7RUFDdEQsa0NBQWtDO0dBQ2hDO0dBQ0EsQ0FBRTtHQUNGLEVBQUUsU0FBUyxDQUFDLFNBQVMsc0NBQXVDLEVBQUU7RUFDL0Q7RUFDRCxzQ0FBc0MsQ0FBQyx5QkFBMEI7RUFDakUsdUJBQXVCLENBQUMsNEJBQTZCO0VBQ3JELG1DQUFtQztHQUNqQztHQUNBLENBQUU7R0FDRixFQUFFLFNBQVMsQ0FBQyxTQUFTLHVDQUF3QyxFQUFFO0VBQ2hFO0VBQ0QsdUNBQXVDLENBQUMsZ0JBQWlCO0VBQ3pELHdDQUF3QyxDQUFDLDJCQUE0QjtFQUNyRSwyQkFBMkIsQ0FBQyx1Q0FBd0M7RUFDcEUsd0NBQXdDLENBQUMsNEJBQTZCO0VBQ3RFLDJCQUEyQixDQUFDLHdDQUF5QztFQUNyRSwyQ0FBMkM7R0FDekM7R0FDQSxDQUFFO0dBQ0YsRUFBRSxTQUFTLENBQUMsU0FBUywrQ0FBZ0QsRUFBRTtFQUN4RTtFQUNELCtDQUErQyxDQUM3Qyw4QkFDRDtFQUNELFNBQVMsQ0FBQyxnQ0FBaUM7RUFDM0MsVUFBVSxDQUFDLG1DQUFvQztFQUMvQyxxQkFBcUIsQ0FBQyxhQUFjO0NBQ3JDO0FBQ0Y7QUFDRCxJQUFJLG9CQUFvQjs7OztBQ3JqRXhCLE1BQU0scUNBQXFDLElBQUk7QUFDL0MsS0FBSyxNQUFNLENBQUMsT0FBTyxVQUFVLElBQUksT0FBTyxRQUFRQyxrQkFBVSxDQUN4RCxNQUFLLE1BQU0sQ0FBQyxZQUFZQyxXQUFTLElBQUksT0FBTyxRQUFRLFVBQVUsRUFBRTtDQUM5RCxNQUFNLENBQUMsT0FBTyxVQUFVLFlBQVksR0FBR0E7Q0FDdkMsTUFBTSxDQUFDLFFBQVEsSUFBSSxHQUFHLE1BQU0sTUFBTSxJQUFJO0NBQ3RDLE1BQU0sbUJBQW1CLE9BQU8sT0FDOUI7RUFDRTtFQUNBO0NBQ0QsR0FDRCxTQUNEO0FBQ0QsS0FBSSxDQUFDLG1CQUFtQixJQUFJLE1BQU0sRUFDaEMsbUJBQW1CLElBQUksdUJBQXVCLElBQUksTUFBTTtDQUUxRCxtQkFBbUIsSUFBSSxNQUFNLENBQUMsSUFBSSxZQUFZO0VBQzVDO0VBQ0E7RUFDQTtFQUNBO0NBQ0QsRUFBQztBQUNIO0FBRUgsTUFBTSxVQUFVO0NBQ2QsSUFBSSxFQUFFLE9BQU8sRUFBRSxZQUFZO0FBQ3pCLFNBQU8sbUJBQW1CLElBQUksTUFBTSxDQUFDLElBQUksV0FBVztDQUNyRDtDQUNELHlCQUF5QixRQUFRLFlBQVk7QUFDM0MsU0FBTztHQUNMLE9BQU8sS0FBSyxJQUFJLFFBQVEsV0FBVztHQUVuQyxjQUFjO0dBQ2QsVUFBVTtHQUNWLFlBQVk7RUFDYjtDQUNGO0NBQ0QsZUFBZSxRQUFRLFlBQVksWUFBWTtFQUM3QyxPQUFPLGVBQWUsT0FBTyxPQUFPLFlBQVksV0FBVztBQUMzRCxTQUFPO0NBQ1I7Q0FDRCxlQUFlLFFBQVEsWUFBWTtFQUNqQyxPQUFPLE9BQU8sTUFBTTtBQUNwQixTQUFPO0NBQ1I7Q0FDRCxRQUFRLEVBQUUsT0FBTyxFQUFFO0FBQ2pCLFNBQU8sQ0FBQyxHQUFHLG1CQUFtQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEFBQUM7Q0FDakQ7Q0FDRCxJQUFJLFFBQVEsWUFBWUMsU0FBTztBQUM3QixTQUFPLE9BQU8sTUFBTSxjQUFjQTtDQUNuQztDQUNELElBQUksRUFBRSxTQUFTLE9BQU8sT0FBTyxFQUFFLFlBQVk7QUFDekMsTUFBSSxNQUFNLFlBQ1IsUUFBTyxNQUFNO0VBRWYsTUFBTSxTQUFTLG1CQUFtQixJQUFJLE1BQU0sQ0FBQyxJQUFJLFdBQVc7QUFDNUQsTUFBSSxDQUFDLE9BQ0gsUUFBTyxLQUFLO0VBRWQsTUFBTSxFQUFFLGtCQUFrQixhQUFhLEdBQUc7QUFDMUMsTUFBSSxhQUNGLE1BQU0sY0FBYyxTQUNsQixTQUNBLE9BQ0EsWUFDQSxrQkFDQSxZQUNEO09BRUQsTUFBTSxjQUFjLFFBQVEsUUFBUSxTQUFTLGlCQUFpQjtBQUVoRSxTQUFPLE1BQU07Q0FDZDtBQUNGO0FBQ0QsU0FBUyxtQkFBbUIsU0FBUztDQUNuQyxNQUFNLGFBQWEsQ0FBRTtBQUNyQixNQUFLLE1BQU0sU0FBUyxtQkFBbUIsTUFBTSxFQUMzQyxXQUFXLFNBQVMsSUFBSSxNQUFNO0VBQUU7RUFBUztFQUFPLE9BQU8sQ0FBRTtDQUFFLEdBQUU7QUFFL0QsUUFBTztBQUNSO0FBQ0QsU0FBUyxTQUFTLFNBQVMsT0FBTyxZQUFZLFVBQVUsYUFBYTtDQUNuRSxNQUFNLHNCQUFzQixRQUFRLFFBQVEsU0FBUyxTQUFTO0NBQzlELFNBQVMsZ0JBQWdCLEdBQUcsTUFBTTtFQUNoQyxJQUFJLFVBQVUsb0JBQW9CLFNBQVMsTUFBTSxHQUFHLEtBQUs7QUFDekQsTUFBSSxZQUFZLFdBQVc7R0FDekIsVUFBVSxPQUFPLE9BQU8sQ0FBRSxHQUFFLFNBQVM7SUFDbkMsTUFBTSxRQUFRLFlBQVk7S0FDekIsWUFBWSxZQUFZLEtBQUs7R0FDL0IsRUFBQztBQUNGLFVBQU8sb0JBQW9CLFFBQVE7RUFDcEM7QUFDRCxNQUFJLFlBQVksU0FBUztHQUN2QixNQUFNLENBQUMsVUFBVSxjQUFjLEdBQUcsWUFBWTtHQUM5QyxRQUFRLElBQUksS0FDVixDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsRUFBRSxXQUFXLCtCQUErQixFQUFFLFNBQVMsQ0FBQyxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQzlGO0VBQ0Y7QUFDRCxNQUFJLFlBQVksWUFDZCxRQUFRLElBQUksS0FBSyxZQUFZLFdBQVc7QUFFMUMsTUFBSSxZQUFZLG1CQUFtQjtHQUNqQyxNQUFNLFdBQVcsb0JBQW9CLFNBQVMsTUFBTSxHQUFHLEtBQUs7QUFDNUQsUUFBSyxNQUFNLENBQUNDLFFBQU0sTUFBTSxJQUFJLE9BQU8sUUFDakMsWUFBWSxrQkFDYixDQUNDLEtBQUlBLFVBQVEsVUFBVTtJQUNwQixRQUFRLElBQUksS0FDVixDQUFDLENBQUMsRUFBRUEsT0FBSyx1Q0FBdUMsRUFBRSxNQUFNLENBQUMsRUFBRSxXQUFXLFVBQVUsRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUNuRztBQUNELFFBQUksRUFBRSxTQUFTLFdBQ2IsU0FBUyxTQUFTLFNBQVNBO0lBRTdCLE9BQU8sU0FBU0E7R0FDakI7QUFFSCxVQUFPLG9CQUFvQixTQUFTO0VBQ3JDO0FBQ0QsU0FBTyxvQkFBb0IsR0FBRyxLQUFLO0NBQ3BDO0FBQ0QsUUFBTyxPQUFPLE9BQU8saUJBQWlCLG9CQUFvQjtBQUMzRDs7OztBQ3ZIRCxTQUFTLG9CQUFvQixTQUFTO0NBQ3BDLE1BQU0sTUFBTSxtQkFBbUIsUUFBUTtBQUN2QyxRQUFPLEVBQ0wsTUFBTSxJQUNQO0FBQ0Y7QUFDRCxvQkFBb0IsVUFBVUM7QUFDOUIsU0FBUywwQkFBMEIsU0FBUztDQUMxQyxNQUFNLE1BQU0sbUJBQW1CLFFBQVE7QUFDdkMsUUFBTztFQUNMLEdBQUc7RUFDSCxNQUFNO0NBQ1A7QUFDRjtBQUNELDBCQUEwQixVQUFVQTs7OztBQ2hCcEMsTUFBTSxVQUFVOzs7O0FDT2hCLE1BQU0sVUFBVUMsVUFBSyxPQUFPLFlBQVksMkJBQTJCLGFBQWEsQ0FBQyxTQUMvRSxFQUNFLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxTQUFTLENBQ3hDLEVBQ0Y7Ozs7QUNQRCxJQUFzQix3QkFBdEIsY0FBb0RDLGtCQUFRO0NBQzFELE9BQU8sUUFBUSxDQUFDLENBQUMsYUFBYyxHQUFFLENBQUMsWUFBYSxDQUFDO0NBRWhELE9BQU8sUUFBUUEsa0JBQVEsTUFBTSxFQUMzQixhQUNFLGlFQUNILEVBQUM7Q0FFRixNQUFNQyxpQkFBTyxPQUFPLFNBQVMsUUFBUSxLQUFLLEVBQUUsRUFDMUMsYUFDRSxxSEFDSCxFQUFDO0NBRUYsYUFBc0JBLGlCQUFPLE9BQU8sb0JBQW9CLEVBQ3RELGFBQWEsa0NBQ2QsRUFBQztDQUVGLGtCQUFrQkEsaUJBQU8sT0FBTyx1QkFBdUIsZ0JBQWdCLEVBQ3JFLGFBQWEseUJBQ2QsRUFBQztDQUVGLFNBQVNBLGlCQUFPLE9BQU8sZ0JBQWdCLE9BQU8sRUFDNUMsYUFBYSxnREFDZCxFQUFDO0NBRUYsV0FBV0EsaUJBQU8sT0FBTyw2QkFBNkIsU0FBUyxFQUM3RCxhQUFhLGtDQUNkLEVBQUM7Q0FFRixZQUFZQSxpQkFBTyxRQUFRLGdCQUFnQixNQUFNLEVBQy9DLGFBQWEsZ0NBQ2QsRUFBQztDQUVGLGdCQUF5QkEsaUJBQU8sT0FBTyxxQkFBcUIsRUFDMUQsYUFBYSxzQkFDZCxFQUFDO0NBRUYsY0FBdUJBLGlCQUFPLE9BQU8sbUJBQW1CLEVBQ3RELGFBQWEsNkJBQ2QsRUFBQztDQUVGLHNCQUFzQkEsaUJBQU8sUUFBUSwyQkFBMkIsT0FBTyxFQUNyRSxhQUFhLHFEQUNkLEVBQUM7Q0FFRixTQUFTQSxpQkFBTyxRQUFRLGFBQWEsT0FBTyxFQUMxQyxhQUFhLHVDQUNkLEVBQUM7Q0FFRixhQUFhO0FBQ1gsU0FBTztHQUNMLEtBQUssS0FBSztHQUNWLFlBQVksS0FBSztHQUNqQixpQkFBaUIsS0FBSztHQUN0QixRQUFRLEtBQUs7R0FDYixVQUFVLEtBQUs7R0FDZixXQUFXLEtBQUs7R0FDaEIsZUFBZSxLQUFLO0dBQ3BCLGFBQWEsS0FBSztHQUNsQixxQkFBcUIsS0FBSztHQUMxQixRQUFRLEtBQUs7RUFDZDtDQUNGO0FBQ0Y7QUE4REQsU0FBZ0IsOEJBQThCQyxTQUE0QjtBQUN4RSxRQUFPO0VBQ0wsS0FBSyxRQUFRLEtBQUs7RUFDbEIsaUJBQWlCO0VBQ2pCLFFBQVE7RUFDUixVQUFVO0VBQ1YsV0FBVztFQUNYLHFCQUFxQjtFQUNyQixRQUFRO0VBQ1IsR0FBRztDQUNKO0FBQ0Y7Ozs7QUN4SUQsSUFBc0IscUJBQXRCLGNBQWlEQyxrQkFBUTtDQUN2RCxPQUFPLFFBQVEsQ0FBQyxDQUFDLFNBQVUsQ0FBQztDQUU1QixPQUFPLFFBQVFBLGtCQUFRLE1BQU0sRUFDM0IsYUFBYSx5Q0FDZCxFQUFDO0NBRUYsTUFBTUMsaUJBQU8sT0FBTyxTQUFTLFFBQVEsS0FBSyxFQUFFLEVBQzFDLGFBQ0UscUhBQ0gsRUFBQztDQUVGLGFBQXNCQSxpQkFBTyxPQUFPLG9CQUFvQixFQUN0RCxhQUFhLGtDQUNkLEVBQUM7Q0FFRixrQkFBa0JBLGlCQUFPLE9BQU8sdUJBQXVCLGdCQUFnQixFQUNyRSxhQUFhLHlCQUNkLEVBQUM7Q0FFRixTQUFTQSxpQkFBTyxPQUFPLGFBQWEsT0FBTyxFQUN6QyxhQUFhLGdEQUNkLEVBQUM7Q0FFRixhQUFhO0FBQ1gsU0FBTztHQUNMLEtBQUssS0FBSztHQUNWLFlBQVksS0FBSztHQUNqQixpQkFBaUIsS0FBSztHQUN0QixRQUFRLEtBQUs7RUFDZDtDQUNGO0FBQ0Y7QUE4QkQsU0FBZ0IsMkJBQTJCQyxTQUF5QjtBQUNsRSxRQUFPO0VBQ0wsS0FBSyxRQUFRLEtBQUs7RUFDbEIsaUJBQWlCO0VBQ2pCLFFBQVE7RUFDUixHQUFHO0NBQ0o7QUFDRjs7OztBQ2hFRCxNQUFNQyxVQUFRLGFBQWEsVUFBVTtBQUVyQyxlQUFzQixRQUFRQyxhQUE2QjtDQUN6RCxNQUFNLFVBQVUsMkJBQTJCLFlBQVk7Q0FDdkQsTUFBTSx5Q0FBMEIsUUFBUSxLQUFLLFFBQVEsZ0JBQWdCO0NBRXJFLE1BQU0sU0FBUyxNQUFNLGVBQ25CLGlCQUNBLFFBQVEsb0NBQXFCLFFBQVEsS0FBSyxRQUFRLFdBQVcsR0FBRyxPQUNqRTtBQUVELE1BQUssTUFBTSxVQUFVLE9BQU8sU0FBUztFQUNuQyxNQUFNLGdDQUFpQixRQUFRLEtBQUssUUFBUSxRQUFRLE9BQU8sZ0JBQWdCO0VBRTNFRCxRQUFNLENBQUMsNEJBQTRCLENBQUMsRUFBRSxPQUFPLFlBQVksU0FBUyxPQUFPO0VBQ3pFLE1BQU0sc0NBQXVCLFFBQVEsZUFBZSxFQUFFLEVBQ3BELFNBQVMsT0FBTyxZQUFZLFFBQzdCLEVBQUM7Q0FDSDtBQUNGOzs7O0FDVEQsTUFBTUUsVUFBUSxhQUFhLGNBQWM7QUFRekMsZUFBc0IsV0FBV0MsYUFBZ0M7Q0FDL0RELFFBQU0sK0JBQStCO0NBQ3JDQSxRQUFNLFFBQVEsWUFBWTtDQUUxQixNQUFNLFVBQVUsOEJBQThCLFlBQVk7Q0FFMUQsTUFBTSx5Q0FBMEIsUUFBUSxLQUFLLFFBQVEsZ0JBQWdCO0NBRXJFLE1BQU0sRUFBRSxhQUFhLFNBQVMsYUFBYSxZQUFZLFdBQVcsR0FDaEUsTUFBTSxlQUNKLGlCQUNBLFFBQVEsb0NBQXFCLFFBQVEsS0FBSyxRQUFRLFdBQVcsR0FBRyxPQUNqRTtDQUVILGVBQWUsZ0JBQWdCRSxlQUFxQkMsV0FBaUI7QUFDbkUsTUFBSSxDQUFDLFFBQVEsVUFDWCxRQUFPO0dBQ0wsT0FBTztHQUNQLE1BQU07R0FDTixTQUFTO0lBQUUsTUFBTTtJQUFNLFNBQVM7SUFBTSxLQUFLO0dBQU07RUFDbEQ7RUFFSCxNQUFNLEVBQUUsY0FBTSxnQkFBTyxvQkFBUyxvQkFBUyxHQUFHLFlBQVlDLGVBQWFDLFVBQVE7QUFFM0UsTUFBSSxDQUFDQyxVQUFRLENBQUNDLFFBQ1osUUFBTztHQUNMLE9BQU87R0FDUCxNQUFNO0dBQ04sU0FBUztJQUFFLE1BQU07SUFBTSxTQUFTO0lBQU0sS0FBSztHQUFNO0VBQ2xEO0FBR0gsTUFBSSxDQUFDLFFBQVEsT0FDWCxLQUFJO0dBQ0YsTUFBTUMsVUFBUSxNQUFNLGNBQWM7SUFDaEM7SUFDQTtJQUNBLFVBQVVDLFVBQVE7SUFDbEIsTUFBTSxRQUFRO0lBQ2QsWUFDRUosVUFBUSxTQUFTLFFBQVEsSUFDekJBLFVBQVEsU0FBUyxPQUFPLElBQ3hCQSxVQUFRLFNBQVMsS0FBSztHQUN6QixFQUFDO0VBQ0gsU0FBUSxHQUFHO0dBQ1ZMLFFBQ0UsQ0FBQyxRQUFRLEVBQUUsS0FBSyxVQUNkO0lBQUU7SUFBTztJQUFNLFVBQVVTLFVBQVE7R0FBSyxHQUN0QyxNQUNBLEVBQ0QsRUFBRSxDQUNKO0dBQ0QsUUFBUSxNQUFNLEVBQUU7RUFDakI7QUFFSCxTQUFPO0dBQUU7R0FBTztHQUFNO0dBQVM7RUFBUztDQUN6QztDQUVELFNBQVMsWUFBWVAsZUFBcUJDLFdBQWlCO0VBQ3pELE1BQU0sOENBQXNCLDBCQUEwQixFQUNwRCxVQUFVLFFBQ1gsRUFBQyxDQUFDLE1BQU07RUFFVCxNQUFNLEVBQUUsbUJBQW1CLEdBQUcsUUFBUTtBQUN0QyxNQUFJLENBQUMsa0JBQ0gsUUFBTztHQUNMLE9BQU87R0FDUCxNQUFNO0dBQ04sU0FBUztJQUFFLE1BQU07SUFBTSxTQUFTO0lBQU0sS0FBSztHQUFNO0VBQ2xEO0VBRUhILFFBQU0sQ0FBQyxtQkFBbUIsRUFBRSxtQkFBbUIsQ0FBQztFQUNoRCxNQUFNLENBQUNPLFNBQU9ELE9BQUssR0FBRyxrQkFBa0IsTUFBTSxJQUFJO0VBQ2xELE1BQU1FLFlBQVUsSUFBSSxRQUFRLEVBQzFCLE1BQU0sUUFBUSxJQUFJLGFBQ25CO0VBQ0QsSUFBSUU7QUFDSixNQUFJLFFBQVEsYUFBYSxTQUFTO0dBQ2hDLE1BQU0sb0JBQW9CLFdBQ3ZCLE1BQU0sS0FBSyxDQUNYLElBQUksQ0FBQyxTQUFTLEtBQUssTUFBTSxDQUFDLENBQzFCLE9BQU8sQ0FBQyxNQUFNLFVBQVUsS0FBSyxVQUFVLE1BQU0sQ0FDN0MsSUFBSSxDQUFDLFNBQVMsS0FBSyxVQUFVLEVBQUUsQ0FBQyxDQUNoQyxJQUFJLFNBQVM7R0FFaEJELFlBQVUsa0JBQWtCLEtBQzFCLENBQUNBLGNBQVlBLFVBQVEsU0FBU0wsY0FDL0I7QUFFRCxPQUFJLENBQUNLLFVBQ0gsT0FBTSxJQUFJLFVBQ1IsQ0FBQyw2QkFBNkIsRUFBRUwsY0FBWSx3QkFBd0IsRUFBRSxZQUFZO0VBR3ZGLE9BQ0NLLFlBQVU7R0FDUixLQUFLLENBQUMsQ0FBQyxFQUFFSixXQUFTO0dBQ2xCO0dBQ0EsTUFBTUQ7RUFDUDtBQUVILFNBQU87R0FBRTtHQUFPO0dBQU07R0FBUztFQUFTO0NBQ3pDO0FBRUQsS0FBSSxDQUFDLFFBQVEsUUFBUTtFQUNuQixNQUFNLFFBQVEsWUFBWTtFQUMxQixNQUFNLGtCQUFrQixpQkFBaUIsRUFDdkMsc0JBQXNCLFFBQVEsT0FDNUIsQ0FBQyxNQUFNLFdBQVc7R0FDaEIsS0FBSyxHQUFHLFlBQVksQ0FBQyxFQUFFLE9BQU8saUJBQWlCLElBQUksWUFBWTtBQUUvRCxVQUFPO0VBQ1IsR0FDRCxDQUFFLEVBQ0gsQ0FDRixFQUFDO0NBQ0g7Q0FFRCxNQUFNLEVBQUUsT0FBTyxNQUFNLFNBQVMsU0FBUyxHQUFHLFFBQVEsY0FDOUMsWUFBWSxhQUFhLFlBQVksUUFBUSxHQUM3QyxNQUFNLGdCQUFnQixhQUFhLFlBQVksUUFBUTtBQUUzRCxNQUFLLE1BQU0sVUFBVSxTQUFTO0VBQzVCLE1BQU0sZ0NBQ0osUUFBUSxLQUNSLFFBQVEsUUFDUixHQUFHLE9BQU8saUJBQWlCLENBQzVCO0VBQ0QsTUFBTSxNQUNKLE9BQU8sYUFBYSxVQUFVLE9BQU8sYUFBYSxTQUFTLFNBQVM7RUFDdEUsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxFQUFFLEtBQUs7RUFDakUsTUFBTSw4QkFBZSxRQUFRLFNBQVM7QUFFdEMsTUFBSSxDQUFDLFFBQVEsUUFBUTtBQUNuQixPQUFJLHlCQUFZLFFBQVEsRUFBRTtJQUN4QkosUUFBTSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxRQUFRO0FBQ3ZDO0dBQ0Q7QUFFRCxPQUFJLENBQUMsUUFBUSxzREFDRixHQUFHLFVBQVUsUUFBUSxDQUFDLEVBQUU7SUFDL0IsS0FBSztJQUNMLEtBQUssUUFBUTtHQUNkLEVBQUM7QUFHSixPQUFJLFFBQVEsYUFBYSxRQUFRLE9BQU87SUFDdENBLFFBQU0sS0FBSyxDQUFDLHdCQUF3QixFQUFFLFFBQVEsS0FBSyxDQUFDO0FBQ3BELFFBQUk7S0FDRixNQUFNLFlBQVksUUFBUSxjQUN0QixPQUFPLFFBQVEsWUFBWSxJQUV6QixNQUFNLFFBQVMsTUFBTSxnQkFBZ0I7TUFDN0I7TUFDQztNQUNQLEtBQUssUUFBUTtLQUNkLEVBQUMsRUFDRixLQUFLO0tBQ1gsTUFBTSxxQ0FBd0IsUUFBUTtLQUN0QyxNQUFNLFlBQVksTUFBTSxRQUFTLE1BQU0sbUJBQW1CO01BQ2pEO01BQ0Q7TUFDTixNQUFNO01BQ04sWUFBWTtNQUNaLFdBQVcsRUFBRSxRQUFRLE1BQU87TUFDNUIsU0FBUztPQUNQLGtCQUFrQixhQUFhO09BQy9CLGdCQUFnQjtNQUNqQjtNQUVELE1BQU0sTUFBTSxjQUFjLFFBQVE7S0FDbkMsRUFBQztLQUNGQSxRQUFNLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0tBQ3BDQSxRQUFNLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLFVBQVUsS0FBSyxxQkFBcUI7SUFDcEUsU0FBUSxHQUFHO0tBQ1ZBLFFBQU0sTUFDSixDQUFDLE9BQU8sRUFBRSxLQUFLLFVBQ2I7TUFBRTtNQUFPO01BQU0sS0FBSyxRQUFRO01BQUssVUFBVTtLQUFTLEdBQ3BELE1BQ0EsRUFDRCxFQUFFLENBQ0o7S0FDREEsUUFBTSxNQUFNLEVBQUU7SUFDZjtHQUNGO0VBQ0Y7Q0FDRjtBQUNGO0FBRUQsU0FBUyxTQUFTVyxLQUFhO0NBQzdCLE1BQU0sV0FBVyxJQUFJLE1BQU0sSUFBSTtDQUMvQixNQUFNTixZQUFVLFNBQVMsS0FBSztDQUM5QixNQUFNTyxTQUFPLFNBQVMsS0FBSyxJQUFJO0FBRS9CLFFBQU87RUFDTDtFQUNBO0VBQ0E7Q0FDRDtBQUNGOzs7O0FDOU5ELElBQXNCLDBCQUF0QixjQUFzREMsa0JBQVE7Q0FDNUQsT0FBTyxRQUFRLENBQUMsQ0FBQyxjQUFlLENBQUM7Q0FFakMsT0FBTyxRQUFRQSxrQkFBUSxNQUFNLEVBQzNCLGFBQWEsbURBQ2QsRUFBQztDQUVGLE1BQU1DLGlCQUFPLE9BQU8sU0FBUyxRQUFRLEtBQUssRUFBRSxFQUMxQyxhQUNFLHFIQUNILEVBQUM7Q0FFRixhQUFzQkEsaUJBQU8sT0FBTyxvQkFBb0IsRUFDdEQsYUFBYSxrQ0FDZCxFQUFDO0NBRUYsa0JBQWtCQSxpQkFBTyxPQUFPLHVCQUF1QixnQkFBZ0IsRUFDckUsYUFBYSx5QkFDZCxFQUFDO0NBRUYsWUFBWUEsaUJBQU8sT0FBTyxtQkFBbUIsTUFBTSxFQUNqRCxhQUNFLGdHQUNILEVBQUM7Q0FFRixhQUFhO0FBQ1gsU0FBTztHQUNMLEtBQUssS0FBSztHQUNWLFlBQVksS0FBSztHQUNqQixpQkFBaUIsS0FBSztHQUN0QixXQUFXLEtBQUs7RUFDakI7Q0FDRjtBQUNGO0FBOEJELFNBQWdCLGdDQUFnQ0MsU0FBOEI7QUFDNUUsUUFBTztFQUNMLEtBQUssUUFBUSxLQUFLO0VBQ2xCLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsR0FBRztDQUNKO0FBQ0Y7Ozs7QUM5REQsTUFBTUMsVUFBUSxhQUFhLGVBQWU7QUFFMUMsTUFBTUMsaUJBRUYsRUFDRixRQUFRLENBQUMsUUFBUSxXQUFXO21DQUNoQixRQUFRO0VBQUM7RUFBVztFQUFXO0VBQVEsR0FBRztDQUFPLEdBQUUsRUFDM0QsT0FBTyxVQUNSLEVBQUM7QUFDSCxFQUNGO0FBRUQsZUFBc0IscUJBQXFCQyxhQUFrQztDQUMzRSxNQUFNLFVBQVUsZ0NBQWdDLFlBQVk7Q0FFNUQsTUFBTSxzQ0FBdUIsUUFBUSxLQUFLLFFBQVEsZ0JBQWdCO0NBRWxFLE1BQU0sU0FBUyxNQUFNLGVBQ25CLGlCQUNBLFFBQVEsb0NBQXFCLFFBQVEsS0FBSyxRQUFRLFdBQVcsR0FBRyxPQUNqRTtDQUVELE1BQU0sU0FBUyxPQUFPLFFBQVEsS0FDNUIsQ0FBQyxNQUFNLEVBQUUsYUFBYSxRQUFRLFlBQVksRUFBRSxTQUFTLFlBQ3REO0FBRUQsS0FBSSxDQUFDLE9BQ0gsT0FBTSxJQUFJLE1BQ1IsQ0FBQywrQkFBK0IsRUFBRSxRQUFRLFNBQVMsc0JBQXNCLENBQUM7Q0FJOUUsTUFBTSxXQUFXLG1CQUFtQixRQUFRLFdBQVcsSUFBSSxDQUFDLGdDQUV4RCxRQUFRLEtBQ1IsUUFBUSxXQUNSLEdBQUcsT0FBTyxXQUFXLENBQUMsRUFBRSxRQUFRLFNBQVMsQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUFDLENBQ3hELENBQ0Y7QUFFRCxLQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsUUFBUSxVQUN2QyxPQUFNLElBQUksTUFDUixDQUFDLCtCQUErQixFQUFFLFFBQVEsU0FBUyxnQkFBZ0IsQ0FBQztDQUl4RUYsUUFBTSxDQUFDLHVDQUF1QyxDQUFDLENBQUM7Q0FDaERBLFFBQU0sUUFBUSxTQUFTO0NBRXZCLE1BQU0sZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLFNBQVMsSUFBSSxDQUFDLE1BQU0sV0FBVyxFQUFFLENBQUMsQ0FBQztDQUUzRSxNQUFNLGdCQUFnQixTQUFTLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxjQUFjLEdBQUc7QUFFbEUsS0FBSSxjQUFjLE9BQ2hCLE9BQU0sSUFBSSxNQUNSLENBQUMsa0NBQWtDLEVBQUUsS0FBSyxVQUFVLGNBQWMsRUFBRTtDQUl4RSxNQUFNLGdDQUNKLFFBQVEsS0FDUixRQUFRLFdBQ1IsR0FBRyxPQUFPLFdBQVcsQ0FBQyxFQUFFLFFBQVEsU0FBUyxlQUFlLENBQUMsQ0FDMUQ7Q0FFRCxlQUFlLFFBQVEsWUFBWSxVQUFVLE9BQU87Q0FFcERBLFFBQU0sQ0FBQywyQkFBMkIsRUFBRSxRQUFRLENBQUM7QUFDOUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzREQsSUFBYSxVQUFiLE1BQXFCO0NBQ25CLFlBQVk7Q0FDWixNQUFNO0NBQ04sUUFBUTtDQUNSLGdCQUFnQjtDQUNoQixhQUFhO0NBQ2IsU0FBUztDQUNULGVBQWU7Q0FDZixVQUFVO0FBQ1gifQ==