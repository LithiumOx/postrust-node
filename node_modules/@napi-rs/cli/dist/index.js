import { createRequire } from "node:module";
import path, { join, parse, resolve } from "node:path";
import * as colors from "colorette";
import { underline, yellow } from "colorette";
import { Command, Option } from "clipanion";
import rawDebug from "debug";
import fs, { copyFile, existsSync, mkdir, mkdirSync, promises, readFile, readdir, rmSync, stat, statSync, unlink, writeFile } from "node:fs";
import { promisify } from "node:util";
import { exec, execSync, spawn, spawnSync } from "node:child_process";
import { isNil, merge, omit, omitBy, pick, sortBy } from "lodash-es";
import { createHash } from "node:crypto";
import { homedir } from "node:os";
import { parse as parse$1 } from "semver";
import { dump, load } from "js-yaml";
import * as typanion from "typanion";
import { rename } from "node:fs/promises";
import { findUp } from "find-up";
import { Octokit } from "@octokit/rest";

//#region src/def/artifacts.ts
var BaseArtifactsCommand = class extends Command {
	static paths = [["artifacts"]];
	static usage = Command.Usage({ description: "Copy artifacts from Github Actions into npm packages and ready to publish" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o,-d", "./artifacts", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	buildOutputDir = Option.String("--build-output-dir", { description: "Path to the build output dir, only needed when targets contains `wasm32-wasi-*`" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir,
			npmDir: this.npmDir,
			buildOutputDir: this.buildOutputDir
		};
	}
};
function applyDefaultArtifactsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./artifacts",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/utils/log.ts
rawDebug.formatters.i = (v) => {
	return colors.green(v);
};
const debugFactory = (namespace) => {
	const debug$8 = rawDebug(`napi:${namespace}`);
	debug$8.info = (...args) => console.error(colors.black(colors.bgGreen(" INFO ")), ...args);
	debug$8.warn = (...args) => console.error(colors.black(colors.bgYellow(" WARNING ")), ...args);
	debug$8.error = (...args) => console.error(colors.white(colors.bgRed(" ERROR ")), ...args.map((arg) => arg instanceof Error ? arg.stack ?? arg.message : arg));
	return debug$8;
};
const debug$7 = debugFactory("utils");

//#endregion
//#region package.json
var name = "@napi-rs/cli";
var version$1 = "3.0.4";
var description = "Cli tools for napi-rs";
var author = "LongYinan <lynweklm@gmail.com>";
var homepage = "https://github.com/napi-rs/napi-rs";
var license = "MIT";
var type = "module";
var engines = { "node": ">= 16" };
var bin = {
	"napi": "./dist/cli.js",
	"napi-raw": "./cli.mjs"
};
var main = "./dist/index.cjs";
var module = "./dist/index.js";
var exports = {
	".": {
		"import": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.js"
		},
		"require": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.cjs"
		}
	},
	"./package.json": {
		"import": "./package.json",
		"require": "./package.json"
	}
};
var files = ["dist", "src"];
var keywords = [
	"cli",
	"rust",
	"napi",
	"n-api",
	"node-api",
	"node-addon",
	"neon"
];
var maintainers = [{
	"name": "LongYinan",
	"email": "lynweklm@gmail.com",
	"homepage": "https://github.com/Brooooooklyn"
}, {
	"name": "forehalo",
	"homepage": "https://github.com/forehalo"
}];
var repository = {
	"type": "git",
	"url": "git+https://github.com/napi-rs/napi-rs.git"
};
var publishConfig = {
	"registry": "https://registry.npmjs.org/",
	"access": "public"
};
var bugs = { "url": "https://github.com/napi-rs/napi-rs/issues" };
var dependencies = {
	"@inquirer/prompts": "^7.4.0",
	"@napi-rs/cross-toolchain": "^1.0.0",
	"@napi-rs/wasm-tools": "^1.0.0",
	"@octokit/rest": "^22.0.0",
	"clipanion": "^4.0.0-rc.4",
	"colorette": "^2.0.20",
	"debug": "^4.4.0",
	"emnapi": "^1.4.0",
	"find-up": "^7.0.0",
	"js-yaml": "^4.1.0",
	"lodash-es": "^4.17.21",
	"semver": "^7.7.1",
	"typanion": "^3.14.0"
};
var devDependencies = {
	"@emnapi/core": "^1.4.0",
	"@emnapi/runtime": "^1.4.0",
	"@oxc-node/core": "^0.0.30",
	"@std/toml": "npm:@jsr/std__toml@^1.0.8",
	"@types/debug": "^4.1.12",
	"@types/inquirer": "^9.0.7",
	"@types/js-yaml": "^4.0.9",
	"@types/lodash-es": "^4.17.12",
	"@types/node": "^22.13.16",
	"@types/semver": "^7.7.0",
	"ava": "^6.2.0",
	"env-paths": "^3.0.0",
	"prettier": "^3.5.3",
	"rolldown": "latest",
	"tslib": "^2.8.1",
	"typescript": "^5.8.2"
};
var peerDependencies = {
	"@emnapi/runtime": "^1.1.0",
	"emnapi": "^1.1.0"
};
var peerDependenciesMeta = {
	"@emnapi/runtime": { "optional": true },
	"emnapi": { "optional": true }
};
var funding = {
	"type": "github",
	"url": "https://github.com/sponsors/Brooooooklyn"
};
var scripts = {
	"clean": "node --import @oxc-node/core/register ./clean.ts",
	"codegen": "node --import @oxc-node/core/register ./codegen/index.ts",
	"build": "tsc && yarn clean && rolldown -c rolldown.config.js",
	"test": "node --import @oxc-node/core/register ../node_modules/ava/entrypoints/cli.mjs"
};
var ava = {
	"extensions": { "ts": "module" },
	"timeout": "1m",
	"files": ["**/__tests__/**/*.spec.ts", "e2e/**/*.spec.ts"]
};
var gitHead = "521b5774aa89f1a7c807a6ddba509ce43973f624";
var package_default = {
	name,
	version: version$1,
	description,
	author,
	homepage,
	license,
	type,
	engines,
	bin,
	main,
	module,
	exports,
	files,
	keywords,
	maintainers,
	repository,
	publishConfig,
	bugs,
	dependencies,
	devDependencies,
	peerDependencies,
	peerDependenciesMeta,
	funding,
	scripts,
	ava,
	gitHead
};

//#endregion
//#region src/utils/misc.ts
const readFileAsync = promisify(readFile);
const writeFileAsync = promisify(writeFile);
const unlinkAsync = promisify(unlink);
const copyFileAsync = promisify(copyFile);
const mkdirAsync = promisify(mkdir);
const statAsync = promisify(stat);
const readdirAsync = promisify(readdir);
async function fileExists(path$1) {
	const exists = await statAsync(path$1).then(() => true).catch(() => false);
	return exists;
}
async function dirExistsAsync(path$1) {
	try {
		const stats = await statAsync(path$1);
		return stats.isDirectory();
	} catch {
		return false;
	}
}
function pick$1(o, ...keys) {
	return keys.reduce((acc, key) => {
		acc[key] = o[key];
		return acc;
	}, {});
}
async function updatePackageJson(path$1, partial) {
	const exists = await fileExists(path$1);
	if (!exists) {
		debug$7(`File not exists ${path$1}`);
		return;
	}
	const old = JSON.parse(await readFileAsync(path$1, "utf8"));
	await writeFileAsync(path$1, JSON.stringify({
		...old,
		...partial
	}, null, 2));
}
const CLI_VERSION = package_default.version;

//#endregion
//#region src/utils/target.ts
const AVAILABLE_TARGETS = [
	"aarch64-apple-darwin",
	"aarch64-linux-android",
	"aarch64-unknown-linux-gnu",
	"aarch64-unknown-linux-musl",
	"aarch64-unknown-linux-ohos",
	"aarch64-pc-windows-msvc",
	"x86_64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu",
	"x86_64-unknown-linux-musl",
	"x86_64-unknown-linux-ohos",
	"x86_64-unknown-freebsd",
	"i686-pc-windows-msvc",
	"armv7-unknown-linux-gnueabihf",
	"armv7-unknown-linux-musleabihf",
	"armv7-linux-androideabi",
	"universal-apple-darwin",
	"riscv64gc-unknown-linux-gnu",
	"powerpc64le-unknown-linux-gnu",
	"s390x-unknown-linux-gnu",
	"wasm32-wasi-preview1-threads",
	"wasm32-wasip1-threads"
];
const DEFAULT_TARGETS = [
	"x86_64-apple-darwin",
	"aarch64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu"
];
const TARGET_LINKER = {
	"aarch64-unknown-linux-musl": "aarch64-linux-musl-gcc",
	"riscv64gc-unknown-linux-gnu": "riscv64-linux-gnu-gcc",
	"powerpc64le-unknown-linux-gnu": "powerpc64le-linux-gnu-gcc",
	"s390x-unknown-linux-gnu": "s390x-linux-gnu-gcc"
};
const CpuToNodeArch = {
	x86_64: "x64",
	aarch64: "arm64",
	i686: "ia32",
	armv7: "arm",
	riscv64gc: "riscv64",
	powerpc64le: "ppc64"
};
const SysToNodePlatform = {
	linux: "linux",
	freebsd: "freebsd",
	darwin: "darwin",
	windows: "win32",
	ohos: "openharmony"
};
const UniArchsByPlatform = { darwin: ["x64", "arm64"] };
/**
* A triple is a specific format for specifying a target architecture.
* Triples may be referred to as a target triple which is the architecture for the artifact produced, and the host triple which is the architecture that the compiler is running on.
* The general format of the triple is `<arch><sub>-<vendor>-<sys>-<abi>` where:
*   - `arch` = The base CPU architecture, for example `x86_64`, `i686`, `arm`, `thumb`, `mips`, etc.
*   - `sub` = The CPU sub-architecture, for example `arm` has `v7`, `v7s`, `v5te`, etc.
*   - `vendor` = The vendor, for example `unknown`, `apple`, `pc`, `nvidia`, etc.
*   - `sys` = The system name, for example `linux`, `windows`, `darwin`, etc. none is typically used for bare-metal without an OS.
*   - `abi` = The ABI, for example `gnu`, `android`, `eabi`, etc.
*/
function parseTriple(rawTriple) {
	if (rawTriple === "wasm32-wasi" || rawTriple === "wasm32-wasi-preview1-threads" || rawTriple.startsWith("wasm32-wasip")) return {
		triple: rawTriple,
		platformArchABI: "wasm32-wasi",
		platform: "wasi",
		arch: "wasm32",
		abi: "wasi"
	};
	const triple = rawTriple.endsWith("eabi") ? `${rawTriple.slice(0, -4)}-eabi` : rawTriple;
	const triples = triple.split("-");
	let cpu;
	let sys;
	let abi = null;
	if (triples.length === 2) [cpu, sys] = triples;
	else [cpu, , sys, abi = null] = triples;
	const platform = SysToNodePlatform[sys] ?? sys;
	const arch = CpuToNodeArch[cpu] ?? cpu;
	if (rawTriple.includes("ohos")) return {
		triple: rawTriple,
		platformArchABI: `linux-${arch}-ohos`,
		platform: "openharmony",
		arch,
		abi: null
	};
	return {
		triple: rawTriple,
		platformArchABI: abi ? `${platform}-${arch}-${abi}` : `${platform}-${arch}`,
		platform,
		arch,
		abi
	};
}
function getSystemDefaultTarget() {
	const host = execSync(`rustc -vV`, { env: process.env }).toString("utf8").split("\n").find((line) => line.startsWith("host: "));
	const triple = host?.slice(6);
	if (!triple) throw new TypeError(`Can not parse target triple from host`);
	return parseTriple(triple);
}
function getTargetLinker(target) {
	return TARGET_LINKER[target];
}
function targetToEnvVar(target) {
	return target.replace(/-/g, "_").toUpperCase();
}

//#endregion
//#region src/utils/version.ts
let NapiVersion = /* @__PURE__ */ function(NapiVersion$1) {
	NapiVersion$1[NapiVersion$1["Napi1"] = 1] = "Napi1";
	NapiVersion$1[NapiVersion$1["Napi2"] = 2] = "Napi2";
	NapiVersion$1[NapiVersion$1["Napi3"] = 3] = "Napi3";
	NapiVersion$1[NapiVersion$1["Napi4"] = 4] = "Napi4";
	NapiVersion$1[NapiVersion$1["Napi5"] = 5] = "Napi5";
	NapiVersion$1[NapiVersion$1["Napi6"] = 6] = "Napi6";
	NapiVersion$1[NapiVersion$1["Napi7"] = 7] = "Napi7";
	NapiVersion$1[NapiVersion$1["Napi8"] = 8] = "Napi8";
	NapiVersion$1[NapiVersion$1["Napi9"] = 9] = "Napi9";
	return NapiVersion$1;
}({});
const NAPI_VERSION_MATRIX = new Map([
	[NapiVersion.Napi1, "8.6.0 | 9.0.0 | 10.0.0"],
	[NapiVersion.Napi2, "8.10.0 | 9.3.0 | 10.0.0"],
	[NapiVersion.Napi3, "6.14.2 | 8.11.2 | 9.11.0 | 10.0.0"],
	[NapiVersion.Napi4, "10.16.0 | 11.8.0 | 12.0.0"],
	[NapiVersion.Napi5, "10.17.0 | 12.11.0 | 13.0.0"],
	[NapiVersion.Napi6, "10.20.0 | 12.17.0 | 14.0.0"],
	[NapiVersion.Napi7, "10.23.0 | 12.19.0 | 14.12.0 | 15.0.0"],
	[NapiVersion.Napi8, "12.22.0 | 14.17.0 | 15.12.0 | 16.0.0"],
	[NapiVersion.Napi9, "18.17.0 | 20.3.0 | 21.1.0"]
]);
function parseNodeVersion(v) {
	const matches = v.match(/v?([0-9]+)\.([0-9]+)\.([0-9]+)/i);
	if (!matches) throw new Error("Unknown node version number: " + v);
	const [, major, minor, patch] = matches;
	return {
		major: parseInt(major),
		minor: parseInt(minor),
		patch: parseInt(patch)
	};
}
function requiredNodeVersions(napiVersion) {
	const requirement = NAPI_VERSION_MATRIX.get(napiVersion);
	if (!requirement) return [parseNodeVersion("10.0.0")];
	return requirement.split("|").map(parseNodeVersion);
}
function toEngineRequirement(versions) {
	const requirements = [];
	versions.forEach((v, i) => {
		let req = "";
		if (i !== 0) {
			const lastVersion = versions[i - 1];
			req += `< ${lastVersion.major + 1}`;
		}
		req += `${i === 0 ? "" : " || "}>= ${v.major}.${v.minor}.${v.patch}`;
		requirements.push(req);
	});
	return requirements.join(" ");
}
function napiEngineRequirement(napiVersion) {
	return toEngineRequirement(requiredNodeVersions(napiVersion));
}

//#endregion
//#region src/utils/metadata.ts
async function parseMetadata(manifestPath) {
	if (!fs.existsSync(manifestPath)) throw new Error(`No crate found in manifest: ${manifestPath}`);
	const childProcess = spawn("cargo", [
		"metadata",
		"--manifest-path",
		manifestPath,
		"--format-version",
		"1"
	], { stdio: "pipe" });
	let stdout = "";
	let stderr = "";
	let status = 0;
	let error = null;
	childProcess.stdout.on("data", (data) => {
		stdout += data;
	});
	childProcess.stderr.on("data", (data) => {
		stderr += data;
	});
	await new Promise((resolve$1) => {
		childProcess.on("close", (code) => {
			status = code ?? 0;
			resolve$1();
		});
	});
	if (error) throw new Error("cargo metadata failed to run", { cause: error });
	if (status !== 0) {
		const simpleMessage = `cargo metadata exited with code ${status}`;
		throw new Error(`${simpleMessage} and error message:\n\n${stderr}`, { cause: new Error(simpleMessage) });
	}
	try {
		return JSON.parse(stdout);
	} catch (e) {
		throw new Error("Failed to parse cargo metadata JSON", { cause: e });
	}
}

//#endregion
//#region src/utils/config.ts
async function readNapiConfig(path$1, configPath) {
	if (configPath && !await fileExists(configPath)) throw new Error(`NAPI-RS config not found at ${configPath}`);
	if (!await fileExists(path$1)) throw new Error(`package.json not found at ${path$1}`);
	const content = await readFileAsync(path$1, "utf8");
	let pkgJson;
	try {
		pkgJson = JSON.parse(content);
	} catch (e) {
		throw new Error(`Failed to parse package.json at ${path$1}`, { cause: e });
	}
	let separatedConfig;
	if (configPath) {
		const configContent = await readFileAsync(configPath, "utf8");
		try {
			separatedConfig = JSON.parse(configContent);
		} catch (e) {
			throw new Error(`Failed to parse NAPI-RS config at ${configPath}`, { cause: e });
		}
	}
	const userNapiConfig = pkgJson.napi ?? {};
	if (pkgJson.napi && separatedConfig) {
		const pkgJsonPath = underline(path$1);
		const configPathUnderline = underline(configPath);
		console.warn(yellow(`Both napi field in ${pkgJsonPath} and [NAPI-RS config](${configPathUnderline}) file are found, the NAPI-RS config file will be used.`));
		Object.assign(userNapiConfig, separatedConfig);
	}
	const napiConfig = merge({
		binaryName: "index",
		packageName: pkgJson.name,
		targets: [],
		packageJson: pkgJson,
		npmClient: "npm"
	}, omit(userNapiConfig, "targets"));
	let targets = userNapiConfig.targets ?? [];
	if (userNapiConfig?.name) {
		console.warn(yellow(`[DEPRECATED] napi.name is deprecated, use napi.binaryName instead.`));
		napiConfig.binaryName = userNapiConfig.name;
	}
	if (!targets.length) {
		let deprecatedWarned = false;
		const warning = yellow(`[DEPRECATED] napi.triples is deprecated, use napi.targets instead.`);
		if (userNapiConfig.triples?.defaults) {
			deprecatedWarned = true;
			console.warn(warning);
			targets = targets.concat(DEFAULT_TARGETS);
		}
		if (userNapiConfig.triples?.additional?.length) {
			targets = targets.concat(userNapiConfig.triples.additional);
			if (!deprecatedWarned) console.warn(warning);
		}
	}
	const uniqueTargets = new Set(targets);
	if (uniqueTargets.size !== targets.length) {
		const duplicateTarget = targets.find((target, index) => targets.indexOf(target) !== index);
		throw new Error(`Duplicate targets are not allowed: ${duplicateTarget}`);
	}
	napiConfig.targets = targets.map(parseTriple);
	return napiConfig;
}

//#endregion
//#region src/utils/cargo.ts
function tryInstallCargoBinary(name$1, bin$1) {
	if (detectCargoBinary(bin$1)) {
		debug$7("Cargo binary already installed: %s", name$1);
		return;
	}
	try {
		debug$7("Installing cargo binary: %s", name$1);
		execSync(`cargo install ${name$1}`, { stdio: "inherit" });
	} catch (e) {
		throw new Error(`Failed to install cargo binary: ${name$1}`, { cause: e });
	}
}
function detectCargoBinary(bin$1) {
	debug$7("Detecting cargo binary: %s", bin$1);
	try {
		execSync(`cargo help ${bin$1}`, { stdio: "ignore" });
		debug$7("Cargo binary detected: %s", bin$1);
		return true;
	} catch {
		debug$7("Cargo binary not detected: %s", bin$1);
		return false;
	}
}

//#endregion
//#region src/utils/typegen.ts
const TOP_LEVEL_NAMESPACE = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER = `/* auto-generated by NAPI-RS */
/* eslint-disable */
`;
var TypeDefKind = /* @__PURE__ */ function(TypeDefKind$1) {
	TypeDefKind$1["Const"] = "const";
	TypeDefKind$1["Enum"] = "enum";
	TypeDefKind$1["StringEnum"] = "string_enum";
	TypeDefKind$1["Interface"] = "interface";
	TypeDefKind$1["Type"] = "type";
	TypeDefKind$1["Fn"] = "fn";
	TypeDefKind$1["Struct"] = "struct";
	TypeDefKind$1["Impl"] = "impl";
	return TypeDefKind$1;
}(TypeDefKind || {});
function prettyPrint(line, constEnum, ident, ambient = false) {
	let s = line.js_doc ?? "";
	switch (line.kind) {
		case TypeDefKind.Interface:
			s += `export interface ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.Type:
			s += `export type ${line.name} = \n${line.def}`;
			break;
		case TypeDefKind.Enum:
			const enumName = constEnum ? "const enum" : "enum";
			s += `${exportDeclare(ambient)} ${enumName} ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.StringEnum:
			if (constEnum) s += `${exportDeclare(ambient)} const enum ${line.name} {\n${line.def}\n}`;
			else s += `export type ${line.name} = ${line.def.replaceAll(/.*=/g, "").replaceAll(",", "|")};`;
			break;
		case TypeDefKind.Struct:
			s += `${exportDeclare(ambient)} class ${line.name} {\n${line.def}\n}`;
			if (line.original_name && line.original_name !== line.name) s += `\nexport type ${line.original_name} = ${line.name}`;
			break;
		case TypeDefKind.Fn:
			s += `${exportDeclare(ambient)} ${line.def}`;
			break;
		default: s += line.def;
	}
	return correctStringIdent(s, ident);
}
function exportDeclare(ambient) {
	if (ambient) return "export";
	return "export declare";
}
async function processTypeDef(intermediateTypeFile, constEnum) {
	const exports$1 = [];
	const defs = await readIntermediateTypeFile(intermediateTypeFile);
	const groupedDefs = preprocessTypeDef(defs);
	const dts = sortBy(Array.from(groupedDefs), ([namespace]) => namespace).map(([namespace, defs$1]) => {
		if (namespace === TOP_LEVEL_NAMESPACE) return defs$1.map((def) => {
			switch (def.kind) {
				case TypeDefKind.Const:
				case TypeDefKind.Enum:
				case TypeDefKind.StringEnum:
				case TypeDefKind.Fn:
				case TypeDefKind.Struct: {
					exports$1.push(def.name);
					if (def.original_name && def.original_name !== def.name) exports$1.push(def.original_name);
					break;
				}
				default: break;
			}
			return prettyPrint(def, constEnum, 0);
		}).join("\n\n");
		else {
			exports$1.push(namespace);
			let declaration = "";
			declaration += `export declare namespace ${namespace} {\n`;
			for (const def of defs$1) declaration += prettyPrint(def, constEnum, 2, true) + "\n";
			declaration += "}";
			return declaration;
		}
	}).join("\n\n") + "\n";
	return {
		dts,
		exports: exports$1
	};
}
async function readIntermediateTypeFile(file) {
	const content = await readFileAsync(file, "utf8");
	const defs = content.split("\n").filter(Boolean).map((line) => {
		line = line.trim();
		const parsed = JSON.parse(line);
		if (parsed.js_doc) parsed.js_doc = parsed.js_doc.replace(/\\n/g, "\n");
		if (parsed.def) parsed.def = parsed.def.replace(/\\n/g, "\n");
		return parsed;
	});
	return defs.sort((a, b) => {
		if (a.kind === TypeDefKind.Struct) {
			if (b.kind === TypeDefKind.Struct) return a.name.localeCompare(b.name);
			return -1;
		} else if (b.kind === TypeDefKind.Struct) return 1;
		else return a.name.localeCompare(b.name);
	});
}
function preprocessTypeDef(defs) {
	const namespaceGrouped = /* @__PURE__ */ new Map();
	const classDefs = /* @__PURE__ */ new Map();
	for (const def of defs) {
		const namespace = def.js_mod ?? TOP_LEVEL_NAMESPACE;
		if (!namespaceGrouped.has(namespace)) namespaceGrouped.set(namespace, []);
		const group = namespaceGrouped.get(namespace);
		if (def.kind === TypeDefKind.Struct) {
			group.push(def);
			classDefs.set(def.name, def);
		} else if (def.kind === TypeDefKind.Impl) {
			const classDef = classDefs.get(def.name);
			if (classDef) {
				if (classDef.def) classDef.def += "\n";
				classDef.def += def.def;
				if (classDef.def) classDef.def = classDef.def.replace(/\\n/g, "\n");
			}
		} else group.push(def);
	}
	return namespaceGrouped;
}
function correctStringIdent(src, ident) {
	let bracketDepth = 0;
	const result = src.split("\n").map((line) => {
		line = line.trim();
		if (line === "") return "";
		const isInMultilineComment = line.startsWith("*");
		const isClosingBracket = line.endsWith("}");
		const isOpeningBracket = line.endsWith("{");
		const isTypeDeclaration = line.endsWith("=");
		const isTypeVariant = line.startsWith("|");
		let rightIndent = ident;
		if ((isOpeningBracket || isTypeDeclaration) && !isInMultilineComment) {
			bracketDepth += 1;
			rightIndent += (bracketDepth - 1) * 2;
		} else {
			if (isClosingBracket && bracketDepth > 0 && !isInMultilineComment && !isTypeVariant) bracketDepth -= 1;
			rightIndent += bracketDepth * 2;
		}
		if (isInMultilineComment) rightIndent += 1;
		const s = `${" ".repeat(rightIndent)}${line}`;
		return s;
	}).join("\n");
	return result;
}

//#endregion
//#region src/utils/read-config.ts
async function readConfig(options) {
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	return config;
}

//#endregion
//#region src/api/artifacts.ts
const debug$6 = debugFactory("artifacts");
async function collectArtifacts(userOptions) {
	const options = applyDefaultArtifactsOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const { targets, binaryName, packageName } = await readNapiConfig(packageJsonPath);
	const distDirs = targets.map((platform) => join(options.cwd, options.npmDir, platform.platformArchABI));
	const universalSourceBins = new Set(targets.filter((platform) => platform.arch === "universal").flatMap((p) => UniArchsByPlatform[p.platform]?.map((a) => `${p.platform}-${a}`)).filter(Boolean));
	await collectNodeBinaries(join(options.cwd, options.outputDir)).then((output) => Promise.all(output.map(async (filePath) => {
		debug$6.info(`Read [${colors.yellowBright(filePath)}]`);
		const sourceContent = await readFileAsync(filePath);
		const parsedName = parse(filePath);
		const terms = parsedName.name.split(".");
		const platformArchABI = terms.pop();
		const _binaryName = terms.join(".");
		if (_binaryName !== binaryName) {
			debug$6.warn(`[${_binaryName}] is not matched with [${binaryName}], skip`);
			return;
		}
		const dir = distDirs.find((dir$1) => dir$1.includes(platformArchABI));
		if (!dir && universalSourceBins.has(platformArchABI)) {
			debug$6.warn(`[${platformArchABI}] has no dist dir but it is source bin for universal arch, skip`);
			return;
		}
		if (!dir) throw new Error(`No dist dir found for ${filePath}`);
		const distFilePath = join(dir, parsedName.base);
		debug$6.info(`Write file content to [${colors.yellowBright(distFilePath)}]`);
		await writeFileAsync(distFilePath, sourceContent);
		const distFilePathLocal = join(parse(packageJsonPath).dir, parsedName.base);
		debug$6.info(`Write file content to [${colors.yellowBright(distFilePathLocal)}]`);
		await writeFileAsync(distFilePathLocal, sourceContent);
	})));
	const wasiTarget = targets.find((t) => t.platform === "wasi");
	if (wasiTarget) {
		const wasiDir = join(options.cwd, options.npmDir, wasiTarget.platformArchABI);
		const cjsFile = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi.cjs`);
		const workerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker.mjs`);
		const browserEntry = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi-browser.js`);
		const browserWorkerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker-browser.mjs`);
		debug$6.info(`Move wasi binding file [${colors.yellowBright(cjsFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi.cjs`), await readFileAsync(cjsFile));
		debug$6.info(`Move wasi worker file [${colors.yellowBright(workerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker.mjs`), await readFileAsync(workerFile));
		debug$6.info(`Move wasi browser entry file [${colors.yellowBright(browserEntry)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi-browser.js`), (await readFileAsync(browserEntry, "utf8")).replace(`new URL('./wasi-worker-browser.mjs', import.meta.url)`, `new URL('${packageName}-wasm32-wasi/wasi-worker-browser.mjs', import.meta.url)`));
		debug$6.info(`Move wasi browser worker file [${colors.yellowBright(browserWorkerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker-browser.mjs`), await readFileAsync(browserWorkerFile));
	}
}
async function collectNodeBinaries(root) {
	const files$1 = await readdirAsync(root, { withFileTypes: true });
	const nodeBinaries = files$1.filter((file) => file.isFile() && (file.name.endsWith(".node") || file.name.endsWith(".wasm"))).map((file) => join(root, file.name));
	const dirs = files$1.filter((file) => file.isDirectory());
	for (const dir of dirs) if (dir.name !== "node_modules") nodeBinaries.push(...await collectNodeBinaries(join(root, dir.name)));
	return nodeBinaries;
}

//#endregion
//#region src/api/templates/js-binding.ts
function createCjsBinding(localName, pkgName, idents) {
	return `${bindingHeader}
const { createRequire } = require('node:module')
require = createRequire(__filename)

${createCommonBinding(localName, pkgName)}
module.exports = nativeBinding
${idents.map((ident) => `module.exports.${ident} = nativeBinding.${ident}`).join("\n")}
`;
}
function createEsmBinding(localName, pkgName, idents) {
	return `${bindingHeader}
import { createRequire } from 'node:module'
const require = createRequire(import.meta.url)
const __dirname = new URL('.', import.meta.url).pathname

${createCommonBinding(localName, pkgName)}
const { ${idents.join(", ")} } = nativeBinding
${idents.map((ident) => `export { ${ident} }`).join("\n")}
`;
}
const bindingHeader = `// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */
`;
function createCommonBinding(localName, pkgName) {
	function requireTuple(tuple, identSize = 8) {
		const identLow = " ".repeat(identSize - 2);
		const ident = " ".repeat(identSize);
		return `try {
${ident}return require('./${localName}.${tuple}.node')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}
${identLow}try {
${ident}return require('${pkgName}-${tuple}')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}`;
	}
	return `const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      nativeBinding = require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      ${requireTuple("android-arm64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("android-arm-eabi")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Android \${process.arch}\`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      ${requireTuple("win32-x64-msvc")}
    } else if (process.arch === 'ia32') {
      ${requireTuple("win32-ia32-msvc")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("win32-arm64-msvc")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Windows: \${process.arch}\`))
    }
  } else if (process.platform === 'darwin') {
    ${requireTuple("darwin-universal", 6)}
    if (process.arch === 'x64') {
      ${requireTuple("darwin-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("darwin-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on macOS: \${process.arch}\`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      ${requireTuple("freebsd-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("freebsd-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on FreeBSD: \${process.arch}\`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        ${requireTuple("linux-x64-musl", 10)}
      } else {
        ${requireTuple("linux-x64-gnu", 10)}
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        ${requireTuple("linux-arm64-musl", 10)}
      } else {
        ${requireTuple("linux-arm64-gnu", 10)}
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        ${requireTuple("linux-arm-musleabihf", 10)}
      } else {
        ${requireTuple("linux-arm-gnueabihf", 10)}
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        ${requireTuple("linux-riscv64-musl", 10)}
      } else {
        ${requireTuple("linux-riscv64-gnu", 10)}
      }
    } else if (process.arch === 'ppc64') {
      ${requireTuple("linux-ppc64-gnu")}
    } else if (process.arch === 's390x') {
      ${requireTuple("linux-s390x-gnu")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Linux: \${process.arch}\`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      ${requireTuple("linux-arm64-ohos")}
    } else if (process.arch === 'x64') {
      ${requireTuple("linux-x64-ohos")}
    } else if (process.arch === 'arm') {
      ${requireTuple("linux-arm-ohos")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on OpenHarmony: \${process.arch}\`))
    }
  } else {
    loadErrors.push(new Error(\`Unsupported OS: \${process.platform}, architecture: \${process.arch}\`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  try {
    nativeBinding = require('./${localName}.wasi.cjs')
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      loadErrors.push(err)
    }
  }
  if (!nativeBinding) {
    try {
      nativeBinding = require('${pkgName}-wasm32-wasi')
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        loadErrors.push(err)
      }
    }
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      \`Cannot find native binding. \` +
        \`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). \` +
        'Please try \`npm i\` again after removing both package-lock.json and node_modules directory.',
      { cause: loadErrors }
    )
  }
  throw new Error(\`Failed to load native binding\`)
}
`;
}

//#endregion
//#region src/api/templates/load-wasi-template.ts
const createWasiBrowserBinding = (wasiFilename, initialMemory = 4e3, maximumMemory = 65536, fs$1 = false, asyncInit = false, buffer = false) => {
	const fsImport = fs$1 ? buffer ? `import { memfs, Buffer } from '@napi-rs/wasm-runtime/fs'` : `import { memfs } from '@napi-rs/wasm-runtime/fs'` : "";
	const bufferImport = buffer && !fs$1 ? `import { Buffer } from 'buffer'` : "";
	const wasiCreation = fs$1 ? `
export const { fs: __fs, vol: __volume } = memfs()

const __wasi = new __WASI({
  version: 'preview1',
  fs: __fs,
  preopens: {
    '/': '/',
  },
})` : `
const __wasi = new __WASI({
  version: 'preview1',
})`;
	const workerFsHandler = fs$1 ? `    worker.addEventListener('message', __wasmCreateOnMessageForFsProxy(__fs))\n` : "";
	const emnapiInjectBuffer = buffer ? "__emnapiContext.feature.Buffer = Buffer" : "";
	const emnapiInstantiateImport = asyncInit ? `instantiateNapiModule as __emnapiInstantiateNapiModule` : `instantiateNapiModuleSync as __emnapiInstantiateNapiModuleSync`;
	const emnapiInstantiateCall = asyncInit ? `await __emnapiInstantiateNapiModule` : `__emnapiInstantiateNapiModuleSync`;
	return `import {
  createOnMessage as __wasmCreateOnMessageForFsProxy,
  getDefaultContext as __emnapiGetDefaultContext,
  ${emnapiInstantiateImport},
  WASI as __WASI,
} from '@napi-rs/wasm-runtime'
${fsImport}
${bufferImport}
${wasiCreation}

const __wasmUrl = new URL('./${wasiFilename}.wasm', import.meta.url).href
const __emnapiContext = __emnapiGetDefaultContext()
${emnapiInjectBuffer}

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

const __wasmFile = await fetch(__wasmUrl).then((res) => res.arrayBuffer())

const {
  instance: __napiInstance,
  module: __wasiModule,
  napiModule: __napiModule,
} = ${emnapiInstantiateCall}(__wasmFile, {
  context: __emnapiContext,
  asyncWorkPoolSize: 4,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(new URL('./wasi-worker-browser.mjs', import.meta.url), {
      type: 'module',
    })
${workerFsHandler}
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;
};
const createWasiBinding = (wasmFileName, packageName, initialMemory = 4e3, maximumMemory = 65536) => `/* eslint-disable */
/* prettier-ignore */

/* auto-generated by NAPI-RS */

const __nodeFs = require('node:fs')
const __nodePath = require('node:path')
const { WASI: __nodeWASI } = require('node:wasi')
const { Worker } = require('node:worker_threads')

const {
  createOnMessage: __wasmCreateOnMessageForFsProxy,
  getDefaultContext: __emnapiGetDefaultContext,
  instantiateNapiModuleSync: __emnapiInstantiateNapiModuleSync,
} = require('@napi-rs/wasm-runtime')

const __rootDir = __nodePath.parse(process.cwd()).root

const __wasi = new __nodeWASI({
  version: 'preview1',
  env: process.env,
  preopens: {
    [__rootDir]: __rootDir,
  }
})

const __emnapiContext = __emnapiGetDefaultContext()

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

let __wasmFilePath = __nodePath.join(__dirname, '${wasmFileName}.wasm')
const __wasmDebugFilePath = __nodePath.join(__dirname, '${wasmFileName}.debug.wasm')

if (__nodeFs.existsSync(__wasmDebugFilePath)) {
  __wasmFilePath = __wasmDebugFilePath
} else if (!__nodeFs.existsSync(__wasmFilePath)) {
  try {
    __wasmFilePath = __nodePath.resolve('${packageName}-wasm32-wasi')
  } catch {
    throw new Error('Cannot find ${wasmFileName}.wasm file, and ${packageName}-wasm32-wasi package is not installed.')
  }
}

const { instance: __napiInstance, module: __wasiModule, napiModule: __napiModule } = __emnapiInstantiateNapiModuleSync(__nodeFs.readFileSync(__wasmFilePath), {
  context: __emnapiContext,
  asyncWorkPoolSize: (function() {
    const threadsSizeFromEnv = Number(process.env.NAPI_RS_ASYNC_WORK_POOL_SIZE ?? process.env.UV_THREADPOOL_SIZE)
    // NaN > 0 is false
    if (threadsSizeFromEnv > 0) {
      return threadsSizeFromEnv
    } else {
      return 4
    }
  })(),
  reuseWorker: true,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(__nodePath.join(__dirname, 'wasi-worker.mjs'), {
      env: process.env,
    })
    worker.onmessage = ({ data }) => {
      __wasmCreateOnMessageForFsProxy(__nodeFs)(data)
    }

    // The main thread of Node.js waits for all the active handles before exiting.
    // But Rust threads are never waited without \`thread::join\`.
    // So here we hack the code of Node.js to prevent the workers from being referenced (active).
    // According to https://github.com/nodejs/node/blob/19e0d472728c79d418b74bddff588bea70a403d0/lib/internal/worker.js#L415,
    // a worker is consist of two handles: kPublicPort and kHandle.
    {
      const kPublicPort = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kPublicPort")
      );
      if (kPublicPort) {
        worker[kPublicPort].ref = () => {};
      }

      const kHandle = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kHandle")
      );
      if (kHandle) {
        worker[kHandle].ref = () => {};
      }

      worker.unref();
    }
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;

//#endregion
//#region src/api/templates/wasi-worker-template.ts
const WASI_WORKER_TEMPLATE = `import fs from "node:fs";
import { createRequire } from "node:module";
import { parse } from "node:path";
import { WASI } from "node:wasi";
import { parentPort, Worker } from "node:worker_threads";

const require = createRequire(import.meta.url);

const { instantiateNapiModuleSync, MessageHandler, getDefaultContext } = require("@napi-rs/wasm-runtime");

if (parentPort) {
  parentPort.on("message", (data) => {
    globalThis.onmessage({ data });
  });
}

Object.assign(globalThis, {
  self: globalThis,
  require,
  Worker,
  importScripts: function (f) {
    ;(0, eval)(fs.readFileSync(f, "utf8") + "//# sourceURL=" + f);
  },
  postMessage: function (msg) {
    if (parentPort) {
      parentPort.postMessage(msg);
    }
  },
});

const emnapiContext = getDefaultContext();

const __rootDir = parse(process.cwd()).root;

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    const wasi = new WASI({
      version: 'preview1',
      env: process.env,
      preopens: {
        [__rootDir]: __rootDir,
      },
    });

    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      context: emnapiContext,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory
        };
      },
    });
  },
});

globalThis.onmessage = function (e) {
  handler.handle(e);
};
`;
const createWasiBrowserWorkerBinding = (fs$1) => {
	const fsImport = fs$1 ? `import { instantiateNapiModuleSync, MessageHandler, WASI, createFsProxy } from '@napi-rs/wasm-runtime'
import { memfsExported as __memfsExported } from '@napi-rs/wasm-runtime/fs'

const fs = createFsProxy(__memfsExported)` : `import { instantiateNapiModuleSync, MessageHandler, WASI } from '@napi-rs/wasm-runtime'`;
	const wasiCreation = fs$1 ? `const wasi = new WASI({
      fs,
      preopens: {
        '/': '/',
      },
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })` : `const wasi = new WASI({
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })`;
	return `${fsImport}

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    ${wasiCreation}
    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory,
        }
      },
    })
  },
})

globalThis.onmessage = function (e) {
  handler.handle(e)
}
`;
};

//#endregion
//#region src/api/build.ts
const debug$5 = debugFactory("build");
const require = createRequire(import.meta.url);
async function buildProject(rawOptions) {
	debug$5("napi build command receive options: %O", rawOptions);
	const options = {
		dtsCache: true,
		...rawOptions,
		cwd: rawOptions.cwd ?? process.cwd()
	};
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const manifestPath = resolvePath(options.manifestPath ?? "Cargo.toml");
	const metadata = await parseMetadata(manifestPath);
	const crate = metadata.packages.find((p) => {
		if (options.package) return p.name === options.package;
		else return p.manifest_path === manifestPath;
	});
	if (!crate) throw new Error("Unable to find crate to build. It seems you are trying to build a crate in a workspace, try using `--package` option to specify the package to build.");
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	const builder = new Builder(metadata, crate, config, options);
	return builder.build();
}
var Builder = class {
	args = [];
	envs = {};
	outputs = [];
	target;
	crateDir;
	outputDir;
	targetDir;
	enableTypeDef = false;
	constructor(metadata, crate, config, options) {
		this.metadata = metadata;
		this.crate = crate;
		this.config = config;
		this.options = options;
		this.target = options.target ? parseTriple(options.target) : process.env.CARGO_BUILD_TARGET ? parseTriple(process.env.CARGO_BUILD_TARGET) : getSystemDefaultTarget();
		this.crateDir = parse(crate.manifest_path).dir;
		this.outputDir = resolve(this.options.cwd, options.outputDir ?? this.crateDir);
		this.targetDir = options.targetDir ?? process.env.CARGO_BUILD_TARGET_DIR ?? metadata.target_directory;
		this.enableTypeDef = this.crate.dependencies.some((dep) => dep.name === "napi-derive" && (dep.uses_default_features || dep.features.includes("type-def")));
		if (!this.enableTypeDef) {
			const requirementWarning = "`napi-derive` crate is not used or `type-def` feature is not enabled for `napi-derive` crate";
			debug$5.warn(`${requirementWarning}. Will skip binding generation for \`.node\`, \`.wasi\` and \`.d.ts\` files.`);
			if (this.options.dts || this.options.dtsHeader || this.config.dtsHeader || this.config.dtsHeaderFile) debug$5.warn(`${requirementWarning}. \`dts\` related options are enabled but will be ignored.`);
		}
	}
	get cdyLibName() {
		return this.crate.targets.find((t) => t.crate_types.includes("cdylib"))?.name;
	}
	get binName() {
		return this.options.bin ?? (this.cdyLibName ? null : this.crate.targets.find((t) => t.crate_types.includes("bin"))?.name);
	}
	build() {
		if (!this.cdyLibName) {
			const warning = "Missing `crate-type = [\"cdylib\"]` in [lib] config. The build result will not be available as node addon.";
			if (this.binName) debug$5.warn(warning);
			else throw new Error(warning);
		}
		return this.pickBinary().setPackage().setFeatures().setTarget().pickCrossToolchain().setEnvs().setBypassArgs().exec();
	}
	pickCrossToolchain() {
		if (!this.options.useNapiCross) return this;
		if (this.options.useCross) debug$5.warn("You are trying to use both `--cross` and `--use-napi-cross` options, `--use-cross` will be ignored.");
		if (this.options.crossCompile) debug$5.warn("You are trying to use both `--cross-compile` and `--use-napi-cross` options, `--cross-compile` will be ignored.");
		try {
			const { version: version$2, download } = require("@napi-rs/cross-toolchain");
			const alias = { "s390x-unknown-linux-gnu": "s390x-ibm-linux-gnu" };
			const toolchainPath = join(homedir(), ".napi-rs", "cross-toolchain", version$2, this.target.triple);
			mkdirSync(toolchainPath, { recursive: true });
			if (existsSync(join(toolchainPath, "package.json"))) debug$5(`Toolchain ${toolchainPath} exists, skip extracting`);
			else {
				const tarArchive = download(process.arch, this.target.triple);
				tarArchive.unpack(toolchainPath);
			}
			const upperCaseTarget = targetToEnvVar(this.target.triple);
			const crossTargetName = alias[this.target.triple] ?? this.target.triple;
			const linkerEnv = `CARGO_TARGET_${upperCaseTarget}_LINKER`;
			this.envs[linkerEnv] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_SYSROOT) this.envs[`TARGET_SYSROOT`] = join(toolchainPath, crossTargetName, "sysroot");
			if (!process.env.TARGET_AR) this.envs[`TARGET_AR`] = join(toolchainPath, "bin", `${crossTargetName}-ar`);
			if (!process.env.TARGET_RANLIB) this.envs[`TARGET_RANLIB`] = join(toolchainPath, "bin", `${crossTargetName}-ranlib`);
			if (!process.env.TARGET_READELF) this.envs[`TARGET_READELF`] = join(toolchainPath, "bin", `${crossTargetName}-readelf`);
			if (!process.env.TARGET_C_INCLUDE_PATH) this.envs[`TARGET_C_INCLUDE_PATH`] = join(toolchainPath, crossTargetName, "sysroot", "usr", "include/");
			if (!process.env.TARGET_CC) this.envs[`TARGET_CC`] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_CXX) this.envs[`TARGET_CXX`] = join(toolchainPath, "bin", `${crossTargetName}-g++`);
			if (process.env.TARGET_CC?.startsWith("clang") || process.env.CC?.startsWith("clang") && !process.env.TARGET_CC) {
				const TARGET_CFLAGS = process.env.TARGET_CFLAGS ?? "";
				this.envs.TARGET_CFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CFLAGS}`;
			}
			if (process.env.CXX?.startsWith("clang++") && !process.env.TARGET_CXX || process.env.TARGET_CXX?.startsWith("clang++")) {
				const TARGET_CXXFLAGS = process.env.TARGET_CXXFLAGS ?? "";
				this.envs.TARGET_CXXFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CXXFLAGS}`;
			}
			this.envs.PATH = this.envs.PATH ? `${toolchainPath}/bin:${this.envs.PATH}:${process.env.PATH}` : `${toolchainPath}/bin:${process.env.PATH}`;
		} catch (e) {
			debug$5.warn("Pick cross toolchain failed", e);
		}
		return this;
	}
	exec() {
		debug$5(`Start building crate: ${this.crate.name}`);
		debug$5("  %i", `cargo ${this.args.join(" ")}`);
		const controller = new AbortController();
		const watch = this.options.watch;
		const buildTask = new Promise((resolve$1, reject) => {
			if (this.options.useCross && this.options.crossCompile) throw new Error("`--use-cross` and `--cross-compile` can not be used together");
			const command = process.env.CARGO ?? (this.options.useCross ? "cross" : "cargo");
			const buildProcess = spawn(command, this.args, {
				env: {
					...process.env,
					...this.envs
				},
				stdio: watch ? [
					"inherit",
					"inherit",
					"pipe"
				] : "inherit",
				cwd: this.options.cwd,
				signal: controller.signal
			});
			buildProcess.once("exit", (code) => {
				if (code === 0) {
					debug$5("%i", `Build crate ${this.crate.name} successfully!`);
					resolve$1();
				} else reject(/* @__PURE__ */ new Error(`Build failed with exit code ${code}`));
			});
			buildProcess.once("error", (e) => {
				reject(new Error(`Build failed with error: ${e.message}`, { cause: e }));
			});
			buildProcess.stderr?.on("data", (data) => {
				const output = data.toString();
				console.error(output);
				if (/Finished\s(`dev`|`release`)/.test(output)) this.postBuild().catch(() => {});
			});
		});
		return {
			task: buildTask.then(() => this.postBuild()),
			abort: () => controller.abort()
		};
	}
	pickBinary() {
		let set = false;
		if (this.options.watch) if (process.env.CI) debug$5.warn("Watch mode is not supported in CI environment");
		else {
			debug$5("Use %i", "cargo-watch");
			tryInstallCargoBinary("cargo-watch", "watch");
			this.args.push("watch", "--why", "-i", "*.{js,ts,node}", "-w", this.crateDir, "--", "cargo", "build");
			set = true;
		}
		if (this.options.crossCompile) if (this.target.platform === "win32") if (process.platform === "win32") debug$5.warn("You are trying to cross compile to win32 platform on win32 platform which is unnecessary.");
		else {
			debug$5("Use %i", "cargo-xwin");
			tryInstallCargoBinary("cargo-xwin", "xwin");
			this.args.push("xwin", "build");
			if (this.target.arch === "ia32") this.envs.XWIN_ARCH = "x86";
			set = true;
		}
		else if (this.target.platform === "linux" && process.platform === "linux" && this.target.arch === process.arch && function(abi) {
			const glibcVersionRuntime = process.report?.getReport()?.header?.glibcVersionRuntime;
			const libc = glibcVersionRuntime ? "gnu" : "musl";
			return abi === libc;
		}(this.target.abi)) debug$5.warn("You are trying to cross compile to linux target on linux platform which is unnecessary.");
		else if (this.target.platform === "darwin" && process.platform === "darwin") debug$5.warn("You are trying to cross compile to darwin target on darwin platform which is unnecessary.");
		else {
			debug$5("Use %i", "cargo-zigbuild");
			tryInstallCargoBinary("cargo-zigbuild", "zigbuild");
			this.args.push("zigbuild");
			set = true;
		}
		if (!set) this.args.push("build");
		return this;
	}
	setPackage() {
		const args = [];
		if (this.options.package) args.push("--package", this.options.package);
		if (this.binName) args.push("--bin", this.binName);
		if (args.length) {
			debug$5("Set package flags: ");
			debug$5("  %O", args);
			this.args.push(...args);
		}
		return this;
	}
	setTarget() {
		debug$5("Set compiling target to: ");
		debug$5("  %i", this.target.triple);
		this.args.push("--target", this.target.triple);
		return this;
	}
	setEnvs() {
		if (this.enableTypeDef) {
			this.envs.NAPI_TYPE_DEF_TMP_FOLDER = this.generateIntermediateTypeDefFolder();
			this.setForceBuildEnvs(this.envs.NAPI_TYPE_DEF_TMP_FOLDER);
		}
		let rustflags = process.env.RUSTFLAGS ?? process.env.CARGO_BUILD_RUSTFLAGS ?? "";
		if (this.target.abi?.includes("musl") && !rustflags.includes("target-feature=-crt-static")) rustflags += " -C target-feature=-crt-static";
		if (this.options.strip && !rustflags.includes("link-arg=-s")) rustflags += " -C link-arg=-s";
		if (rustflags.length) this.envs.RUSTFLAGS = rustflags;
		const linker = this.options.crossCompile ? void 0 : getTargetLinker(this.target.triple);
		const linkerEnv = `CARGO_TARGET_${targetToEnvVar(this.target.triple)}_LINKER`;
		if (linker && !process.env[linkerEnv] && !this.envs[linkerEnv]) this.envs[linkerEnv] = linker;
		if (this.target.platform === "android") this.setAndroidEnv();
		if (this.target.platform === "wasi") this.setWasiEnv();
		if (this.target.platform === "openharmony") this.setOpenHarmonyEnv();
		debug$5("Set envs: ");
		Object.entries(this.envs).forEach(([k, v]) => {
			debug$5("  %i", `${k}=${v}`);
		});
		return this;
	}
	setForceBuildEnvs(typeDefTmpFolder) {
		this.metadata.packages.forEach((crate) => {
			if (crate.dependencies.some((d) => d.name === "napi-derive") && !existsSync(join(typeDefTmpFolder, crate.name))) this.envs[`NAPI_FORCE_BUILD_${crate.name.replace(/-/g, "_").toUpperCase()}`] = Date.now().toString();
		});
	}
	setAndroidEnv() {
		const { ANDROID_NDK_LATEST_HOME } = process.env;
		if (!ANDROID_NDK_LATEST_HOME) debug$5.warn(`${colors.red("ANDROID_NDK_LATEST_HOME")} environment variable is missing`);
		if (process.platform === "android") return;
		const targetArch = this.target.arch === "arm" ? "armv7a" : "aarch64";
		const targetPlatform = this.target.arch === "arm" ? "androideabi24" : "android24";
		const hostPlatform = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "windows" : "linux";
		Object.assign(this.envs, {
			CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-android24-clang`,
			CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-androideabi24-clang`,
			TARGET_CC: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang`,
			TARGET_CXX: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang++`,
			TARGET_AR: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ar`,
			TARGET_RANLIB: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ranlib`,
			ANDROID_NDK: ANDROID_NDK_LATEST_HOME,
			PATH: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`
		});
	}
	setWasiEnv() {
		const emnapi = join(require.resolve("emnapi"), "..", "lib", "wasm32-wasi-threads");
		this.envs.EMNAPI_LINK_DIR = emnapi;
		const { WASI_SDK_PATH } = process.env;
		if (WASI_SDK_PATH && existsSync(WASI_SDK_PATH)) {
			this.envs.CARGO_TARGET_WASM32_WASI_PREVIEW1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP2_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.setEnvIfNotExists("TARGET_CC", join(WASI_SDK_PATH, "bin", "clang"));
			this.setEnvIfNotExists("TARGET_CXX", join(WASI_SDK_PATH, "bin", "clang++"));
			this.setEnvIfNotExists("TARGET_AR", join(WASI_SDK_PATH, "bin", "ar"));
			this.setEnvIfNotExists("TARGET_RANLIB", join(WASI_SDK_PATH, "bin", "ranlib"));
			this.setEnvIfNotExists("TARGET_CFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists("TARGET_CXXFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists(`TARGET_LDFLAGS`, `-fuse-ld=${WASI_SDK_PATH}/bin/wasm-ld --target=wasm32-wasi-threads`);
		}
	}
	setOpenHarmonyEnv() {
		const { OHOS_SDK_PATH, OHOS_SDK_NATIVE } = process.env;
		const ndkPath = OHOS_SDK_PATH ? `${OHOS_SDK_NATIVE}/native` : OHOS_SDK_NATIVE;
		if (!ndkPath && process.platform !== "openharmony") {
			debug$5.warn(`${colors.red("OHOS_SDK_PATH")} or ${colors.red("OHOS_SDK_NATIVE")} environment variable is missing`);
			return;
		}
		const linkerName = `CARGO_TARGET_${this.target.triple.toUpperCase().replace(/-/g, "_")}_LINKER`;
		const ranPath = `${ndkPath}/llvm/bin/llvm-ranlib`;
		const arPath = `${ndkPath}/llvm/bin/llvm-ar`;
		const ccPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang`;
		const cxxPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang++`;
		const asPath = `${ndkPath}/llvm/bin/llvm-as`;
		const ldPath = `${ndkPath}/llvm/bin/ld.lld`;
		const stripPath = `${ndkPath}/llvm/bin/llvm-strip`;
		const objDumpPath = `${ndkPath}/llvm/bin/llvm-objdump`;
		const objCopyPath = `${ndkPath}/llvm/bin/llvm-objcopy`;
		const nmPath = `${ndkPath}/llvm/bin/llvm-nm`;
		const binPath = `${ndkPath}/llvm/bin`;
		const libPath = `${ndkPath}/llvm/lib`;
		this.setEnvIfNotExists("LIBCLANG_PATH", libPath);
		this.setEnvIfNotExists("DEP_ATOMIC", "clang_rt.builtins");
		this.setEnvIfNotExists(linkerName, ccPath);
		this.setEnvIfNotExists("TARGET_CC", ccPath);
		this.setEnvIfNotExists("TARGET_CXX", cxxPath);
		this.setEnvIfNotExists("TARGET_AR", arPath);
		this.setEnvIfNotExists("TARGET_RANLIB", ranPath);
		this.setEnvIfNotExists("TARGET_AS", asPath);
		this.setEnvIfNotExists("TARGET_LD", ldPath);
		this.setEnvIfNotExists("TARGET_STRIP", stripPath);
		this.setEnvIfNotExists("TARGET_OBJDUMP", objDumpPath);
		this.setEnvIfNotExists("TARGET_OBJCOPY", objCopyPath);
		this.setEnvIfNotExists("TARGET_NM", nmPath);
		this.envs.PATH = `${binPath}${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`;
	}
	setFeatures() {
		const args = [];
		if (this.options.allFeatures && this.options.noDefaultFeatures) throw new Error("Cannot specify --all-features and --no-default-features together");
		if (this.options.allFeatures) args.push("--all-features");
		else if (this.options.noDefaultFeatures) args.push("--no-default-features");
		if (this.options.features) args.push("--features", ...this.options.features);
		debug$5("Set features flags: ");
		debug$5("  %O", args);
		this.args.push(...args);
		return this;
	}
	setBypassArgs() {
		if (this.options.release) this.args.push("--release");
		if (this.options.verbose) this.args.push("--verbose");
		if (this.options.targetDir) this.args.push("--target-dir", this.options.targetDir);
		if (this.options.profile) this.args.push("--profile", this.options.profile);
		if (this.options.manifestPath) this.args.push("--manifest-path", this.options.manifestPath);
		if (this.options.cargoOptions?.length) this.args.push(...this.options.cargoOptions);
		return this;
	}
	generateIntermediateTypeDefFolder() {
		let folder = join(this.targetDir, "napi-rs", `${this.crate.name}-${createHash("sha256").update(this.crate.manifest_path).update(CLI_VERSION).digest("hex").substring(0, 8)}`);
		if (!this.options.dtsCache) {
			rmSync(folder, {
				recursive: true,
				force: true
			});
			folder += `_${Date.now()}`;
		}
		mkdirAsync(folder, { recursive: true });
		return folder;
	}
	async postBuild() {
		try {
			debug$5(`Try to create output directory:`);
			debug$5("  %i", this.outputDir);
			await mkdirAsync(this.outputDir, { recursive: true });
			debug$5(`Output directory created`);
		} catch (e) {
			throw new Error(`Failed to create output directory ${this.outputDir}`, { cause: e });
		}
		const wasmBinaryName = await this.copyArtifact();
		if (this.cdyLibName) {
			const idents = await this.generateTypeDef();
			const jsOutput = await this.writeJsBinding(idents);
			const wasmBindingsOutput = await this.writeWasiBinding(wasmBinaryName, idents);
			if (jsOutput) this.outputs.push(jsOutput);
			if (wasmBindingsOutput) this.outputs.push(...wasmBindingsOutput);
		}
		return this.outputs;
	}
	async copyArtifact() {
		const [srcName, destName, wasmBinaryName] = this.getArtifactNames();
		if (!srcName || !destName) return;
		const profile = this.options.profile ?? (this.options.release ? "release" : "debug");
		const src = join(this.targetDir, this.target.triple, profile, srcName);
		debug$5(`Copy artifact from: [${src}]`);
		const dest = join(this.outputDir, destName);
		const isWasm = dest.endsWith(".wasm");
		try {
			if (await fileExists(dest)) {
				debug$5("Old artifact found, remove it first");
				await unlinkAsync(dest);
			}
			debug$5("Copy artifact to:");
			debug$5("  %i", dest);
			if (isWasm) {
				const { ModuleConfig } = await import("@napi-rs/wasm-tools");
				debug$5("Generate debug wasm module");
				try {
					const debugWasmModule = new ModuleConfig().generateDwarf(true).generateNameSection(true).generateProducersSection(true).preserveCodeTransform(true).strictValidate(false).parse(await readFileAsync(src));
					const debugWasmBinary = debugWasmModule.emitWasm(true);
					await writeFileAsync(dest.replace(/\.wasm$/, ".debug.wasm"), debugWasmBinary);
					debug$5("Generate release wasm module");
					const releaseWasmModule = new ModuleConfig().generateDwarf(false).generateNameSection(false).generateProducersSection(false).preserveCodeTransform(false).strictValidate(false).onlyStableFeatures(false).parse(debugWasmBinary);
					const releaseWasmBinary = releaseWasmModule.emitWasm(false);
					await writeFileAsync(dest, releaseWasmBinary);
				} catch (e) {
					debug$5.warn(`Failed to generate debug wasm module: ${e.message ?? e}`);
					await copyFileAsync(src, dest);
				}
			} else await copyFileAsync(src, dest);
			this.outputs.push({
				kind: dest.endsWith(".node") ? "node" : isWasm ? "wasm" : "exe",
				path: dest
			});
			return wasmBinaryName ? join(this.outputDir, wasmBinaryName) : null;
		} catch (e) {
			throw new Error("Failed to copy artifact", { cause: e });
		}
	}
	getArtifactNames() {
		if (this.cdyLibName) {
			const cdyLib = this.cdyLibName.replace(/-/g, "_");
			const wasiTarget = this.config.targets.find((t) => t.platform === "wasi");
			const srcName = this.target.platform === "darwin" ? `lib${cdyLib}.dylib` : this.target.platform === "win32" ? `${cdyLib}.dll` : this.target.platform === "wasi" || this.target.platform === "wasm" ? `${cdyLib}.wasm` : `lib${cdyLib}.so`;
			let destName = this.config.binaryName;
			if (this.options.platform) destName += `.${this.target.platformArchABI}`;
			if (srcName.endsWith(".wasm")) destName += ".wasm";
			else destName += ".node";
			return [
				srcName,
				destName,
				wasiTarget ? `${this.config.binaryName}.${wasiTarget.platformArchABI}.wasm` : null
			];
		} else if (this.binName) {
			const srcName = this.target.platform === "win32" ? `${this.binName}.exe` : this.binName;
			return [srcName, srcName];
		}
		return [];
	}
	async generateTypeDef() {
		const typeDefDir = this.envs.NAPI_TYPE_DEF_TMP_FOLDER;
		if (!this.enableTypeDef || !await dirExistsAsync(typeDefDir)) return [];
		const dest = join(this.outputDir, this.options.dts ?? "index.d.ts");
		let header = "";
		let dts = "";
		let exports$1 = [];
		if (!this.options.noDtsHeader) {
			const dtsHeader = this.options.dtsHeader ?? this.config.dtsHeader;
			if (this.config.dtsHeaderFile) try {
				header = await readFileAsync(join(this.options.cwd, this.config.dtsHeaderFile), "utf-8");
			} catch (e) {
				debug$5.warn(`Failed to read dts header file ${this.config.dtsHeaderFile}`, e);
			}
			else if (dtsHeader) header = dtsHeader;
			else header = DEFAULT_TYPE_DEF_HEADER;
		}
		const files$1 = await readdirAsync(typeDefDir, { withFileTypes: true });
		if (!files$1.length) {
			debug$5("No type def files found. Skip generating dts file.");
			return [];
		}
		for (const file of files$1) {
			if (!file.isFile()) continue;
			const { dts: fileDts, exports: fileExports } = await processTypeDef(join(typeDefDir, file.name), this.options.constEnum ?? this.config.constEnum ?? true);
			dts += fileDts;
			exports$1.push(...fileExports);
		}
		if (dts.indexOf("ExternalObject<") > -1) header += `
export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`;
		if (dts.indexOf("TypedArray") > -1) header += `
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array
`;
		dts = header + dts;
		try {
			debug$5("Writing type def to:");
			debug$5("  %i", dest);
			await writeFileAsync(dest, dts, "utf-8");
			this.outputs.push({
				kind: "dts",
				path: dest
			});
		} catch (e) {
			debug$5.error("Failed to write type def file");
			debug$5.error(e);
		}
		return exports$1;
	}
	async writeJsBinding(idents) {
		if (!this.options.platform || this.options.noJsBinding || idents.length === 0) return;
		const name$1 = this.options.jsBinding ?? "index.js";
		const createBinding = this.options.esm ? createEsmBinding : createCjsBinding;
		const binding = createBinding(this.config.binaryName, this.config.packageName, idents);
		try {
			const dest = join(this.outputDir, name$1);
			debug$5("Writing js binding to:");
			debug$5("  %i", dest);
			await writeFileAsync(dest, binding, "utf-8");
			return {
				kind: "js",
				path: dest
			};
		} catch (e) {
			throw new Error("Failed to write js binding file", { cause: e });
		}
	}
	async writeWasiBinding(distFileName, idents) {
		if (distFileName) {
			const { name: name$1, dir } = parse(distFileName);
			const bindingPath = join(dir, `${this.config.binaryName}.wasi.cjs`);
			const browserBindingPath = join(dir, `${this.config.binaryName}.wasi-browser.js`);
			const workerPath = join(dir, "wasi-worker.mjs");
			const browserWorkerPath = join(dir, "wasi-worker-browser.mjs");
			const browserEntryPath = join(dir, "browser.js");
			const exportsCode = `module.exports = __napiModule.exports\n` + idents.map((ident) => `module.exports.${ident} = __napiModule.exports.${ident}`).join("\n");
			await writeFileAsync(bindingPath, createWasiBinding(name$1, this.config.packageName, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory) + exportsCode + "\n", "utf8");
			await writeFileAsync(browserBindingPath, createWasiBrowserBinding(name$1, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory, this.config.wasm?.browser?.fs, this.config.wasm?.browser?.asyncInit, this.config.wasm?.browser?.buffer) + `export default __napiModule.exports\n` + idents.map((ident) => `export const ${ident} = __napiModule.exports.${ident}`).join("\n") + "\n", "utf8");
			await writeFileAsync(workerPath, WASI_WORKER_TEMPLATE, "utf8");
			await writeFileAsync(browserWorkerPath, createWasiBrowserWorkerBinding(this.config.wasm?.browser?.fs ?? false), "utf8");
			await writeFileAsync(browserEntryPath, `export * from '${this.config.packageName}-wasm32-wasi'\n`);
			return [
				{
					kind: "js",
					path: bindingPath
				},
				{
					kind: "js",
					path: browserBindingPath
				},
				{
					kind: "js",
					path: workerPath
				},
				{
					kind: "js",
					path: browserWorkerPath
				},
				{
					kind: "js",
					path: browserEntryPath
				}
			];
		}
		return [];
	}
	setEnvIfNotExists(env, value$1) {
		if (!process.env[env]) this.envs[env] = value$1;
	}
};

//#endregion
//#region src/def/create-npm-dirs.ts
var BaseCreateNpmDirsCommand = class extends Command {
	static paths = [["create-npm-dirs"]];
	static usage = Command.Usage({ description: "Create npm package dirs for different platforms" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultCreateNpmDirsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/api/create-npm-dirs.ts
const debug$4 = debugFactory("create-npm-dirs");
async function createNpmDirs(userOptions) {
	const options = applyDefaultCreateNpmDirsOptions(userOptions);
	async function mkdirAsync$1(dir) {
		debug$4("Try to create dir: %i", dir);
		if (options.dryRun) return;
		await mkdirAsync(dir, { recursive: true });
	}
	async function writeFileAsync$1(file, content) {
		debug$4("Writing file %i", file);
		if (options.dryRun) {
			debug$4(content);
			return;
		}
		await writeFileAsync(file, content);
	}
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const npmPath = resolve(options.cwd, options.npmDir);
	debug$4(`Read content from [${options.configPath ?? packageJsonPath}]`);
	const { targets, binaryName, packageName, packageJson } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of targets) {
		const targetDir = join(npmPath, `${target.platformArchABI}`);
		await mkdirAsync$1(targetDir);
		const binaryFileName = target.arch === "wasm32" ? `${binaryName}.${target.platformArchABI}.wasm` : `${binaryName}.${target.platformArchABI}.node`;
		const scopedPackageJson = {
			name: `${packageName}-${target.platformArchABI}`,
			version: packageJson.version,
			cpu: target.arch !== "universal" ? [target.arch] : void 0,
			main: binaryFileName,
			files: [binaryFileName],
			...pick$1(packageJson, "description", "keywords", "author", "authors", "homepage", "license", "engines", "repository", "bugs")
		};
		if (packageJson.publishConfig) scopedPackageJson.publishConfig = pick$1(packageJson.publishConfig, "registry", "access");
		if (target.arch !== "wasm32") scopedPackageJson.os = [target.platform];
		else {
			const entry = `${binaryName}.wasi.cjs`;
			scopedPackageJson.main = entry;
			scopedPackageJson.browser = `${binaryName}.wasi-browser.js`;
			scopedPackageJson.files?.push(entry, scopedPackageJson.browser, `wasi-worker.mjs`, `wasi-worker-browser.mjs`);
			let needRestrictNodeVersion = true;
			if (scopedPackageJson.engines?.node) try {
				const { major } = parse$1(scopedPackageJson.engines.node) ?? { major: 0 };
				if (major >= 14) needRestrictNodeVersion = false;
			} catch {}
			if (needRestrictNodeVersion) scopedPackageJson.engines = { node: ">=14.0.0" };
			const wasmRuntime = await fetch(`https://registry.npmjs.org/@napi-rs/wasm-runtime`).then((res) => res.json());
			scopedPackageJson.dependencies = { "@napi-rs/wasm-runtime": `^${wasmRuntime["dist-tags"].latest}` };
		}
		if (target.abi === "gnu") scopedPackageJson.libc = ["glibc"];
		else if (target.abi === "musl") scopedPackageJson.libc = ["musl"];
		const targetPackageJson = join(targetDir, "package.json");
		await writeFileAsync$1(targetPackageJson, JSON.stringify(scopedPackageJson, null, 2) + "\n");
		const targetReadme = join(targetDir, "README.md");
		await writeFileAsync$1(targetReadme, readme(packageName, target));
		debug$4.info(`${packageName} -${target.platformArchABI} created`);
	}
}
function readme(packageName, target) {
	return `# \`${packageName}-${target.platformArchABI}\`

This is the **${target.triple}** binary for \`${packageName}\`
`;
}

//#endregion
//#region src/def/new.ts
var BaseNewCommand = class extends Command {
	static paths = [["new"]];
	static usage = Command.Usage({ description: "Create a new project with pre-configured boilerplate" });
	$$path = Option.String({ required: false });
	$$name = Option.String("--name,-n", { description: "The name of the project, default to the name of the directory if not provided" });
	minNodeApiVersion = Option.String("--min-node-api,-v", "4", {
		validator: typanion.isNumber(),
		description: "The minimum Node-API version to support"
	});
	packageManager = Option.String("--package-manager", "yarn", { description: "The package manager to use. Only support yarn 4.x for now." });
	license = Option.String("--license,-l", "MIT", { description: "License for open-sourced project" });
	targets = Option.Array("--targets,-t", [], { description: "All targets the crate will be compiled for." });
	enableDefaultTargets = Option.Boolean("--enable-default-targets", true, { description: "Whether enable default targets" });
	enableAllTargets = Option.Boolean("--enable-all-targets", false, { description: "Whether enable all targets" });
	enableTypeDef = Option.Boolean("--enable-type-def", true, { description: "Whether enable the `type-def` feature for typescript definitions auto-generation" });
	enableGithubActions = Option.Boolean("--enable-github-actions", true, { description: "Whether generate preconfigured GitHub Actions workflow" });
	testFramework = Option.String("--test-framework", "ava", { description: "The JavaScript test framework to use, only support `ava` for now" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Whether to run the command in dry-run mode" });
	getOptions() {
		return {
			path: this.$$path,
			name: this.$$name,
			minNodeApiVersion: this.minNodeApiVersion,
			packageManager: this.packageManager,
			license: this.license,
			targets: this.targets,
			enableDefaultTargets: this.enableDefaultTargets,
			enableAllTargets: this.enableAllTargets,
			enableTypeDef: this.enableTypeDef,
			enableGithubActions: this.enableGithubActions,
			testFramework: this.testFramework,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultNewOptions(options) {
	return {
		minNodeApiVersion: 4,
		packageManager: "yarn",
		license: "MIT",
		targets: [],
		enableDefaultTargets: true,
		enableAllTargets: false,
		enableTypeDef: true,
		enableGithubActions: true,
		testFramework: "ava",
		dryRun: false,
		...options
	};
}

//#endregion
//#region ../node_modules/@std/toml/stringify.js
function joinKeys(keys) {
	return keys.map((str) => {
		return str.length === 0 || str.match(/[^A-Za-z0-9_-]/) ? JSON.stringify(str) : str;
	}).join(".");
}
var Dumper = class {
	maxPad = 0;
	srcObject;
	output = [];
	#arrayTypeCache = /* @__PURE__ */ new Map();
	constructor(srcObjc) {
		this.srcObject = srcObjc;
	}
	dump(fmtOptions = {}) {
		this.output = this.#printObject(this.srcObject);
		this.output = this.#format(fmtOptions);
		return this.output;
	}
	#printObject(obj, keys = []) {
		const out = [];
		const props = Object.keys(obj);
		const inlineProps = [];
		const multilineProps = [];
		for (const prop of props) if (this.#isSimplySerializable(obj[prop])) inlineProps.push(prop);
		else multilineProps.push(prop);
		const sortedProps = inlineProps.concat(multilineProps);
		for (const prop of sortedProps) {
			const value$1 = obj[prop];
			if (value$1 instanceof Date) out.push(this.#dateDeclaration([prop], value$1));
			else if (typeof value$1 === "string" || value$1 instanceof RegExp) out.push(this.#strDeclaration([prop], value$1.toString()));
			else if (typeof value$1 === "number") out.push(this.#numberDeclaration([prop], value$1));
			else if (typeof value$1 === "boolean") out.push(this.#boolDeclaration([prop], value$1));
			else if (value$1 instanceof Array) {
				const arrayType = this.#getTypeOfArray(value$1);
				if (arrayType === "ONLY_PRIMITIVE") out.push(this.#arrayDeclaration([prop], value$1));
				else if (arrayType === "ONLY_OBJECT_EXCLUDING_ARRAY") for (let i = 0; i < value$1.length; i++) {
					out.push("");
					out.push(this.#headerGroup([...keys, prop]));
					out.push(...this.#printObject(value$1[i], [...keys, prop]));
				}
				else {
					const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
					out.push(`${this.#declaration([prop])}[${str}]`);
				}
			} else if (typeof value$1 === "object") {
				out.push("");
				out.push(this.#header([...keys, prop]));
				if (value$1) {
					const toParse = value$1;
					out.push(...this.#printObject(toParse, [...keys, prop]));
				}
			}
		}
		out.push("");
		return out;
	}
	#isPrimitive(value$1) {
		return value$1 instanceof Date || value$1 instanceof RegExp || [
			"string",
			"number",
			"boolean"
		].includes(typeof value$1);
	}
	#getTypeOfArray(arr) {
		if (this.#arrayTypeCache.has(arr)) return this.#arrayTypeCache.get(arr);
		const type$1 = this.#doGetTypeOfArray(arr);
		this.#arrayTypeCache.set(arr, type$1);
		return type$1;
	}
	#doGetTypeOfArray(arr) {
		if (!arr.length) return "ONLY_PRIMITIVE";
		const onlyPrimitive = this.#isPrimitive(arr[0]);
		if (arr[0] instanceof Array) return "MIXED";
		for (let i = 1; i < arr.length; i++) if (onlyPrimitive !== this.#isPrimitive(arr[i]) || arr[i] instanceof Array) return "MIXED";
		return onlyPrimitive ? "ONLY_PRIMITIVE" : "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#printAsInlineValue(value$1) {
		if (value$1 instanceof Date) return `"${this.#printDate(value$1)}"`;
		else if (typeof value$1 === "string" || value$1 instanceof RegExp) return JSON.stringify(value$1.toString());
		else if (typeof value$1 === "number") return value$1;
		else if (typeof value$1 === "boolean") return value$1.toString();
		else if (value$1 instanceof Array) {
			const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
			return `[${str}]`;
		} else if (typeof value$1 === "object") {
			if (!value$1) throw new Error("Should never reach");
			const str = Object.keys(value$1).map((key) => {
				return `${joinKeys([key])} = ${this.#printAsInlineValue(value$1[key])}`;
			}).join(",");
			return `{${str}}`;
		}
		throw new Error("Should never reach");
	}
	#isSimplySerializable(value$1) {
		return typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || value$1 instanceof RegExp || value$1 instanceof Date || value$1 instanceof Array && this.#getTypeOfArray(value$1) !== "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#header(keys) {
		return `[${joinKeys(keys)}]`;
	}
	#headerGroup(keys) {
		return `[[${joinKeys(keys)}]]`;
	}
	#declaration(keys) {
		const title = joinKeys(keys);
		if (title.length > this.maxPad) this.maxPad = title.length;
		return `${title} = `;
	}
	#arrayDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#strDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#numberDeclaration(keys, value$1) {
		if (Number.isNaN(value$1)) return `${this.#declaration(keys)}nan`;
		switch (value$1) {
			case Infinity: return `${this.#declaration(keys)}inf`;
			case -Infinity: return `${this.#declaration(keys)}-inf`;
			default: return `${this.#declaration(keys)}${value$1}`;
		}
	}
	#boolDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${value$1}`;
	}
	#printDate(value$1) {
		function dtPad(v, lPad = 2) {
			return v.padStart(lPad, "0");
		}
		const m = dtPad((value$1.getUTCMonth() + 1).toString());
		const d = dtPad(value$1.getUTCDate().toString());
		const h = dtPad(value$1.getUTCHours().toString());
		const min = dtPad(value$1.getUTCMinutes().toString());
		const s = dtPad(value$1.getUTCSeconds().toString());
		const ms = dtPad(value$1.getUTCMilliseconds().toString(), 3);
		const fData = `${value$1.getUTCFullYear()}-${m}-${d}T${h}:${min}:${s}.${ms}`;
		return fData;
	}
	#dateDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${this.#printDate(value$1)}`;
	}
	#format(options = {}) {
		const { keyAlignment = false } = options;
		const rDeclaration = /^(\".*\"|[^=]*)\s=/;
		const out = [];
		for (let i = 0; i < this.output.length; i++) {
			const l = this.output[i];
			if (l[0] === "[" && l[1] !== "[") {
				if (this.output[i + 1] === "" && this.output[i + 2]?.slice(0, l.length) === l.slice(0, -1) + ".") {
					i += 1;
					continue;
				}
				out.push(l);
			} else if (keyAlignment) {
				const m = rDeclaration.exec(l);
				if (m && m[1]) out.push(l.replace(m[1], m[1].padEnd(this.maxPad)));
				else out.push(l);
			} else out.push(l);
		}
		const cleanedOutput = [];
		for (let i = 0; i < out.length; i++) {
			const l = out[i];
			if (!(l === "" && out[i + 1] === "")) cleanedOutput.push(l);
		}
		return cleanedOutput;
	}
};
/**
* Converts an object to a {@link https://toml.io | TOML} string.
*
* @example Usage
* ```ts
* import { stringify } from "@std/toml/stringify";
* import { assertEquals } from "@std/assert";
*
* const obj = {
*   title: "TOML Example",
*   owner: {
*     name: "Bob",
*     bio: "Bob is a cool guy",
*  }
* };
* const tomlString = stringify(obj);
* assertEquals(tomlString, `title = "TOML Example"\n\n[owner]\nname = "Bob"\nbio = "Bob is a cool guy"\n`);
* ```
* @param obj Source object
* @param options Options for stringifying.
* @returns TOML string
*/ function stringify(obj, options) {
	return new Dumper(obj).dump(options).join("\n");
}

//#endregion
//#region ../node_modules/@jsr/std__collections/_utils.js
/**
* Filters the given array, removing all elements that do not match the given predicate
* **in place. This means `array` will be modified!**.
*/ function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}

//#endregion
//#region ../node_modules/@jsr/std__collections/deep_merge.js
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, /* @__PURE__ */ new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys) {
		if (key === "__proto__") continue;
		const a = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a;
			continue;
		}
		const b = other[key];
		if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
			seen.add(a);
			seen.add(b);
			result[key] = mergeObjects(a, b, seen, options);
			continue;
		}
		result[key] = b;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
/**
* Test whether a value is mergeable or not
* Builtins that look like objects, null and user defined classes
* are not considered mergeable (it means that reference will be copied)
*/ function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}

//#endregion
//#region ../node_modules/@std/toml/_parser.js
/**
* Copy of `import { isLeap } from "@std/datetime";` because it cannot be impoted as long as it is unstable.
*/ function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
var Scanner = class {
	#whitespace = /[ \t]/;
	#position = 0;
	#source;
	constructor(source) {
		this.#source = source;
	}
	get position() {
		return this.#position;
	}
	get source() {
		return this.#source;
	}
	/**
	* Get current character
	* @param index - relative index from current position
	*/ char(index = 0) {
		return this.#source[this.#position + index] ?? "";
	}
	/**
	* Get sliced string
	* @param start - start position relative from current position
	* @param end - end position relative from current position
	*/ slice(start, end) {
		return this.#source.slice(this.#position + start, this.#position + end);
	}
	/**
	* Move position to next
	*/ next(count = 1) {
		this.#position += count;
	}
	skipWhitespaces() {
		while (this.#whitespace.test(this.char()) && !this.eof()) this.next();
		if (!this.isCurrentCharEOL() && /\s/.test(this.char())) {
			const escaped = "\\u" + this.char().charCodeAt(0).toString(16);
			const position = this.#position;
			throw new SyntaxError(`Cannot parse the TOML: It contains invalid whitespace at position '${position}': \`${escaped}\``);
		}
	}
	nextUntilChar(options = { skipComments: true }) {
		while (!this.eof()) {
			const char = this.char();
			if (this.#whitespace.test(char) || this.isCurrentCharEOL()) this.next();
			else if (options.skipComments && this.char() === "#") while (!this.isCurrentCharEOL() && !this.eof()) this.next();
			else break;
		}
	}
	/**
	* Position reached EOF or not
	*/ eof() {
		return this.#position >= this.#source.length;
	}
	isCurrentCharEOL() {
		return this.char() === "\n" || this.startsWith("\r\n");
	}
	startsWith(searchString) {
		return this.#source.startsWith(searchString, this.#position);
	}
	match(regExp) {
		if (!regExp.sticky) throw new Error(`RegExp ${regExp} does not have a sticky 'y' flag`);
		regExp.lastIndex = this.#position;
		return this.#source.match(regExp);
	}
};
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
/**
* Creates a nested object from the keys and values.
*
* e.g. `unflat(["a", "b", "c"], 1)` returns `{ a: { b: { c: 1 } } }`
*/ function unflat(keys, values = {}) {
	return keys.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function isObject(value$1) {
	return typeof value$1 === "object" && value$1 !== null;
}
function getTargetValue(target, keys) {
	const key = keys[0];
	if (!key) throw new Error("Cannot parse the TOML: key length is not a positive number");
	return target[key];
}
function deepAssignTable(target, table$1) {
	const { keys, type: type$1, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, value$1));
	if (Array.isArray(currentValue)) {
		const last = currentValue.at(-1);
		deepAssign(last, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssignTableArray(target, table$1) {
	const { type: type$1, keys, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, [value$1]));
	if (Array.isArray(currentValue)) {
		currentValue.push(value$1);
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssign(target, body) {
	switch (body.type) {
		case "Block": return deepMerge(target, body.value);
		case "Table": return deepAssignTable(target, body);
		case "TableArray": return deepAssignTableArray(target, body);
	}
}
function or(parsers) {
	return (scanner) => {
		for (const parse$3 of parsers) {
			const result = parse$3(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
/** Join the parse results of the given parser into an array.
*
* If the parser fails at the first attempt, it will return an empty array.
*/ function join$1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
/** Join the parse results of the given parser into an array.
*
* This requires the parser to succeed at least once.
*/ function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		const sep = Separator(scanner);
		if (!sep.ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function merge$1(parser) {
	return (scanner) => {
		const result = parser(scanner);
		if (!result.ok) return failure();
		let body = {};
		for (const record of result.body) if (typeof record === "object" && record !== null) body = deepMerge(body, record);
		return success(body);
	};
}
function repeat(parser) {
	return (scanner) => {
		const body = [];
		while (!scanner.eof()) {
			const result = parser(scanner);
			if (!result.ok) break;
			body.push(result.body);
			scanner.nextUntilChar();
		}
		if (body.length === 0) return failure();
		return success(body);
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str)) return failure();
		scanner.next(str.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	scanner.skipWhitespaces();
	const key = scanner.match(BARE_KEY_REGEXP)?.[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = string === "true";
	return success(value$1);
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = INFINITY_MAP.get(string);
	return success(value$1);
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = NaN;
	return success(value$1);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BINARY_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 2);
	return isNaN(number) ? failure() : success(number);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(OCTAL_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 8);
	return isNaN(number) ? failure() : success(number);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(HEX_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 16);
	return isNaN(number) ? failure() : success(number);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INTEGER_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const int = parseInt(value$1, 10);
	return success(int);
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(FLOAT_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$1 = parseFloat(value$1);
	if (isNaN(float$1)) return failure();
	return success(float$1);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(LOCAL_TIME_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({});
	}
	const pairs = surround("{", join$1(pair, ","), "}")(scanner);
	if (!pairs.ok) return failure();
	let table$1 = {};
	for (const pair$1 of pairs.body) table$1 = deepMerge(table$1, pair$1);
	return success(table$1);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary,
	octal,
	hex,
	float,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
function block(scanner) {
	scanner.nextUntilChar();
	const result = merge$1(repeat(pair))(scanner);
	if (result.ok) return success({
		type: "Block",
		value: result.body
	});
	return failure();
}
const tableHeader = surround("[", dottedKey, "]");
function table(scanner) {
	scanner.nextUntilChar();
	const header = tableHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "Table",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
const tableArrayHeader = surround("[[", dottedKey, "]]");
function tableArray(scanner) {
	scanner.nextUntilChar();
	const header = tableArrayHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "TableArray",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
function toml(scanner) {
	const blocks = repeat(or([
		block,
		tableArray,
		table
	]))(scanner);
	if (!blocks.ok) return success({});
	const body = blocks.body.reduce(deepAssign, {});
	return success(body);
}
function createParseErrorMessage(scanner, message) {
	const string = scanner.source.slice(0, scanner.position);
	const lines = string.split("\n");
	const row = lines.length;
	const column = lines.at(-1)?.length ?? 0;
	return `Parse error on line ${row}, column ${column}: ${message}`;
}
function parserFactory(parser) {
	return (tomlString) => {
		const scanner = new Scanner(tomlString);
		try {
			const result = parser(scanner);
			if (result.ok && scanner.eof()) return result.body;
			const message = `Unexpected character: "${scanner.char()}"`;
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		} catch (error) {
			if (error instanceof Error) throw new SyntaxError(createParseErrorMessage(scanner, error.message));
			const message = "Invalid error type caught";
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		}
	};
}

//#endregion
//#region ../node_modules/@std/toml/parse.js
/**
* Parses a {@link https://toml.io | TOML} string into an object.
*
* @example Usage
* ```ts
* import { parse } from "@std/toml/parse";
* import { assertEquals } from "@std/assert";
*
* const tomlString = `title = "TOML Example"
* [owner]
* name = "Alice"
* bio = "Alice is a programmer."`;
*
* const obj = parse(tomlString);
* assertEquals(obj, { title: "TOML Example", owner: { name: "Alice", bio: "Alice is a programmer." } });
* ```
* @param tomlString TOML string to be parsed.
* @returns The parsed JS object.
*/ function parse$2(tomlString) {
	return parserFactory(toml)(tomlString);
}

//#endregion
//#region src/def/rename.ts
var BaseRenameCommand = class extends Command {
	static paths = [["rename"]];
	static usage = Command.Usage({ description: "Rename the NAPI-RS project" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	$$name = Option.String("--name,-n", { description: "The new name of the project" });
	binaryName = Option.String("--binary-name,-b", { description: "The new binary name *.node files" });
	packageName = Option.String("--package-name", { description: "The new package name of the project" });
	manifestPath = Option.String("--manifest-path", "Cargo.toml", { description: "Path to `Cargo.toml`" });
	repository = Option.String("--repository", { description: "The new repository of the project" });
	description = Option.String("--description", { description: "The new description of the project" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			name: this.$$name,
			binaryName: this.binaryName,
			packageName: this.packageName,
			manifestPath: this.manifestPath,
			repository: this.repository,
			description: this.description
		};
	}
};
function applyDefaultRenameOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		manifestPath: "Cargo.toml",
		...options
	};
}

//#endregion
//#region src/api/rename.ts
async function renameProject(userOptions) {
	const options = applyDefaultRenameOptions(userOptions);
	const napiConfig = await readConfig(options);
	const oldName = napiConfig.binaryName;
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const cargoTomlPath = resolve(options.cwd, options.manifestPath);
	const packageJsonContent = await readFileAsync(packageJsonPath, "utf8");
	const packageJsonData = JSON.parse(packageJsonContent);
	merge(packageJsonData, omitBy(pick(options, [
		"name",
		"description",
		"author",
		"license"
	]), isNil), { napi: omitBy({
		binaryName: options.binaryName,
		packageName: options.packageName
	}, isNil) });
	if (options.configPath) {
		const configPath = resolve(options.cwd, options.configPath);
		const configContent = await readFileAsync(configPath, "utf8");
		const configData = JSON.parse(configContent);
		configData.binaryName = options.binaryName;
		configData.packageName = options.packageName;
		await writeFileAsync(configPath, JSON.stringify(configData, null, 2));
	}
	await writeFileAsync(packageJsonPath, JSON.stringify(packageJsonData, null, 2));
	const tomlContent = await readFileAsync(cargoTomlPath, "utf8");
	const cargoToml = parse$2(tomlContent);
	if (cargoToml.package && options.binaryName) {
		const sanitizedName = options.binaryName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
		cargoToml.package.name = sanitizedName;
	}
	const updatedTomlContent = stringify(cargoToml);
	await writeFileAsync(cargoTomlPath, updatedTomlContent);
	if (oldName !== options.binaryName) {
		const githubActionsPath = await findUp(".github", {
			cwd: options.cwd,
			type: "directory"
		});
		if (githubActionsPath) {
			const githubActionsCIYmlPath = join(githubActionsPath, "workflows", "CI.yml");
			if (existsSync(githubActionsCIYmlPath)) {
				const githubActionsContent = await readFileAsync(githubActionsCIYmlPath, "utf8");
				const githubActionsData = load(githubActionsContent);
				if (githubActionsData.env?.APP_NAME) {
					githubActionsData.env.APP_NAME = options.binaryName;
					await writeFileAsync(githubActionsCIYmlPath, dump(githubActionsData, {
						lineWidth: -1,
						noRefs: true,
						sortKeys: false
					}));
				}
			}
		}
		const oldWasiBrowserBindingPath = join(options.cwd, `${oldName}.wasi-browser.js`);
		if (existsSync(oldWasiBrowserBindingPath)) await rename(oldWasiBrowserBindingPath, join(options.cwd, `${options.binaryName}.wasi-browser.js`));
		const oldWasiBindingPath = join(options.cwd, `${oldName}.wasi.cjs`);
		if (existsSync(oldWasiBindingPath)) await rename(oldWasiBindingPath, join(options.cwd, `${options.binaryName}.wasi.cjs`));
		const gitAttributesPath = join(options.cwd, ".gitattributes");
		if (existsSync(gitAttributesPath)) {
			const gitAttributesContent = await readFileAsync(gitAttributesPath, "utf8");
			const gitAttributesData = gitAttributesContent.split("\n").map((line) => {
				return line.replace(`${oldName}.wasi-browser.js`, `${options.binaryName}.wasi-browser.js`).replace(`${oldName}.wasi.cjs`, `${options.binaryName}.wasi.cjs`);
			}).join("\n");
			await writeFileAsync(gitAttributesPath, gitAttributesData);
		}
	}
}

//#endregion
//#region src/api/new.ts
const debug$3 = debugFactory("new");
const TEMPLATE_REPOS = {
	yarn: "https://github.com/napi-rs/package-template",
	pnpm: "https://github.com/napi-rs/package-template-pnpm"
};
async function checkGitCommand() {
	try {
		await new Promise((resolve$1) => {
			const cp = exec("git --version");
			cp.on("error", () => {
				resolve$1(false);
			});
			cp.on("exit", (code) => {
				if (code === 0) resolve$1(true);
				else resolve$1(false);
			});
		});
		return true;
	} catch {
		return false;
	}
}
async function ensureCacheDir(packageManager) {
	const cacheDir = path.join(homedir(), ".napi-rs", "template", packageManager);
	await mkdirAsync(cacheDir, { recursive: true });
	return cacheDir;
}
async function downloadTemplate(packageManager, cacheDir) {
	const repoUrl = TEMPLATE_REPOS[packageManager];
	const templatePath = path.join(cacheDir, "repo");
	if (existsSync(templatePath)) {
		debug$3(`Template cache found at ${templatePath}, updating...`);
		try {
			await new Promise((resolve$1, reject) => {
				const cp = exec("git fetch origin", { cwd: templatePath });
				cp.on("error", reject);
				cp.on("exit", (code) => {
					if (code === 0) resolve$1();
					else reject(/* @__PURE__ */ new Error(`Failed to fetch latest changes, git process exited with code ${code}`));
				});
			});
			execSync("git reset --hard origin/main", {
				cwd: templatePath,
				stdio: "ignore"
			});
			debug$3("Template updated successfully");
		} catch (error) {
			debug$3(`Failed to update template: ${error}`);
			throw new Error(`Failed to update template from ${repoUrl}: ${error}`);
		}
	} else {
		debug$3(`Cloning template from ${repoUrl}...`);
		try {
			execSync(`git clone ${repoUrl} repo`, {
				cwd: cacheDir,
				stdio: "inherit"
			});
			debug$3("Template cloned successfully");
		} catch (error) {
			throw new Error(`Failed to clone template from ${repoUrl}: ${error}`);
		}
	}
}
async function copyDirectory(src, dest, includeWasiBindings) {
	await mkdirAsync(dest, { recursive: true });
	const entries = await promises.readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);
		if (entry.name === ".git") continue;
		if (entry.isDirectory()) await copyDirectory(srcPath, destPath, includeWasiBindings);
		else {
			if (!includeWasiBindings && (entry.name.endsWith(".wasi-browser.js") || entry.name.endsWith(".wasi.cjs") || entry.name.endsWith("wasi-worker.browser.mjs ") || entry.name.endsWith("wasi-worker.mjs") || entry.name.endsWith("browser.js"))) continue;
			await promises.copyFile(srcPath, destPath);
		}
	}
}
async function filterTargetsInPackageJson(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const packageJson = JSON.parse(content);
	if (packageJson.napi?.targets) packageJson.napi.targets = packageJson.napi.targets.filter((target) => enabledTargets.includes(target));
	await promises.writeFile(filePath, JSON.stringify(packageJson, null, 2) + "\n");
}
async function filterTargetsInGithubActions(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const yaml = load(content);
	const macOSAndWindowsTargets = new Set([
		"x86_64-pc-windows-msvc",
		"aarch64-pc-windows-msvc",
		"x86_64-apple-darwin"
	]);
	const linuxTargets = new Set([
		"x86_64-unknown-linux-gnu",
		"x86_64-unknown-linux-musl",
		"aarch64-unknown-linux-gnu",
		"aarch64-unknown-linux-musl",
		"armv7-unknown-linux-gnueabihf",
		"armv7-unknown-linux-musleabihf",
		"riscv64gc-unknown-linux-gnu",
		"powerpc64le-unknown-linux-gnu",
		"s390x-unknown-linux-gnu",
		"aarch64-linux-android",
		"armv7-linux-androideabi"
	]);
	const hasLinuxTargets = enabledTargets.some((target) => linuxTargets.has(target));
	if (yaml?.jobs?.build?.strategy?.matrix?.settings) yaml.jobs.build.strategy.matrix.settings = yaml.jobs.build.strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	const jobsToRemove = [];
	if (enabledTargets.every((target) => !macOSAndWindowsTargets.has(target))) jobsToRemove.push("test-macOS-windows-binding");
	else if (yaml?.jobs?.["test-macOS-windows-binding"]?.strategy?.matrix?.settings) yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings = yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	if (!hasLinuxTargets) {
		if (yaml?.jobs?.["test-linux-binding"]) jobsToRemove.push("test-linux-binding");
	} else if (yaml?.jobs?.["test-linux-binding"]?.strategy?.matrix?.target) yaml.jobs["test-linux-binding"].strategy.matrix.target = yaml.jobs["test-linux-binding"].strategy.matrix.target.filter((target) => {
		if (target) return enabledTargets.includes(target);
		return true;
	});
	if (!enabledTargets.includes("wasm32-wasip1-threads")) jobsToRemove.push("test-wasi");
	if (!enabledTargets.includes("x86_64-unknown-freebsd")) jobsToRemove.push("build-freebsd");
	for (const [jobName, jobConfig] of Object.entries(yaml.jobs || {})) if (jobName.startsWith("test-") && jobName !== "test-macOS-windows-binding" && jobName !== "test-linux-x64-gnu-binding") {
		const job = jobConfig;
		if (job.strategy?.matrix?.settings?.[0]?.target) {
			const target = job.strategy.matrix.settings[0].target;
			if (!enabledTargets.includes(target)) jobsToRemove.push(jobName);
		}
	}
	for (const jobName of jobsToRemove) delete yaml.jobs[jobName];
	if (Array.isArray(yaml.jobs?.publish?.needs)) yaml.jobs.publish.needs = yaml.jobs.publish.needs.filter((need) => !jobsToRemove.includes(need));
	const updatedYaml = dump(yaml, {
		lineWidth: -1,
		noRefs: true,
		sortKeys: false
	});
	await promises.writeFile(filePath, updatedYaml);
}
function processOptions(options) {
	debug$3("Processing options...");
	if (!options.path) throw new Error("Please provide the path as the argument");
	options.path = path.resolve(process.cwd(), options.path);
	debug$3(`Resolved target path to: ${options.path}`);
	if (!options.name) {
		options.name = path.parse(options.path).base;
		debug$3(`No project name provided, fix it to dir name: ${options.name}`);
	}
	if (!options.targets?.length) if (options.enableAllTargets) {
		options.targets = AVAILABLE_TARGETS.concat();
		debug$3("Enable all targets");
	} else if (options.enableDefaultTargets) {
		options.targets = DEFAULT_TARGETS.concat();
		debug$3("Enable default targets");
	} else throw new Error("At least one target must be enabled");
	if (options.targets.some((target) => target === "wasm32-wasi-preview1-threads")) {
		const out = execSync(`rustup target list`, { encoding: "utf8" });
		if (out.includes("wasm32-wasip1-threads")) options.targets = options.targets.map((target) => target === "wasm32-wasi-preview1-threads" ? "wasm32-wasip1-threads" : target);
	}
	return applyDefaultNewOptions(options);
}
async function newProject(userOptions) {
	debug$3("Will create napi-rs project with given options:");
	debug$3(userOptions);
	const options = processOptions(userOptions);
	debug$3("Targets to be enabled:");
	debug$3(options.targets);
	if (!await checkGitCommand()) throw new Error("Git is not installed or not available in PATH. Please install Git to continue.");
	const packageManager = options.packageManager;
	await ensurePath(options.path, options.dryRun);
	if (!options.dryRun) try {
		const cacheDir = await ensureCacheDir(packageManager);
		await downloadTemplate(packageManager, cacheDir);
		const templatePath = path.join(cacheDir, "repo");
		await copyDirectory(templatePath, options.path, options.targets.includes("wasm32-wasip1-threads"));
		await renameProject({
			cwd: options.path,
			name: options.name,
			binaryName: getBinaryName(options.name)
		});
		const packageJsonPath = path.join(options.path, "package.json");
		if (existsSync(packageJsonPath)) await filterTargetsInPackageJson(packageJsonPath, options.targets);
		const ciPath = path.join(options.path, ".github", "workflows", "CI.yml");
		if (existsSync(ciPath) && options.enableGithubActions) await filterTargetsInGithubActions(ciPath, options.targets);
		else if (!options.enableGithubActions && existsSync(path.join(options.path, ".github"))) await promises.rm(path.join(options.path, ".github"), {
			recursive: true,
			force: true
		});
		const pkgJsonContent = await promises.readFile(packageJsonPath, "utf-8");
		const pkgJson = JSON.parse(pkgJsonContent);
		if (!pkgJson.engines) pkgJson.engines = {};
		pkgJson.engines.node = napiEngineRequirement(options.minNodeApiVersion);
		if (options.license && pkgJson.license !== options.license) pkgJson.license = options.license;
		if (options.testFramework !== "ava") debug$3(`Test framework ${options.testFramework} requested but not yet implemented`);
		await promises.writeFile(packageJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
	} catch (error) {
		throw new Error(`Failed to create project: ${error}`);
	}
	debug$3(`Project created at: ${options.path}`);
}
async function ensurePath(path$1, dryRun = false) {
	const stat$1 = await statAsync(path$1, {}).catch(() => void 0);
	if (stat$1) {
		if (stat$1.isFile()) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not a directory.`);
		else if (stat$1.isDirectory()) {
			const files$1 = await readdirAsync(path$1);
			if (files$1.length) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not empty.`);
		}
	}
	if (!dryRun) try {
		debug$3(`Try to create target directory: ${path$1}`);
		if (!dryRun) await mkdirAsync(path$1, { recursive: true });
	} catch (e) {
		throw new Error(`Failed to create target directory: ${path$1}`, { cause: e });
	}
}
function getBinaryName(name$1) {
	return name$1.split("/").pop();
}

//#endregion
//#region src/def/pre-publish.ts
var BasePrePublishCommand = class extends Command {
	static paths = [["pre-publish"], ["prepublish"]];
	static usage = Command.Usage({ description: "Update package.json and copy addons into per platform packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir,-p", "npm", { description: "Path to the folder where the npm packages put" });
	tagStyle = Option.String("--tag-style,--tagstyle,-t", "lerna", { description: "git tag style, `npm` or `lerna`" });
	ghRelease = Option.Boolean("--gh-release", true, { description: "Whether create GitHub release" });
	ghReleaseName = Option.String("--gh-release-name", { description: "GitHub release name" });
	ghReleaseId = Option.String("--gh-release-id", { description: "Existing GitHub release id" });
	skipOptionalPublish = Option.Boolean("--skip-optional-publish", false, { description: "Whether skip optionalDependencies packages publish" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			tagStyle: this.tagStyle,
			ghRelease: this.ghRelease,
			ghReleaseName: this.ghReleaseName,
			ghReleaseId: this.ghReleaseId,
			skipOptionalPublish: this.skipOptionalPublish,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultPrePublishOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		tagStyle: "lerna",
		ghRelease: true,
		skipOptionalPublish: false,
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/def/version.ts
var BaseVersionCommand = class extends Command {
	static paths = [["version"]];
	static usage = Command.Usage({ description: "Update version in created npm packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir
		};
	}
};
function applyDefaultVersionOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/api/version.ts
const debug$2 = debugFactory("version");
async function version(userOptions) {
	const options = applyDefaultVersionOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of config.targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, target.platformArchABI);
		debug$2(`Update version to %i in [%i]`, config.packageJson.version, pkgDir);
		await updatePackageJson(join(pkgDir, "package.json"), { version: config.packageJson.version });
	}
}

//#endregion
//#region src/api/pre-publish.ts
const debug$1 = debugFactory("pre-publish");
async function prePublish(userOptions) {
	debug$1("Receive pre-publish options:");
	debug$1("  %O", userOptions);
	const options = applyDefaultPrePublishOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const { packageJson, targets, packageName, binaryName, npmClient } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	async function createGhRelease(packageName$1, version$2) {
		if (!options.ghRelease) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		const { repo: repo$1, owner: owner$1, pkgInfo: pkgInfo$1, octokit: octokit$1 } = getRepoInfo(packageName$1, version$2);
		if (!repo$1 || !owner$1) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		if (!options.dryRun) try {
			await octokit$1.repos.createRelease({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag,
				name: options.ghReleaseName,
				prerelease: version$2.includes("alpha") || version$2.includes("beta") || version$2.includes("rc")
			});
		} catch (e) {
			debug$1(`Params: ${JSON.stringify({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag
			}, null, 2)}`);
			console.error(e);
		}
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	function getRepoInfo(packageName$1, version$2) {
		const headCommit = execSync("git log -1 --pretty=%B", { encoding: "utf-8" }).trim();
		const { GITHUB_REPOSITORY } = process.env;
		if (!GITHUB_REPOSITORY) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		debug$1(`Github repository: ${GITHUB_REPOSITORY}`);
		const [owner$1, repo$1] = GITHUB_REPOSITORY.split("/");
		const octokit$1 = new Octokit({ auth: process.env.GITHUB_TOKEN });
		let pkgInfo$1;
		if (options.tagStyle === "lerna") {
			const packagesToPublish = headCommit.split("\n").map((line) => line.trim()).filter((line, index) => line.length && index).map((line) => line.substring(2)).map(parseTag);
			pkgInfo$1 = packagesToPublish.find((pkgInfo$2) => pkgInfo$2.name === packageName$1);
			if (!pkgInfo$1) throw new TypeError(`No release commit found with ${packageName$1}, original commit info: ${headCommit}`);
		} else pkgInfo$1 = {
			tag: `v${version$2}`,
			version: version$2,
			name: packageName$1
		};
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	if (!options.dryRun) {
		await version(userOptions);
		await updatePackageJson(packageJsonPath, { optionalDependencies: targets.reduce((deps, target) => {
			deps[`${packageName}-${target.platformArchABI}`] = packageJson.version;
			return deps;
		}, {}) });
	}
	const { owner, repo, pkgInfo, octokit } = options.ghReleaseId ? getRepoInfo(packageName, packageJson.version) : await createGhRelease(packageName, packageJson.version);
	for (const target of targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, `${target.platformArchABI}`);
		const ext = target.platform === "wasi" || target.platform === "wasm" ? "wasm" : "node";
		const filename = `${binaryName}.${target.platformArchABI}.${ext}`;
		const dstPath = join(pkgDir, filename);
		if (!options.dryRun) {
			if (!existsSync(dstPath)) {
				debug$1.warn(`%s doesn't exist`, dstPath);
				continue;
			}
			if (!options.skipOptionalPublish) execSync(`${npmClient} publish`, {
				cwd: pkgDir,
				env: process.env
			});
			if (options.ghRelease && repo && owner) {
				debug$1.info(`Creating GitHub release ${pkgInfo.tag}`);
				try {
					const releaseId = options.ghReleaseId ? Number(options.ghReleaseId) : (await octokit.repos.getReleaseByTag({
						repo,
						owner,
						tag: pkgInfo.tag
					})).data.id;
					const dstFileStats = statSync(dstPath);
					const assetInfo = await octokit.repos.uploadReleaseAsset({
						owner,
						repo,
						name: filename,
						release_id: releaseId,
						mediaType: { format: "raw" },
						headers: {
							"content-length": dstFileStats.size,
							"content-type": "application/octet-stream"
						},
						data: await readFileAsync(dstPath)
					});
					debug$1.info(`GitHub release created`);
					debug$1.info(`Download URL: %s`, assetInfo.data.browser_download_url);
				} catch (e) {
					debug$1.error(`Param: ${JSON.stringify({
						owner,
						repo,
						tag: pkgInfo.tag,
						filename: dstPath
					}, null, 2)}`);
					debug$1.error(e);
				}
			}
		}
	}
}
function parseTag(tag) {
	const segments = tag.split("@");
	const version$2 = segments.pop();
	const name$1 = segments.join("@");
	return {
		name: name$1,
		version: version$2,
		tag
	};
}

//#endregion
//#region src/def/universalize.ts
var BaseUniversalizeCommand = class extends Command {
	static paths = [["universalize"]];
	static usage = Command.Usage({ description: "Combile built binaries into one universal binary" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o", "./", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir
		};
	}
};
function applyDefaultUniversalizeOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./",
		...options
	};
}

//#endregion
//#region src/api/universalize.ts
const debug = debugFactory("universalize");
const universalizers = { darwin: (inputs, output) => {
	spawnSync("lipo", [
		"-create",
		"-output",
		output,
		...inputs
	], { stdio: "inherit" });
} };
async function universalizeBinaries(userOptions) {
	const options = applyDefaultUniversalizeOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	const target = config.targets.find((t) => t.platform === process.platform && t.arch === "universal");
	if (!target) throw new Error(`'universal' arch for platform '${process.platform}' not found in config!`);
	const srcFiles = UniArchsByPlatform[process.platform]?.map((arch) => resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-${arch}.node`));
	if (!srcFiles || !universalizers[process.platform]) throw new Error(`'universal' arch for platform '${process.platform}' not supported.`);
	debug(`Looking up source binaries to combine: `);
	debug("  %O", srcFiles);
	const srcFileLookup = await Promise.all(srcFiles.map((f) => fileExists(f)));
	const notFoundFiles = srcFiles.filter((_, i) => !srcFileLookup[i]);
	if (notFoundFiles.length) throw new Error(`Some binary files were not found: ${JSON.stringify(notFoundFiles)}`);
	const output = resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-universal.node`);
	universalizers[process.platform]?.(srcFiles, output);
	debug(`Produced universal binary: ${output}`);
}

//#endregion
//#region src/index.ts
/**
*
* @usage
*
* ```ts
* const cli = new NapiCli()
*
* cli.build({
*   cwd: '/path/to/your/project',
* })
* ```
*/
var NapiCli = class {
	artifacts = collectArtifacts;
	new = newProject;
	build = buildProject;
	createNpmDirs = createNpmDirs;
	prePublish = prePublish;
	rename = renameProject;
	universalize = universalizeBinaries;
	version = version;
};

//#endregion
export { NapiCli, parseTriple };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJuYW1lcyI6WyJvcHRpb25zOiBBcnRpZmFjdHNPcHRpb25zIiwibmFtZXNwYWNlOiBzdHJpbmciLCJkZWJ1ZyIsInBhdGg6IHN0cmluZyIsInBhdGgiLCJwaWNrIiwibzogTyIsInBhcnRpYWw6IFJlY29yZDxzdHJpbmcsIGFueT4iLCJkZWJ1ZyIsInBrZ0pzb24iLCJUQVJHRVRfTElOS0VSOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwiQ3B1VG9Ob2RlQXJjaDogUmVjb3JkPHN0cmluZywgTm9kZUpTQXJjaD4iLCJTeXNUb05vZGVQbGF0Zm9ybTogUmVjb3JkPHN0cmluZywgUGxhdGZvcm0+IiwiVW5pQXJjaHNCeVBsYXRmb3JtOiBQYXJ0aWFsPFJlY29yZDxQbGF0Zm9ybSwgTm9kZUpTQXJjaFtdPj4iLCJyYXdUcmlwbGU6IHN0cmluZyIsImNwdTogc3RyaW5nIiwic3lzOiBzdHJpbmciLCJhYmk6IHN0cmluZyB8IG51bGwiLCJ0YXJnZXQ6IHN0cmluZyIsInY6IHN0cmluZyIsIm5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbiIsInZlcnNpb25zOiBOb2RlVmVyc2lvbltdIiwicmVxdWlyZW1lbnRzOiBzdHJpbmdbXSIsIm1hbmlmZXN0UGF0aDogc3RyaW5nIiwicmVzb2x2ZSIsInBhdGg6IHN0cmluZyIsImNvbmZpZ1BhdGg/OiBzdHJpbmciLCJwYXRoIiwic2VwYXJhdGVkQ29uZmlnOiBVc2VyTmFwaUNvbmZpZyB8IHVuZGVmaW5lZCIsIm5hcGlDb25maWc6IE5hcGlDb25maWciLCJ0YXJnZXRzOiBzdHJpbmdbXSIsIm5hbWU6IHN0cmluZyIsImJpbjogc3RyaW5nIiwiYmluIiwiZGVidWciLCJuYW1lIiwibGluZTogVHlwZURlZkxpbmUiLCJjb25zdEVudW06IGJvb2xlYW4iLCJpZGVudDogbnVtYmVyIiwiYW1iaWVudDogYm9vbGVhbiIsImludGVybWVkaWF0ZVR5cGVGaWxlOiBzdHJpbmciLCJleHBvcnRzOiBzdHJpbmdbXSIsImRlZnMiLCJleHBvcnRzIiwiZmlsZTogc3RyaW5nIiwiZGVmczogVHlwZURlZkxpbmVbXSIsInNyYzogc3RyaW5nIiwib3B0aW9uczogTWluaW1hbE5hcGlPcHRpb25zIiwiZGVidWciLCJ1c2VyT3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucyIsImRpciIsInJvb3Q6IHN0cmluZyIsImZpbGVzIiwibG9jYWxOYW1lOiBzdHJpbmciLCJwa2dOYW1lOiBzdHJpbmciLCJpZGVudHM6IHN0cmluZ1tdIiwidHVwbGU6IHN0cmluZyIsIndhc2lGaWxlbmFtZTogc3RyaW5nIiwiZnMiLCJ3YXNtRmlsZU5hbWU6IHN0cmluZyIsInBhY2thZ2VOYW1lOiBzdHJpbmciLCJmczogYm9vbGVhbiIsImZzIiwiZGVidWciLCJyYXdPcHRpb25zOiBCdWlsZE9wdGlvbnMiLCJvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMiLCJtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSIsImNyYXRlOiBDcmF0ZSIsImNvbmZpZzogTmFwaUNvbmZpZyIsImFsaWFzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwidmVyc2lvbiIsInJlc29sdmUiLCJhYmk6IHN0cmluZyB8IG51bGwiLCJ0eXBlRGVmVG1wRm9sZGVyOiBzdHJpbmciLCJleHBvcnRzOiBzdHJpbmdbXSIsImZpbGVzIiwiZXhwb3J0cyIsImlkZW50czogc3RyaW5nW10iLCJuYW1lIiwiZGlzdEZpbGVOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsIiwiZW52OiBzdHJpbmciLCJ2YWx1ZTogc3RyaW5nIiwidmFsdWUiLCJvcHRpb25zOiBDcmVhdGVOcG1EaXJzT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zIiwibWtkaXJBc3luYyIsImRpcjogc3RyaW5nIiwicmF3TWtkaXJBc3luYyIsIndyaXRlRmlsZUFzeW5jIiwiZmlsZTogc3RyaW5nIiwiY29udGVudDogc3RyaW5nIiwicmF3V3JpdGVGaWxlQXN5bmMiLCJzY29wZWRQYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHMiLCJwaWNrIiwicGFyc2UiLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwidGFyZ2V0OiBUYXJnZXQiLCJvcHRpb25zOiBOZXdPcHRpb25zIiwiI3ByaW50T2JqZWN0IiwiI2Zvcm1hdCIsIiNpc1NpbXBseVNlcmlhbGl6YWJsZSIsInZhbHVlIiwiI2RhdGVEZWNsYXJhdGlvbiIsIiNzdHJEZWNsYXJhdGlvbiIsIiNudW1iZXJEZWNsYXJhdGlvbiIsIiNib29sRGVjbGFyYXRpb24iLCIjZ2V0VHlwZU9mQXJyYXkiLCIjYXJyYXlEZWNsYXJhdGlvbiIsIiNoZWFkZXJHcm91cCIsIiNwcmludEFzSW5saW5lVmFsdWUiLCIjZGVjbGFyYXRpb24iLCIjaGVhZGVyIiwiI2FycmF5VHlwZUNhY2hlIiwidHlwZSIsIiNkb0dldFR5cGVPZkFycmF5IiwiI2lzUHJpbWl0aXZlIiwiI3ByaW50RGF0ZSIsInZhbHVlIiwiI3NvdXJjZSIsIiNwb3NpdGlvbiIsIiN3aGl0ZXNwYWNlIiwidmFsdWUiLCJ0YWJsZSIsInBhcnNlIiwiam9pbiIsIm1lcmdlIiwiZmxvYXQiLCJwYWlyIiwicGFyc2UiLCJvcHRpb25zOiBSZW5hbWVPcHRpb25zIiwidXNlck9wdGlvbnM6IFJlbmFtZU9wdGlvbnMiLCJwYXJzZVRvbWwiLCJzdHJpbmdpZnlUb21sIiwieWFtbFBhcnNlIiwieWFtbFN0cmluZ2lmeSIsImRlYnVnIiwicmVzb2x2ZSIsInBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlciIsImNhY2hlRGlyOiBzdHJpbmciLCJzcmM6IHN0cmluZyIsImRlc3Q6IHN0cmluZyIsImluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4iLCJmcyIsImZpbGVQYXRoOiBzdHJpbmciLCJlbmFibGVkVGFyZ2V0czogc3RyaW5nW10iLCJ0YXJnZXQ6IHN0cmluZyIsInlhbWxMb2FkIiwic2V0dGluZzogYW55Iiwiam9ic1RvUmVtb3ZlOiBzdHJpbmdbXSIsIm5lZWQ6IHN0cmluZyIsInlhbWxEdW1wIiwib3B0aW9uczogUmF3TmV3T3B0aW9ucyIsInVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zIiwicGF0aDogc3RyaW5nIiwic3RhdCIsInBhdGgiLCJmaWxlcyIsIm5hbWU6IHN0cmluZyIsIm5hbWUiLCJvcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucyIsIm9wdGlvbnM6IFZlcnNpb25PcHRpb25zIiwiZGVidWciLCJ1c2VyT3B0aW9uczogVmVyc2lvbk9wdGlvbnMiLCJkZWJ1ZyIsInVzZXJPcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucyIsInBhY2thZ2VOYW1lOiBzdHJpbmciLCJ2ZXJzaW9uOiBzdHJpbmciLCJwYWNrYWdlTmFtZSIsInZlcnNpb24iLCJyZXBvIiwib3duZXIiLCJvY3Rva2l0IiwicGtnSW5mbyIsInBrZ0luZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkIiwidGFnOiBzdHJpbmciLCJuYW1lIiwib3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucyIsInVuaXZlcnNhbGl6ZXJzOiBQYXJ0aWFsPFxuICBSZWNvcmQ8Tm9kZUpTLlBsYXRmb3JtLCAoaW5wdXRzOiBzdHJpbmdbXSwgb3V0cHV0OiBzdHJpbmcpID0+IHZvaWQ+XG4+IiwidXNlck9wdGlvbnM6IFVuaXZlcnNhbGl6ZU9wdGlvbnMiXSwic291cmNlcyI6WyIuLi9zcmMvZGVmL2FydGlmYWN0cy50cyIsIi4uL3NyYy91dGlscy9sb2cudHMiLCIuLi9wYWNrYWdlLmpzb24iLCIuLi9zcmMvdXRpbHMvbWlzYy50cyIsIi4uL3NyYy91dGlscy90YXJnZXQudHMiLCIuLi9zcmMvdXRpbHMvdmVyc2lvbi50cyIsIi4uL3NyYy91dGlscy9tZXRhZGF0YS50cyIsIi4uL3NyYy91dGlscy9jb25maWcudHMiLCIuLi9zcmMvdXRpbHMvY2FyZ28udHMiLCIuLi9zcmMvdXRpbHMvdHlwZWdlbi50cyIsIi4uL3NyYy91dGlscy9yZWFkLWNvbmZpZy50cyIsIi4uL3NyYy9hcGkvYXJ0aWZhY3RzLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvanMtYmluZGluZy50cyIsIi4uL3NyYy9hcGkvdGVtcGxhdGVzL2xvYWQtd2FzaS10ZW1wbGF0ZS50cyIsIi4uL3NyYy9hcGkvdGVtcGxhdGVzL3dhc2ktd29ya2VyLXRlbXBsYXRlLnRzIiwiLi4vc3JjL2FwaS9idWlsZC50cyIsIi4uL3NyYy9kZWYvY3JlYXRlLW5wbS1kaXJzLnRzIiwiLi4vc3JjL2FwaS9jcmVhdGUtbnBtLWRpcnMudHMiLCIuLi9zcmMvZGVmL25ldy50cyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac3RkL3RvbWwvc3RyaW5naWZ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bqc3Ivc3RkX19jb2xsZWN0aW9ucy9fdXRpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGpzci9zdGRfX2NvbGxlY3Rpb25zL2RlZXBfbWVyZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQHN0ZC90b21sL19wYXJzZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQHN0ZC90b21sL3BhcnNlLmpzIiwiLi4vc3JjL2RlZi9yZW5hbWUudHMiLCIuLi9zcmMvYXBpL3JlbmFtZS50cyIsIi4uL3NyYy9hcGkvbmV3LnRzIiwiLi4vc3JjL2RlZi9wcmUtcHVibGlzaC50cyIsIi4uL3NyYy9kZWYvdmVyc2lvbi50cyIsIi4uL3NyYy9hcGkvdmVyc2lvbi50cyIsIi4uL3NyYy9hcGkvcHJlLXB1Ymxpc2gudHMiLCIuLi9zcmMvZGVmL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9hcGkvdW5pdmVyc2FsaXplLnRzIiwiLi4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQXJ0aWZhY3RzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydhcnRpZmFjdHMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdDb3B5IGFydGlmYWN0cyBmcm9tIEdpdGh1YiBBY3Rpb25zIGludG8gbnBtIHBhY2thZ2VzIGFuZCByZWFkeSB0byBwdWJsaXNoJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBvdXRwdXREaXIgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8sLWQnLCAnLi9hcnRpZmFjdHMnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBidWlsZE91dHB1dERpcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYnVpbGQtb3V0cHV0LWRpcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHRoZSBidWlsZCBvdXRwdXQgZGlyLCBvbmx5IG5lZWRlZCB3aGVuIHRhcmdldHMgY29udGFpbnMgYHdhc20zMi13YXNpLSpgJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG91dHB1dERpcjogdGhpcy5vdXRwdXREaXIsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgYnVpbGRPdXRwdXREaXI6IHRoaXMuYnVpbGRPdXRwdXREaXIsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIG5wbSBwYWNrYWdlcyBhbmQgcmVhZHkgdG8gcHVibGlzaFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0c09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmRcbiAgICpcbiAgICogQGRlZmF1bHQgJy4vYXJ0aWZhY3RzJ1xuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgYnVpbGQgb3V0cHV0IGRpciwgb25seSBuZWVkZWQgd2hlbiB0YXJnZXRzIGNvbnRhaW5zIGB3YXNtMzItd2FzaS0qYFxuICAgKi9cbiAgYnVpbGRPdXRwdXREaXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnMob3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG91dHB1dERpcjogJy4vYXJ0aWZhY3RzJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcmV0dGUnXG5pbXBvcnQgcmF3RGVidWcgZnJvbSAnZGVidWcnXG5cbi8vIGRlYnVnKCclaScsICdUaGlzIGlzIGFuIGluZm8nKVxucmF3RGVidWcuZm9ybWF0dGVycy5pID0gKHYpID0+IHtcbiAgcmV0dXJuIGNvbG9ycy5ncmVlbih2KVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnZGVidWcnIHtcbiAgaW50ZXJmYWNlIERlYnVnZ2VyIHtcbiAgICBpbmZvOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICAgIHdhcm46IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gICAgZXJyb3I6IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlYnVnRmFjdG9yeSA9IChuYW1lc3BhY2U6IHN0cmluZykgPT4ge1xuICBjb25zdCBkZWJ1ZyA9IHJhd0RlYnVnKGBuYXBpOiR7bmFtZXNwYWNlfWApXG5cbiAgZGVidWcuaW5mbyA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKGNvbG9ycy5ibGFjayhjb2xvcnMuYmdHcmVlbignIElORk8gJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy53YXJuID0gKC4uLmFyZ3M6IGFueVtdKSA9PlxuICAgIGNvbnNvbGUuZXJyb3IoY29sb3JzLmJsYWNrKGNvbG9ycy5iZ1llbGxvdygnIFdBUk5JTkcgJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy5lcnJvciA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgY29sb3JzLndoaXRlKGNvbG9ycy5iZ1JlZCgnIEVSUk9SICcpKSxcbiAgICAgIC4uLmFyZ3MubWFwKChhcmcpID0+XG4gICAgICAgIGFyZyBpbnN0YW5jZW9mIEVycm9yID8gKGFyZy5zdGFjayA/PyBhcmcubWVzc2FnZSkgOiBhcmcsXG4gICAgICApLFxuICAgIClcblxuICByZXR1cm4gZGVidWdcbn1cbmV4cG9ydCBjb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndXRpbHMnKVxuIiwie1xuICBcIm5hbWVcIjogXCJAbmFwaS1ycy9jbGlcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMy4wLjRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNsaSB0b29scyBmb3IgbmFwaS1yc1wiLFxuICBcImF1dGhvclwiOiBcIkxvbmdZaW5hbiA8bHlud2VrbG1AZ21haWwuY29tPlwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1yc1wiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJ0eXBlXCI6IFwibW9kdWxlXCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0gMTZcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJuYXBpXCI6IFwiLi9kaXN0L2NsaS5qc1wiLFxuICAgIFwibmFwaS1yYXdcIjogXCIuL2NsaS5tanNcIlxuICB9LFxuICBcIm1haW5cIjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIFwibW9kdWxlXCI6IFwiLi9kaXN0L2luZGV4LmpzXCIsXG4gIFwiZXhwb3J0c1wiOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIFwiaW1wb3J0XCI6IHtcbiAgICAgICAgXCJ0eXBlc1wiOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9pbmRleC5qc1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlXCI6IHtcbiAgICAgICAgXCJ0eXBlc1wiOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9pbmRleC5janNcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIuL3BhY2thZ2UuanNvblwiOiB7XG4gICAgICBcImltcG9ydFwiOiBcIi4vcGFja2FnZS5qc29uXCIsXG4gICAgICBcInJlcXVpcmVcIjogXCIuL3BhY2thZ2UuanNvblwiXG4gICAgfVxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcInNyY1wiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY2xpXCIsXG4gICAgXCJydXN0XCIsXG4gICAgXCJuYXBpXCIsXG4gICAgXCJuLWFwaVwiLFxuICAgIFwibm9kZS1hcGlcIixcbiAgICBcIm5vZGUtYWRkb25cIixcbiAgICBcIm5lb25cIlxuICBdLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJMb25nWWluYW5cIixcbiAgICAgIFwiZW1haWxcIjogXCJseW53ZWtsbUBnbWFpbC5jb21cIixcbiAgICAgIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vQnJvb29vb29rbHluXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImZvcmVoYWxvXCIsXG4gICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ZvcmVoYWxvXCJcbiAgICB9XG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1ycy5naXRcIlxuICB9LFxuICBcInB1Ymxpc2hDb25maWdcIjoge1xuICAgIFwicmVnaXN0cnlcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9cIixcbiAgICBcImFjY2Vzc1wiOiBcInB1YmxpY1wiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9uYXBpLXJzL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBpbnF1aXJlci9wcm9tcHRzXCI6IFwiXjcuNC4wXCIsXG4gICAgXCJAbmFwaS1ycy9jcm9zcy10b29sY2hhaW5cIjogXCJeMS4wLjBcIixcbiAgICBcIkBuYXBpLXJzL3dhc20tdG9vbHNcIjogXCJeMS4wLjBcIixcbiAgICBcIkBvY3Rva2l0L3Jlc3RcIjogXCJeMjIuMC4wXCIsXG4gICAgXCJjbGlwYW5pb25cIjogXCJeNC4wLjAtcmMuNFwiLFxuICAgIFwiY29sb3JldHRlXCI6IFwiXjIuMC4yMFwiLFxuICAgIFwiZGVidWdcIjogXCJeNC40LjBcIixcbiAgICBcImVtbmFwaVwiOiBcIl4xLjQuMFwiLFxuICAgIFwiZmluZC11cFwiOiBcIl43LjAuMFwiLFxuICAgIFwianMteWFtbFwiOiBcIl40LjEuMFwiLFxuICAgIFwibG9kYXNoLWVzXCI6IFwiXjQuMTcuMjFcIixcbiAgICBcInNlbXZlclwiOiBcIl43LjcuMVwiLFxuICAgIFwidHlwYW5pb25cIjogXCJeMy4xNC4wXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGVtbmFwaS9jb3JlXCI6IFwiXjEuNC4wXCIsXG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjogXCJeMS40LjBcIixcbiAgICBcIkBveGMtbm9kZS9jb3JlXCI6IFwiXjAuMC4zMFwiLFxuICAgIFwiQHN0ZC90b21sXCI6IFwibnBtOkBqc3Ivc3RkX190b21sQF4xLjAuOFwiLFxuICAgIFwiQHR5cGVzL2RlYnVnXCI6IFwiXjQuMS4xMlwiLFxuICAgIFwiQHR5cGVzL2lucXVpcmVyXCI6IFwiXjkuMC43XCIsXG4gICAgXCJAdHlwZXMvanMteWFtbFwiOiBcIl40LjAuOVwiLFxuICAgIFwiQHR5cGVzL2xvZGFzaC1lc1wiOiBcIl40LjE3LjEyXCIsXG4gICAgXCJAdHlwZXMvbm9kZVwiOiBcIl4yMi4xMy4xNlwiLFxuICAgIFwiQHR5cGVzL3NlbXZlclwiOiBcIl43LjcuMFwiLFxuICAgIFwiYXZhXCI6IFwiXjYuMi4wXCIsXG4gICAgXCJlbnYtcGF0aHNcIjogXCJeMy4wLjBcIixcbiAgICBcInByZXR0aWVyXCI6IFwiXjMuNS4zXCIsXG4gICAgXCJyb2xsZG93blwiOiBcImxhdGVzdFwiLFxuICAgIFwidHNsaWJcIjogXCJeMi44LjFcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCJeNS44LjJcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGVtbmFwaS9ydW50aW1lXCI6IFwiXjEuMS4wXCIsXG4gICAgXCJlbW5hcGlcIjogXCJeMS4xLjBcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNNZXRhXCI6IHtcbiAgICBcIkBlbW5hcGkvcnVudGltZVwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9LFxuICAgIFwiZW1uYXBpXCI6IHtcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgXCJmdW5kaW5nXCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRodWJcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zcG9uc29ycy9Ccm9vb29vb2tseW5cIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiY2xlYW5cIjogXCJub2RlIC0taW1wb3J0IEBveGMtbm9kZS9jb3JlL3JlZ2lzdGVyIC4vY2xlYW4udHNcIixcbiAgICBcImNvZGVnZW5cIjogXCJub2RlIC0taW1wb3J0IEBveGMtbm9kZS9jb3JlL3JlZ2lzdGVyIC4vY29kZWdlbi9pbmRleC50c1wiLFxuICAgIFwiYnVpbGRcIjogXCJ0c2MgJiYgeWFybiBjbGVhbiAmJiByb2xsZG93biAtYyByb2xsZG93bi5jb25maWcuanNcIixcbiAgICBcInRlc3RcIjogXCJub2RlIC0taW1wb3J0IEBveGMtbm9kZS9jb3JlL3JlZ2lzdGVyIC4uL25vZGVfbW9kdWxlcy9hdmEvZW50cnlwb2ludHMvY2xpLm1qc1wiXG4gIH0sXG4gIFwiYXZhXCI6IHtcbiAgICBcImV4dGVuc2lvbnNcIjoge1xuICAgICAgXCJ0c1wiOiBcIm1vZHVsZVwiXG4gICAgfSxcbiAgICBcInRpbWVvdXRcIjogXCIxbVwiLFxuICAgIFwiZmlsZXNcIjogW1xuICAgICAgXCIqKi9fX3Rlc3RzX18vKiovKi5zcGVjLnRzXCIsXG4gICAgICBcImUyZS8qKi8qLnNwZWMudHNcIlxuICAgIF1cbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiNTIxYjU3NzRhYTg5ZjFhN2M4MDdhNmRkYmE1MDljZTQzOTczZjYyNFwiXG59XG4iLCJpbXBvcnQge1xuICByZWFkRmlsZSxcbiAgd3JpdGVGaWxlLFxuICBjb3B5RmlsZSxcbiAgbWtkaXIsXG4gIHVubGluayxcbiAgc3RhdCxcbiAgcmVhZGRpcixcbn0gZnJvbSAnbm9kZTpmcydcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ25vZGU6dXRpbCdcblxuaW1wb3J0IHBrZ0pzb24gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJyB3aXRoIHsgdHlwZTogJ2pzb24nIH1cbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9sb2cuanMnXG5cbmV4cG9ydCBjb25zdCByZWFkRmlsZUFzeW5jID0gcHJvbWlzaWZ5KHJlYWRGaWxlKVxuZXhwb3J0IGNvbnN0IHdyaXRlRmlsZUFzeW5jID0gcHJvbWlzaWZ5KHdyaXRlRmlsZSlcbmV4cG9ydCBjb25zdCB1bmxpbmtBc3luYyA9IHByb21pc2lmeSh1bmxpbmspXG5leHBvcnQgY29uc3QgY29weUZpbGVBc3luYyA9IHByb21pc2lmeShjb3B5RmlsZSlcbmV4cG9ydCBjb25zdCBta2RpckFzeW5jID0gcHJvbWlzaWZ5KG1rZGlyKVxuZXhwb3J0IGNvbnN0IHN0YXRBc3luYyA9IHByb21pc2lmeShzdGF0KVxuZXhwb3J0IGNvbnN0IHJlYWRkaXJBc3luYyA9IHByb21pc2lmeShyZWFkZGlyKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmlsZUV4aXN0cyhwYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgZXhpc3RzID0gYXdhaXQgc3RhdEFzeW5jKHBhdGgpXG4gICAgLnRoZW4oKCkgPT4gdHJ1ZSlcbiAgICAuY2F0Y2goKCkgPT4gZmFsc2UpXG4gIHJldHVybiBleGlzdHNcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpckV4aXN0c0FzeW5jKHBhdGg6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgc3RhdEFzeW5jKHBhdGgpXG4gICAgcmV0dXJuIHN0YXRzLmlzRGlyZWN0b3J5KClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2s8TywgSyBleHRlbmRzIGtleW9mIE8+KG86IE8sIC4uLmtleXM6IEtbXSk6IFBpY2s8TywgSz4ge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSBvW2tleV1cbiAgICByZXR1cm4gYWNjXG4gIH0sIHt9IGFzIE8pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVQYWNrYWdlSnNvbihcbiAgcGF0aDogc3RyaW5nLFxuICBwYXJ0aWFsOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuKSB7XG4gIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGZpbGVFeGlzdHMocGF0aClcbiAgaWYgKCFleGlzdHMpIHtcbiAgICBkZWJ1ZyhgRmlsZSBub3QgZXhpc3RzICR7cGF0aH1gKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IG9sZCA9IEpTT04ucGFyc2UoYXdhaXQgcmVhZEZpbGVBc3luYyhwYXRoLCAndXRmOCcpKVxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhwYXRoLCBKU09OLnN0cmluZ2lmeSh7IC4uLm9sZCwgLi4ucGFydGlhbCB9LCBudWxsLCAyKSlcbn1cblxuZXhwb3J0IGNvbnN0IENMSV9WRVJTSU9OID0gcGtnSnNvbi52ZXJzaW9uXG4iLCJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcblxuZXhwb3J0IHR5cGUgUGxhdGZvcm0gPSBOb2RlSlMuUGxhdGZvcm0gfCAnd2FzbScgfCAnd2FzaScgfCAnb3Blbmhhcm1vbnknXG5cbmV4cG9ydCBjb25zdCBVTklWRVJTQUxfVEFSR0VUUyA9IHtcbiAgJ3VuaXZlcnNhbC1hcHBsZS1kYXJ3aW4nOiBbJ2FhcmNoNjQtYXBwbGUtZGFyd2luJywgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nXSxcbn0gYXMgY29uc3RcblxuZXhwb3J0IGNvbnN0IEFWQUlMQUJMRV9UQVJHRVRTID0gW1xuICAnYWFyY2g2NC1hcHBsZS1kYXJ3aW4nLFxuICAnYWFyY2g2NC1saW51eC1hbmRyb2lkJyxcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2wnLFxuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW9ob3MnLFxuICAnYWFyY2g2NC1wYy13aW5kb3dzLW1zdmMnLFxuICAneDg2XzY0LWFwcGxlLWRhcndpbicsXG4gICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LWdudScsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LW9ob3MnLFxuICAneDg2XzY0LXVua25vd24tZnJlZWJzZCcsXG4gICdpNjg2LXBjLXdpbmRvd3MtbXN2YycsXG4gICdhcm12Ny11bmtub3duLWxpbnV4LWdudWVhYmloZicsXG4gICdhcm12Ny11bmtub3duLWxpbnV4LW11c2xlYWJpaGYnLFxuICAnYXJtdjctbGludXgtYW5kcm9pZGVhYmknLFxuICAndW5pdmVyc2FsLWFwcGxlLWRhcndpbicsXG4gICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnLFxuICAncG93ZXJwYzY0bGUtdW5rbm93bi1saW51eC1nbnUnLFxuICAnczM5MHgtdW5rbm93bi1saW51eC1nbnUnLFxuICAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcycsXG4gICd3YXNtMzItd2FzaXAxLXRocmVhZHMnLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBUYXJnZXRUcmlwbGUgPSAodHlwZW9mIEFWQUlMQUJMRV9UQVJHRVRTKVtudW1iZXJdXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RBUkdFVFMgPSBbXG4gICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgJ2FhcmNoNjQtYXBwbGUtZGFyd2luJyxcbiAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtZ251Jyxcbl0gYXMgY29uc3RcblxuZXhwb3J0IGNvbnN0IFRBUkdFVF9MSU5LRVI6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCc6ICdhYXJjaDY0LWxpbnV4LW11c2wtZ2NjJyxcbiAgJ3Jpc2N2NjRnYy11bmtub3duLWxpbnV4LWdudSc6ICdyaXNjdjY0LWxpbnV4LWdudS1nY2MnLFxuICAncG93ZXJwYzY0bGUtdW5rbm93bi1saW51eC1nbnUnOiAncG93ZXJwYzY0bGUtbGludXgtZ251LWdjYycsXG4gICdzMzkweC11bmtub3duLWxpbnV4LWdudSc6ICdzMzkweC1saW51eC1nbnUtZ2NjJyxcbn1cblxuLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2FyY2hcbnR5cGUgTm9kZUpTQXJjaCA9XG4gIHwgJ2FybSdcbiAgfCAnYXJtNjQnXG4gIHwgJ2lhMzInXG4gIHwgJ21pcHMnXG4gIHwgJ21pcHNlbCdcbiAgfCAncHBjJ1xuICB8ICdwcGM2NCdcbiAgfCAncmlzY3Y2NCdcbiAgfCAnczM5MCdcbiAgfCAnczM5MHgnXG4gIHwgJ3gzMidcbiAgfCAneDY0J1xuICB8ICd1bml2ZXJzYWwnXG4gIHwgJ3dhc20zMidcblxuY29uc3QgQ3B1VG9Ob2RlQXJjaDogUmVjb3JkPHN0cmluZywgTm9kZUpTQXJjaD4gPSB7XG4gIHg4Nl82NDogJ3g2NCcsXG4gIGFhcmNoNjQ6ICdhcm02NCcsXG4gIGk2ODY6ICdpYTMyJyxcbiAgYXJtdjc6ICdhcm0nLFxuICByaXNjdjY0Z2M6ICdyaXNjdjY0JyxcbiAgcG93ZXJwYzY0bGU6ICdwcGM2NCcsXG59XG5cbmV4cG9ydCBjb25zdCBOb2RlQXJjaFRvQ3B1OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICB4NjQ6ICd4ODZfNjQnLFxuICBhcm02NDogJ2FhcmNoNjQnLFxuICBpYTMyOiAnaTY4NicsXG4gIGFybTogJ2FybXY3JyxcbiAgcmlzY3Y2NDogJ3Jpc2N2NjRnYycsXG4gIHBwYzY0OiAncG93ZXJwYzY0bGUnLFxufVxuXG5jb25zdCBTeXNUb05vZGVQbGF0Zm9ybTogUmVjb3JkPHN0cmluZywgUGxhdGZvcm0+ID0ge1xuICBsaW51eDogJ2xpbnV4JyxcbiAgZnJlZWJzZDogJ2ZyZWVic2QnLFxuICBkYXJ3aW46ICdkYXJ3aW4nLFxuICB3aW5kb3dzOiAnd2luMzInLFxuICBvaG9zOiAnb3Blbmhhcm1vbnknLFxufVxuXG5leHBvcnQgY29uc3QgVW5pQXJjaHNCeVBsYXRmb3JtOiBQYXJ0aWFsPFJlY29yZDxQbGF0Zm9ybSwgTm9kZUpTQXJjaFtdPj4gPSB7XG4gIGRhcndpbjogWyd4NjQnLCAnYXJtNjQnXSxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYXJnZXQge1xuICB0cmlwbGU6IHN0cmluZ1xuICBwbGF0Zm9ybUFyY2hBQkk6IHN0cmluZ1xuICBwbGF0Zm9ybTogUGxhdGZvcm1cbiAgYXJjaDogTm9kZUpTQXJjaFxuICBhYmk6IHN0cmluZyB8IG51bGxcbn1cblxuLyoqXG4gKiBBIHRyaXBsZSBpcyBhIHNwZWNpZmljIGZvcm1hdCBmb3Igc3BlY2lmeWluZyBhIHRhcmdldCBhcmNoaXRlY3R1cmUuXG4gKiBUcmlwbGVzIG1heSBiZSByZWZlcnJlZCB0byBhcyBhIHRhcmdldCB0cmlwbGUgd2hpY2ggaXMgdGhlIGFyY2hpdGVjdHVyZSBmb3IgdGhlIGFydGlmYWN0IHByb2R1Y2VkLCBhbmQgdGhlIGhvc3QgdHJpcGxlIHdoaWNoIGlzIHRoZSBhcmNoaXRlY3R1cmUgdGhhdCB0aGUgY29tcGlsZXIgaXMgcnVubmluZyBvbi5cbiAqIFRoZSBnZW5lcmFsIGZvcm1hdCBvZiB0aGUgdHJpcGxlIGlzIGA8YXJjaD48c3ViPi08dmVuZG9yPi08c3lzPi08YWJpPmAgd2hlcmU6XG4gKiAgIC0gYGFyY2hgID0gVGhlIGJhc2UgQ1BVIGFyY2hpdGVjdHVyZSwgZm9yIGV4YW1wbGUgYHg4Nl82NGAsIGBpNjg2YCwgYGFybWAsIGB0aHVtYmAsIGBtaXBzYCwgZXRjLlxuICogICAtIGBzdWJgID0gVGhlIENQVSBzdWItYXJjaGl0ZWN0dXJlLCBmb3IgZXhhbXBsZSBgYXJtYCBoYXMgYHY3YCwgYHY3c2AsIGB2NXRlYCwgZXRjLlxuICogICAtIGB2ZW5kb3JgID0gVGhlIHZlbmRvciwgZm9yIGV4YW1wbGUgYHVua25vd25gLCBgYXBwbGVgLCBgcGNgLCBgbnZpZGlhYCwgZXRjLlxuICogICAtIGBzeXNgID0gVGhlIHN5c3RlbSBuYW1lLCBmb3IgZXhhbXBsZSBgbGludXhgLCBgd2luZG93c2AsIGBkYXJ3aW5gLCBldGMuIG5vbmUgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGJhcmUtbWV0YWwgd2l0aG91dCBhbiBPUy5cbiAqICAgLSBgYWJpYCA9IFRoZSBBQkksIGZvciBleGFtcGxlIGBnbnVgLCBgYW5kcm9pZGAsIGBlYWJpYCwgZXRjLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUcmlwbGUocmF3VHJpcGxlOiBzdHJpbmcpOiBUYXJnZXQge1xuICBpZiAoXG4gICAgcmF3VHJpcGxlID09PSAnd2FzbTMyLXdhc2knIHx8XG4gICAgcmF3VHJpcGxlID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcycgfHxcbiAgICByYXdUcmlwbGUuc3RhcnRzV2l0aCgnd2FzbTMyLXdhc2lwJylcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyaXBsZTogcmF3VHJpcGxlLFxuICAgICAgcGxhdGZvcm1BcmNoQUJJOiAnd2FzbTMyLXdhc2knLFxuICAgICAgcGxhdGZvcm06ICd3YXNpJyxcbiAgICAgIGFyY2g6ICd3YXNtMzInLFxuICAgICAgYWJpOiAnd2FzaScsXG4gICAgfVxuICB9XG4gIGNvbnN0IHRyaXBsZSA9IHJhd1RyaXBsZS5lbmRzV2l0aCgnZWFiaScpXG4gICAgPyBgJHtyYXdUcmlwbGUuc2xpY2UoMCwgLTQpfS1lYWJpYFxuICAgIDogcmF3VHJpcGxlXG4gIGNvbnN0IHRyaXBsZXMgPSB0cmlwbGUuc3BsaXQoJy0nKVxuICBsZXQgY3B1OiBzdHJpbmdcbiAgbGV0IHN5czogc3RyaW5nXG4gIGxldCBhYmk6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIGlmICh0cmlwbGVzLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIGFhcmNoNjQtZnVjaHNpYVxuICAgIC8vIF4gY3B1ICAgXiBzeXNcbiAgICA7W2NwdSwgc3lzXSA9IHRyaXBsZXNcbiAgfSBlbHNlIHtcbiAgICAvLyBhYXJjaDY0LXVua25vd24tbGludXgtbXVzbFxuICAgIC8vIF4gY3B1ICAgICAgICAgICBeIHN5cyBeIGFiaVxuICAgIC8vIGFhcmNoNjQtYXBwbGUtZGFyd2luXG4gICAgLy8gXiBjcHUgICAgICAgICBeIHN5cyAgKGFiaSBpcyBOb25lKVxuICAgIDtbY3B1LCAsIHN5cywgYWJpID0gbnVsbF0gPSB0cmlwbGVzXG4gIH1cblxuICBjb25zdCBwbGF0Zm9ybSA9IFN5c1RvTm9kZVBsYXRmb3JtW3N5c10gPz8gKHN5cyBhcyBQbGF0Zm9ybSlcbiAgY29uc3QgYXJjaCA9IENwdVRvTm9kZUFyY2hbY3B1XSA/PyAoY3B1IGFzIE5vZGVKU0FyY2gpXG5cbiAgaWYgKHJhd1RyaXBsZS5pbmNsdWRlcygnb2hvcycpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyaXBsZTogcmF3VHJpcGxlLFxuICAgICAgcGxhdGZvcm1BcmNoQUJJOiBgbGludXgtJHthcmNofS1vaG9zYCxcbiAgICAgIHBsYXRmb3JtOiAnb3Blbmhhcm1vbnknLFxuICAgICAgYXJjaCxcbiAgICAgIGFiaTogbnVsbCxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0cmlwbGU6IHJhd1RyaXBsZSxcbiAgICBwbGF0Zm9ybUFyY2hBQkk6IGFiaSA/IGAke3BsYXRmb3JtfS0ke2FyY2h9LSR7YWJpfWAgOiBgJHtwbGF0Zm9ybX0tJHthcmNofWAsXG4gICAgcGxhdGZvcm0sXG4gICAgYXJjaCxcbiAgICBhYmksXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN5c3RlbURlZmF1bHRUYXJnZXQoKTogVGFyZ2V0IHtcbiAgY29uc3QgaG9zdCA9IGV4ZWNTeW5jKGBydXN0YyAtdlZgLCB7XG4gICAgZW52OiBwcm9jZXNzLmVudixcbiAgfSlcbiAgICAudG9TdHJpbmcoJ3V0ZjgnKVxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuZmluZCgobGluZSkgPT4gbGluZS5zdGFydHNXaXRoKCdob3N0OiAnKSlcbiAgY29uc3QgdHJpcGxlID0gaG9zdD8uc2xpY2UoJ2hvc3Q6ICcubGVuZ3RoKVxuICBpZiAoIXRyaXBsZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbiBub3QgcGFyc2UgdGFyZ2V0IHRyaXBsZSBmcm9tIGhvc3RgKVxuICB9XG4gIHJldHVybiBwYXJzZVRyaXBsZSh0cmlwbGUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUYXJnZXRMaW5rZXIodGFyZ2V0OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gVEFSR0VUX0xJTktFUlt0YXJnZXRdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YXJnZXRUb0VudlZhcih0YXJnZXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB0YXJnZXQucmVwbGFjZSgvLS9nLCAnXycpLnRvVXBwZXJDYXNlKClcbn1cbiIsImV4cG9ydCBlbnVtIE5hcGlWZXJzaW9uIHtcbiAgTmFwaTEgPSAxLFxuICBOYXBpMixcbiAgTmFwaTMsXG4gIE5hcGk0LFxuICBOYXBpNSxcbiAgTmFwaTYsXG4gIE5hcGk3LFxuICBOYXBpOCxcbiAgTmFwaTksXG59XG5cbi8vLyBiZWNhdXNlIG5vZGUgc3VwcG9ydCBuZXcgbmFwaSB2ZXJzaW9uIGluIHNvbWUgbWlub3IgdmVyc2lvbiB1cGRhdGVzLCBzbyB3ZSBtaWdodCBtZWV0IHN1Y2ggc2l0dWF0aW9uOlxuLy8vIGBub2RlIHYxMC4yMC4wYCBzdXBwb3J0cyBgbmFwaTVgIGFuZCBgbmFwaTZgLCBidXQgYG5vZGUgdjEyLjAuMGAgb25seSBzdXBwb3J0IGBuYXBpNGAsXG4vLy8gYnkgd2hpY2gsIHdlIGNhbiBub3QgdGVsbCBkaXJlY3RseSBuYXBpIHZlcnNpb24gc3VwcG9ydGxlc3MgZnJvbSBub2RlIHZlcnNpb24gZGlyZWN0bHkuXG5jb25zdCBOQVBJX1ZFUlNJT05fTUFUUklYID0gbmV3IE1hcDxOYXBpVmVyc2lvbiwgc3RyaW5nPihbXG4gIFtOYXBpVmVyc2lvbi5OYXBpMSwgJzguNi4wIHwgOS4wLjAgfCAxMC4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGkyLCAnOC4xMC4wIHwgOS4zLjAgfCAxMC4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGkzLCAnNi4xNC4yIHwgOC4xMS4yIHwgOS4xMS4wIHwgMTAuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNCwgJzEwLjE2LjAgfCAxMS44LjAgfCAxMi4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk1LCAnMTAuMTcuMCB8IDEyLjExLjAgfCAxMy4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk2LCAnMTAuMjAuMCB8IDEyLjE3LjAgfCAxNC4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk3LCAnMTAuMjMuMCB8IDEyLjE5LjAgfCAxNC4xMi4wIHwgMTUuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpOCwgJzEyLjIyLjAgfCAxNC4xNy4wIHwgMTUuMTIuMCB8IDE2LjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTksICcxOC4xNy4wIHwgMjAuMy4wIHwgMjEuMS4wJ10sXG5dKVxuXG5pbnRlcmZhY2UgTm9kZVZlcnNpb24ge1xuICBtYWpvcjogbnVtYmVyXG4gIG1pbm9yOiBudW1iZXJcbiAgcGF0Y2g6IG51bWJlclxufVxuXG5mdW5jdGlvbiBwYXJzZU5vZGVWZXJzaW9uKHY6IHN0cmluZyk6IE5vZGVWZXJzaW9uIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHYubWF0Y2goL3Y/KFswLTldKylcXC4oWzAtOV0rKVxcLihbMC05XSspL2kpXG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdmVyc2lvbiBudW1iZXI6ICcgKyB2KVxuICB9XG5cbiAgY29uc3QgWywgbWFqb3IsIG1pbm9yLCBwYXRjaF0gPSBtYXRjaGVzXG5cbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogcGFyc2VJbnQobWFqb3IpLFxuICAgIG1pbm9yOiBwYXJzZUludChtaW5vciksXG4gICAgcGF0Y2g6IHBhcnNlSW50KHBhdGNoKSxcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1aXJlZE5vZGVWZXJzaW9ucyhuYXBpVmVyc2lvbjogTmFwaVZlcnNpb24pOiBOb2RlVmVyc2lvbltdIHtcbiAgY29uc3QgcmVxdWlyZW1lbnQgPSBOQVBJX1ZFUlNJT05fTUFUUklYLmdldChuYXBpVmVyc2lvbilcblxuICBpZiAoIXJlcXVpcmVtZW50KSB7XG4gICAgcmV0dXJuIFtwYXJzZU5vZGVWZXJzaW9uKCcxMC4wLjAnKV1cbiAgfVxuXG4gIHJldHVybiByZXF1aXJlbWVudC5zcGxpdCgnfCcpLm1hcChwYXJzZU5vZGVWZXJzaW9uKVxufVxuXG5mdW5jdGlvbiB0b0VuZ2luZVJlcXVpcmVtZW50KHZlcnNpb25zOiBOb2RlVmVyc2lvbltdKTogc3RyaW5nIHtcbiAgY29uc3QgcmVxdWlyZW1lbnRzOiBzdHJpbmdbXSA9IFtdXG4gIHZlcnNpb25zLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICBsZXQgcmVxID0gJydcbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgY29uc3QgbGFzdFZlcnNpb24gPSB2ZXJzaW9uc1tpIC0gMV1cbiAgICAgIHJlcSArPSBgPCAke2xhc3RWZXJzaW9uLm1ham9yICsgMX1gXG4gICAgfVxuXG4gICAgcmVxICs9IGAke2kgPT09IDAgPyAnJyA6ICcgfHwgJ30+PSAke3YubWFqb3J9LiR7di5taW5vcn0uJHt2LnBhdGNofWBcbiAgICByZXF1aXJlbWVudHMucHVzaChyZXEpXG4gIH0pXG5cbiAgcmV0dXJuIHJlcXVpcmVtZW50cy5qb2luKCcgJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hcGlFbmdpbmVSZXF1aXJlbWVudChuYXBpVmVyc2lvbjogTmFwaVZlcnNpb24pOiBzdHJpbmcge1xuICByZXR1cm4gdG9FbmdpbmVSZXF1aXJlbWVudChyZXF1aXJlZE5vZGVWZXJzaW9ucyhuYXBpVmVyc2lvbikpXG59XG4iLCJpbXBvcnQgeyBzcGF3biB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCBmcyBmcm9tICdub2RlOmZzJ1xuXG5leHBvcnQgdHlwZSBDcmF0ZVRhcmdldEtpbmQgPVxuICB8ICdiaW4nXG4gIHwgJ2V4YW1wbGUnXG4gIHwgJ3Rlc3QnXG4gIHwgJ2JlbmNoJ1xuICB8ICdsaWInXG4gIHwgJ3JsaWInXG4gIHwgJ2NkeWxpYidcbiAgfCAnY3VzdG9tLWJ1aWxkJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENyYXRlVGFyZ2V0IHtcbiAgbmFtZTogc3RyaW5nXG4gIGtpbmQ6IENyYXRlVGFyZ2V0S2luZFtdXG4gIGNyYXRlX3R5cGVzOiBDcmF0ZVRhcmdldEtpbmRbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyYXRlIHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgc3JjX3BhdGg6IHN0cmluZ1xuICB2ZXJzaW9uOiBzdHJpbmdcbiAgZWRpdGlvbjogc3RyaW5nXG4gIHRhcmdldHM6IENyYXRlVGFyZ2V0W11cbiAgZmVhdHVyZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPlxuICBtYW5pZmVzdF9wYXRoOiBzdHJpbmdcbiAgZGVwZW5kZW5jaWVzOiBBcnJheTx7XG4gICAgbmFtZTogc3RyaW5nXG4gICAgc291cmNlOiBzdHJpbmdcbiAgICByZXE6IHN0cmluZ1xuICAgIGtpbmQ6IHN0cmluZyB8IG51bGxcbiAgICByZW5hbWU6IHN0cmluZyB8IG51bGxcbiAgICBvcHRpb25hbDogYm9vbGVhblxuICAgIHVzZXNfZGVmYXVsdF9mZWF0dXJlczogYm9vbGVhblxuICAgIGZlYXR1cmVzOiBzdHJpbmdbXVxuICAgIHRhcmdldDogc3RyaW5nIHwgbnVsbFxuICAgIHJlZ2lzdHJ5OiBzdHJpbmcgfCBudWxsXG4gIH0+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSB7XG4gIHZlcnNpb246IG51bWJlclxuICBwYWNrYWdlczogQ3JhdGVbXVxuICB3b3Jrc3BhY2VfbWVtYmVyczogc3RyaW5nW11cbiAgdGFyZ2V0X2RpcmVjdG9yeTogc3RyaW5nXG4gIHdvcmtzcGFjZV9yb290OiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlTWV0YWRhdGEobWFuaWZlc3RQYXRoOiBzdHJpbmcpIHtcbiAgaWYgKCFmcy5leGlzdHNTeW5jKG1hbmlmZXN0UGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNyYXRlIGZvdW5kIGluIG1hbmlmZXN0OiAke21hbmlmZXN0UGF0aH1gKVxuICB9XG5cbiAgY29uc3QgY2hpbGRQcm9jZXNzID0gc3Bhd24oXG4gICAgJ2NhcmdvJyxcbiAgICBbJ21ldGFkYXRhJywgJy0tbWFuaWZlc3QtcGF0aCcsIG1hbmlmZXN0UGF0aCwgJy0tZm9ybWF0LXZlcnNpb24nLCAnMSddLFxuICAgIHsgc3RkaW86ICdwaXBlJyB9LFxuICApXG5cbiAgbGV0IHN0ZG91dCA9ICcnXG4gIGxldCBzdGRlcnIgPSAnJ1xuICBsZXQgc3RhdHVzID0gMFxuICBsZXQgZXJyb3IgPSBudWxsXG5cbiAgY2hpbGRQcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgc3Rkb3V0ICs9IGRhdGFcbiAgfSlcblxuICBjaGlsZFByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICBzdGRlcnIgKz0gZGF0YVxuICB9KVxuXG4gIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgY2hpbGRQcm9jZXNzLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICBzdGF0dXMgPSBjb2RlID8/IDBcbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH0pXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYXJnbyBtZXRhZGF0YSBmYWlsZWQgdG8gcnVuJywgeyBjYXVzZTogZXJyb3IgfSlcbiAgfVxuICBpZiAoc3RhdHVzICE9PSAwKSB7XG4gICAgY29uc3Qgc2ltcGxlTWVzc2FnZSA9IGBjYXJnbyBtZXRhZGF0YSBleGl0ZWQgd2l0aCBjb2RlICR7c3RhdHVzfWBcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2ltcGxlTWVzc2FnZX0gYW5kIGVycm9yIG1lc3NhZ2U6XFxuXFxuJHtzdGRlcnJ9YCwge1xuICAgICAgY2F1c2U6IG5ldyBFcnJvcihzaW1wbGVNZXNzYWdlKSxcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdGRvdXQpIGFzIENhcmdvV29ya3NwYWNlTWV0YWRhdGFcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIGNhcmdvIG1ldGFkYXRhIEpTT04nLCB7IGNhdXNlOiBlIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IHVuZGVybGluZSwgeWVsbG93IH0gZnJvbSAnY29sb3JldHRlJ1xuaW1wb3J0IHsgbWVyZ2UsIG9taXQgfSBmcm9tICdsb2Rhc2gtZXMnXG5cbmltcG9ydCB7IGZpbGVFeGlzdHMsIHJlYWRGaWxlQXN5bmMgfSBmcm9tICcuL21pc2MuanMnXG5pbXBvcnQgeyBERUZBVUxUX1RBUkdFVFMsIHBhcnNlVHJpcGxlLCBUYXJnZXQgfSBmcm9tICcuL3RhcmdldC5qcydcblxuZXhwb3J0IHR5cGUgVmFsdWVPZkNvbnN0QXJyYXk8VD4gPSBUW0V4Y2x1ZGU8a2V5b2YgVCwga2V5b2YgQXJyYXk8YW55Pj5dXG5cbmV4cG9ydCBjb25zdCBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcnMgPSBbJ3lhcm4nLCAncG5wbSddIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgU3VwcG9ydGVkVGVzdEZyYW1ld29ya3MgPSBbJ2F2YSddIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyID0gVmFsdWVPZkNvbnN0QXJyYXk8XG4gIHR5cGVvZiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcnNcbj5cbmV4cG9ydCB0eXBlIFN1cHBvcnRlZFRlc3RGcmFtZXdvcmsgPSBWYWx1ZU9mQ29uc3RBcnJheTxcbiAgdHlwZW9mIFN1cHBvcnRlZFRlc3RGcmFtZXdvcmtzXG4+XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlck5hcGlDb25maWcge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgYmluYXJ5IHRvIGJlIGdlbmVyYXRlZCwgZGVmYXVsdCB0byBgaW5kZXhgXG4gICAqL1xuICBiaW5hcnlOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBucG0gcGFja2FnZSwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiByb290IHBhY2thZ2UuanNvbiBuYW1lXG4gICAqXG4gICAqIEFsd2F5cyBnaXZlbiBgQHNjb3BlL3BrZ2AgYW5kIGFyY2ggc3VmZml4IHdpbGwgYmUgYXBwZW5kZWQgbGlrZSBgQHNjb3BlL3BrZy1saW51eC1nbnUteDY0YFxuICAgKi9cbiAgcGFja2FnZU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFsbCB0YXJnZXRzIHRoZSBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIGZvclxuICAgKi9cbiAgdGFyZ2V0cz86IHN0cmluZ1tdXG5cbiAgLyoqXG4gICAqIFRoZSBucG0gY2xpZW50IHByb2plY3QgdXNlcy5cbiAgICovXG4gIG5wbUNsaWVudD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGdlbmVyYXRlIGNvbnN0IGVudW0gZm9yIHR5cGVzY3JpcHQgYmluZGluZ3NcbiAgICovXG4gIGNvbnN0RW51bT86IGJvb2xlYW5cblxuICAvKipcbiAgICogZHRzIGhlYWRlciBwcmVwZW5kIHRvIHRoZSBnZW5lcmF0ZWQgZHRzIGZpbGVcbiAgICovXG4gIGR0c0hlYWRlcj86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBkdHMgaGVhZGVyIGZpbGUgcGF0aCB0byBiZSBwcmVwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBkdHMgZmlsZVxuICAgKiBpZiBib3RoIGR0c0hlYWRlciBhbmQgZHRzSGVhZGVyRmlsZSBhcmUgcHJvdmlkZWQsIGR0c0hlYWRlckZpbGUgd2lsbCBiZSB1c2VkXG4gICAqL1xuICBkdHNIZWFkZXJGaWxlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIHdhc20gY29tcGlsYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgd2FzbT86IHtcbiAgICAvKipcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYkFzc2VtYmx5L0phdmFTY3JpcHRfaW50ZXJmYWNlL01lbW9yeVxuICAgICAqIEBkZWZhdWx0IDQwMDAgcGFnZXMgKDI1Nk1pQilcbiAgICAgKi9cbiAgICBpbml0aWFsTWVtb3J5PzogbnVtYmVyXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgNjU1MzYgcGFnZXMgKDRHaUIpXG4gICAgICovXG4gICAgbWF4aW11bU1lbW9yeT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogQnJvd3NlciB3YXNtIGJpbmRpbmcgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIGJyb3dzZXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byB1c2UgZnMgbW9kdWxlIGluIGJyb3dzZXJcbiAgICAgICAqL1xuICAgICAgZnM/OiBib29sZWFuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gaW5pdGlhbGl6ZSB3YXNtIGFzeW5jaHJvbm91c2x5XG4gICAgICAgKi9cbiAgICAgIGFzeW5jSW5pdD86IGJvb2xlYW5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBpbmplY3QgYGJ1ZmZlcmAgdG8gZW1uYXBpIGNvbnRleHRcbiAgICAgICAqL1xuICAgICAgYnVmZmVyPzogYm9vbGVhblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBiaW5hcnlOYW1lIGluc3RlYWRcbiAgICovXG4gIG5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBwYWNrYWdlTmFtZSBpbnN0ZWFkXG4gICAqL1xuICBwYWNrYWdlPzoge1xuICAgIG5hbWU/OiBzdHJpbmdcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHRhcmdldHMgaW5zdGVhZFxuICAgKi9cbiAgdHJpcGxlcz86IHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBkZWZhdWx0IHRhcmdldHNcbiAgICAgKi9cbiAgICBkZWZhdWx0czogYm9vbGVhblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgdGFyZ2V0cyB0byBiZSBjb21waWxlZCBmb3JcbiAgICAgKi9cbiAgICBhZGRpdGlvbmFsPzogc3RyaW5nW11cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbW1vblBhY2thZ2VKc29uRmllbGRzIHtcbiAgbmFtZTogc3RyaW5nXG4gIHZlcnNpb246IHN0cmluZ1xuICBkZXNjcmlwdGlvbj86IHN0cmluZ1xuICBrZXl3b3Jkcz86IHN0cmluZ1tdXG4gIGF1dGhvcj86IHN0cmluZ1xuICBhdXRob3JzPzogc3RyaW5nW11cbiAgbGljZW5zZT86IHN0cmluZ1xuICBjcHU/OiBzdHJpbmdbXVxuICBvcz86IHN0cmluZ1tdXG4gIGxpYmM/OiBzdHJpbmdbXVxuICBmaWxlcz86IHN0cmluZ1tdXG4gIHJlcG9zaXRvcnk/OiBhbnlcbiAgaG9tZXBhZ2U/OiBhbnlcbiAgZW5naW5lcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgcHVibGlzaENvbmZpZz86IGFueVxuICBidWdzPzogYW55XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBuYXBpPzogVXNlck5hcGlDb25maWdcbiAgdHlwZT86ICdtb2R1bGUnIHwgJ2NvbW1vbmpzJ1xuICBzY3JpcHRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXG4gIC8vIG1vZHVsZXNcbiAgbWFpbj86IHN0cmluZ1xuICBtb2R1bGU/OiBzdHJpbmdcbiAgdHlwZXM/OiBzdHJpbmdcbiAgYnJvd3Nlcj86IHN0cmluZ1xuICBleHBvcnRzPzogYW55XG5cbiAgZGVwZW5kZW5jaWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBkZXZEZXBlbmRlbmNpZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cbiAgYXZhPzoge1xuICAgIHRpbWVvdXQ/OiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBOYXBpQ29uZmlnID0gUmVxdWlyZWQ8XG4gIFBpY2s8VXNlck5hcGlDb25maWcsICdiaW5hcnlOYW1lJyB8ICdwYWNrYWdlTmFtZScgfCAnbnBtQ2xpZW50Jz5cbj4gJlxuICBQaWNrPFVzZXJOYXBpQ29uZmlnLCAnd2FzbScgfCAnZHRzSGVhZGVyJyB8ICdkdHNIZWFkZXJGaWxlJyB8ICdjb25zdEVudW0nPiAmIHtcbiAgICB0YXJnZXRzOiBUYXJnZXRbXVxuICAgIHBhY2thZ2VKc29uOiBDb21tb25QYWNrYWdlSnNvbkZpZWxkc1xuICB9XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkTmFwaUNvbmZpZyhcbiAgcGF0aDogc3RyaW5nLFxuICBjb25maWdQYXRoPzogc3RyaW5nLFxuKTogUHJvbWlzZTxOYXBpQ29uZmlnPiB7XG4gIGlmIChjb25maWdQYXRoICYmICEoYXdhaXQgZmlsZUV4aXN0cyhjb25maWdQYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5BUEktUlMgY29uZmlnIG5vdCBmb3VuZCBhdCAke2NvbmZpZ1BhdGh9YClcbiAgfVxuICBpZiAoIShhd2FpdCBmaWxlRXhpc3RzKHBhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFja2FnZS5qc29uIG5vdCBmb3VuZCBhdCAke3BhdGh9YClcbiAgfVxuICAvLyBNYXkgc3VwcG9ydCBtdWx0aXBsZSBjb25maWcgc291cmNlcyBsYXRlciBvbi5cbiAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMocGF0aCwgJ3V0ZjgnKVxuICBsZXQgcGtnSnNvblxuICB0cnkge1xuICAgIHBrZ0pzb24gPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIENvbW1vblBhY2thZ2VKc29uRmllbGRzXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBwYWNrYWdlLmpzb24gYXQgJHtwYXRofWAsIHtcbiAgICAgIGNhdXNlOiBlLFxuICAgIH0pXG4gIH1cblxuICBsZXQgc2VwYXJhdGVkQ29uZmlnOiBVc2VyTmFwaUNvbmZpZyB8IHVuZGVmaW5lZFxuICBpZiAoY29uZmlnUGF0aCkge1xuICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGNvbmZpZ1BhdGgsICd1dGY4JylcbiAgICB0cnkge1xuICAgICAgc2VwYXJhdGVkQ29uZmlnID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KSBhcyBVc2VyTmFwaUNvbmZpZ1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIE5BUEktUlMgY29uZmlnIGF0ICR7Y29uZmlnUGF0aH1gLCB7XG4gICAgICAgIGNhdXNlOiBlLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCB1c2VyTmFwaUNvbmZpZyA9IHBrZ0pzb24ubmFwaSA/PyB7fVxuICBpZiAocGtnSnNvbi5uYXBpICYmIHNlcGFyYXRlZENvbmZpZykge1xuICAgIGNvbnN0IHBrZ0pzb25QYXRoID0gdW5kZXJsaW5lKHBhdGgpXG4gICAgY29uc3QgY29uZmlnUGF0aFVuZGVybGluZSA9IHVuZGVybGluZShjb25maWdQYXRoISlcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICB5ZWxsb3coXG4gICAgICAgIGBCb3RoIG5hcGkgZmllbGQgaW4gJHtwa2dKc29uUGF0aH0gYW5kIFtOQVBJLVJTIGNvbmZpZ10oJHtjb25maWdQYXRoVW5kZXJsaW5lfSkgZmlsZSBhcmUgZm91bmQsIHRoZSBOQVBJLVJTIGNvbmZpZyBmaWxlIHdpbGwgYmUgdXNlZC5gLFxuICAgICAgKSxcbiAgICApXG4gICAgT2JqZWN0LmFzc2lnbih1c2VyTmFwaUNvbmZpZywgc2VwYXJhdGVkQ29uZmlnKVxuICB9XG4gIGNvbnN0IG5hcGlDb25maWc6IE5hcGlDb25maWcgPSBtZXJnZShcbiAgICB7XG4gICAgICBiaW5hcnlOYW1lOiAnaW5kZXgnLFxuICAgICAgcGFja2FnZU5hbWU6IHBrZ0pzb24ubmFtZSxcbiAgICAgIHRhcmdldHM6IFtdLFxuICAgICAgcGFja2FnZUpzb246IHBrZ0pzb24sXG4gICAgICBucG1DbGllbnQ6ICducG0nLFxuICAgIH0sXG4gICAgb21pdCh1c2VyTmFwaUNvbmZpZywgJ3RhcmdldHMnKSxcbiAgKVxuXG4gIGxldCB0YXJnZXRzOiBzdHJpbmdbXSA9IHVzZXJOYXBpQ29uZmlnLnRhcmdldHMgPz8gW11cblxuICAvLyBjb21wYXRpYmxlIHdpdGggb2xkIGNvbmZpZ1xuICBpZiAodXNlck5hcGlDb25maWc/Lm5hbWUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICB5ZWxsb3coXG4gICAgICAgIGBbREVQUkVDQVRFRF0gbmFwaS5uYW1lIGlzIGRlcHJlY2F0ZWQsIHVzZSBuYXBpLmJpbmFyeU5hbWUgaW5zdGVhZC5gLFxuICAgICAgKSxcbiAgICApXG4gICAgbmFwaUNvbmZpZy5iaW5hcnlOYW1lID0gdXNlck5hcGlDb25maWcubmFtZVxuICB9XG5cbiAgaWYgKCF0YXJnZXRzLmxlbmd0aCkge1xuICAgIGxldCBkZXByZWNhdGVkV2FybmVkID0gZmFsc2VcbiAgICBjb25zdCB3YXJuaW5nID0geWVsbG93KFxuICAgICAgYFtERVBSRUNBVEVEXSBuYXBpLnRyaXBsZXMgaXMgZGVwcmVjYXRlZCwgdXNlIG5hcGkudGFyZ2V0cyBpbnN0ZWFkLmAsXG4gICAgKVxuICAgIGlmICh1c2VyTmFwaUNvbmZpZy50cmlwbGVzPy5kZWZhdWx0cykge1xuICAgICAgZGVwcmVjYXRlZFdhcm5lZCA9IHRydWVcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKVxuICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KERFRkFVTFRfVEFSR0VUUylcbiAgICB9XG5cbiAgICBpZiAodXNlck5hcGlDb25maWcudHJpcGxlcz8uYWRkaXRpb25hbD8ubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQodXNlck5hcGlDb25maWcudHJpcGxlcy5hZGRpdGlvbmFsKVxuICAgICAgaWYgKCFkZXByZWNhdGVkV2FybmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZHVwbGljYXRlIHRhcmdldHNcbiAgY29uc3QgdW5pcXVlVGFyZ2V0cyA9IG5ldyBTZXQodGFyZ2V0cylcbiAgaWYgKHVuaXF1ZVRhcmdldHMuc2l6ZSAhPT0gdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICBjb25zdCBkdXBsaWNhdGVUYXJnZXQgPSB0YXJnZXRzLmZpbmQoXG4gICAgICAodGFyZ2V0LCBpbmRleCkgPT4gdGFyZ2V0cy5pbmRleE9mKHRhcmdldCkgIT09IGluZGV4LFxuICAgIClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSB0YXJnZXRzIGFyZSBub3QgYWxsb3dlZDogJHtkdXBsaWNhdGVUYXJnZXR9YClcbiAgfVxuXG4gIG5hcGlDb25maWcudGFyZ2V0cyA9IHRhcmdldHMubWFwKHBhcnNlVHJpcGxlKVxuXG4gIHJldHVybiBuYXBpQ29uZmlnXG59XG4iLCJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcblxuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuL2xvZy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHRyeUluc3RhbGxDYXJnb0JpbmFyeShuYW1lOiBzdHJpbmcsIGJpbjogc3RyaW5nKSB7XG4gIGlmIChkZXRlY3RDYXJnb0JpbmFyeShiaW4pKSB7XG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBhbHJlYWR5IGluc3RhbGxlZDogJXMnLCBuYW1lKVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygnSW5zdGFsbGluZyBjYXJnbyBiaW5hcnk6ICVzJywgbmFtZSlcbiAgICBleGVjU3luYyhgY2FyZ28gaW5zdGFsbCAke25hbWV9YCwge1xuICAgICAgc3RkaW86ICdpbmhlcml0JyxcbiAgICB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5zdGFsbCBjYXJnbyBiaW5hcnk6ICR7bmFtZX1gLCB7XG4gICAgICBjYXVzZTogZSxcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVjdENhcmdvQmluYXJ5KGJpbjogc3RyaW5nKSB7XG4gIGRlYnVnKCdEZXRlY3RpbmcgY2FyZ28gYmluYXJ5OiAlcycsIGJpbilcbiAgdHJ5IHtcbiAgICBleGVjU3luYyhgY2FyZ28gaGVscCAke2Jpbn1gLCB7XG4gICAgICBzdGRpbzogJ2lnbm9yZScsXG4gICAgfSlcbiAgICBkZWJ1ZygnQ2FyZ28gYmluYXJ5IGRldGVjdGVkOiAlcycsIGJpbilcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIHtcbiAgICBkZWJ1ZygnQ2FyZ28gYmluYXJ5IG5vdCBkZXRlY3RlZDogJXMnLCBiaW4pXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsImltcG9ydCB7IHNvcnRCeSB9IGZyb20gJ2xvZGFzaC1lcydcblxuaW1wb3J0IHsgcmVhZEZpbGVBc3luYyB9IGZyb20gJy4vbWlzYy5qcydcblxuY29uc3QgVE9QX0xFVkVMX05BTUVTUEFDRSA9ICdfX1RPUF9MRVZFTF9NT0RVTEVfXydcbmV4cG9ydCBjb25zdCBERUZBVUxUX1RZUEVfREVGX0hFQURFUiA9IGAvKiBhdXRvLWdlbmVyYXRlZCBieSBOQVBJLVJTICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuYFxuXG5lbnVtIFR5cGVEZWZLaW5kIHtcbiAgQ29uc3QgPSAnY29uc3QnLFxuICBFbnVtID0gJ2VudW0nLFxuICBTdHJpbmdFbnVtID0gJ3N0cmluZ19lbnVtJyxcbiAgSW50ZXJmYWNlID0gJ2ludGVyZmFjZScsXG4gIFR5cGUgPSAndHlwZScsXG4gIEZuID0gJ2ZuJyxcbiAgU3RydWN0ID0gJ3N0cnVjdCcsXG4gIEltcGwgPSAnaW1wbCcsXG59XG5cbmludGVyZmFjZSBUeXBlRGVmTGluZSB7XG4gIGtpbmQ6IFR5cGVEZWZLaW5kXG4gIG5hbWU6IHN0cmluZ1xuICBvcmlnaW5hbF9uYW1lPzogc3RyaW5nXG4gIGRlZjogc3RyaW5nXG4gIGpzX2RvYz86IHN0cmluZ1xuICBqc19tb2Q/OiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gcHJldHR5UHJpbnQoXG4gIGxpbmU6IFR5cGVEZWZMaW5lLFxuICBjb25zdEVudW06IGJvb2xlYW4sXG4gIGlkZW50OiBudW1iZXIsXG4gIGFtYmllbnQgPSBmYWxzZSxcbik6IHN0cmluZyB7XG4gIGxldCBzID0gbGluZS5qc19kb2MgPz8gJydcbiAgc3dpdGNoIChsaW5lLmtpbmQpIHtcbiAgICBjYXNlIFR5cGVEZWZLaW5kLkludGVyZmFjZTpcbiAgICAgIHMgKz0gYGV4cG9ydCBpbnRlcmZhY2UgJHtsaW5lLm5hbWV9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5UeXBlOlxuICAgICAgcyArPSBgZXhwb3J0IHR5cGUgJHtsaW5lLm5hbWV9ID0gXFxuJHtsaW5lLmRlZn1gXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5FbnVtOlxuICAgICAgY29uc3QgZW51bU5hbWUgPSBjb25zdEVudW0gPyAnY29uc3QgZW51bScgOiAnZW51bSdcbiAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gJHtlbnVtTmFtZX0gJHtsaW5lLm5hbWV9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5TdHJpbmdFbnVtOlxuICAgICAgaWYgKGNvbnN0RW51bSkge1xuICAgICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9IGNvbnN0IGVudW0gJHtsaW5lLm5hbWV9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzICs9IGBleHBvcnQgdHlwZSAke2xpbmUubmFtZX0gPSAke2xpbmUuZGVmLnJlcGxhY2VBbGwoLy4qPS9nLCAnJykucmVwbGFjZUFsbCgnLCcsICd8Jyl9O2BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cnVjdDpcbiAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gY2xhc3MgJHtsaW5lLm5hbWV9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICBpZiAobGluZS5vcmlnaW5hbF9uYW1lICYmIGxpbmUub3JpZ2luYWxfbmFtZSAhPT0gbGluZS5uYW1lKSB7XG4gICAgICAgIHMgKz0gYFxcbmV4cG9ydCB0eXBlICR7bGluZS5vcmlnaW5hbF9uYW1lfSA9ICR7bGluZS5uYW1lfWBcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLkZuOlxuICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSAke2xpbmUuZGVmfWBcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcyArPSBsaW5lLmRlZlxuICB9XG5cbiAgcmV0dXJuIGNvcnJlY3RTdHJpbmdJZGVudChzLCBpZGVudClcbn1cblxuZnVuY3Rpb24gZXhwb3J0RGVjbGFyZShhbWJpZW50OiBib29sZWFuKTogc3RyaW5nIHtcbiAgaWYgKGFtYmllbnQpIHtcbiAgICByZXR1cm4gJ2V4cG9ydCdcbiAgfVxuXG4gIHJldHVybiAnZXhwb3J0IGRlY2xhcmUnXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzVHlwZURlZihcbiAgaW50ZXJtZWRpYXRlVHlwZUZpbGU6IHN0cmluZyxcbiAgY29uc3RFbnVtOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IGV4cG9ydHM6IHN0cmluZ1tdID0gW11cbiAgY29uc3QgZGVmcyA9IGF3YWl0IHJlYWRJbnRlcm1lZGlhdGVUeXBlRmlsZShpbnRlcm1lZGlhdGVUeXBlRmlsZSlcbiAgY29uc3QgZ3JvdXBlZERlZnMgPSBwcmVwcm9jZXNzVHlwZURlZihkZWZzKVxuXG4gIGNvbnN0IGR0cyA9XG4gICAgc29ydEJ5KEFycmF5LmZyb20oZ3JvdXBlZERlZnMpLCAoW25hbWVzcGFjZV0pID0+IG5hbWVzcGFjZSlcbiAgICAgIC5tYXAoKFtuYW1lc3BhY2UsIGRlZnNdKSA9PiB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09IFRPUF9MRVZFTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gZGVmc1xuICAgICAgICAgICAgLm1hcCgoZGVmKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZGVmLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLkNvbnN0OlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuRW51bTpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cmluZ0VudW06XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5GbjpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cnVjdDoge1xuICAgICAgICAgICAgICAgICAgZXhwb3J0cy5wdXNoKGRlZi5uYW1lKVxuICAgICAgICAgICAgICAgICAgaWYgKGRlZi5vcmlnaW5hbF9uYW1lICYmIGRlZi5vcmlnaW5hbF9uYW1lICE9PSBkZWYubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLnB1c2goZGVmLm9yaWdpbmFsX25hbWUpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcHJldHR5UHJpbnQoZGVmLCBjb25zdEVudW0sIDApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcblxcbicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwb3J0cy5wdXNoKG5hbWVzcGFjZSlcbiAgICAgICAgICBsZXQgZGVjbGFyYXRpb24gPSAnJ1xuICAgICAgICAgIGRlY2xhcmF0aW9uICs9IGBleHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgJHtuYW1lc3BhY2V9IHtcXG5gXG4gICAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xuICAgICAgICAgICAgZGVjbGFyYXRpb24gKz0gcHJldHR5UHJpbnQoZGVmLCBjb25zdEVudW0sIDIsIHRydWUpICsgJ1xcbidcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVjbGFyYXRpb24gKz0gJ30nXG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuam9pbignXFxuXFxuJykgKyAnXFxuJ1xuXG4gIHJldHVybiB7XG4gICAgZHRzLFxuICAgIGV4cG9ydHMsXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEludGVybWVkaWF0ZVR5cGVGaWxlKGZpbGU6IHN0cmluZykge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhmaWxlLCAndXRmOCcpXG5cbiAgY29uc3QgZGVmcyA9IGNvbnRlbnRcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKVxuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShsaW5lKSBhcyBUeXBlRGVmTGluZVxuICAgICAgLy8gQ29udmVydCBlc2NhcGVkIG5ld2xpbmVzIGJhY2sgdG8gYWN0dWFsIG5ld2xpbmVzIGluIGpzX2RvYyBmaWVsZHNcbiAgICAgIGlmIChwYXJzZWQuanNfZG9jKSB7XG4gICAgICAgIHBhcnNlZC5qc19kb2MgPSBwYXJzZWQuanNfZG9jLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgfVxuICAgICAgLy8gQ29udmVydCBlc2NhcGVkIG5ld2xpbmVzIHRvIGFjdHVhbCBuZXdsaW5lcyBpbiBkZWYgZmllbGRzIGZvciBzdHJ1Y3QvY2xhc3MvaW50ZXJmYWNlL3R5cGUgdHlwZXNcbiAgICAgIC8vIHdoZXJlIFxcbiByZXByZXNlbnRzIG1ldGhvZC9maWVsZCBzZXBhcmF0b3JzIHRoYXQgc2hvdWxkIGJlIGFjdHVhbCBuZXdsaW5lc1xuICAgICAgaWYgKHBhcnNlZC5kZWYpIHtcbiAgICAgICAgcGFyc2VkLmRlZiA9IHBhcnNlZC5kZWYucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkXG4gICAgfSlcblxuICAvLyBtb3ZlIGFsbCBgc3RydWN0YCBkZWYgdG8gdGhlIHZlcnkgdG9wXG4gIC8vIGFuZCBvcmRlciB0aGUgcmVzdCBhbHBoYWJldGljYWxseS5cbiAgcmV0dXJuIGRlZnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgaWYgKGIua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKGIua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1R5cGVEZWYoZGVmczogVHlwZURlZkxpbmVbXSk6IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lW10+IHtcbiAgY29uc3QgbmFtZXNwYWNlR3JvdXBlZCA9IG5ldyBNYXA8c3RyaW5nLCBUeXBlRGVmTGluZVtdPigpXG4gIGNvbnN0IGNsYXNzRGVmcyA9IG5ldyBNYXA8c3RyaW5nLCBUeXBlRGVmTGluZT4oKVxuXG4gIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSBkZWYuanNfbW9kID8/IFRPUF9MRVZFTF9OQU1FU1BBQ0VcbiAgICBpZiAoIW5hbWVzcGFjZUdyb3VwZWQuaGFzKG5hbWVzcGFjZSkpIHtcbiAgICAgIG5hbWVzcGFjZUdyb3VwZWQuc2V0KG5hbWVzcGFjZSwgW10pXG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXAgPSBuYW1lc3BhY2VHcm91cGVkLmdldChuYW1lc3BhY2UpIVxuXG4gICAgaWYgKGRlZi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgIGdyb3VwLnB1c2goZGVmKVxuICAgICAgY2xhc3NEZWZzLnNldChkZWYubmFtZSwgZGVmKVxuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFR5cGVEZWZLaW5kLkltcGwpIHtcbiAgICAgIC8vIG1lcmdlIGBpbXBsYCBpbnRvIGNsYXNzIGRlZmluaXRpb25cbiAgICAgIGNvbnN0IGNsYXNzRGVmID0gY2xhc3NEZWZzLmdldChkZWYubmFtZSlcbiAgICAgIGlmIChjbGFzc0RlZikge1xuICAgICAgICBpZiAoY2xhc3NEZWYuZGVmKSB7XG4gICAgICAgICAgY2xhc3NEZWYuZGVmICs9ICdcXG4nXG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc0RlZi5kZWYgKz0gZGVmLmRlZlxuICAgICAgICAvLyBDb252ZXJ0IGFueSByZW1haW5pbmcgXFxuIHNlcXVlbmNlcyBpbiB0aGUgbWVyZ2VkIGRlZiB0byBhY3R1YWwgbmV3bGluZXNcbiAgICAgICAgaWYgKGNsYXNzRGVmLmRlZikge1xuICAgICAgICAgIGNsYXNzRGVmLmRlZiA9IGNsYXNzRGVmLmRlZi5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5wdXNoKGRlZilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZXNwYWNlR3JvdXBlZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29ycmVjdFN0cmluZ0lkZW50KHNyYzogc3RyaW5nLCBpZGVudDogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IGJyYWNrZXREZXB0aCA9IDBcbiAgY29uc3QgcmVzdWx0ID0gc3JjXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKVxuICAgICAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0luTXVsdGlsaW5lQ29tbWVudCA9IGxpbmUuc3RhcnRzV2l0aCgnKicpXG4gICAgICBjb25zdCBpc0Nsb3NpbmdCcmFja2V0ID0gbGluZS5lbmRzV2l0aCgnfScpXG4gICAgICBjb25zdCBpc09wZW5pbmdCcmFja2V0ID0gbGluZS5lbmRzV2l0aCgneycpXG4gICAgICBjb25zdCBpc1R5cGVEZWNsYXJhdGlvbiA9IGxpbmUuZW5kc1dpdGgoJz0nKVxuICAgICAgY29uc3QgaXNUeXBlVmFyaWFudCA9IGxpbmUuc3RhcnRzV2l0aCgnfCcpXG5cbiAgICAgIGxldCByaWdodEluZGVudCA9IGlkZW50XG4gICAgICBpZiAoKGlzT3BlbmluZ0JyYWNrZXQgfHwgaXNUeXBlRGVjbGFyYXRpb24pICYmICFpc0luTXVsdGlsaW5lQ29tbWVudCkge1xuICAgICAgICBicmFja2V0RGVwdGggKz0gMVxuICAgICAgICByaWdodEluZGVudCArPSAoYnJhY2tldERlcHRoIC0gMSkgKiAyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNDbG9zaW5nQnJhY2tldCAmJlxuICAgICAgICAgIGJyYWNrZXREZXB0aCA+IDAgJiZcbiAgICAgICAgICAhaXNJbk11bHRpbGluZUNvbW1lbnQgJiZcbiAgICAgICAgICAhaXNUeXBlVmFyaWFudFxuICAgICAgICApIHtcbiAgICAgICAgICBicmFja2V0RGVwdGggLT0gMVxuICAgICAgICB9XG4gICAgICAgIHJpZ2h0SW5kZW50ICs9IGJyYWNrZXREZXB0aCAqIDJcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSW5NdWx0aWxpbmVDb21tZW50KSB7XG4gICAgICAgIHJpZ2h0SW5kZW50ICs9IDFcbiAgICAgIH1cblxuICAgICAgY29uc3QgcyA9IGAkeycgJy5yZXBlYXQocmlnaHRJbmRlbnQpfSR7bGluZX1gXG5cbiAgICAgIHJldHVybiBzXG4gICAgfSlcbiAgICAuam9pbignXFxuJylcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJpbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyByZWFkTmFwaUNvbmZpZyB9IGZyb20gJy4vY29uZmlnLmpzJ1xuXG5pbnRlcmZhY2UgTWluaW1hbE5hcGlPcHRpb25zIHtcbiAgY3dkOiBzdHJpbmdcbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRDb25maWcob3B0aW9uczogTWluaW1hbE5hcGlPcHRpb25zKSB7XG4gIGNvbnN0IHJlc29sdmVQYXRoID0gKC4uLnBhdGhzOiBzdHJpbmdbXSkgPT4gcmVzb2x2ZShvcHRpb25zLmN3ZCwgLi4ucGF0aHMpXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHJlc29sdmVQYXRoKFxuICAgICAgb3B0aW9ucy5jb25maWdQYXRoID8/IG9wdGlvbnMucGFja2FnZUpzb25QYXRoID8/ICdwYWNrYWdlLmpzb24nLFxuICAgICksXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZVBhdGgob3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuICByZXR1cm4gY29uZmlnXG59XG4iLCJpbXBvcnQgeyBqb2luLCBwYXJzZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9yZXR0ZSdcblxuaW1wb3J0IHtcbiAgYXBwbHlEZWZhdWx0QXJ0aWZhY3RzT3B0aW9ucyxcbiAgQXJ0aWZhY3RzT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL2FydGlmYWN0cy5qcydcbmltcG9ydCB7XG4gIHJlYWROYXBpQ29uZmlnLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIHJlYWRGaWxlQXN5bmMsXG4gIHdyaXRlRmlsZUFzeW5jLFxuICBVbmlBcmNoc0J5UGxhdGZvcm0sXG4gIHJlYWRkaXJBc3luYyxcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdhcnRpZmFjdHMnKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29sbGVjdEFydGlmYWN0cyh1c2VyT3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0QXJ0aWZhY3RzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcbiAgY29uc3QgeyB0YXJnZXRzLCBiaW5hcnlOYW1lLCBwYWNrYWdlTmFtZSB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhwYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgZGlzdERpcnMgPSB0YXJnZXRzLm1hcCgocGxhdGZvcm0pID0+XG4gICAgam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5ucG1EaXIsIHBsYXRmb3JtLnBsYXRmb3JtQXJjaEFCSSksXG4gIClcblxuICBjb25zdCB1bml2ZXJzYWxTb3VyY2VCaW5zID0gbmV3IFNldChcbiAgICB0YXJnZXRzXG4gICAgICAuZmlsdGVyKChwbGF0Zm9ybSkgPT4gcGxhdGZvcm0uYXJjaCA9PT0gJ3VuaXZlcnNhbCcpXG4gICAgICAuZmxhdE1hcCgocCkgPT5cbiAgICAgICAgVW5pQXJjaHNCeVBsYXRmb3JtW3AucGxhdGZvcm1dPy5tYXAoKGEpID0+IGAke3AucGxhdGZvcm19LSR7YX1gKSxcbiAgICAgIClcbiAgICAgIC5maWx0ZXIoQm9vbGVhbikgYXMgc3RyaW5nW10sXG4gIClcblxuICBhd2FpdCBjb2xsZWN0Tm9kZUJpbmFyaWVzKGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMub3V0cHV0RGlyKSkudGhlbihcbiAgICAob3V0cHV0KSA9PlxuICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgIG91dHB1dC5tYXAoYXN5bmMgKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgICAgZGVidWcuaW5mbyhgUmVhZCBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KGZpbGVQYXRoKX1dYClcbiAgICAgICAgICBjb25zdCBzb3VyY2VDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhmaWxlUGF0aClcbiAgICAgICAgICBjb25zdCBwYXJzZWROYW1lID0gcGFyc2UoZmlsZVBhdGgpXG4gICAgICAgICAgY29uc3QgdGVybXMgPSBwYXJzZWROYW1lLm5hbWUuc3BsaXQoJy4nKVxuICAgICAgICAgIGNvbnN0IHBsYXRmb3JtQXJjaEFCSSA9IHRlcm1zLnBvcCgpIVxuICAgICAgICAgIGNvbnN0IF9iaW5hcnlOYW1lID0gdGVybXMuam9pbignLicpXG5cbiAgICAgICAgICBpZiAoX2JpbmFyeU5hbWUgIT09IGJpbmFyeU5hbWUpIHtcbiAgICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAgIGBbJHtfYmluYXJ5TmFtZX1dIGlzIG5vdCBtYXRjaGVkIHdpdGggWyR7YmluYXJ5TmFtZX1dLCBza2lwYCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkaXIgPSBkaXN0RGlycy5maW5kKChkaXIpID0+IGRpci5pbmNsdWRlcyhwbGF0Zm9ybUFyY2hBQkkpKVxuICAgICAgICAgIGlmICghZGlyICYmIHVuaXZlcnNhbFNvdXJjZUJpbnMuaGFzKHBsYXRmb3JtQXJjaEFCSSkpIHtcbiAgICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAgIGBbJHtwbGF0Zm9ybUFyY2hBQkl9XSBoYXMgbm8gZGlzdCBkaXIgYnV0IGl0IGlzIHNvdXJjZSBiaW4gZm9yIHVuaXZlcnNhbCBhcmNoLCBza2lwYCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkaXN0IGRpciBmb3VuZCBmb3IgJHtmaWxlUGF0aH1gKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRpc3RGaWxlUGF0aCA9IGpvaW4oZGlyLCBwYXJzZWROYW1lLmJhc2UpXG4gICAgICAgICAgZGVidWcuaW5mbyhcbiAgICAgICAgICAgIGBXcml0ZSBmaWxlIGNvbnRlbnQgdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodChkaXN0RmlsZVBhdGgpfV1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkaXN0RmlsZVBhdGgsIHNvdXJjZUNvbnRlbnQpXG4gICAgICAgICAgY29uc3QgZGlzdEZpbGVQYXRoTG9jYWwgPSBqb2luKFxuICAgICAgICAgICAgcGFyc2UocGFja2FnZUpzb25QYXRoKS5kaXIsXG4gICAgICAgICAgICBwYXJzZWROYW1lLmJhc2UsXG4gICAgICAgICAgKVxuICAgICAgICAgIGRlYnVnLmluZm8oXG4gICAgICAgICAgICBgV3JpdGUgZmlsZSBjb250ZW50IHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoZGlzdEZpbGVQYXRoTG9jYWwpfV1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkaXN0RmlsZVBhdGhMb2NhbCwgc291cmNlQ29udGVudClcbiAgICAgICAgfSksXG4gICAgICApLFxuICApXG5cbiAgY29uc3Qgd2FzaVRhcmdldCA9IHRhcmdldHMuZmluZCgodCkgPT4gdC5wbGF0Zm9ybSA9PT0gJ3dhc2knKVxuICBpZiAod2FzaVRhcmdldCkge1xuICAgIGNvbnN0IHdhc2lEaXIgPSBqb2luKFxuICAgICAgb3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm5wbURpcixcbiAgICAgIHdhc2lUYXJnZXQucGxhdGZvcm1BcmNoQUJJLFxuICAgIClcbiAgICBjb25zdCBjanNGaWxlID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgJHtiaW5hcnlOYW1lfS53YXNpLmNqc2AsXG4gICAgKVxuICAgIGNvbnN0IHdvcmtlckZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGB3YXNpLXdvcmtlci5tanNgLFxuICAgIClcbiAgICBjb25zdCBicm93c2VyRW50cnkgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGAke2JpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgKVxuICAgIGNvbnN0IGJyb3dzZXJXb3JrZXJGaWxlID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgd2FzaS13b3JrZXItYnJvd3Nlci5tanNgLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSBiaW5kaW5nIGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgY2pzRmlsZSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYCR7YmluYXJ5TmFtZX0ud2FzaS5janNgKSxcbiAgICAgIGF3YWl0IHJlYWRGaWxlQXN5bmMoY2pzRmlsZSksXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIHdvcmtlciBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIHdvcmtlckZpbGUsXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGB3YXNpLXdvcmtlci5tanNgKSxcbiAgICAgIGF3YWl0IHJlYWRGaWxlQXN5bmMod29ya2VyRmlsZSksXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIGJyb3dzZXIgZW50cnkgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICBicm93c2VyRW50cnksXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGAke2JpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2ApLFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy84NDI3XG4gICAgICAoYXdhaXQgcmVhZEZpbGVBc3luYyhicm93c2VyRW50cnksICd1dGY4JykpLnJlcGxhY2UoXG4gICAgICAgIGBuZXcgVVJMKCcuL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKWAsXG4gICAgICAgIGBuZXcgVVJMKCcke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaS93YXNpLXdvcmtlci1icm93c2VyLm1qcycsIGltcG9ydC5tZXRhLnVybClgLFxuICAgICAgKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgYnJvd3NlciB3b3JrZXIgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICBicm93c2VyV29ya2VyRmlsZSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCksXG4gICAgICBhd2FpdCByZWFkRmlsZUFzeW5jKGJyb3dzZXJXb3JrZXJGaWxlKSxcbiAgICApXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29sbGVjdE5vZGVCaW5hcmllcyhyb290OiBzdHJpbmcpIHtcbiAgY29uc3QgZmlsZXMgPSBhd2FpdCByZWFkZGlyQXN5bmMocm9vdCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pXG4gIGNvbnN0IG5vZGVCaW5hcmllcyA9IGZpbGVzXG4gICAgLmZpbHRlcihcbiAgICAgIChmaWxlKSA9PlxuICAgICAgICBmaWxlLmlzRmlsZSgpICYmXG4gICAgICAgIChmaWxlLm5hbWUuZW5kc1dpdGgoJy5ub2RlJykgfHwgZmlsZS5uYW1lLmVuZHNXaXRoKCcud2FzbScpKSxcbiAgICApXG4gICAgLm1hcCgoZmlsZSkgPT4gam9pbihyb290LCBmaWxlLm5hbWUpKVxuXG4gIGNvbnN0IGRpcnMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUuaXNEaXJlY3RvcnkoKSlcbiAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgIGlmIChkaXIubmFtZSAhPT0gJ25vZGVfbW9kdWxlcycpIHtcbiAgICAgIG5vZGVCaW5hcmllcy5wdXNoKC4uLihhd2FpdCBjb2xsZWN0Tm9kZUJpbmFyaWVzKGpvaW4ocm9vdCwgZGlyLm5hbWUpKSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlQmluYXJpZXNcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDanNCaW5kaW5nKFxuICBsb2NhbE5hbWU6IHN0cmluZyxcbiAgcGtnTmFtZTogc3RyaW5nLFxuICBpZGVudHM6IHN0cmluZ1tdLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2JpbmRpbmdIZWFkZXJ9XG5jb25zdCB7IGNyZWF0ZVJlcXVpcmUgfSA9IHJlcXVpcmUoJ25vZGU6bW9kdWxlJylcbnJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKF9fZmlsZW5hbWUpXG5cbiR7Y3JlYXRlQ29tbW9uQmluZGluZyhsb2NhbE5hbWUsIHBrZ05hbWUpfVxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVCaW5kaW5nXG4ke2lkZW50c1xuICAubWFwKChpZGVudCkgPT4gYG1vZHVsZS5leHBvcnRzLiR7aWRlbnR9ID0gbmF0aXZlQmluZGluZy4ke2lkZW50fWApXG4gIC5qb2luKCdcXG4nKX1cbmBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVzbUJpbmRpbmcoXG4gIGxvY2FsTmFtZTogc3RyaW5nLFxuICBwa2dOYW1lOiBzdHJpbmcsXG4gIGlkZW50czogc3RyaW5nW10sXG4pOiBzdHJpbmcge1xuICByZXR1cm4gYCR7YmluZGluZ0hlYWRlcn1cbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSdcbmNvbnN0IHJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybClcbmNvbnN0IF9fZGlybmFtZSA9IG5ldyBVUkwoJy4nLCBpbXBvcnQubWV0YS51cmwpLnBhdGhuYW1lXG5cbiR7Y3JlYXRlQ29tbW9uQmluZGluZyhsb2NhbE5hbWUsIHBrZ05hbWUpfVxuY29uc3QgeyAke2lkZW50cy5qb2luKCcsICcpfSB9ID0gbmF0aXZlQmluZGluZ1xuJHtpZGVudHMubWFwKChpZGVudCkgPT4gYGV4cG9ydCB7ICR7aWRlbnR9IH1gKS5qb2luKCdcXG4nKX1cbmBcbn1cblxuY29uc3QgYmluZGluZ0hlYWRlciA9IGAvLyBwcmV0dGllci1pZ25vcmVcbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuYFxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25CaW5kaW5nKGxvY2FsTmFtZTogc3RyaW5nLCBwa2dOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBmdW5jdGlvbiByZXF1aXJlVHVwbGUodHVwbGU6IHN0cmluZywgaWRlbnRTaXplID0gOCkge1xuICAgIGNvbnN0IGlkZW50TG93ID0gJyAnLnJlcGVhdChpZGVudFNpemUgLSAyKVxuICAgIGNvbnN0IGlkZW50ID0gJyAnLnJlcGVhdChpZGVudFNpemUpXG4gICAgcmV0dXJuIGB0cnkge1xuJHtpZGVudH1yZXR1cm4gcmVxdWlyZSgnLi8ke2xvY2FsTmFtZX0uJHt0dXBsZX0ubm9kZScpXG4ke2lkZW50TG93fX0gY2F0Y2ggKGUpIHtcbiR7aWRlbnR9bG9hZEVycm9ycy5wdXNoKGUpXG4ke2lkZW50TG93fX1cbiR7aWRlbnRMb3d9dHJ5IHtcbiR7aWRlbnR9cmV0dXJuIHJlcXVpcmUoJyR7cGtnTmFtZX0tJHt0dXBsZX0nKVxuJHtpZGVudExvd319IGNhdGNoIChlKSB7XG4ke2lkZW50fWxvYWRFcnJvcnMucHVzaChlKVxuJHtpZGVudExvd319YFxuICB9XG5cbiAgcmV0dXJuIGBjb25zdCB7IHJlYWRGaWxlU3luYyB9ID0gcmVxdWlyZSgnbm9kZTpmcycpXG5sZXQgbmF0aXZlQmluZGluZyA9IG51bGxcbmNvbnN0IGxvYWRFcnJvcnMgPSBbXVxuXG5jb25zdCBpc011c2wgPSAoKSA9PiB7XG4gIGxldCBtdXNsID0gZmFsc2VcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICBtdXNsID0gaXNNdXNsRnJvbUZpbGVzeXN0ZW0oKVxuICAgIGlmIChtdXNsID09PSBudWxsKSB7XG4gICAgICBtdXNsID0gaXNNdXNsRnJvbVJlcG9ydCgpXG4gICAgfVxuICAgIGlmIChtdXNsID09PSBudWxsKSB7XG4gICAgICBtdXNsID0gaXNNdXNsRnJvbUNoaWxkUHJvY2VzcygpXG4gICAgfVxuICB9XG4gIHJldHVybiBtdXNsXG59XG5cbmNvbnN0IGlzRmlsZU11c2wgPSAoZikgPT4gZi5pbmNsdWRlcygnbGliYy5tdXNsLScpIHx8IGYuaW5jbHVkZXMoJ2xkLW11c2wtJylcblxuY29uc3QgaXNNdXNsRnJvbUZpbGVzeXN0ZW0gPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlYWRGaWxlU3luYygnL3Vzci9iaW4vbGRkJywgJ3V0Zi04JykuaW5jbHVkZXMoJ211c2wnKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmNvbnN0IGlzTXVzbEZyb21SZXBvcnQgPSAoKSA9PiB7XG4gIGxldCByZXBvcnQgPSBudWxsXG4gIGlmICh0eXBlb2YgcHJvY2Vzcy5yZXBvcnQ/LmdldFJlcG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MucmVwb3J0LmV4Y2x1ZGVOZXR3b3JrID0gdHJ1ZVxuICAgIHJlcG9ydCA9IHByb2Nlc3MucmVwb3J0LmdldFJlcG9ydCgpXG4gIH1cbiAgaWYgKCFyZXBvcnQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChyZXBvcnQuaGVhZGVyICYmIHJlcG9ydC5oZWFkZXIuZ2xpYmNWZXJzaW9uUnVudGltZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHJlcG9ydC5zaGFyZWRPYmplY3RzKSkge1xuICAgIGlmIChyZXBvcnQuc2hhcmVkT2JqZWN0cy5zb21lKGlzRmlsZU11c2wpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgaXNNdXNsRnJvbUNoaWxkUHJvY2VzcyA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKCdsZGQgLS12ZXJzaW9uJywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLmluY2x1ZGVzKCdtdXNsJylcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElmIHdlIHJlYWNoIHRoaXMgY2FzZSwgd2UgZG9uJ3Qga25vdyBpZiB0aGUgc3lzdGVtIGlzIG11c2wgb3Igbm90LCBzbyBpcyBiZXR0ZXIgdG8ganVzdCBmYWxsYmFjayB0byBmYWxzZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVOYXRpdmUoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OQVBJX1JTX05BVElWRV9MSUJSQVJZX1BBVEgpIHtcbiAgICB0cnkge1xuICAgICAgbmF0aXZlQmluZGluZyA9IHJlcXVpcmUocHJvY2Vzcy5lbnYuTkFQSV9SU19OQVRJVkVfTElCUkFSWV9QQVRIKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChlcnIpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdhbmRyb2lkLWFybTY0Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnYW5kcm9pZC1hcm0tZWFiaScpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBBbmRyb2lkIFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzIteDY0LW1zdmMnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzItaWEzMi1tc3ZjJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi1hcm02NC1tc3ZjJyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIFdpbmRvd3M6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLXVuaXZlcnNhbCcsIDYpfVxuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLXg2NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLWFybTY0Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIG1hY09TOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdmcmVlYnNkJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZnJlZWJzZC14NjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2ZyZWVic2QtYXJtNjQnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gRnJlZUJTRDogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgteDY0LW11c2wnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgteDY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm02NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybTY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLW11c2xlYWJpaGYnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLWdudWVhYmloZicsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3Jpc2N2NjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXJpc2N2NjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1yaXNjdjY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3BwYzY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXBwYzY0LWdudScpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnczM5MHgnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtczM5MHgtZ251Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIExpbnV4OiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdvcGVuaGFybW9ueScpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtNjQtb2hvcycpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXg2NC1vaG9zJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLW9ob3MnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gT3Blbkhhcm1vbnk6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBPUzogXFwke3Byb2Nlc3MucGxhdGZvcm19LCBhcmNoaXRlY3R1cmU6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgfVxufVxuXG5uYXRpdmVCaW5kaW5nID0gcmVxdWlyZU5hdGl2ZSgpXG5cbmlmICghbmF0aXZlQmluZGluZyB8fCBwcm9jZXNzLmVudi5OQVBJX1JTX0ZPUkNFX1dBU0kpIHtcbiAgdHJ5IHtcbiAgICBuYXRpdmVCaW5kaW5nID0gcmVxdWlyZSgnLi8ke2xvY2FsTmFtZX0ud2FzaS5janMnKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19GT1JDRV9XQVNJKSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2goZXJyKVxuICAgIH1cbiAgfVxuICBpZiAoIW5hdGl2ZUJpbmRpbmcpIHtcbiAgICB0cnkge1xuICAgICAgbmF0aXZlQmluZGluZyA9IHJlcXVpcmUoJyR7cGtnTmFtZX0td2FzbTMyLXdhc2knKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICAgICAgICBsb2FkRXJyb3JzLnB1c2goZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAoIW5hdGl2ZUJpbmRpbmcpIHtcbiAgaWYgKGxvYWRFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFxcYENhbm5vdCBmaW5kIG5hdGl2ZSBiaW5kaW5nLiBcXGAgK1xuICAgICAgICBcXGBucG0gaGFzIGEgYnVnIHJlbGF0ZWQgdG8gb3B0aW9uYWwgZGVwZW5kZW5jaWVzIChodHRwczovL2dpdGh1Yi5jb20vbnBtL2NsaS9pc3N1ZXMvNDgyOCkuIFxcYCArXG4gICAgICAgICdQbGVhc2UgdHJ5IFxcYG5wbSBpXFxgIGFnYWluIGFmdGVyIHJlbW92aW5nIGJvdGggcGFja2FnZS1sb2NrLmpzb24gYW5kIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnkuJyxcbiAgICAgIHsgY2F1c2U6IGxvYWRFcnJvcnMgfVxuICAgIClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXFxgRmFpbGVkIHRvIGxvYWQgbmF0aXZlIGJpbmRpbmdcXGApXG59XG5gXG59XG4iLCJleHBvcnQgY29uc3QgY3JlYXRlV2FzaUJyb3dzZXJCaW5kaW5nID0gKFxuICB3YXNpRmlsZW5hbWU6IHN0cmluZyxcbiAgaW5pdGlhbE1lbW9yeSA9IDQwMDAsXG4gIG1heGltdW1NZW1vcnkgPSA2NTUzNixcbiAgZnMgPSBmYWxzZSxcbiAgYXN5bmNJbml0ID0gZmFsc2UsXG4gIGJ1ZmZlciA9IGZhbHNlLFxuKSA9PiB7XG4gIGNvbnN0IGZzSW1wb3J0ID0gZnNcbiAgICA/IGJ1ZmZlclxuICAgICAgPyBgaW1wb3J0IHsgbWVtZnMsIEJ1ZmZlciB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydgXG4gICAgICA6IGBpbXBvcnQgeyBtZW1mcyB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydgXG4gICAgOiAnJ1xuICBjb25zdCBidWZmZXJJbXBvcnQgPSBidWZmZXIgJiYgIWZzID8gYGltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcidgIDogJydcbiAgY29uc3Qgd2FzaUNyZWF0aW9uID0gZnNcbiAgICA/IGBcbmV4cG9ydCBjb25zdCB7IGZzOiBfX2ZzLCB2b2w6IF9fdm9sdW1lIH0gPSBtZW1mcygpXG5cbmNvbnN0IF9fd2FzaSA9IG5ldyBfX1dBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICBmczogX19mcyxcbiAgcHJlb3BlbnM6IHtcbiAgICAnLyc6ICcvJyxcbiAgfSxcbn0pYFxuICAgIDogYFxuY29uc3QgX193YXNpID0gbmV3IF9fV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG59KWBcblxuICBjb25zdCB3b3JrZXJGc0hhbmRsZXIgPSBmc1xuICAgID8gYCAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHkoX19mcykpXFxuYFxuICAgIDogJydcblxuICBjb25zdCBlbW5hcGlJbmplY3RCdWZmZXIgPSBidWZmZXJcbiAgICA/ICdfX2VtbmFwaUNvbnRleHQuZmVhdHVyZS5CdWZmZXIgPSBCdWZmZXInXG4gICAgOiAnJ1xuICBjb25zdCBlbW5hcGlJbnN0YW50aWF0ZUltcG9ydCA9IGFzeW5jSW5pdFxuICAgID8gYGluc3RhbnRpYXRlTmFwaU1vZHVsZSBhcyBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZWBcbiAgICA6IGBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jIGFzIF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luY2BcbiAgY29uc3QgZW1uYXBpSW5zdGFudGlhdGVDYWxsID0gYXN5bmNJbml0XG4gICAgPyBgYXdhaXQgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVgXG4gICAgOiBgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jYFxuXG4gIHJldHVybiBgaW1wb3J0IHtcbiAgY3JlYXRlT25NZXNzYWdlIGFzIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHksXG4gIGdldERlZmF1bHRDb250ZXh0IGFzIF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQsXG4gICR7ZW1uYXBpSW5zdGFudGlhdGVJbXBvcnR9LFxuICBXQVNJIGFzIF9fV0FTSSxcbn0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lJ1xuJHtmc0ltcG9ydH1cbiR7YnVmZmVySW1wb3J0fVxuJHt3YXNpQ3JlYXRpb259XG5cbmNvbnN0IF9fd2FzbVVybCA9IG5ldyBVUkwoJy4vJHt3YXNpRmlsZW5hbWV9Lndhc20nLCBpbXBvcnQubWV0YS51cmwpLmhyZWZcbmNvbnN0IF9fZW1uYXBpQ29udGV4dCA9IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQoKVxuJHtlbW5hcGlJbmplY3RCdWZmZXJ9XG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmNvbnN0IF9fd2FzbUZpbGUgPSBhd2FpdCBmZXRjaChfX3dhc21VcmwpLnRoZW4oKHJlcykgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG5cbmNvbnN0IHtcbiAgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLFxuICBtb2R1bGU6IF9fd2FzaU1vZHVsZSxcbiAgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlLFxufSA9ICR7ZW1uYXBpSW5zdGFudGlhdGVDYWxsfShfX3dhc21GaWxlLCB7XG4gIGNvbnRleHQ6IF9fZW1uYXBpQ29udGV4dCxcbiAgYXN5bmNXb3JrUG9vbFNpemU6IDQsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKCcuL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKSwge1xuICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgfSlcbiR7d29ya2VyRnNIYW5kbGVyfVxuICAgIHJldHVybiB3b3JrZXJcbiAgfSxcbiAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICBpbXBvcnRPYmplY3QuZW52ID0ge1xuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVtbmFwaSxcbiAgICAgIG1lbW9yeTogX19zaGFyZWRNZW1vcnksXG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRPYmplY3RcbiAgfSxcbiAgYmVmb3JlSW5pdCh7IGluc3RhbmNlIH0pIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaW5zdGFuY2UuZXhwb3J0cykpIHtcbiAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ19fbmFwaV9yZWdpc3Rlcl9fJykpIHtcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1tuYW1lXSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxufSlcbmBcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCaW5kaW5nID0gKFxuICB3YXNtRmlsZU5hbWU6IHN0cmluZyxcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgaW5pdGlhbE1lbW9yeSA9IDQwMDAsXG4gIG1heGltdW1NZW1vcnkgPSA2NTUzNixcbikgPT4gYC8qIGVzbGludC1kaXNhYmxlICovXG4vKiBwcmV0dGllci1pZ25vcmUgKi9cblxuLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuXG5jb25zdCBfX25vZGVGcyA9IHJlcXVpcmUoJ25vZGU6ZnMnKVxuY29uc3QgX19ub2RlUGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpXG5jb25zdCB7IFdBU0k6IF9fbm9kZVdBU0kgfSA9IHJlcXVpcmUoJ25vZGU6d2FzaScpXG5jb25zdCB7IFdvcmtlciB9ID0gcmVxdWlyZSgnbm9kZTp3b3JrZXJfdGhyZWFkcycpXG5cbmNvbnN0IHtcbiAgY3JlYXRlT25NZXNzYWdlOiBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5LFxuICBnZXREZWZhdWx0Q29udGV4dDogX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCxcbiAgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYzogX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLFxufSA9IHJlcXVpcmUoJ0BuYXBpLXJzL3dhc20tcnVudGltZScpXG5cbmNvbnN0IF9fcm9vdERpciA9IF9fbm9kZVBhdGgucGFyc2UocHJvY2Vzcy5jd2QoKSkucm9vdFxuXG5jb25zdCBfX3dhc2kgPSBuZXcgX19ub2RlV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG4gIGVudjogcHJvY2Vzcy5lbnYsXG4gIHByZW9wZW5zOiB7XG4gICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgfVxufSlcblxuY29uc3QgX19lbW5hcGlDb250ZXh0ID0gX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCgpXG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmxldCBfX3dhc21GaWxlUGF0aCA9IF9fbm9kZVBhdGguam9pbihfX2Rpcm5hbWUsICcke3dhc21GaWxlTmFtZX0ud2FzbScpXG5jb25zdCBfX3dhc21EZWJ1Z0ZpbGVQYXRoID0gX19ub2RlUGF0aC5qb2luKF9fZGlybmFtZSwgJyR7d2FzbUZpbGVOYW1lfS5kZWJ1Zy53YXNtJylcblxuaWYgKF9fbm9kZUZzLmV4aXN0c1N5bmMoX193YXNtRGVidWdGaWxlUGF0aCkpIHtcbiAgX193YXNtRmlsZVBhdGggPSBfX3dhc21EZWJ1Z0ZpbGVQYXRoXG59IGVsc2UgaWYgKCFfX25vZGVGcy5leGlzdHNTeW5jKF9fd2FzbUZpbGVQYXRoKSkge1xuICB0cnkge1xuICAgIF9fd2FzbUZpbGVQYXRoID0gX19ub2RlUGF0aC5yZXNvbHZlKCcke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaScpXG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgJHt3YXNtRmlsZU5hbWV9Lndhc20gZmlsZSwgYW5kICR7cGFja2FnZU5hbWV9LXdhc20zMi13YXNpIHBhY2thZ2UgaXMgbm90IGluc3RhbGxlZC4nKVxuICB9XG59XG5cbmNvbnN0IHsgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLCBtb2R1bGU6IF9fd2FzaU1vZHVsZSwgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlIH0gPSBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMoX19ub2RlRnMucmVhZEZpbGVTeW5jKF9fd2FzbUZpbGVQYXRoKSwge1xuICBjb250ZXh0OiBfX2VtbmFwaUNvbnRleHQsXG4gIGFzeW5jV29ya1Bvb2xTaXplOiAoZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdGhyZWFkc1NpemVGcm9tRW52ID0gTnVtYmVyKHByb2Nlc3MuZW52Lk5BUElfUlNfQVNZTkNfV09SS19QT09MX1NJWkUgPz8gcHJvY2Vzcy5lbnYuVVZfVEhSRUFEUE9PTF9TSVpFKVxuICAgIC8vIE5hTiA+IDAgaXMgZmFsc2VcbiAgICBpZiAodGhyZWFkc1NpemVGcm9tRW52ID4gMCkge1xuICAgICAgcmV0dXJuIHRocmVhZHNTaXplRnJvbUVudlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNFxuICAgIH1cbiAgfSkoKSxcbiAgcmV1c2VXb3JrZXI6IHRydWUsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihfX25vZGVQYXRoLmpvaW4oX19kaXJuYW1lLCAnd2FzaS13b3JrZXIubWpzJyksIHtcbiAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgfSlcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5KF9fbm9kZUZzKShkYXRhKVxuICAgIH1cblxuICAgIC8vIFRoZSBtYWluIHRocmVhZCBvZiBOb2RlLmpzIHdhaXRzIGZvciBhbGwgdGhlIGFjdGl2ZSBoYW5kbGVzIGJlZm9yZSBleGl0aW5nLlxuICAgIC8vIEJ1dCBSdXN0IHRocmVhZHMgYXJlIG5ldmVyIHdhaXRlZCB3aXRob3V0IFxcYHRocmVhZDo6am9pblxcYC5cbiAgICAvLyBTbyBoZXJlIHdlIGhhY2sgdGhlIGNvZGUgb2YgTm9kZS5qcyB0byBwcmV2ZW50IHRoZSB3b3JrZXJzIGZyb20gYmVpbmcgcmVmZXJlbmNlZCAoYWN0aXZlKS5cbiAgICAvLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvMTllMGQ0NzI3MjhjNzlkNDE4Yjc0YmRkZmY1ODhiZWE3MGE0MDNkMC9saWIvaW50ZXJuYWwvd29ya2VyLmpzI0w0MTUsXG4gICAgLy8gYSB3b3JrZXIgaXMgY29uc2lzdCBvZiB0d28gaGFuZGxlczoga1B1YmxpY1BvcnQgYW5kIGtIYW5kbGUuXG4gICAge1xuICAgICAgY29uc3Qga1B1YmxpY1BvcnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtQdWJsaWNQb3J0XCIpXG4gICAgICApO1xuICAgICAgaWYgKGtQdWJsaWNQb3J0KSB7XG4gICAgICAgIHdvcmtlcltrUHVibGljUG9ydF0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtIYW5kbGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtIYW5kbGVcIilcbiAgICAgICk7XG4gICAgICBpZiAoa0hhbmRsZSkge1xuICAgICAgICB3b3JrZXJba0hhbmRsZV0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIHdvcmtlci51bnJlZigpO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VyXG4gIH0sXG4gIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICBtZW1vcnk6IF9fc2hhcmVkTWVtb3J5LFxuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0T2JqZWN0XG4gIH0sXG4gIGJlZm9yZUluaXQoeyBpbnN0YW5jZSB9KSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfX25hcGlfcmVnaXN0ZXJfXycpKSB7XG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbbmFtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pXG5gXG4iLCJleHBvcnQgY29uc3QgV0FTSV9XT1JLRVJfVEVNUExBVEUgPSBgaW1wb3J0IGZzIGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSBcIm5vZGU6bW9kdWxlXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IFdBU0kgfSBmcm9tIFwibm9kZTp3YXNpXCI7XG5pbXBvcnQgeyBwYXJlbnRQb3J0LCBXb3JrZXIgfSBmcm9tIFwibm9kZTp3b3JrZXJfdGhyZWFkc1wiO1xuXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuXG5jb25zdCB7IGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMsIE1lc3NhZ2VIYW5kbGVyLCBnZXREZWZhdWx0Q29udGV4dCB9ID0gcmVxdWlyZShcIkBuYXBpLXJzL3dhc20tcnVudGltZVwiKTtcblxuaWYgKHBhcmVudFBvcnQpIHtcbiAgcGFyZW50UG9ydC5vbihcIm1lc3NhZ2VcIiwgKGRhdGEpID0+IHtcbiAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSh7IGRhdGEgfSk7XG4gIH0pO1xufVxuXG5PYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgc2VsZjogZ2xvYmFsVGhpcyxcbiAgcmVxdWlyZSxcbiAgV29ya2VyLFxuICBpbXBvcnRTY3JpcHRzOiBmdW5jdGlvbiAoZikge1xuICAgIDsoMCwgZXZhbCkoZnMucmVhZEZpbGVTeW5jKGYsIFwidXRmOFwiKSArIFwiLy8jIHNvdXJjZVVSTD1cIiArIGYpO1xuICB9LFxuICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChwYXJlbnRQb3J0KSB7XG4gICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9LFxufSk7XG5cbmNvbnN0IGVtbmFwaUNvbnRleHQgPSBnZXREZWZhdWx0Q29udGV4dCgpO1xuXG5jb25zdCBfX3Jvb3REaXIgPSBwYXJzZShwcm9jZXNzLmN3ZCgpKS5yb290O1xuXG5jb25zdCBoYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKHtcbiAgb25Mb2FkKHsgd2FzbU1vZHVsZSwgd2FzbU1lbW9yeSB9KSB7XG4gICAgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIHZlcnNpb246ICdwcmV2aWV3MScsXG4gICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyh3YXNtTW9kdWxlLCB7XG4gICAgICBjaGlsZFRocmVhZDogdHJ1ZSxcbiAgICAgIHdhc2ksXG4gICAgICBjb250ZXh0OiBlbW5hcGlDb250ZXh0LFxuICAgICAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICAgICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW52LFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICAgICAgbWVtb3J5OiB3YXNtTWVtb3J5XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufSk7XG5cbmdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgaGFuZGxlci5oYW5kbGUoZSk7XG59O1xuYFxuXG5leHBvcnQgY29uc3QgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nID0gKGZzOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGZzSW1wb3J0ID0gZnNcbiAgICA/IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSwgY3JlYXRlRnNQcm94eSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdcbmltcG9ydCB7IG1lbWZzRXhwb3J0ZWQgYXMgX19tZW1mc0V4cG9ydGVkIH0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lL2ZzJ1xuXG5jb25zdCBmcyA9IGNyZWF0ZUZzUHJveHkoX19tZW1mc0V4cG9ydGVkKWBcbiAgICA6IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdgXG4gIGNvbnN0IHdhc2lDcmVhdGlvbiA9IGZzXG4gICAgPyBgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIGZzLFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgJy8nOiAnLycsXG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICAgIHByaW50RXJyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgIH0pYFxuICAgIDogYGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgICAgcHJpbnRFcnI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIH0sXG4gICAgfSlgXG4gIHJldHVybiBgJHtmc0ltcG9ydH1cblxuY29uc3QgaGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcih7XG4gIG9uTG9hZCh7IHdhc21Nb2R1bGUsIHdhc21NZW1vcnkgfSkge1xuICAgICR7d2FzaUNyZWF0aW9ufVxuICAgIHJldHVybiBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jKHdhc21Nb2R1bGUsIHtcbiAgICAgIGNoaWxkVGhyZWFkOiB0cnVlLFxuICAgICAgd2FzaSxcbiAgICAgIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9LFxufSlcblxuZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICBoYW5kbGVyLmhhbmRsZShlKVxufVxuYFxufVxuIiwiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnbm9kZTpjcnlwdG8nXG5pbXBvcnQgeyBleGlzdHNTeW5jLCBta2RpclN5bmMsIHJtU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbm9kZTptb2R1bGUnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCB7IHBhcnNlLCBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuXG5pbXBvcnQgeyBCdWlsZE9wdGlvbnMgYXMgUmF3QnVpbGRPcHRpb25zIH0gZnJvbSAnLi4vZGVmL2J1aWxkLmpzJ1xuaW1wb3J0IHtcbiAgQ0xJX1ZFUlNJT04sXG4gIGNvcHlGaWxlQXN5bmMsXG4gIENyYXRlLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVFlQRV9ERUZfSEVBREVSLFxuICBmaWxlRXhpc3RzLFxuICBnZXRTeXN0ZW1EZWZhdWx0VGFyZ2V0LFxuICBnZXRUYXJnZXRMaW5rZXIsXG4gIG1rZGlyQXN5bmMsXG4gIE5hcGlDb25maWcsXG4gIHBhcnNlTWV0YWRhdGEsXG4gIHBhcnNlVHJpcGxlLFxuICBwcm9jZXNzVHlwZURlZixcbiAgcmVhZEZpbGVBc3luYyxcbiAgcmVhZE5hcGlDb25maWcsXG4gIFRhcmdldCxcbiAgdGFyZ2V0VG9FbnZWYXIsXG4gIHRyeUluc3RhbGxDYXJnb0JpbmFyeSxcbiAgdW5saW5rQXN5bmMsXG4gIHdyaXRlRmlsZUFzeW5jLFxuICBkaXJFeGlzdHNBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuaW1wb3J0IHsgY3JlYXRlQ2pzQmluZGluZywgY3JlYXRlRXNtQmluZGluZyB9IGZyb20gJy4vdGVtcGxhdGVzL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlV2FzaUJpbmRpbmcsXG4gIGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyxcbn0gZnJvbSAnLi90ZW1wbGF0ZXMvbG9hZC13YXNpLXRlbXBsYXRlLmpzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nLFxuICBXQVNJX1dPUktFUl9URU1QTEFURSxcbn0gZnJvbSAnLi90ZW1wbGF0ZXMvd2FzaS13b3JrZXItdGVtcGxhdGUuanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdidWlsZCcpXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpXG5cbnR5cGUgT3V0cHV0S2luZCA9ICdqcycgfCAnZHRzJyB8ICdub2RlJyB8ICdleGUnIHwgJ3dhc20nXG50eXBlIE91dHB1dCA9IHsga2luZDogT3V0cHV0S2luZDsgcGF0aDogc3RyaW5nIH1cblxudHlwZSBCdWlsZE9wdGlvbnMgPSBSYXdCdWlsZE9wdGlvbnMgJiB7IGNhcmdvT3B0aW9ucz86IHN0cmluZ1tdIH1cbnR5cGUgUGFyc2VkQnVpbGRPcHRpb25zID0gT21pdDxCdWlsZE9wdGlvbnMsICdjd2QnPiAmIHsgY3dkOiBzdHJpbmcgfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRQcm9qZWN0KHJhd09wdGlvbnM6IEJ1aWxkT3B0aW9ucykge1xuICBkZWJ1ZygnbmFwaSBidWlsZCBjb21tYW5kIHJlY2VpdmUgb3B0aW9uczogJU8nLCByYXdPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnM6IFBhcnNlZEJ1aWxkT3B0aW9ucyA9IHtcbiAgICBkdHNDYWNoZTogdHJ1ZSxcbiAgICAuLi5yYXdPcHRpb25zLFxuICAgIGN3ZDogcmF3T3B0aW9ucy5jd2QgPz8gcHJvY2Vzcy5jd2QoKSxcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVQYXRoID0gKC4uLnBhdGhzOiBzdHJpbmdbXSkgPT4gcmVzb2x2ZShvcHRpb25zLmN3ZCwgLi4ucGF0aHMpXG5cbiAgY29uc3QgbWFuaWZlc3RQYXRoID0gcmVzb2x2ZVBhdGgob3B0aW9ucy5tYW5pZmVzdFBhdGggPz8gJ0NhcmdvLnRvbWwnKVxuICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHBhcnNlTWV0YWRhdGEobWFuaWZlc3RQYXRoKVxuXG4gIGNvbnN0IGNyYXRlID0gbWV0YWRhdGEucGFja2FnZXMuZmluZCgocCkgPT4ge1xuICAgIC8vIHBhY2thZ2Ugd2l0aCBnaXZlbiBuYW1lXG4gICAgaWYgKG9wdGlvbnMucGFja2FnZSkge1xuICAgICAgcmV0dXJuIHAubmFtZSA9PT0gb3B0aW9ucy5wYWNrYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwLm1hbmlmZXN0X3BhdGggPT09IG1hbmlmZXN0UGF0aFxuICAgIH1cbiAgfSlcblxuICBpZiAoIWNyYXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1VuYWJsZSB0byBmaW5kIGNyYXRlIHRvIGJ1aWxkLiBJdCBzZWVtcyB5b3UgYXJlIHRyeWluZyB0byBidWlsZCBhIGNyYXRlIGluIGEgd29ya3NwYWNlLCB0cnkgdXNpbmcgYC0tcGFja2FnZWAgb3B0aW9uIHRvIHNwZWNpZnkgdGhlIHBhY2thZ2UgdG8gYnVpbGQuJyxcbiAgICApXG4gIH1cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcmVzb2x2ZVBhdGgoXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPz8gb3B0aW9ucy5wYWNrYWdlSnNvblBhdGggPz8gJ3BhY2thZ2UuanNvbicsXG4gICAgKSxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgY29uc3QgYnVpbGRlciA9IG5ldyBCdWlsZGVyKG1ldGFkYXRhLCBjcmF0ZSwgY29uZmlnLCBvcHRpb25zKVxuXG4gIHJldHVybiBidWlsZGVyLmJ1aWxkKClcbn1cblxuY2xhc3MgQnVpbGRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXJnczogc3RyaW5nW10gPSBbXVxuICBwcml2YXRlIHJlYWRvbmx5IGVudnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dHM6IE91dHB1dFtdID0gW11cblxuICBwcml2YXRlIHJlYWRvbmx5IHRhcmdldDogVGFyZ2V0XG4gIHByaXZhdGUgcmVhZG9ubHkgY3JhdGVEaXI6IHN0cmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dERpcjogc3RyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0RGlyOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBlbmFibGVUeXBlRGVmOiBib29sZWFuID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldGFkYXRhOiBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY3JhdGU6IENyYXRlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBOYXBpQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogUGFyc2VkQnVpbGRPcHRpb25zLFxuICApIHtcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0XG4gICAgICA/IHBhcnNlVHJpcGxlKG9wdGlvbnMudGFyZ2V0KVxuICAgICAgOiBwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVRcbiAgICAgICAgPyBwYXJzZVRyaXBsZShwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVQpXG4gICAgICAgIDogZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCgpXG4gICAgdGhpcy5jcmF0ZURpciA9IHBhcnNlKGNyYXRlLm1hbmlmZXN0X3BhdGgpLmRpclxuICAgIHRoaXMub3V0cHV0RGlyID0gcmVzb2x2ZShcbiAgICAgIHRoaXMub3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm91dHB1dERpciA/PyB0aGlzLmNyYXRlRGlyLFxuICAgIClcbiAgICB0aGlzLnRhcmdldERpciA9XG4gICAgICBvcHRpb25zLnRhcmdldERpciA/P1xuICAgICAgcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUX0RJUiA/P1xuICAgICAgbWV0YWRhdGEudGFyZ2V0X2RpcmVjdG9yeVxuICAgIHRoaXMuZW5hYmxlVHlwZURlZiA9IHRoaXMuY3JhdGUuZGVwZW5kZW5jaWVzLnNvbWUoXG4gICAgICAoZGVwKSA9PlxuICAgICAgICBkZXAubmFtZSA9PT0gJ25hcGktZGVyaXZlJyAmJlxuICAgICAgICAoZGVwLnVzZXNfZGVmYXVsdF9mZWF0dXJlcyB8fCBkZXAuZmVhdHVyZXMuaW5jbHVkZXMoJ3R5cGUtZGVmJykpLFxuICAgIClcblxuICAgIGlmICghdGhpcy5lbmFibGVUeXBlRGVmKSB7XG4gICAgICBjb25zdCByZXF1aXJlbWVudFdhcm5pbmcgPVxuICAgICAgICAnYG5hcGktZGVyaXZlYCBjcmF0ZSBpcyBub3QgdXNlZCBvciBgdHlwZS1kZWZgIGZlYXR1cmUgaXMgbm90IGVuYWJsZWQgZm9yIGBuYXBpLWRlcml2ZWAgY3JhdGUnXG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBXaWxsIHNraXAgYmluZGluZyBnZW5lcmF0aW9uIGZvciBcXGAubm9kZVxcYCwgXFxgLndhc2lcXGAgYW5kIFxcYC5kLnRzXFxgIGZpbGVzLmAsXG4gICAgICApXG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmR0cyB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZHRzSGVhZGVyIHx8XG4gICAgICAgIHRoaXMuY29uZmlnLmR0c0hlYWRlciB8fFxuICAgICAgICB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlXG4gICAgICApIHtcbiAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBcXGBkdHNcXGAgcmVsYXRlZCBvcHRpb25zIGFyZSBlbmFibGVkIGJ1dCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBjZHlMaWJOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnY2R5bGliJykpXG4gICAgICA/Lm5hbWVcbiAgfVxuXG4gIGdldCBiaW5OYW1lKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm9wdGlvbnMuYmluID8/XG4gICAgICAvLyBvbmx5IGF2YWlsYWJsZSBpZiBub3QgY2R5bGliIG9yIGJpbiBuYW1lIHNwZWNpZmllZFxuICAgICAgKHRoaXMuY2R5TGliTmFtZVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnYmluJykpPy5uYW1lKVxuICAgIClcbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCB3YXJuaW5nID1cbiAgICAgICAgJ01pc3NpbmcgYGNyYXRlLXR5cGUgPSBbXCJjZHlsaWJcIl1gIGluIFtsaWJdIGNvbmZpZy4gVGhlIGJ1aWxkIHJlc3VsdCB3aWxsIG5vdCBiZSBhdmFpbGFibGUgYXMgbm9kZSBhZGRvbi4nXG5cbiAgICAgIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgICAgZGVidWcud2Fybih3YXJuaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdhcm5pbmcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGlja0JpbmFyeSgpXG4gICAgICAuc2V0UGFja2FnZSgpXG4gICAgICAuc2V0RmVhdHVyZXMoKVxuICAgICAgLnNldFRhcmdldCgpXG4gICAgICAucGlja0Nyb3NzVG9vbGNoYWluKClcbiAgICAgIC5zZXRFbnZzKClcbiAgICAgIC5zZXRCeXBhc3NBcmdzKClcbiAgICAgIC5leGVjKClcbiAgfVxuXG4gIHByaXZhdGUgcGlja0Nyb3NzVG9vbGNoYWluKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU5hcGlDcm9zcykge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51c2VDcm9zcykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIHVzZSBib3RoIGAtLWNyb3NzYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLXVzZS1jcm9zc2Agd2lsbCBiZSBpZ25vcmVkLicsXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYm90aCBgLS1jcm9zcy1jb21waWxlYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLWNyb3NzLWNvbXBpbGVgIHdpbGwgYmUgaWdub3JlZC4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZlcnNpb24sIGRvd25sb2FkIH0gPSByZXF1aXJlKCdAbmFwaS1ycy9jcm9zcy10b29sY2hhaW4nKVxuXG4gICAgICBjb25zdCBhbGlhczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JzogJ3MzOTB4LWlibS1saW51eC1nbnUnLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b29sY2hhaW5QYXRoID0gam9pbihcbiAgICAgICAgaG9tZWRpcigpLFxuICAgICAgICAnLm5hcGktcnMnLFxuICAgICAgICAnY3Jvc3MtdG9vbGNoYWluJyxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgdGhpcy50YXJnZXQudHJpcGxlLFxuICAgICAgKVxuICAgICAgbWtkaXJTeW5jKHRvb2xjaGFpblBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICBpZiAoZXhpc3RzU3luYyhqb2luKHRvb2xjaGFpblBhdGgsICdwYWNrYWdlLmpzb24nKSkpIHtcbiAgICAgICAgZGVidWcoYFRvb2xjaGFpbiAke3Rvb2xjaGFpblBhdGh9IGV4aXN0cywgc2tpcCBleHRyYWN0aW5nYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhckFyY2hpdmUgPSBkb3dubG9hZChwcm9jZXNzLmFyY2gsIHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgICAgdGFyQXJjaGl2ZS51bnBhY2sodG9vbGNoYWluUGF0aClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVwcGVyQ2FzZVRhcmdldCA9IHRhcmdldFRvRW52VmFyKHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgIGNvbnN0IGNyb3NzVGFyZ2V0TmFtZSA9IGFsaWFzW3RoaXMudGFyZ2V0LnRyaXBsZV0gPz8gdGhpcy50YXJnZXQudHJpcGxlXG4gICAgICBjb25zdCBsaW5rZXJFbnYgPSBgQ0FSR09fVEFSR0VUXyR7dXBwZXJDYXNlVGFyZ2V0fV9MSU5LRVJgXG4gICAgICB0aGlzLmVudnNbbGlua2VyRW52XSA9IGpvaW4oXG4gICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWdjY2AsXG4gICAgICApXG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9TWVNST09UKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1NZU1JPT1RgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICBjcm9zc1RhcmdldE5hbWUsXG4gICAgICAgICAgJ3N5c3Jvb3QnLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9BUikge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9BUmBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgICdiaW4nLFxuICAgICAgICAgIGAke2Nyb3NzVGFyZ2V0TmFtZX0tYXJgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9SQU5MSUIpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfUkFOTElCYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1yYW5saWJgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9SRUFERUxGKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1JFQURFTEZgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LXJlYWRlbGZgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9DX0lOQ0xVREVfUEFUSCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9DX0lOQ0xVREVfUEFUSGBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgIGNyb3NzVGFyZ2V0TmFtZSxcbiAgICAgICAgICAnc3lzcm9vdCcsXG4gICAgICAgICAgJ3VzcicsXG4gICAgICAgICAgJ2luY2x1ZGUvJyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfQ0MpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQ0NgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWdjY2AsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9DWFhgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWcrK2AsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEFSR0VUX0NDPy5zdGFydHNXaXRoKCdjbGFuZycpIHx8XG4gICAgICAgIChwcm9jZXNzLmVudi5DQz8uc3RhcnRzV2l0aCgnY2xhbmcnKSAmJiAhcHJvY2Vzcy5lbnYuVEFSR0VUX0NDKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IFRBUkdFVF9DRkxBR1MgPSBwcm9jZXNzLmVudi5UQVJHRVRfQ0ZMQUdTID8/ICcnXG4gICAgICAgIHRoaXMuZW52cy5UQVJHRVRfQ0ZMQUdTID0gYC0tc3lzcm9vdD0ke3RoaXMuZW52cy5UQVJHRVRfU1lTUk9PVH0gLS1nY2MtdG9vbGNoYWluPSR7dG9vbGNoYWluUGF0aH0gJHtUQVJHRVRfQ0ZMQUdTfWBcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKHByb2Nlc3MuZW52LkNYWD8uc3RhcnRzV2l0aCgnY2xhbmcrKycpICYmICFwcm9jZXNzLmVudi5UQVJHRVRfQ1hYKSB8fFxuICAgICAgICBwcm9jZXNzLmVudi5UQVJHRVRfQ1hYPy5zdGFydHNXaXRoKCdjbGFuZysrJylcbiAgICAgICkge1xuICAgICAgICBjb25zdCBUQVJHRVRfQ1hYRkxBR1MgPSBwcm9jZXNzLmVudi5UQVJHRVRfQ1hYRkxBR1MgPz8gJydcbiAgICAgICAgdGhpcy5lbnZzLlRBUkdFVF9DWFhGTEFHUyA9IGAtLXN5c3Jvb3Q9JHt0aGlzLmVudnMuVEFSR0VUX1NZU1JPT1R9IC0tZ2NjLXRvb2xjaGFpbj0ke3Rvb2xjaGFpblBhdGh9ICR7VEFSR0VUX0NYWEZMQUdTfWBcbiAgICAgIH1cbiAgICAgIHRoaXMuZW52cy5QQVRIID0gdGhpcy5lbnZzLlBBVEhcbiAgICAgICAgPyBgJHt0b29sY2hhaW5QYXRofS9iaW46JHt0aGlzLmVudnMuUEFUSH06JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgICAgICAgOiBgJHt0b29sY2hhaW5QYXRofS9iaW46JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1Zy53YXJuKCdQaWNrIGNyb3NzIHRvb2xjaGFpbiBmYWlsZWQnLCBlIGFzIEVycm9yKVxuICAgICAgLy8gaWdub3JlLCBkbyBub3RoaW5nXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGV4ZWMoKSB7XG4gICAgZGVidWcoYFN0YXJ0IGJ1aWxkaW5nIGNyYXRlOiAke3RoaXMuY3JhdGUubmFtZX1gKVxuICAgIGRlYnVnKCcgICVpJywgYGNhcmdvICR7dGhpcy5hcmdzLmpvaW4oJyAnKX1gKVxuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gICAgY29uc3Qgd2F0Y2ggPSB0aGlzLm9wdGlvbnMud2F0Y2hcbiAgICBjb25zdCBidWlsZFRhc2sgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUNyb3NzICYmIHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdgLS11c2UtY3Jvc3NgIGFuZCBgLS1jcm9zcy1jb21waWxlYCBjYW4gbm90IGJlIHVzZWQgdG9nZXRoZXInLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYW5kID1cbiAgICAgICAgcHJvY2Vzcy5lbnYuQ0FSR08gPz8gKHRoaXMub3B0aW9ucy51c2VDcm9zcyA/ICdjcm9zcycgOiAnY2FyZ28nKVxuICAgICAgY29uc3QgYnVpbGRQcm9jZXNzID0gc3Bhd24oY29tbWFuZCwgdGhpcy5hcmdzLCB7XG4gICAgICAgIGVudjogeyAuLi5wcm9jZXNzLmVudiwgLi4udGhpcy5lbnZzIH0sXG4gICAgICAgIHN0ZGlvOiB3YXRjaCA/IFsnaW5oZXJpdCcsICdpbmhlcml0JywgJ3BpcGUnXSA6ICdpbmhlcml0JyxcbiAgICAgICAgY3dkOiB0aGlzLm9wdGlvbnMuY3dkLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSlcblxuICAgICAgYnVpbGRQcm9jZXNzLm9uY2UoJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgIGRlYnVnKCclaScsIGBCdWlsZCBjcmF0ZSAke3RoaXMuY3JhdGUubmFtZX0gc3VjY2Vzc2Z1bGx5IWApXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQnVpbGQgZmFpbGVkIHdpdGggZXhpdCBjb2RlICR7Y29kZX1gKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgYnVpbGRQcm9jZXNzLm9uY2UoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQnVpbGQgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZS5tZXNzYWdlfWAsIHsgY2F1c2U6IGUgfSkpXG4gICAgICB9KVxuXG4gICAgICAvLyB3YXRjaCBtb2RlIG9ubHksIHRoZXkgYXJlIHBpcGVkIHRocm91Z2ggc3RkZXJyXG4gICAgICBidWlsZFByb2Nlc3Muc3RkZXJyPy5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICBjb25zb2xlLmVycm9yKG91dHB1dClcbiAgICAgICAgaWYgKC9GaW5pc2hlZFxccyhgZGV2YHxgcmVsZWFzZWApLy50ZXN0KG91dHB1dCkpIHtcbiAgICAgICAgICB0aGlzLnBvc3RCdWlsZCgpLmNhdGNoKCgpID0+IHt9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgdGFzazogYnVpbGRUYXNrLnRoZW4oKCkgPT4gdGhpcy5wb3N0QnVpbGQoKSksXG4gICAgICBhYm9ydDogKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGlja0JpbmFyeSgpIHtcbiAgICBsZXQgc2V0ID0gZmFsc2VcbiAgICBpZiAodGhpcy5vcHRpb25zLndhdGNoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuQ0kpIHtcbiAgICAgICAgZGVidWcud2FybignV2F0Y2ggbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIENJIGVudmlyb25tZW50JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdVc2UgJWknLCAnY2FyZ28td2F0Y2gnKVxuICAgICAgICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkoJ2NhcmdvLXdhdGNoJywgJ3dhdGNoJylcbiAgICAgICAgLy8geWFybiBuYXBpIHdhdGNoIC0tdGFyZ2V0IHg4Nl82NC11bmtub3duLWxpbnV4LWdudSBbLS1jcm9zcy1jb21waWxlXVxuICAgICAgICAvLyA9PT0+XG4gICAgICAgIC8vIGNhcmdvIHdhdGNoIFsuLi5dIC0tIGJ1aWxkIC0tdGFyZ2V0IHg4Nl82NC11bmtub3duLWxpbnV4LWdudVxuICAgICAgICAvLyBjYXJnbyB3YXRjaCBbLi4uXSAtLSB6aWdidWlsZCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnVcbiAgICAgICAgdGhpcy5hcmdzLnB1c2goXG4gICAgICAgICAgJ3dhdGNoJyxcbiAgICAgICAgICAnLS13aHknLFxuICAgICAgICAgICctaScsXG4gICAgICAgICAgJyoue2pzLHRzLG5vZGV9JyxcbiAgICAgICAgICAnLXcnLFxuICAgICAgICAgIHRoaXMuY3JhdGVEaXIsXG4gICAgICAgICAgJy0tJyxcbiAgICAgICAgICAnY2FyZ28nLFxuICAgICAgICAgICdidWlsZCcsXG4gICAgICAgIClcbiAgICAgICAgc2V0ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gd2luMzIgcGxhdGZvcm0gb24gd2luMzIgcGxhdGZvcm0gd2hpY2ggaXMgdW5uZWNlc3NhcnkuJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGNhcmdvLXh3aW4gdG8gY3Jvc3MgY29tcGlsZSB0byB3aW4zMiBwbGF0Zm9ybVxuICAgICAgICAgIGRlYnVnKCdVc2UgJWknLCAnY2FyZ28teHdpbicpXG4gICAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby14d2luJywgJ3h3aW4nKVxuICAgICAgICAgIHRoaXMuYXJncy5wdXNoKCd4d2luJywgJ2J1aWxkJylcbiAgICAgICAgICBpZiAodGhpcy50YXJnZXQuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgICAgICAgICB0aGlzLmVudnMuWFdJTl9BUkNIID0gJ3g4NidcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdsaW51eCcgJiZcbiAgICAgICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnICYmXG4gICAgICAgICAgdGhpcy50YXJnZXQuYXJjaCA9PT0gcHJvY2Vzcy5hcmNoICYmXG4gICAgICAgICAgKGZ1bmN0aW9uIChhYmk6IHN0cmluZyB8IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsaWJjVmVyc2lvblJ1bnRpbWUgPVxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIHByb2Nlc3MucmVwb3J0Py5nZXRSZXBvcnQoKT8uaGVhZGVyPy5nbGliY1ZlcnNpb25SdW50aW1lXG4gICAgICAgICAgICBjb25zdCBsaWJjID0gZ2xpYmNWZXJzaW9uUnVudGltZSA/ICdnbnUnIDogJ211c2wnXG4gICAgICAgICAgICByZXR1cm4gYWJpID09PSBsaWJjXG4gICAgICAgICAgfSkodGhpcy50YXJnZXQuYWJpKVxuICAgICAgICApIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gbGludXggdGFyZ2V0IG9uIGxpbnV4IHBsYXRmb3JtIHdoaWNoIGlzIHVubmVjZXNzYXJ5LicsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnZGFyd2luJyAmJlxuICAgICAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgICkge1xuICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gY3Jvc3MgY29tcGlsZSB0byBkYXJ3aW4gdGFyZ2V0IG9uIGRhcndpbiBwbGF0Zm9ybSB3aGljaCBpcyB1bm5lY2Vzc2FyeS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2UgY2FyZ28temlnYnVpbGQgdG8gY3Jvc3MgY29tcGlsZSB0byBvdGhlciBwbGF0Zm9ybXNcbiAgICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXppZ2J1aWxkJylcbiAgICAgICAgICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkoJ2NhcmdvLXppZ2J1aWxkJywgJ3ppZ2J1aWxkJylcbiAgICAgICAgICB0aGlzLmFyZ3MucHVzaCgnemlnYnVpbGQnKVxuICAgICAgICAgIHNldCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2V0KSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnYnVpbGQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRQYWNrYWdlKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYWNrYWdlKSB7XG4gICAgICBhcmdzLnB1c2goJy0tcGFja2FnZScsIHRoaXMub3B0aW9ucy5wYWNrYWdlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1iaW4nLCB0aGlzLmJpbk5hbWUpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnU2V0IHBhY2thZ2UgZmxhZ3M6ICcpXG4gICAgICBkZWJ1ZygnICAlTycsIGFyZ3MpXG4gICAgICB0aGlzLmFyZ3MucHVzaCguLi5hcmdzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldFRhcmdldCgpIHtcbiAgICBkZWJ1ZygnU2V0IGNvbXBpbGluZyB0YXJnZXQgdG86ICcpXG4gICAgZGVidWcoJyAgJWknLCB0aGlzLnRhcmdldC50cmlwbGUpXG5cbiAgICB0aGlzLmFyZ3MucHVzaCgnLS10YXJnZXQnLCB0aGlzLnRhcmdldC50cmlwbGUpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRFbnZzKCkge1xuICAgIC8vIFRZUEUgREVGXG4gICAgaWYgKHRoaXMuZW5hYmxlVHlwZURlZikge1xuICAgICAgdGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUiA9XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJbnRlcm1lZGlhdGVUeXBlRGVmRm9sZGVyKClcbiAgICAgIHRoaXMuc2V0Rm9yY2VCdWlsZEVudnModGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUilcbiAgICB9XG5cbiAgICAvLyBSVVNURkxBR1NcbiAgICBsZXQgcnVzdGZsYWdzID1cbiAgICAgIHByb2Nlc3MuZW52LlJVU1RGTEFHUyA/PyBwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9SVVNURkxBR1MgPz8gJydcblxuICAgIGlmIChcbiAgICAgIHRoaXMudGFyZ2V0LmFiaT8uaW5jbHVkZXMoJ211c2wnKSAmJlxuICAgICAgIXJ1c3RmbGFncy5pbmNsdWRlcygndGFyZ2V0LWZlYXR1cmU9LWNydC1zdGF0aWMnKVxuICAgICkge1xuICAgICAgcnVzdGZsYWdzICs9ICcgLUMgdGFyZ2V0LWZlYXR1cmU9LWNydC1zdGF0aWMnXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpcCAmJiAhcnVzdGZsYWdzLmluY2x1ZGVzKCdsaW5rLWFyZz0tcycpKSB7XG4gICAgICBydXN0ZmxhZ3MgKz0gJyAtQyBsaW5rLWFyZz0tcydcbiAgICB9XG5cbiAgICBpZiAocnVzdGZsYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5lbnZzLlJVU1RGTEFHUyA9IHJ1c3RmbGFnc1xuICAgIH1cbiAgICAvLyBFTkQgUlVTVEZMQUdTXG5cbiAgICAvLyBMSU5LRVJcbiAgICBjb25zdCBsaW5rZXIgPSB0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlXG4gICAgICA/IHZvaWQgMFxuICAgICAgOiBnZXRUYXJnZXRMaW5rZXIodGhpcy50YXJnZXQudHJpcGxlKVxuICAgIC8vIFRPRE86XG4gICAgLy8gICBkaXJlY3RseSBzZXQgQ0FSR09fVEFSR0VUXzx0YXJnZXQ+X0xJTktFUiB3aWxsIGNvdmVyIC5jYXJnby9jb25maWcudG9tbFxuICAgIC8vICAgd2lsbCBkZXRlY3QgYnkgY2FyZ28gY29uZmlnIHdoZW4gaXQgYmVjb21lcyBzdGFibGVcbiAgICAvLyAgIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9jYXJnby9pc3N1ZXMvOTMwMVxuICAgIGNvbnN0IGxpbmtlckVudiA9IGBDQVJHT19UQVJHRVRfJHt0YXJnZXRUb0VudlZhcihcbiAgICAgIHRoaXMudGFyZ2V0LnRyaXBsZSxcbiAgICApfV9MSU5LRVJgXG4gICAgaWYgKGxpbmtlciAmJiAhcHJvY2Vzcy5lbnZbbGlua2VyRW52XSAmJiAhdGhpcy5lbnZzW2xpbmtlckVudl0pIHtcbiAgICAgIHRoaXMuZW52c1tsaW5rZXJFbnZdID0gbGlua2VyXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICAgIHRoaXMuc2V0QW5kcm9pZEVudigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScpIHtcbiAgICAgIHRoaXMuc2V0V2FzaUVudigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnb3Blbmhhcm1vbnknKSB7XG4gICAgICB0aGlzLnNldE9wZW5IYXJtb255RW52KClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2V0IGVudnM6ICcpXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnZzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgIGRlYnVnKCcgICVpJywgYCR7a309JHt2fWApXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldEZvcmNlQnVpbGRFbnZzKHR5cGVEZWZUbXBGb2xkZXI6IHN0cmluZykge1xuICAgIC8vIGR5bmFtaWNhbGx5IGNoZWNrIGFsbCBuYXBpLXJzIGRlcHMgYW5kIHNldCBgTkFQSV9GT1JDRV9CVUlMRF97dXBwZXJjYXNlKHNuYWtlX2Nhc2UobmFtZSkpfSA9IHRpbWVzdGFtcGBcbiAgICB0aGlzLm1ldGFkYXRhLnBhY2thZ2VzLmZvckVhY2goKGNyYXRlKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGNyYXRlLmRlcGVuZGVuY2llcy5zb21lKChkKSA9PiBkLm5hbWUgPT09ICduYXBpLWRlcml2ZScpICYmXG4gICAgICAgICFleGlzdHNTeW5jKGpvaW4odHlwZURlZlRtcEZvbGRlciwgY3JhdGUubmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5lbnZzW1xuICAgICAgICAgIGBOQVBJX0ZPUkNFX0JVSUxEXyR7Y3JhdGUubmFtZS5yZXBsYWNlKC8tL2csICdfJykudG9VcHBlckNhc2UoKX1gXG4gICAgICAgIF0gPSBEYXRlLm5vdygpLnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRBbmRyb2lkRW52KCkge1xuICAgIGNvbnN0IHsgQU5EUk9JRF9OREtfTEFURVNUX0hPTUUgfSA9IHByb2Nlc3MuZW52XG4gICAgaWYgKCFBTkRST0lEX05ES19MQVRFU1RfSE9NRSkge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7Y29sb3JzLnJlZChcbiAgICAgICAgICAnQU5EUk9JRF9OREtfTEFURVNUX0hPTUUnLFxuICAgICAgICApfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBza2lwIGNyb3NzIGNvbXBpbGUgc2V0dXAgaWYgaG9zdCBpcyBhbmRyb2lkXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0QXJjaCA9IHRoaXMudGFyZ2V0LmFyY2ggPT09ICdhcm0nID8gJ2FybXY3YScgOiAnYWFyY2g2NCdcbiAgICBjb25zdCB0YXJnZXRQbGF0Zm9ybSA9XG4gICAgICB0aGlzLnRhcmdldC5hcmNoID09PSAnYXJtJyA/ICdhbmRyb2lkZWFiaTI0JyA6ICdhbmRyb2lkMjQnXG4gICAgY29uc3QgaG9zdFBsYXRmb3JtID1cbiAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgID8gJ2RhcndpbidcbiAgICAgICAgOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICAgICAgPyAnd2luZG93cydcbiAgICAgICAgICA6ICdsaW51eCdcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZW52cywge1xuICAgICAgQ0FSR09fVEFSR0VUX0FBUkNINjRfTElOVVhfQU5EUk9JRF9MSU5LRVI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC1hbmRyb2lkMjQtY2xhbmdgLFxuICAgICAgQ0FSR09fVEFSR0VUX0FSTVY3X0xJTlVYX0FORFJPSURFQUJJX0xJTktFUjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LWFuZHJvaWRlYWJpMjQtY2xhbmdgLFxuICAgICAgVEFSR0VUX0NDOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtJHt0YXJnZXRQbGF0Zm9ybX0tY2xhbmdgLFxuICAgICAgVEFSR0VUX0NYWDogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LSR7dGFyZ2V0UGxhdGZvcm19LWNsYW5nKytgLFxuICAgICAgVEFSR0VUX0FSOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluL2xsdm0tYXJgLFxuICAgICAgVEFSR0VUX1JBTkxJQjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi9sbHZtLXJhbmxpYmAsXG4gICAgICBBTkRST0lEX05ESzogQU5EUk9JRF9OREtfTEFURVNUX0hPTUUsXG4gICAgICBQQVRIOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluJHtwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJzsnIDogJzonfSR7cHJvY2Vzcy5lbnYuUEFUSH1gLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIHNldFdhc2lFbnYoKSB7XG4gICAgY29uc3QgZW1uYXBpID0gam9pbihcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnZW1uYXBpJyksXG4gICAgICAnLi4nLFxuICAgICAgJ2xpYicsXG4gICAgICAnd2FzbTMyLXdhc2ktdGhyZWFkcycsXG4gICAgKVxuICAgIHRoaXMuZW52cy5FTU5BUElfTElOS19ESVIgPSBlbW5hcGlcbiAgICBjb25zdCB7IFdBU0lfU0RLX1BBVEggfSA9IHByb2Nlc3MuZW52XG5cbiAgICBpZiAoV0FTSV9TREtfUEFUSCAmJiBleGlzdHNTeW5jKFdBU0lfU0RLX1BBVEgpKSB7XG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJX1BSRVZJRVcxX1RIUkVBRFNfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lQMV9MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSVAxX1RIUkVBRFNfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lQMl9MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NDJywgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ2NsYW5nJykpXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NYWCcsXG4gICAgICAgIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdjbGFuZysrJyksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQVInLCBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAnYXInKSlcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfUkFOTElCJyxcbiAgICAgICAgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ3JhbmxpYicpLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DRkxBR1MnLFxuICAgICAgICBgLS10YXJnZXQ9d2FzbTMyLXdhc2ktdGhyZWFkcyAtLXN5c3Jvb3Q9JHtXQVNJX1NES19QQVRIfS9zaGFyZS93YXNpLXN5c3Jvb3QgLXB0aHJlYWQgLW1sbHZtIC13YXNtLWVuYWJsZS1zamxqYCxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ1hYRkxBR1MnLFxuICAgICAgICBgLS10YXJnZXQ9d2FzbTMyLXdhc2ktdGhyZWFkcyAtLXN5c3Jvb3Q9JHtXQVNJX1NES19QQVRIfS9zaGFyZS93YXNpLXN5c3Jvb3QgLXB0aHJlYWQgLW1sbHZtIC13YXNtLWVuYWJsZS1zamxqYCxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgIGBUQVJHRVRfTERGTEFHU2AsXG4gICAgICAgIGAtZnVzZS1sZD0ke1dBU0lfU0RLX1BBVEh9L2Jpbi93YXNtLWxkIC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHNgLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0T3Blbkhhcm1vbnlFbnYoKSB7XG4gICAgY29uc3QgeyBPSE9TX1NES19QQVRILCBPSE9TX1NES19OQVRJVkUgfSA9IHByb2Nlc3MuZW52XG4gICAgY29uc3QgbmRrUGF0aCA9IE9IT1NfU0RLX1BBVEhcbiAgICAgID8gYCR7T0hPU19TREtfTkFUSVZFfS9uYXRpdmVgXG4gICAgICA6IE9IT1NfU0RLX05BVElWRVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoIW5ka1BhdGggJiYgcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ29wZW5oYXJtb255Jykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7Y29sb3JzLnJlZCgnT0hPU19TREtfUEFUSCcpfSBvciAke2NvbG9ycy5yZWQoJ09IT1NfU0RLX05BVElWRScpfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nYCxcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBsaW5rZXJOYW1lID0gYENBUkdPX1RBUkdFVF8ke3RoaXMudGFyZ2V0LnRyaXBsZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKX1fTElOS0VSYFxuICAgIGNvbnN0IHJhblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLXJhbmxpYmBcbiAgICBjb25zdCBhclBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLWFyYFxuICAgIGNvbnN0IGNjUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluLyR7dGhpcy50YXJnZXQudHJpcGxlfS1jbGFuZ2BcbiAgICBjb25zdCBjeHhQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vJHt0aGlzLnRhcmdldC50cmlwbGV9LWNsYW5nKytgXG4gICAgY29uc3QgYXNQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1hc2BcbiAgICBjb25zdCBsZFBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sZC5sbGRgXG4gICAgY29uc3Qgc3RyaXBQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1zdHJpcGBcbiAgICBjb25zdCBvYmpEdW1wUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqZHVtcGBcbiAgICBjb25zdCBvYmpDb3B5UGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqY29weWBcbiAgICBjb25zdCBubVBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW5tYFxuICAgIGNvbnN0IGJpblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2JpbmBcbiAgICBjb25zdCBsaWJQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9saWJgXG5cbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdMSUJDTEFOR19QQVRIJywgbGliUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdERVBfQVRPTUlDJywgJ2NsYW5nX3J0LmJ1aWx0aW5zJylcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKGxpbmtlck5hbWUsIGNjUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQ0MnLCBjY1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NYWCcsIGN4eFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0FSJywgYXJQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9SQU5MSUInLCByYW5QYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUycsIGFzUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTEQnLCBsZFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX1NUUklQJywgc3RyaXBQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9PQkpEVU1QJywgb2JqRHVtcFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX09CSkNPUFknLCBvYmpDb3B5UGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTk0nLCBubVBhdGgpXG4gICAgdGhpcy5lbnZzLlBBVEggPSBgJHtiaW5QYXRofSR7cHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6J30ke3Byb2Nlc3MuZW52LlBBVEh9YFxuICB9XG5cbiAgcHJpdmF0ZSBzZXRGZWF0dXJlcygpIHtcbiAgICBjb25zdCBhcmdzID0gW11cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbEZlYXR1cmVzICYmIHRoaXMub3B0aW9ucy5ub0RlZmF1bHRGZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHNwZWNpZnkgLS1hbGwtZmVhdHVyZXMgYW5kIC0tbm8tZGVmYXVsdC1mZWF0dXJlcyB0b2dldGhlcicsXG4gICAgICApXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsRmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1hbGwtZmVhdHVyZXMnKVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm5vRGVmYXVsdEZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tbm8tZGVmYXVsdC1mZWF0dXJlcycpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1mZWF0dXJlcycsIC4uLnRoaXMub3B0aW9ucy5mZWF0dXJlcylcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2V0IGZlYXR1cmVzIGZsYWdzOiAnKVxuICAgIGRlYnVnKCcgICVPJywgYXJncylcbiAgICB0aGlzLmFyZ3MucHVzaCguLi5hcmdzKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0QnlwYXNzQXJncygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbGVhc2UpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXJlbGVhc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tdmVyYm9zZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXREaXIpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXRhcmdldC1kaXInLCB0aGlzLm9wdGlvbnMudGFyZ2V0RGlyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvZmlsZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tcHJvZmlsZScsIHRoaXMub3B0aW9ucy5wcm9maWxlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubWFuaWZlc3RQYXRoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS1tYW5pZmVzdC1wYXRoJywgdGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNhcmdvT3B0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCguLi50aGlzLm9wdGlvbnMuY2FyZ29PcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlSW50ZXJtZWRpYXRlVHlwZURlZkZvbGRlcigpIHtcbiAgICBsZXQgZm9sZGVyID0gam9pbihcbiAgICAgIHRoaXMudGFyZ2V0RGlyLFxuICAgICAgJ25hcGktcnMnLFxuICAgICAgYCR7dGhpcy5jcmF0ZS5uYW1lfS0ke2NyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUodGhpcy5jcmF0ZS5tYW5pZmVzdF9wYXRoKVxuICAgICAgICAudXBkYXRlKENMSV9WRVJTSU9OKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKVxuICAgICAgICAuc3Vic3RyaW5nKDAsIDgpfWAsXG4gICAgKVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZHRzQ2FjaGUpIHtcbiAgICAgIHJtU3luYyhmb2xkZXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KVxuICAgICAgZm9sZGVyICs9IGBfJHtEYXRlLm5vdygpfWBcbiAgICB9XG5cbiAgICBta2RpckFzeW5jKGZvbGRlciwgeyByZWN1cnNpdmU6IHRydWUgfSlcblxuICAgIHJldHVybiBmb2xkZXJcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcG9zdEJ1aWxkKCkge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5OmApXG4gICAgICBkZWJ1ZygnICAlaScsIHRoaXMub3V0cHV0RGlyKVxuICAgICAgYXdhaXQgbWtkaXJBc3luYyh0aGlzLm91dHB1dERpciwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIGRlYnVnKGBPdXRwdXQgZGlyZWN0b3J5IGNyZWF0ZWRgKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5ICR7dGhpcy5vdXRwdXREaXJ9YCwge1xuICAgICAgICBjYXVzZTogZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgd2FzbUJpbmFyeU5hbWUgPSBhd2FpdCB0aGlzLmNvcHlBcnRpZmFjdCgpXG5cbiAgICAvLyBvbmx5IGZvciBjZHlsaWJcbiAgICBpZiAodGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCBpZGVudHMgPSBhd2FpdCB0aGlzLmdlbmVyYXRlVHlwZURlZigpXG4gICAgICBjb25zdCBqc091dHB1dCA9IGF3YWl0IHRoaXMud3JpdGVKc0JpbmRpbmcoaWRlbnRzKVxuICAgICAgY29uc3Qgd2FzbUJpbmRpbmdzT3V0cHV0ID0gYXdhaXQgdGhpcy53cml0ZVdhc2lCaW5kaW5nKFxuICAgICAgICB3YXNtQmluYXJ5TmFtZSxcbiAgICAgICAgaWRlbnRzLFxuICAgICAgKVxuICAgICAgaWYgKGpzT3V0cHV0KSB7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGpzT3V0cHV0KVxuICAgICAgfVxuICAgICAgaWYgKHdhc21CaW5kaW5nc091dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaCguLi53YXNtQmluZGluZ3NPdXRwdXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb3B5QXJ0aWZhY3QoKSB7XG4gICAgY29uc3QgW3NyY05hbWUsIGRlc3ROYW1lLCB3YXNtQmluYXJ5TmFtZV0gPSB0aGlzLmdldEFydGlmYWN0TmFtZXMoKVxuICAgIGlmICghc3JjTmFtZSB8fCAhZGVzdE5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByb2ZpbGUgPVxuICAgICAgdGhpcy5vcHRpb25zLnByb2ZpbGUgPz8gKHRoaXMub3B0aW9ucy5yZWxlYXNlID8gJ3JlbGVhc2UnIDogJ2RlYnVnJylcbiAgICBjb25zdCBzcmMgPSBqb2luKHRoaXMudGFyZ2V0RGlyLCB0aGlzLnRhcmdldC50cmlwbGUsIHByb2ZpbGUsIHNyY05hbWUpXG4gICAgZGVidWcoYENvcHkgYXJ0aWZhY3QgZnJvbTogWyR7c3JjfV1gKVxuICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCBkZXN0TmFtZSlcbiAgICBjb25zdCBpc1dhc20gPSBkZXN0LmVuZHNXaXRoKCcud2FzbScpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoZGVzdCkpIHtcbiAgICAgICAgZGVidWcoJ09sZCBhcnRpZmFjdCBmb3VuZCwgcmVtb3ZlIGl0IGZpcnN0JylcbiAgICAgICAgYXdhaXQgdW5saW5rQXN5bmMoZGVzdClcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdDb3B5IGFydGlmYWN0IHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBpZiAoaXNXYXNtKSB7XG4gICAgICAgIGNvbnN0IHsgTW9kdWxlQ29uZmlnIH0gPSBhd2FpdCBpbXBvcnQoJ0BuYXBpLXJzL3dhc20tdG9vbHMnKVxuICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgZGVidWcgd2FzbSBtb2R1bGUnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbU1vZHVsZSA9IG5ldyBNb2R1bGVDb25maWcoKVxuICAgICAgICAgICAgLmdlbmVyYXRlRHdhcmYodHJ1ZSlcbiAgICAgICAgICAgIC5nZW5lcmF0ZU5hbWVTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAucHJlc2VydmVDb2RlVHJhbnNmb3JtKHRydWUpXG4gICAgICAgICAgICAuc3RyaWN0VmFsaWRhdGUoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoYXdhaXQgcmVhZEZpbGVBc3luYyhzcmMpKVxuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbUJpbmFyeSA9IGRlYnVnV2FzbU1vZHVsZS5lbWl0V2FzbSh0cnVlKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICAgICAgZGVzdC5yZXBsYWNlKC9cXC53YXNtJC8sICcuZGVidWcud2FzbScpLFxuICAgICAgICAgICAgZGVidWdXYXNtQmluYXJ5LFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgcmVsZWFzZSB3YXNtIG1vZHVsZScpXG4gICAgICAgICAgY29uc3QgcmVsZWFzZVdhc21Nb2R1bGUgPSBuZXcgTW9kdWxlQ29uZmlnKClcbiAgICAgICAgICAgIC5nZW5lcmF0ZUR3YXJmKGZhbHNlKVxuICAgICAgICAgICAgLmdlbmVyYXRlTmFtZVNlY3Rpb24oZmFsc2UpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKGZhbHNlKVxuICAgICAgICAgICAgLnByZXNlcnZlQ29kZVRyYW5zZm9ybShmYWxzZSlcbiAgICAgICAgICAgIC5zdHJpY3RWYWxpZGF0ZShmYWxzZSlcbiAgICAgICAgICAgIC5vbmx5U3RhYmxlRmVhdHVyZXMoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoZGVidWdXYXNtQmluYXJ5KVxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VXYXNtQmluYXJ5ID0gcmVsZWFzZVdhc21Nb2R1bGUuZW1pdFdhc20oZmFsc2UpXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGVzdCwgcmVsZWFzZVdhc21CaW5hcnkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSBkZWJ1ZyB3YXNtIG1vZHVsZTogJHsoZSBhcyBhbnkpLm1lc3NhZ2UgPz8gZX1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCBjb3B5RmlsZUFzeW5jKHNyYywgZGVzdClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgY29weUZpbGVBc3luYyhzcmMsIGRlc3QpXG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7XG4gICAgICAgIGtpbmQ6IGRlc3QuZW5kc1dpdGgoJy5ub2RlJykgPyAnbm9kZScgOiBpc1dhc20gPyAnd2FzbScgOiAnZXhlJyxcbiAgICAgICAgcGF0aDogZGVzdCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gd2FzbUJpbmFyeU5hbWUgPyBqb2luKHRoaXMub3V0cHV0RGlyLCB3YXNtQmluYXJ5TmFtZSkgOiBudWxsXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29weSBhcnRpZmFjdCcsIHsgY2F1c2U6IGUgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEFydGlmYWN0TmFtZXMoKSB7XG4gICAgaWYgKHRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3QgY2R5TGliID0gdGhpcy5jZHlMaWJOYW1lLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgICAgY29uc3Qgd2FzaVRhcmdldCA9IHRoaXMuY29uZmlnLnRhcmdldHMuZmluZCgodCkgPT4gdC5wbGF0Zm9ybSA9PT0gJ3dhc2knKVxuXG4gICAgICBjb25zdCBzcmNOYW1lID1cbiAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgICAgPyBgbGliJHtjZHlMaWJ9LmR5bGliYFxuICAgICAgICAgIDogdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICAgICAgICAgID8gYCR7Y2R5TGlifS5kbGxgXG4gICAgICAgICAgICA6IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScgfHwgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3YXNtJ1xuICAgICAgICAgICAgICA/IGAke2NkeUxpYn0ud2FzbWBcbiAgICAgICAgICAgICAgOiBgbGliJHtjZHlMaWJ9LnNvYFxuXG4gICAgICBsZXQgZGVzdE5hbWUgPSB0aGlzLmNvbmZpZy5iaW5hcnlOYW1lXG4gICAgICAvLyBhZGQgcGxhdGZvcm0gc3VmZml4IHRvIGJpbmFyeSBuYW1lXG4gICAgICAvLyBpbmRleFsubGludXgteDY0LWdudV0ubm9kZVxuICAgICAgLy8gICAgICAgXl5eXl5eXl5eXl5eXl5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGxhdGZvcm0pIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gYC4ke3RoaXMudGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gXG4gICAgICB9XG4gICAgICBpZiAoc3JjTmFtZS5lbmRzV2l0aCgnLndhc20nKSkge1xuICAgICAgICBkZXN0TmFtZSArPSAnLndhc20nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0TmFtZSArPSAnLm5vZGUnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNyY05hbWUsXG4gICAgICAgIGRlc3ROYW1lLFxuICAgICAgICB3YXNpVGFyZ2V0XG4gICAgICAgICAgPyBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS4ke3dhc2lUYXJnZXQucGxhdGZvcm1BcmNoQUJJfS53YXNtYFxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIF1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmluTmFtZSkge1xuICAgICAgY29uc3Qgc3JjTmFtZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInID8gYCR7dGhpcy5iaW5OYW1lfS5leGVgIDogdGhpcy5iaW5OYW1lXG5cbiAgICAgIHJldHVybiBbc3JjTmFtZSwgc3JjTmFtZV1cbiAgICB9XG5cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVUeXBlRGVmKCkge1xuICAgIGNvbnN0IHR5cGVEZWZEaXIgPSB0aGlzLmVudnMuTkFQSV9UWVBFX0RFRl9UTVBfRk9MREVSXG4gICAgaWYgKCF0aGlzLmVuYWJsZVR5cGVEZWYgfHwgIShhd2FpdCBkaXJFeGlzdHNBc3luYyh0eXBlRGVmRGlyKSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCB0aGlzLm9wdGlvbnMuZHRzID8/ICdpbmRleC5kLnRzJylcblxuICAgIGxldCBoZWFkZXIgPSAnJ1xuICAgIGxldCBkdHMgPSAnJ1xuICAgIGxldCBleHBvcnRzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ub0R0c0hlYWRlcikge1xuICAgICAgY29uc3QgZHRzSGVhZGVyID0gdGhpcy5vcHRpb25zLmR0c0hlYWRlciA/PyB0aGlzLmNvbmZpZy5kdHNIZWFkZXJcbiAgICAgIC8vIGBkdHNIZWFkZXJGaWxlYCBpbiBjb25maWcgPiBgZHRzSGVhZGVyYCBpbiBjbGkgZmxhZyA+IGBkdHNIZWFkZXJgIGluIGNvbmZpZ1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmR0c0hlYWRlckZpbGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoZWFkZXIgPSBhd2FpdCByZWFkRmlsZUFzeW5jKFxuICAgICAgICAgICAgam9pbih0aGlzLm9wdGlvbnMuY3dkLCB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlKSxcbiAgICAgICAgICAgICd1dGYtOCcsXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVhZCBkdHMgaGVhZGVyIGZpbGUgJHt0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlfWAsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkdHNIZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyID0gZHRzSGVhZGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIgPSBERUZBVUxUX1RZUEVfREVGX0hFQURFUlxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHR5cGVEZWZEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuXG4gICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdObyB0eXBlIGRlZiBmaWxlcyBmb3VuZC4gU2tpcCBnZW5lcmF0aW5nIGR0cyBmaWxlLicpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGlmICghZmlsZS5pc0ZpbGUoKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGR0czogZmlsZUR0cywgZXhwb3J0czogZmlsZUV4cG9ydHMgfSA9IGF3YWl0IHByb2Nlc3NUeXBlRGVmKFxuICAgICAgICBqb2luKHR5cGVEZWZEaXIsIGZpbGUubmFtZSksXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb25zdEVudW0gPz8gdGhpcy5jb25maWcuY29uc3RFbnVtID8/IHRydWUsXG4gICAgICApXG5cbiAgICAgIGR0cyArPSBmaWxlRHRzXG4gICAgICBleHBvcnRzLnB1c2goLi4uZmlsZUV4cG9ydHMpXG4gICAgfVxuXG4gICAgaWYgKGR0cy5pbmRleE9mKCdFeHRlcm5hbE9iamVjdDwnKSA+IC0xKSB7XG4gICAgICBoZWFkZXIgKz0gYFxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRXh0ZXJuYWxPYmplY3Q8VD4ge1xuICByZWFkb25seSAnJzoge1xuICAgIHJlYWRvbmx5ICcnOiB1bmlxdWUgc3ltYm9sXG4gICAgW0s6IHN5bWJvbF06IFRcbiAgfVxufVxuYFxuICAgIH1cblxuICAgIGlmIChkdHMuaW5kZXhPZignVHlwZWRBcnJheScpID4gLTEpIHtcbiAgICAgIGhlYWRlciArPSBgXG5leHBvcnQgdHlwZSBUeXBlZEFycmF5ID0gSW50OEFycmF5IHwgVWludDhBcnJheSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSB8IFVpbnQzMkFycmF5IHwgRmxvYXQzMkFycmF5IHwgRmxvYXQ2NEFycmF5IHwgQmlnSW50NjRBcnJheSB8IEJpZ1VpbnQ2NEFycmF5XG5gXG4gICAgfVxuXG4gICAgZHRzID0gaGVhZGVyICsgZHRzXG5cbiAgICB0cnkge1xuICAgICAgZGVidWcoJ1dyaXRpbmcgdHlwZSBkZWYgdG86JylcbiAgICAgIGRlYnVnKCcgICVpJywgZGVzdClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIGR0cywgJ3V0Zi04JylcbiAgICAgIHRoaXMub3V0cHV0cy5wdXNoKHsga2luZDogJ2R0cycsIHBhdGg6IGRlc3QgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1Zy5lcnJvcignRmFpbGVkIHRvIHdyaXRlIHR5cGUgZGVmIGZpbGUnKVxuICAgICAgZGVidWcuZXJyb3IoZSBhcyBFcnJvcilcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3cml0ZUpzQmluZGluZyhpZGVudHM6IHN0cmluZ1tdKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMub3B0aW9ucy5wbGF0Zm9ybSB8fFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICB0aGlzLm9wdGlvbnMubm9Kc0JpbmRpbmcgfHxcbiAgICAgIGlkZW50cy5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm9wdGlvbnMuanNCaW5kaW5nID8/ICdpbmRleC5qcydcblxuICAgIGNvbnN0IGNyZWF0ZUJpbmRpbmcgPSB0aGlzLm9wdGlvbnMuZXNtID8gY3JlYXRlRXNtQmluZGluZyA6IGNyZWF0ZUNqc0JpbmRpbmdcbiAgICBjb25zdCBiaW5kaW5nID0gY3JlYXRlQmluZGluZyhcbiAgICAgIHRoaXMuY29uZmlnLmJpbmFyeU5hbWUsXG4gICAgICB0aGlzLmNvbmZpZy5wYWNrYWdlTmFtZSxcbiAgICAgIGlkZW50cyxcbiAgICApXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVzdCA9IGpvaW4odGhpcy5vdXRwdXREaXIsIG5hbWUpXG4gICAgICBkZWJ1ZygnV3JpdGluZyBqcyBiaW5kaW5nIHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkZXN0LCBiaW5kaW5nLCAndXRmLTgnKVxuICAgICAgcmV0dXJuIHsga2luZDogJ2pzJywgcGF0aDogZGVzdCB9IHNhdGlzZmllcyBPdXRwdXRcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSBqcyBiaW5kaW5nIGZpbGUnLCB7IGNhdXNlOiBlIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3cml0ZVdhc2lCaW5kaW5nKFxuICAgIGRpc3RGaWxlTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBpZGVudHM6IHN0cmluZ1tdLFxuICApIHtcbiAgICBpZiAoZGlzdEZpbGVOYW1lKSB7XG4gICAgICBjb25zdCB7IG5hbWUsIGRpciB9ID0gcGFyc2UoZGlzdEZpbGVOYW1lKVxuICAgICAgY29uc3QgYmluZGluZ1BhdGggPSBqb2luKGRpciwgYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0ud2FzaS5janNgKVxuICAgICAgY29uc3QgYnJvd3NlckJpbmRpbmdQYXRoID0gam9pbihcbiAgICAgICAgZGlyLFxuICAgICAgICBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgKVxuICAgICAgY29uc3Qgd29ya2VyUGF0aCA9IGpvaW4oZGlyLCAnd2FzaS13b3JrZXIubWpzJylcbiAgICAgIGNvbnN0IGJyb3dzZXJXb3JrZXJQYXRoID0gam9pbihkaXIsICd3YXNpLXdvcmtlci1icm93c2VyLm1qcycpXG4gICAgICBjb25zdCBicm93c2VyRW50cnlQYXRoID0gam9pbihkaXIsICdicm93c2VyLmpzJylcbiAgICAgIGNvbnN0IGV4cG9ydHNDb2RlID1cbiAgICAgICAgYG1vZHVsZS5leHBvcnRzID0gX19uYXBpTW9kdWxlLmV4cG9ydHNcXG5gICtcbiAgICAgICAgaWRlbnRzXG4gICAgICAgICAgLm1hcChcbiAgICAgICAgICAgIChpZGVudCkgPT5cbiAgICAgICAgICAgICAgYG1vZHVsZS5leHBvcnRzLiR7aWRlbnR9ID0gX19uYXBpTW9kdWxlLmV4cG9ydHMuJHtpZGVudH1gLFxuICAgICAgICAgIClcbiAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBiaW5kaW5nUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJpbmRpbmcoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy5wYWNrYWdlTmFtZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5pbml0aWFsTWVtb3J5LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/Lm1heGltdW1NZW1vcnksXG4gICAgICAgICkgK1xuICAgICAgICAgIGV4cG9ydHNDb2RlICtcbiAgICAgICAgICAnXFxuJyxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJCaW5kaW5nUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJyb3dzZXJCaW5kaW5nKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uaW5pdGlhbE1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5tYXhpbXVtTWVtb3J5LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmZzLFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmFzeW5jSW5pdCxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5idWZmZXIsXG4gICAgICAgICkgK1xuICAgICAgICAgIGBleHBvcnQgZGVmYXVsdCBfX25hcGlNb2R1bGUuZXhwb3J0c1xcbmAgK1xuICAgICAgICAgIGlkZW50c1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgKGlkZW50KSA9PlxuICAgICAgICAgICAgICAgIGBleHBvcnQgY29uc3QgJHtpZGVudH0gPSBfX25hcGlNb2R1bGUuZXhwb3J0cy4ke2lkZW50fWAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAgICdcXG4nLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyh3b3JrZXJQYXRoLCBXQVNJX1dPUktFUl9URU1QTEFURSwgJ3V0ZjgnKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJXb3JrZXJQYXRoLFxuICAgICAgICBjcmVhdGVXYXNpQnJvd3NlcldvcmtlckJpbmRpbmcodGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uZnMgPz8gZmFsc2UpLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYnJvd3NlckVudHJ5UGF0aCxcbiAgICAgICAgYGV4cG9ydCAqIGZyb20gJyR7dGhpcy5jb25maWcucGFja2FnZU5hbWV9LXdhc20zMi13YXNpJ1xcbmAsXG4gICAgICApXG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJpbmRpbmdQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYnJvd3NlckJpbmRpbmdQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogd29ya2VyUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJXb3JrZXJQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYnJvd3NlckVudHJ5UGF0aCB9LFxuICAgICAgXSBzYXRpc2ZpZXMgT3V0cHV0W11cbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBwcml2YXRlIHNldEVudklmTm90RXhpc3RzKGVudjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudltlbnZdKSB7XG4gICAgICB0aGlzLmVudnNbZW52XSA9IHZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNyZWF0ZU5wbURpcnNDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ2NyZWF0ZS1ucG0tZGlycyddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRlIG5wbSBwYWNrYWdlIGRpcnMgZm9yIGRpZmZlcmVudCBwbGF0Zm9ybXMnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpcicsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICBkcnlSdW46IHRoaXMuZHJ5UnVuLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBucG0gcGFja2FnZSBkaXJzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlTnBtRGlyc09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcnlSdW4/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyhcbiAgb3B0aW9uczogQ3JlYXRlTnBtRGlyc09wdGlvbnMsXG4pIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdzZW12ZXInXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdENyZWF0ZU5wbURpcnNPcHRpb25zLFxuICBDcmVhdGVOcG1EaXJzT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL2NyZWF0ZS1ucG0tZGlycy5qcydcbmltcG9ydCB7XG4gIGRlYnVnRmFjdG9yeSxcbiAgcmVhZE5hcGlDb25maWcsXG4gIG1rZGlyQXN5bmMgYXMgcmF3TWtkaXJBc3luYyxcbiAgcGljayxcbiAgd3JpdGVGaWxlQXN5bmMgYXMgcmF3V3JpdGVGaWxlQXN5bmMsXG4gIFRhcmdldCxcbiAgdHlwZSBDb21tb25QYWNrYWdlSnNvbkZpZWxkcyxcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdjcmVhdGUtbnBtLWRpcnMnKVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhY2thZ2VNZXRhIHtcbiAgJ2Rpc3QtdGFncyc6IHsgW2luZGV4OiBzdHJpbmddOiBzdHJpbmcgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTnBtRGlycyh1c2VyT3B0aW9uczogQ3JlYXRlTnBtRGlyc09wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdENyZWF0ZU5wbURpcnNPcHRpb25zKHVzZXJPcHRpb25zKVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG1rZGlyQXN5bmMoZGlyOiBzdHJpbmcpIHtcbiAgICBkZWJ1ZygnVHJ5IHRvIGNyZWF0ZSBkaXI6ICVpJywgZGlyKVxuICAgIGlmIChvcHRpb25zLmRyeVJ1bikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXdhaXQgcmF3TWtkaXJBc3luYyhkaXIsIHtcbiAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gd3JpdGVGaWxlQXN5bmMoZmlsZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpIHtcbiAgICBkZWJ1ZygnV3JpdGluZyBmaWxlICVpJywgZmlsZSlcblxuICAgIGlmIChvcHRpb25zLmRyeVJ1bikge1xuICAgICAgZGVidWcoY29udGVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGF3YWl0IHJhd1dyaXRlRmlsZUFzeW5jKGZpbGUsIGNvbnRlbnQpXG4gIH1cblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcbiAgY29uc3QgbnBtUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMubnBtRGlyKVxuXG4gIGRlYnVnKGBSZWFkIGNvbnRlbnQgZnJvbSBbJHtvcHRpb25zLmNvbmZpZ1BhdGggPz8gcGFja2FnZUpzb25QYXRofV1gKVxuXG4gIGNvbnN0IHsgdGFyZ2V0cywgYmluYXJ5TmFtZSwgcGFja2FnZU5hbWUsIHBhY2thZ2VKc29uIH0gPVxuICAgIGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgICAgcGFja2FnZUpzb25QYXRoLFxuICAgICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgICApXG5cbiAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgIGNvbnN0IHRhcmdldERpciA9IGpvaW4obnBtUGF0aCwgYCR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gKVxuICAgIGF3YWl0IG1rZGlyQXN5bmModGFyZ2V0RGlyKVxuXG4gICAgY29uc3QgYmluYXJ5RmlsZU5hbWUgPVxuICAgICAgdGFyZ2V0LmFyY2ggPT09ICd3YXNtMzInXG4gICAgICAgID8gYCR7YmluYXJ5TmFtZX0uJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfS53YXNtYFxuICAgICAgICA6IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ubm9kZWBcbiAgICBjb25zdCBzY29wZWRQYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHMgPSB7XG4gICAgICBuYW1lOiBgJHtwYWNrYWdlTmFtZX0tJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfWAsXG4gICAgICB2ZXJzaW9uOiBwYWNrYWdlSnNvbi52ZXJzaW9uLFxuICAgICAgY3B1OiB0YXJnZXQuYXJjaCAhPT0gJ3VuaXZlcnNhbCcgPyBbdGFyZ2V0LmFyY2hdIDogdW5kZWZpbmVkLFxuICAgICAgbWFpbjogYmluYXJ5RmlsZU5hbWUsXG4gICAgICBmaWxlczogW2JpbmFyeUZpbGVOYW1lXSxcbiAgICAgIC4uLnBpY2soXG4gICAgICAgIHBhY2thZ2VKc29uLFxuICAgICAgICAnZGVzY3JpcHRpb24nLFxuICAgICAgICAna2V5d29yZHMnLFxuICAgICAgICAnYXV0aG9yJyxcbiAgICAgICAgJ2F1dGhvcnMnLFxuICAgICAgICAnaG9tZXBhZ2UnLFxuICAgICAgICAnbGljZW5zZScsXG4gICAgICAgICdlbmdpbmVzJyxcbiAgICAgICAgJ3JlcG9zaXRvcnknLFxuICAgICAgICAnYnVncycsXG4gICAgICApLFxuICAgIH1cbiAgICBpZiAocGFja2FnZUpzb24ucHVibGlzaENvbmZpZykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ucHVibGlzaENvbmZpZyA9IHBpY2soXG4gICAgICAgIHBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcsXG4gICAgICAgICdyZWdpc3RyeScsXG4gICAgICAgICdhY2Nlc3MnLFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAodGFyZ2V0LmFyY2ggIT09ICd3YXNtMzInKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5vcyA9IFt0YXJnZXQucGxhdGZvcm1dXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gYCR7YmluYXJ5TmFtZX0ud2FzaS5janNgXG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5tYWluID0gZW50cnlcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmJyb3dzZXIgPSBgJHtiaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgXG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5maWxlcz8ucHVzaChcbiAgICAgICAgZW50cnksXG4gICAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmJyb3dzZXIsXG4gICAgICAgIGB3YXNpLXdvcmtlci5tanNgLFxuICAgICAgICBgd2FzaS13b3JrZXItYnJvd3Nlci5tanNgLFxuICAgICAgKVxuICAgICAgbGV0IG5lZWRSZXN0cmljdE5vZGVWZXJzaW9uID0gdHJ1ZVxuICAgICAgaWYgKHNjb3BlZFBhY2thZ2VKc29uLmVuZ2luZXM/Lm5vZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IG1ham9yIH0gPSBwYXJzZShzY29wZWRQYWNrYWdlSnNvbi5lbmdpbmVzLm5vZGUpID8/IHtcbiAgICAgICAgICAgIG1ham9yOiAwLFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWFqb3IgPj0gMTQpIHtcbiAgICAgICAgICAgIG5lZWRSZXN0cmljdE5vZGVWZXJzaW9uID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmVlZFJlc3RyaWN0Tm9kZVZlcnNpb24pIHtcbiAgICAgICAgc2NvcGVkUGFja2FnZUpzb24uZW5naW5lcyA9IHtcbiAgICAgICAgICBub2RlOiAnPj0xNC4wLjAnLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNtUnVudGltZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvQG5hcGktcnMvd2FzbS1ydW50aW1lYCxcbiAgICAgICkudGhlbigocmVzKSA9PiByZXMuanNvbigpIGFzIFByb21pc2U8UGFja2FnZU1ldGE+KVxuICAgICAgc2NvcGVkUGFja2FnZUpzb24uZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICAnQG5hcGktcnMvd2FzbS1ydW50aW1lJzogYF4ke3dhc21SdW50aW1lWydkaXN0LXRhZ3MnXS5sYXRlc3R9YCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LmFiaSA9PT0gJ2dudScpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmxpYmMgPSBbJ2dsaWJjJ11cbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hYmkgPT09ICdtdXNsJykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ubGliYyA9IFsnbXVzbCddXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0UGFja2FnZUpzb24gPSBqb2luKHRhcmdldERpciwgJ3BhY2thZ2UuanNvbicpXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICB0YXJnZXRQYWNrYWdlSnNvbixcbiAgICAgIEpTT04uc3RyaW5naWZ5KHNjb3BlZFBhY2thZ2VKc29uLCBudWxsLCAyKSArICdcXG4nLFxuICAgIClcbiAgICBjb25zdCB0YXJnZXRSZWFkbWUgPSBqb2luKHRhcmdldERpciwgJ1JFQURNRS5tZCcpXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmModGFyZ2V0UmVhZG1lLCByZWFkbWUocGFja2FnZU5hbWUsIHRhcmdldCkpXG5cbiAgICBkZWJ1Zy5pbmZvKGAke3BhY2thZ2VOYW1lfSAtJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfSBjcmVhdGVkYClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkbWUocGFja2FnZU5hbWU6IHN0cmluZywgdGFyZ2V0OiBUYXJnZXQpIHtcbiAgcmV0dXJuIGAjIFxcYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1cXGBcblxuVGhpcyBpcyB0aGUgKioke3RhcmdldC50cmlwbGV9KiogYmluYXJ5IGZvciBcXGAke3BhY2thZ2VOYW1lfVxcYFxuYFxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcbmltcG9ydCAqIGFzIHR5cGFuaW9uIGZyb20gJ3R5cGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZU5ld0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1snbmV3J11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdDcmVhdGUgYSBuZXcgcHJvamVjdCB3aXRoIHByZS1jb25maWd1cmVkIGJvaWxlcnBsYXRlJyxcbiAgfSlcblxuICAkJHBhdGggPSBPcHRpb24uU3RyaW5nKHsgcmVxdWlyZWQ6IGZhbHNlIH0pXG5cbiAgJCRuYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1uYW1lLC1uJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaWYgbm90IHByb3ZpZGVkJyxcbiAgfSlcblxuICBtaW5Ob2RlQXBpVmVyc2lvbiA9IE9wdGlvbi5TdHJpbmcoJy0tbWluLW5vZGUtYXBpLC12JywgJzQnLCB7XG4gICAgdmFsaWRhdG9yOiB0eXBhbmlvbi5pc051bWJlcigpLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG1pbmltdW0gTm9kZS1BUEkgdmVyc2lvbiB0byBzdXBwb3J0JyxcbiAgfSlcblxuICBwYWNrYWdlTWFuYWdlciA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1tYW5hZ2VyJywgJ3lhcm4nLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgcGFja2FnZSBtYW5hZ2VyIHRvIHVzZS4gT25seSBzdXBwb3J0IHlhcm4gNC54IGZvciBub3cuJyxcbiAgfSlcblxuICBsaWNlbnNlID0gT3B0aW9uLlN0cmluZygnLS1saWNlbnNlLC1sJywgJ01JVCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0xpY2Vuc2UgZm9yIG9wZW4tc291cmNlZCBwcm9qZWN0JyxcbiAgfSlcblxuICB0YXJnZXRzID0gT3B0aW9uLkFycmF5KCctLXRhcmdldHMsLXQnLCBbXSwge1xuICAgIGRlc2NyaXB0aW9uOiAnQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yLicsXG4gIH0pXG5cbiAgZW5hYmxlRGVmYXVsdFRhcmdldHMgPSBPcHRpb24uQm9vbGVhbignLS1lbmFibGUtZGVmYXVsdC10YXJnZXRzJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzJyxcbiAgfSlcblxuICBlbmFibGVBbGxUYXJnZXRzID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWFsbC10YXJnZXRzJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZW5hYmxlIGFsbCB0YXJnZXRzJyxcbiAgfSlcblxuICBlbmFibGVUeXBlRGVmID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLXR5cGUtZGVmJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1doZXRoZXIgZW5hYmxlIHRoZSBgdHlwZS1kZWZgIGZlYXR1cmUgZm9yIHR5cGVzY3JpcHQgZGVmaW5pdGlvbnMgYXV0by1nZW5lcmF0aW9uJyxcbiAgfSlcblxuICBlbmFibGVHaXRodWJBY3Rpb25zID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWdpdGh1Yi1hY3Rpb25zJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBnZW5lcmF0ZSBwcmVjb25maWd1cmVkIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93JyxcbiAgfSlcblxuICB0ZXN0RnJhbWV3b3JrID0gT3B0aW9uLlN0cmluZygnLS10ZXN0LWZyYW1ld29yaycsICdhdmEnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIEphdmFTY3JpcHQgdGVzdCBmcmFtZXdvcmsgdG8gdXNlLCBvbmx5IHN1cHBvcnQgYGF2YWAgZm9yIG5vdycsXG4gIH0pXG5cbiAgZHJ5UnVuID0gT3B0aW9uLkJvb2xlYW4oJy0tZHJ5LXJ1bicsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIHRvIHJ1biB0aGUgY29tbWFuZCBpbiBkcnktcnVuIG1vZGUnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHRoaXMuJCRwYXRoLFxuICAgICAgbmFtZTogdGhpcy4kJG5hbWUsXG4gICAgICBtaW5Ob2RlQXBpVmVyc2lvbjogdGhpcy5taW5Ob2RlQXBpVmVyc2lvbixcbiAgICAgIHBhY2thZ2VNYW5hZ2VyOiB0aGlzLnBhY2thZ2VNYW5hZ2VyLFxuICAgICAgbGljZW5zZTogdGhpcy5saWNlbnNlLFxuICAgICAgdGFyZ2V0czogdGhpcy50YXJnZXRzLFxuICAgICAgZW5hYmxlRGVmYXVsdFRhcmdldHM6IHRoaXMuZW5hYmxlRGVmYXVsdFRhcmdldHMsXG4gICAgICBlbmFibGVBbGxUYXJnZXRzOiB0aGlzLmVuYWJsZUFsbFRhcmdldHMsXG4gICAgICBlbmFibGVUeXBlRGVmOiB0aGlzLmVuYWJsZVR5cGVEZWYsXG4gICAgICBlbmFibGVHaXRodWJBY3Rpb25zOiB0aGlzLmVuYWJsZUdpdGh1YkFjdGlvbnMsXG4gICAgICB0ZXN0RnJhbWV3b3JrOiB0aGlzLnRlc3RGcmFtZXdvcmssXG4gICAgICBkcnlSdW46IHRoaXMuZHJ5UnVuLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwcm9qZWN0IHdpdGggcHJlLWNvbmZpZ3VyZWQgYm9pbGVycGxhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXdPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHdoZXJlIHRoZSBOQVBJLVJTIHByb2plY3Qgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgcGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSBpZiBub3QgcHJvdmlkZWRcbiAgICovXG4gIG5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIE5vZGUtQVBJIHZlcnNpb24gdG8gc3VwcG9ydFxuICAgKlxuICAgKiBAZGVmYXVsdCA0XG4gICAqL1xuICBtaW5Ob2RlQXBpVmVyc2lvbj86IG51bWJlclxuICAvKipcbiAgICogVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UuIE9ubHkgc3VwcG9ydCB5YXJuIDQueCBmb3Igbm93LlxuICAgKlxuICAgKiBAZGVmYXVsdCAneWFybidcbiAgICovXG4gIHBhY2thZ2VNYW5hZ2VyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdFxuICAgKlxuICAgKiBAZGVmYXVsdCAnTUlUJ1xuICAgKi9cbiAgbGljZW5zZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgdGFyZ2V0cz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSBkZWZhdWx0IHRhcmdldHNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlRGVmYXVsdFRhcmdldHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSBhbGwgdGFyZ2V0c1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZW5hYmxlQWxsVGFyZ2V0cz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZW5hYmxlIHRoZSBgdHlwZS1kZWZgIGZlYXR1cmUgZm9yIHR5cGVzY3JpcHQgZGVmaW5pdGlvbnMgYXV0by1nZW5lcmF0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZVR5cGVEZWY/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGdlbmVyYXRlIHByZWNvbmZpZ3VyZWQgR2l0SHViIEFjdGlvbnMgd29ya2Zsb3dcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlR2l0aHViQWN0aW9ucz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBKYXZhU2NyaXB0IHRlc3QgZnJhbWV3b3JrIHRvIHVzZSwgb25seSBzdXBwb3J0IGBhdmFgIGZvciBub3dcbiAgICpcbiAgICogQGRlZmF1bHQgJ2F2YSdcbiAgICovXG4gIHRlc3RGcmFtZXdvcms/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcnVuIHRoZSBjb21tYW5kIGluIGRyeS1ydW4gbW9kZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0TmV3T3B0aW9ucyhvcHRpb25zOiBOZXdPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgbWluTm9kZUFwaVZlcnNpb246IDQsXG4gICAgcGFja2FnZU1hbmFnZXI6ICd5YXJuJyxcbiAgICBsaWNlbnNlOiAnTUlUJyxcbiAgICB0YXJnZXRzOiBbXSxcbiAgICBlbmFibGVEZWZhdWx0VGFyZ2V0czogdHJ1ZSxcbiAgICBlbmFibGVBbGxUYXJnZXRzOiBmYWxzZSxcbiAgICBlbmFibGVUeXBlRGVmOiB0cnVlLFxuICAgIGVuYWJsZUdpdGh1YkFjdGlvbnM6IHRydWUsXG4gICAgdGVzdEZyYW1ld29yazogJ2F2YScsXG4gICAgZHJ5UnVuOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuLy8gQmFyZSBrZXlzIG1heSBvbmx5IGNvbnRhaW4gQVNDSUkgbGV0dGVycyxcbi8vIEFTQ0lJIGRpZ2l0cywgdW5kZXJzY29yZXMsIGFuZCBkYXNoZXMgKEEtWmEtejAtOV8tKS5cbmZ1bmN0aW9uIGpvaW5LZXlzKGtleXMpIHtcbiAgLy8gRG90dGVkIGtleXMgYXJlIGEgc2VxdWVuY2Ugb2YgYmFyZSBvciBxdW90ZWQga2V5cyBqb2luZWQgd2l0aCBhIGRvdC5cbiAgLy8gVGhpcyBhbGxvd3MgZm9yIGdyb3VwaW5nIHNpbWlsYXIgcHJvcGVydGllcyB0b2dldGhlcjpcbiAgcmV0dXJuIGtleXMubWFwKChzdHIpPT57XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDAgfHwgc3RyLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID8gSlNPTi5zdHJpbmdpZnkoc3RyKSA6IHN0cjtcbiAgfSkuam9pbihcIi5cIik7XG59XG5jbGFzcyBEdW1wZXIge1xuICBtYXhQYWQgPSAwO1xuICBzcmNPYmplY3Q7XG4gIG91dHB1dCA9IFtdO1xuICAjYXJyYXlUeXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHNyY09iamMpe1xuICAgIHRoaXMuc3JjT2JqZWN0ID0gc3JjT2JqYztcbiAgfVxuICBkdW1wKGZtdE9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLiNwcmludE9iamVjdCh0aGlzLnNyY09iamVjdCk7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLiNmb3JtYXQoZm10T3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0O1xuICB9XG4gICNwcmludE9iamVjdChvYmosIGtleXMgPSBbXSkge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBpbmxpbmVQcm9wcyA9IFtdO1xuICAgIGNvbnN0IG11bHRpbGluZVByb3BzID0gW107XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKXtcbiAgICAgIGlmICh0aGlzLiNpc1NpbXBseVNlcmlhbGl6YWJsZShvYmpbcHJvcF0pKSB7XG4gICAgICAgIGlubGluZVByb3BzLnB1c2gocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aWxpbmVQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzb3J0ZWRQcm9wcyA9IGlubGluZVByb3BzLmNvbmNhdChtdWx0aWxpbmVQcm9wcyk7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHNvcnRlZFByb3BzKXtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNkYXRlRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI3N0ckRlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI251bWJlckRlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jYm9vbERlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXlUeXBlID0gdGhpcy4jZ2V0VHlwZU9mQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoYXJyYXlUeXBlID09PSBcIk9OTFlfUFJJTUlUSVZFXCIpIHtcbiAgICAgICAgICBvdXQucHVzaCh0aGlzLiNhcnJheURlY2xhcmF0aW9uKFtcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5VHlwZSA9PT0gXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIikge1xuICAgICAgICAgIC8vIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgb3V0LnB1c2goXCJcIik7XG4gICAgICAgICAgICBvdXQucHVzaCh0aGlzLiNoZWFkZXJHcm91cChbXG4gICAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIG91dC5wdXNoKC4uLnRoaXMuI3ByaW50T2JqZWN0KHZhbHVlW2ldLCBbXG4gICAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbXBsZXggYXJyYXksIHVzZSB0aGUgaW5saW5lIGZvcm1hdC5cbiAgICAgICAgICBjb25zdCBzdHIgPSB2YWx1ZS5tYXAoKHgpPT50aGlzLiNwcmludEFzSW5saW5lVmFsdWUoeCkpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIG91dC5wdXNoKGAke3RoaXMuI2RlY2xhcmF0aW9uKFtcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdKX1bJHtzdHJ9XWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvdXQucHVzaChcIlwiKTtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jaGVhZGVyKFtcbiAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgIHByb3BcbiAgICAgICAgXSkpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB0b1BhcnNlID0gdmFsdWU7XG4gICAgICAgICAgb3V0LnB1c2goLi4udGhpcy4jcHJpbnRPYmplY3QodG9QYXJzZSwgW1xuICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdKSk7XG4gICAgICAgIH1cbiAgICAgIC8vIG91dC5wdXNoKC4uLnRoaXMuX3BhcnNlKHZhbHVlLCBgJHtwYXRofSR7cHJvcH0uYCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQucHVzaChcIlwiKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gICNpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgW1xuICAgICAgXCJzdHJpbmdcIixcbiAgICAgIFwibnVtYmVyXCIsXG4gICAgICBcImJvb2xlYW5cIlxuICAgIF0uaW5jbHVkZXModHlwZW9mIHZhbHVlKTtcbiAgfVxuICAjZ2V0VHlwZU9mQXJyYXkoYXJyKSB7XG4gICAgaWYgKHRoaXMuI2FycmF5VHlwZUNhY2hlLmhhcyhhcnIpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXJyYXlUeXBlQ2FjaGUuZ2V0KGFycik7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLiNkb0dldFR5cGVPZkFycmF5KGFycik7XG4gICAgdGhpcy4jYXJyYXlUeXBlQ2FjaGUuc2V0KGFyciwgdHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgI2RvR2V0VHlwZU9mQXJyYXkoYXJyKSB7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAvLyBhbnkgdHlwZSBzaG91bGQgYmUgZmluZVxuICAgICAgcmV0dXJuIFwiT05MWV9QUklNSVRJVkVcIjtcbiAgICB9XG4gICAgY29uc3Qgb25seVByaW1pdGl2ZSA9IHRoaXMuI2lzUHJpbWl0aXZlKGFyclswXSk7XG4gICAgaWYgKGFyclswXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gXCJNSVhFRFwiO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChvbmx5UHJpbWl0aXZlICE9PSB0aGlzLiNpc1ByaW1pdGl2ZShhcnJbaV0pIHx8IGFycltpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcIk1JWEVEXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbmx5UHJpbWl0aXZlID8gXCJPTkxZX1BSSU1JVElWRVwiIDogXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIjtcbiAgfVxuICAjcHJpbnRBc0lubGluZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGBcIiR7dGhpcy4jcHJpbnREYXRlKHZhbHVlKX1cImA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjb25zdCBzdHIgPSB2YWx1ZS5tYXAoKHgpPT50aGlzLiNwcmludEFzSW5saW5lVmFsdWUoeCkpLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGBbJHtzdHJ9XWA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RyID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2V5KT0+e1xuICAgICAgICByZXR1cm4gYCR7am9pbktleXMoW1xuICAgICAgICAgIGtleVxuICAgICAgICBdKX0gPSAkey8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMuI3ByaW50QXNJbmxpbmVWYWx1ZSh2YWx1ZVtrZXldKX1gO1xuICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYHske3N0cn19YDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoXCIpO1xuICB9XG4gICNpc1NpbXBseVNlcmlhbGl6YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdGhpcy4jZ2V0VHlwZU9mQXJyYXkodmFsdWUpICE9PSBcIk9OTFlfT0JKRUNUX0VYQ0xVRElOR19BUlJBWVwiO1xuICB9XG4gICNoZWFkZXIoa2V5cykge1xuICAgIHJldHVybiBgWyR7am9pbktleXMoa2V5cyl9XWA7XG4gIH1cbiAgI2hlYWRlckdyb3VwKGtleXMpIHtcbiAgICByZXR1cm4gYFtbJHtqb2luS2V5cyhrZXlzKX1dXWA7XG4gIH1cbiAgI2RlY2xhcmF0aW9uKGtleXMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGpvaW5LZXlzKGtleXMpO1xuICAgIGlmICh0aXRsZS5sZW5ndGggPiB0aGlzLm1heFBhZCkge1xuICAgICAgdGhpcy5tYXhQYWQgPSB0aXRsZS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aXRsZX0gPSBgO1xuICB9XG4gICNhcnJheURlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gIH1cbiAgI3N0ckRlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gIH1cbiAgI251bWJlckRlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX1uYW5gO1xuICAgIH1cbiAgICBzd2l0Y2godmFsdWUpe1xuICAgICAgY2FzZSBJbmZpbml0eTpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfWluZmA7XG4gICAgICBjYXNlIC1JbmZpbml0eTpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfS1pbmZgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dmFsdWV9YDtcbiAgICB9XG4gIH1cbiAgI2Jvb2xEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke3ZhbHVlfWA7XG4gIH1cbiAgI3ByaW50RGF0ZSh2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIGR0UGFkKHYsIGxQYWQgPSAyKSB7XG4gICAgICByZXR1cm4gdi5wYWRTdGFydChsUGFkLCBcIjBcIik7XG4gICAgfVxuICAgIGNvbnN0IG0gPSBkdFBhZCgodmFsdWUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IGQgPSBkdFBhZCh2YWx1ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgaCA9IGR0UGFkKHZhbHVlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbWluID0gZHRQYWQodmFsdWUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IHMgPSBkdFBhZCh2YWx1ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbXMgPSBkdFBhZCh2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKS50b1N0cmluZygpLCAzKTtcbiAgICAvLyBmb3JtYXR0ZWQgZGF0ZVxuICAgIGNvbnN0IGZEYXRhID0gYCR7dmFsdWUuZ2V0VVRDRnVsbFllYXIoKX0tJHttfS0ke2R9VCR7aH06JHttaW59OiR7c30uJHttc31gO1xuICAgIHJldHVybiBmRGF0YTtcbiAgfVxuICAjZGF0ZURlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dGhpcy4jcHJpbnREYXRlKHZhbHVlKX1gO1xuICB9XG4gICNmb3JtYXQob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBrZXlBbGlnbm1lbnQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByRGVjbGFyYXRpb24gPSAvXihcXFwiLipcXFwifFtePV0qKVxccz0vO1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dC5sZW5ndGg7IGkrKyl7XG4gICAgICBjb25zdCBsID0gdGhpcy5vdXRwdXRbaV07XG4gICAgICAvLyB3ZSBrZWVwIGVtcHR5IGVudHJ5IGZvciBhcnJheSBvZiBvYmplY3RzXG4gICAgICBpZiAobFswXSA9PT0gXCJbXCIgJiYgbFsxXSAhPT0gXCJbXCIpIHtcbiAgICAgICAgLy8gbm9uLWVtcHR5IG9iamVjdCB3aXRoIG9ubHkgc3Vib2JqZWN0cyBhcyBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICh0aGlzLm91dHB1dFtpICsgMV0gPT09IFwiXCIgJiYgdGhpcy5vdXRwdXRbaSArIDJdPy5zbGljZSgwLCBsLmxlbmd0aCkgPT09IGwuc2xpY2UoMCwgLTEpICsgXCIuXCIpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5QWxpZ25tZW50KSB7XG4gICAgICAgICAgY29uc3QgbSA9IHJEZWNsYXJhdGlvbi5leGVjKGwpO1xuICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGwucmVwbGFjZShtWzFdLCBtWzFdLnBhZEVuZCh0aGlzLm1heFBhZCkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5wdXNoKGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFuaW5nIG11bHRpcGxlIHNwYWNlc1xuICAgIGNvbnN0IGNsZWFuZWRPdXRwdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IGwgPSBvdXRbaV07XG4gICAgICBpZiAoIShsID09PSBcIlwiICYmIG91dFtpICsgMV0gPT09IFwiXCIpKSB7XG4gICAgICAgIGNsZWFuZWRPdXRwdXQucHVzaChsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuZWRPdXRwdXQ7XG4gIH1cbn1cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IHRvIGEge0BsaW5rIGh0dHBzOi8vdG9tbC5pbyB8IFRPTUx9IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZSBVc2FnZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gXCJAc3RkL3RvbWwvc3RyaW5naWZ5XCI7XG4gKiBpbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tIFwiQHN0ZC9hc3NlcnRcIjtcbiAqXG4gKiBjb25zdCBvYmogPSB7XG4gKiAgIHRpdGxlOiBcIlRPTUwgRXhhbXBsZVwiLFxuICogICBvd25lcjoge1xuICogICAgIG5hbWU6IFwiQm9iXCIsXG4gKiAgICAgYmlvOiBcIkJvYiBpcyBhIGNvb2wgZ3V5XCIsXG4gKiAgfVxuICogfTtcbiAqIGNvbnN0IHRvbWxTdHJpbmcgPSBzdHJpbmdpZnkob2JqKTtcbiAqIGFzc2VydEVxdWFscyh0b21sU3RyaW5nLCBgdGl0bGUgPSBcIlRPTUwgRXhhbXBsZVwiXFxuXFxuW293bmVyXVxcbm5hbWUgPSBcIkJvYlwiXFxuYmlvID0gXCJCb2IgaXMgYSBjb29sIGd1eVwiXFxuYCk7XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogU291cmNlIG9iamVjdFxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3Igc3RyaW5naWZ5aW5nLlxuICogQHJldHVybnMgVE9NTCBzdHJpbmdcbiAqLyBleHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IER1bXBlcihvYmopLmR1bXAob3B0aW9ucykuam9pbihcIlxcblwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ2lmeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBnaXZlbiBhcnJheSwgcmVtb3ZpbmcgYWxsIGVsZW1lbnRzIHRoYXQgZG8gbm90IG1hdGNoIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAqICoqaW4gcGxhY2UuIFRoaXMgbWVhbnMgYGFycmF5YCB3aWxsIGJlIG1vZGlmaWVkISoqLlxuICovIGV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJJblBsYWNlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgbGV0IG91dHB1dEluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBjdXIgb2YgYXJyYXkpe1xuICAgIGlmICghcHJlZGljYXRlKGN1cikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhcnJheVtvdXRwdXRJbmRleF0gPSBjdXI7XG4gICAgb3V0cHV0SW5kZXggKz0gMTtcbiAgfVxuICBhcnJheS5zcGxpY2Uob3V0cHV0SW5kZXgpO1xuICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdXRpbHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IGZpbHRlckluUGxhY2UgfSBmcm9tIFwiLi9fdXRpbHMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2UocmVjb3JkLCBvdGhlciwgb3B0aW9ucykge1xuICByZXR1cm4gZGVlcE1lcmdlSW50ZXJuYWwocmVjb3JkLCBvdGhlciwgbmV3IFNldCgpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZUludGVybmFsKHJlY29yZCwgb3RoZXIsIHNlZW4sIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KFtcbiAgICAuLi5nZXRLZXlzKHJlY29yZCksXG4gICAgLi4uZ2V0S2V5cyhvdGhlcilcbiAgXSk7XG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGtleSBvZiBvdGhlciBvYmplY3QgYW5kIHVzZSBjb3JyZWN0IG1lcmdpbmcgc3RyYXRlZ3lcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyl7XG4gICAgLy8gU2tpcCB0byBwcmV2ZW50IE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fIGFjY2Vzc29yIHByb3BlcnR5IGNhbGxzIG9uIG5vbi1EZW5vIHBsYXRmb3Jtc1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBhID0gcmVjb3JkW2tleV07XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKG90aGVyLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYiA9IG90aGVyW2tleV07XG4gICAgaWYgKGlzTm9uTnVsbE9iamVjdChhKSAmJiBpc05vbk51bGxPYmplY3QoYikgJiYgIXNlZW4uaGFzKGEpICYmICFzZWVuLmhhcyhiKSkge1xuICAgICAgc2Vlbi5hZGQoYSk7XG4gICAgICBzZWVuLmFkZChiKTtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPYmplY3RzKGEsIGIsIHNlZW4sIG9wdGlvbnMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIHZhbHVlXG4gICAgcmVzdWx0W2tleV0gPSBiO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMobGVmdCwgcmlnaHQsIHNlZW4sIG9wdGlvbnMgPSB7XG4gIGFycmF5czogXCJtZXJnZVwiLFxuICBzZXRzOiBcIm1lcmdlXCIsXG4gIG1hcHM6IFwibWVyZ2VcIlxufSkge1xuICAvLyBSZWN1cnNpdmVseSBtZXJnZSBtZXJnZWFibGUgb2JqZWN0c1xuICBpZiAoaXNNZXJnZWFibGUobGVmdCkgJiYgaXNNZXJnZWFibGUocmlnaHQpKSB7XG4gICAgcmV0dXJuIGRlZXBNZXJnZUludGVybmFsKGxlZnQsIHJpZ2h0LCBzZWVuLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShsZWZ0KSAmJiBpc0l0ZXJhYmxlKHJpZ2h0KSkge1xuICAgIC8vIEhhbmRsZSBhcnJheXNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsZWZ0KSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0KSkge1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gICAgLy8gSGFuZGxlIG1hcHNcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIE1hcCAmJiByaWdodCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgaWYgKG9wdGlvbnMubWFwcyA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKFtcbiAgICAgICAgICAuLi5sZWZ0LFxuICAgICAgICAgIC4uLnJpZ2h0XG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgc2V0c1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgU2V0ICYmIHJpZ2h0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBpZiAob3B0aW9ucy5zZXRzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoW1xuICAgICAgICAgIC4uLmxlZnQsXG4gICAgICAgICAgLi4ucmlnaHRcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByaWdodDtcbn1cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgbWVyZ2VhYmxlIG9yIG5vdFxuICogQnVpbHRpbnMgdGhhdCBsb29rIGxpa2Ugb2JqZWN0cywgbnVsbCBhbmQgdXNlciBkZWZpbmVkIGNsYXNzZXNcbiAqIGFyZSBub3QgY29uc2lkZXJlZCBtZXJnZWFibGUgKGl0IG1lYW5zIHRoYXQgcmVmZXJlbmNlIHdpbGwgYmUgY29waWVkKVxuICovIGZ1bmN0aW9uIGlzTWVyZ2VhYmxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gaXNJdGVyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gZ2V0S2V5cyhyZWNvcmQpIHtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyZWNvcmQpO1xuICBmaWx0ZXJJblBsYWNlKHJlc3VsdCwgKGtleSk9Pk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChyZWNvcmQsIGtleSkpO1xuICByZXN1bHQucHVzaCguLi5PYmplY3Qua2V5cyhyZWNvcmQpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZXBfbWVyZ2UuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gXCJAanNyL3N0ZF9fY29sbGVjdGlvbnMvZGVlcC1tZXJnZVwiO1xuLyoqXG4gKiBDb3B5IG9mIGBpbXBvcnQgeyBpc0xlYXAgfSBmcm9tIFwiQHN0ZC9kYXRldGltZVwiO2AgYmVjYXVzZSBpdCBjYW5ub3QgYmUgaW1wb3RlZCBhcyBsb25nIGFzIGl0IGlzIHVuc3RhYmxlLlxuICovIGZ1bmN0aW9uIGlzTGVhcCh5ZWFyTnVtYmVyKSB7XG4gIHJldHVybiB5ZWFyTnVtYmVyICUgNCA9PT0gMCAmJiB5ZWFyTnVtYmVyICUgMTAwICE9PSAwIHx8IHllYXJOdW1iZXIgJSA0MDAgPT09IDA7XG59XG5leHBvcnQgY2xhc3MgU2Nhbm5lciB7XG4gICN3aGl0ZXNwYWNlID0gL1sgXFx0XS87XG4gICNwb3NpdGlvbiA9IDA7XG4gICNzb3VyY2U7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSl7XG4gICAgdGhpcy4jc291cmNlID0gc291cmNlO1xuICB9XG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb247XG4gIH1cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIGluZGV4IC0gcmVsYXRpdmUgaW5kZXggZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqLyBjaGFyKGluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2VbdGhpcy4jcG9zaXRpb24gKyBpbmRleF0gPz8gXCJcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHNsaWNlZCBzdHJpbmdcbiAgICogQHBhcmFtIHN0YXJ0IC0gc3RhcnQgcG9zaXRpb24gcmVsYXRpdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqIEBwYXJhbSBlbmQgLSBlbmQgcG9zaXRpb24gcmVsYXRpdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqLyBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5zbGljZSh0aGlzLiNwb3NpdGlvbiArIHN0YXJ0LCB0aGlzLiNwb3NpdGlvbiArIGVuZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgcG9zaXRpb24gdG8gbmV4dFxuICAgKi8gbmV4dChjb3VudCA9IDEpIHtcbiAgICB0aGlzLiNwb3NpdGlvbiArPSBjb3VudDtcbiAgfVxuICBza2lwV2hpdGVzcGFjZXMoKSB7XG4gICAgd2hpbGUodGhpcy4jd2hpdGVzcGFjZS50ZXN0KHRoaXMuY2hhcigpKSAmJiAhdGhpcy5lb2YoKSl7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgLy8gSW52YWxpZCBpZiBjdXJyZW50IGNoYXIgaXMgb3RoZXIga2luZHMgb2Ygd2hpdGVzcGFjZVxuICAgIGlmICghdGhpcy5pc0N1cnJlbnRDaGFyRU9MKCkgJiYgL1xccy8udGVzdCh0aGlzLmNoYXIoKSkpIHtcbiAgICAgIGNvbnN0IGVzY2FwZWQgPSBcIlxcXFx1XCIgKyB0aGlzLmNoYXIoKS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jcG9zaXRpb247XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENhbm5vdCBwYXJzZSB0aGUgVE9NTDogSXQgY29udGFpbnMgaW52YWxpZCB3aGl0ZXNwYWNlIGF0IHBvc2l0aW9uICcke3Bvc2l0aW9ufSc6IFxcYCR7ZXNjYXBlZH1cXGBgKTtcbiAgICB9XG4gIH1cbiAgbmV4dFVudGlsQ2hhcihvcHRpb25zID0ge1xuICAgIHNraXBDb21tZW50czogdHJ1ZVxuICB9KSB7XG4gICAgd2hpbGUoIXRoaXMuZW9mKCkpe1xuICAgICAgY29uc3QgY2hhciA9IHRoaXMuY2hhcigpO1xuICAgICAgaWYgKHRoaXMuI3doaXRlc3BhY2UudGVzdChjaGFyKSB8fCB0aGlzLmlzQ3VycmVudENoYXJFT0woKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5za2lwQ29tbWVudHMgJiYgdGhpcy5jaGFyKCkgPT09IFwiI1wiKSB7XG4gICAgICAgIC8vIGVudGVyaW5nIGNvbW1lbnRcbiAgICAgICAgd2hpbGUoIXRoaXMuaXNDdXJyZW50Q2hhckVPTCgpICYmICF0aGlzLmVvZigpKXtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQb3NpdGlvbiByZWFjaGVkIEVPRiBvciBub3RcbiAgICovIGVvZigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPj0gdGhpcy4jc291cmNlLmxlbmd0aDtcbiAgfVxuICBpc0N1cnJlbnRDaGFyRU9MKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXIoKSA9PT0gXCJcXG5cIiB8fCB0aGlzLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIik7XG4gIH1cbiAgc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nLCB0aGlzLiNwb3NpdGlvbik7XG4gIH1cbiAgbWF0Y2gocmVnRXhwKSB7XG4gICAgaWYgKCFyZWdFeHAuc3RpY2t5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZ0V4cCAke3JlZ0V4cH0gZG9lcyBub3QgaGF2ZSBhIHN0aWNreSAneScgZmxhZ2ApO1xuICAgIH1cbiAgICByZWdFeHAubGFzdEluZGV4ID0gdGhpcy4jcG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5tYXRjaChyZWdFeHApO1xuICB9XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVXRpbGl0aWVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3VjY2Vzcyhib2R5KSB7XG4gIHJldHVybiB7XG4gICAgb2s6IHRydWUsXG4gICAgYm9keVxuICB9O1xufVxuZnVuY3Rpb24gZmFpbHVyZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBvazogZmFsc2VcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGUga2V5cyBhbmQgdmFsdWVzLlxuICpcbiAqIGUuZy4gYHVuZmxhdChbXCJhXCIsIFwiYlwiLCBcImNcIl0sIDEpYCByZXR1cm5zIGB7IGE6IHsgYjogeyBjOiAxIH0gfSB9YFxuICovIGV4cG9ydCBmdW5jdGlvbiB1bmZsYXQoa2V5cywgdmFsdWVzID0ge30pIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlUmlnaHQoKGFjYywga2V5KT0+KHtcbiAgICAgIFtrZXldOiBhY2NcbiAgICB9KSwgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRWYWx1ZSh0YXJnZXQsIGtleXMpIHtcbiAgY29uc3Qga2V5ID0ga2V5c1swXTtcbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgdGhlIFRPTUw6IGtleSBsZW5ndGggaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIHJldHVybiB0YXJnZXRba2V5XTtcbn1cbmZ1bmN0aW9uIGRlZXBBc3NpZ25UYWJsZSh0YXJnZXQsIHRhYmxlKSB7XG4gIGNvbnN0IHsga2V5cywgdHlwZSwgdmFsdWUgfSA9IHRhYmxlO1xuICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRUYXJnZXRWYWx1ZSh0YXJnZXQsIGtleXMpO1xuICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHVuZmxhdChrZXlzLCB2YWx1ZSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBjb25zdCBsYXN0ID0gY3VycmVudFZhbHVlLmF0KC0xKTtcbiAgICBkZWVwQXNzaWduKGxhc3QsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc09iamVjdChjdXJyZW50VmFsdWUpKSB7XG4gICAgZGVlcEFzc2lnbihjdXJyZW50VmFsdWUsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYXNzaWduXCIpO1xufVxuZnVuY3Rpb24gZGVlcEFzc2lnblRhYmxlQXJyYXkodGFyZ2V0LCB0YWJsZSkge1xuICBjb25zdCB7IHR5cGUsIGtleXMsIHZhbHVlIH0gPSB0YWJsZTtcbiAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB1bmZsYXQoa2V5cywgW1xuICAgICAgdmFsdWVcbiAgICBdKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgIGN1cnJlbnRWYWx1ZS5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc09iamVjdChjdXJyZW50VmFsdWUpKSB7XG4gICAgZGVlcEFzc2lnbihjdXJyZW50VmFsdWUsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYXNzaWduXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0LCBib2R5KSB7XG4gIHN3aXRjaChib2R5LnR5cGUpe1xuICAgIGNhc2UgXCJCbG9ja1wiOlxuICAgICAgcmV0dXJuIGRlZXBNZXJnZSh0YXJnZXQsIGJvZHkudmFsdWUpO1xuICAgIGNhc2UgXCJUYWJsZVwiOlxuICAgICAgcmV0dXJuIGRlZXBBc3NpZ25UYWJsZSh0YXJnZXQsIGJvZHkpO1xuICAgIGNhc2UgXCJUYWJsZUFycmF5XCI6XG4gICAgICByZXR1cm4gZGVlcEFzc2lnblRhYmxlQXJyYXkodGFyZ2V0LCBib2R5KTtcbiAgfVxufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQYXJzZXIgY29tYmluYXRvcnMgYW5kIGdlbmVyYXRvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIG9yKHBhcnNlcnMpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGZvciAoY29uc3QgcGFyc2Ugb2YgcGFyc2Vycyl7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZShzY2FubmVyKTtcbiAgICAgIGlmIChyZXN1bHQub2spIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBmYWlsdXJlKCk7XG4gIH07XG59XG4vKiogSm9pbiB0aGUgcGFyc2UgcmVzdWx0cyBvZiB0aGUgZ2l2ZW4gcGFyc2VyIGludG8gYW4gYXJyYXkuXG4gKlxuICogSWYgdGhlIHBhcnNlciBmYWlscyBhdCB0aGUgZmlyc3QgYXR0ZW1wdCwgaXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gKi8gZnVuY3Rpb24gam9pbihwYXJzZXIsIHNlcGFyYXRvcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghZmlyc3Qub2spIHJldHVybiBzdWNjZXNzKG91dCk7XG4gICAgb3V0LnB1c2goZmlyc3QuYm9keSk7XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgaWYgKCFTZXBhcmF0b3Ioc2Nhbm5lcikub2spIGJyZWFrO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3Mob3V0KTtcbiAgfTtcbn1cbi8qKiBKb2luIHRoZSBwYXJzZSByZXN1bHRzIG9mIHRoZSBnaXZlbiBwYXJzZXIgaW50byBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIHJlcXVpcmVzIHRoZSBwYXJzZXIgdG8gc3VjY2VlZCBhdCBsZWFzdCBvbmNlLlxuICovIGZ1bmN0aW9uIGpvaW4xKHBhcnNlciwgc2VwYXJhdG9yKSB7XG4gIGNvbnN0IFNlcGFyYXRvciA9IGNoYXJhY3RlcihzZXBhcmF0b3IpO1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgZmlyc3QgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFmaXJzdC5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBjb25zdCBvdXQgPSBbXG4gICAgICBmaXJzdC5ib2R5XG4gICAgXTtcbiAgICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgICBpZiAoIVNlcGFyYXRvcihzY2FubmVyKS5vaykgYnJlYWs7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke3NlcGFyYXRvcn1cImApO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcyhvdXQpO1xuICB9O1xufVxuZnVuY3Rpb24ga3Yoa2V5UGFyc2VyLCBzZXBhcmF0b3IsIHZhbHVlUGFyc2VyKSB7XG4gIGNvbnN0IFNlcGFyYXRvciA9IGNoYXJhY3RlcihzZXBhcmF0b3IpO1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgcG9zaXRpb24gPSBzY2FubmVyLnBvc2l0aW9uO1xuICAgIGNvbnN0IGtleSA9IGtleVBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIWtleS5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBjb25zdCBzZXAgPSBTZXBhcmF0b3Ioc2Nhbm5lcik7XG4gICAgaWYgKCFzZXAub2spIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihga2V5L3ZhbHVlIHBhaXIgZG9lc24ndCBoYXZlIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXZhbHVlLm9rKSB7XG4gICAgICBjb25zdCBsaW5lRW5kSW5kZXggPSBzY2FubmVyLnNvdXJjZS5pbmRleE9mKFwiXFxuXCIsIHNjYW5uZXIucG9zaXRpb24pO1xuICAgICAgY29uc3QgZW5kUG9zaXRpb24gPSBsaW5lRW5kSW5kZXggPiAwID8gbGluZUVuZEluZGV4IDogc2Nhbm5lci5zb3VyY2UubGVuZ3RoO1xuICAgICAgY29uc3QgbGluZSA9IHNjYW5uZXIuc291cmNlLnNsaWNlKHBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENhbm5vdCBwYXJzZSB2YWx1ZSBvbiBsaW5lICcke2xpbmV9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2Vzcyh1bmZsYXQoa2V5LmJvZHksIHZhbHVlLmJvZHkpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlKHBhcnNlcikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIGxldCBib2R5ID0ge307XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVzdWx0LmJvZHkpe1xuICAgICAgaWYgKHR5cGVvZiByZWNvcmQgPT09IFwib2JqZWN0XCIgJiYgcmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBkZWVwTWVyZ2UoYm9keSwgcmVjb3JkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiByZXBlYXQocGFyc2VyKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgICAgYm9keS5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICAgIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICAgIH1cbiAgICBpZiAoYm9keS5sZW5ndGggPT09IDApIHJldHVybiBmYWlsdXJlKCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiBzdXJyb3VuZChsZWZ0LCBwYXJzZXIsIHJpZ2h0KSB7XG4gIGNvbnN0IExlZnQgPSBjaGFyYWN0ZXIobGVmdCk7XG4gIGNvbnN0IFJpZ2h0ID0gY2hhcmFjdGVyKHJpZ2h0KTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGlmICghTGVmdChzY2FubmVyKS5vaykge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFSaWdodChzY2FubmVyKS5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb3QgY2xvc2VkIGJ5IFwiJHtyaWdodH1cIiBhZnRlciBzdGFydGVkIHdpdGggXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MocmVzdWx0LmJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gY2hhcmFjdGVyKHN0cikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aChzdHIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIHNjYW5uZXIubmV4dChzdHIubGVuZ3RoKTtcbiAgICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICAgIHJldHVybiBzdWNjZXNzKHVuZGVmaW5lZCk7XG4gIH07XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2VyIGNvbXBvbmVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBCQVJFX0tFWV9SRUdFWFAgPSAvW0EtWmEtejAtOV8tXSsveTtcbmV4cG9ydCBmdW5jdGlvbiBiYXJlS2V5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3Qga2V5ID0gc2Nhbm5lci5tYXRjaChCQVJFX0tFWV9SRUdFWFApPy5bMF07XG4gIGlmICgha2V5KSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoa2V5Lmxlbmd0aCk7XG4gIHJldHVybiBzdWNjZXNzKGtleSk7XG59XG5mdW5jdGlvbiBlc2NhcGVTZXF1ZW5jZShzY2FubmVyKSB7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJcXFxcXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICAvLyBTZWUgaHR0cHM6Ly90b21sLmlvL2VuL3YxLjAuMC1yYy4zI3N0cmluZ1xuICBzd2l0Y2goc2Nhbm5lci5jaGFyKCkpe1xuICAgIGNhc2UgXCJiXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxiXCIpO1xuICAgIGNhc2UgXCJ0XCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFx0XCIpO1xuICAgIGNhc2UgXCJuXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxuXCIpO1xuICAgIGNhc2UgXCJmXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxmXCIpO1xuICAgIGNhc2UgXCJyXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxyXCIpO1xuICAgIGNhc2UgXCJ1XCI6XG4gICAgY2FzZSBcIlVcIjpcbiAgICAgIHtcbiAgICAgICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgY29kZVBvaW50TGVuID0gc2Nhbm5lci5jaGFyKCkgPT09IFwidVwiID8gNCA6IDY7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHBhcnNlSW50KFwiMHhcIiArIHNjYW5uZXIuc2xpY2UoMSwgMSArIGNvZGVQb2ludExlbiksIDE2KTtcbiAgICAgICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgc2Nhbm5lci5uZXh0KGNvZGVQb2ludExlbiArIDEpO1xuICAgICAgICByZXR1cm4gc3VjY2VzcyhzdHIpO1xuICAgICAgfVxuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoJ1wiJyk7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoXCJcXFxcXCIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlOiBcXFxcJHtzY2FubmVyLmNoYXIoKX1gKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJhc2ljU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSAnXCInKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSAnXCInICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBpZiAoc2Nhbm5lci5jaGFyKCkgPT09IFwiXFxuXCIpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlNpbmdsZS1saW5lIHN0cmluZyBjYW5ub3QgY29udGFpbiBFT0xcIik7XG4gICAgfVxuICAgIGNvbnN0IGVzY2FwZWRDaGFyID0gZXNjYXBlU2VxdWVuY2Uoc2Nhbm5lcik7XG4gICAgaWYgKGVzY2FwZWRDaGFyLm9rKSB7XG4gICAgICBhY2MucHVzaChlc2NhcGVkQ2hhci5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgfVxuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBTaW5nbGUtbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIHNjYW5uZXIubmV4dCgpOyAvLyBza2lwIGxhc3QgJ1wiXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWxTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiJ1wiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSBcIidcIiAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJTaW5nbGUtbGluZSBzdHJpbmcgY2Fubm90IGNvbnRhaW4gRU9MXCIpO1xuICAgIH1cbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFNpbmdsZS1saW5lIHN0cmluZyBpcyBub3QgY2xvc2VkOlxcbiR7YWNjLmpvaW4oXCJcIil9YCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0KCk7IC8vIHNraXAgbGFzdCBcIidcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lQmFzaWNTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aCgnXCJcIlwiJykpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgzKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKExGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxyXFxuXCIpKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKENSTEYpIGlzIHRyaW1tZWRcbiAgICBzY2FubmVyLm5leHQoMik7XG4gIH1cbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKCFzY2FubmVyLnN0YXJ0c1dpdGgoJ1wiXCJcIicpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICAvLyBsaW5lIGVuZGluZyBiYWNrc2xhc2hcbiAgICBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcclxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVNlcXVlbmNlKHNjYW5uZXIpO1xuICAgIGlmIChlc2NhcGVkQ2hhci5vaykge1xuICAgICAgYWNjLnB1c2goZXNjYXBlZENoYXIuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5wdXNoKHNjYW5uZXIuY2hhcigpKTtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoc2Nhbm5lci5lb2YoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTXVsdGktbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIC8vIGlmIGVuZHMgd2l0aCA0IGBcImAsIHB1c2ggdGhlIGZpc3QgYFwiYCB0byBzdHJpbmdcbiAgaWYgKHNjYW5uZXIuY2hhcigzKSA9PT0gJ1wiJykge1xuICAgIGFjYy5wdXNoKCdcIicpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIHNjYW5uZXIubmV4dCgzKTsgLy8gc2tpcCBsYXN0ICdcIlwiXCJcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lTGl0ZXJhbFN0cmluZyhzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmICghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoMyk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcclxcblwiKSkge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChDUkxGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICB9XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE11bHRpLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICAvLyBpZiBlbmRzIHdpdGggNCBgJ2AsIHB1c2ggdGhlIGZpc3QgYCdgIHRvIHN0cmluZ1xuICBpZiAoc2Nhbm5lci5jaGFyKDMpID09PSBcIidcIikge1xuICAgIGFjYy5wdXNoKFwiJ1wiKTtcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfVxuICBzY2FubmVyLm5leHQoMyk7IC8vIHNraXAgbGFzdCBcIicnJ1wiXG4gIHJldHVybiBzdWNjZXNzKGFjYy5qb2luKFwiXCIpKTtcbn1cbmNvbnN0IEJPT0xFQU5fUkVHRVhQID0gLyg/OnRydWV8ZmFsc2UpXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYm9vbGVhbihzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChCT09MRUFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gc3RyaW5nID09PSBcInRydWVcIjtcbiAgcmV0dXJuIHN1Y2Nlc3ModmFsdWUpO1xufVxuY29uc3QgSU5GSU5JVFlfTUFQID0gbmV3IE1hcChbXG4gIFtcbiAgICBcImluZlwiLFxuICAgIEluZmluaXR5XG4gIF0sXG4gIFtcbiAgICBcIitpbmZcIixcbiAgICBJbmZpbml0eVxuICBdLFxuICBbXG4gICAgXCItaW5mXCIsXG4gICAgLUluZmluaXR5XG4gIF1cbl0pO1xuY29uc3QgSU5GSU5JVFlfUkVHRVhQID0gL1srLV0/aW5mXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gaW5maW5pdHkoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goSU5GSU5JVFlfUkVHRVhQKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgY29uc3Qgc3RyaW5nID0gbWF0Y2hbMF07XG4gIHNjYW5uZXIubmV4dChzdHJpbmcubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBJTkZJTklUWV9NQVAuZ2V0KHN0cmluZyk7XG4gIHJldHVybiBzdWNjZXNzKHZhbHVlKTtcbn1cbmNvbnN0IE5BTl9SRUdFWFAgPSAvWystXT9uYW5cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBuYW4oc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTkFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gTmFOO1xuICByZXR1cm4gc3VjY2Vzcyh2YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgZG90dGVkS2V5ID0gam9pbjEob3IoW1xuICBiYXJlS2V5LFxuICBiYXNpY1N0cmluZyxcbiAgbGl0ZXJhbFN0cmluZ1xuXSksIFwiLlwiKTtcbmNvbnN0IEJJTkFSWV9SRUdFWFAgPSAvMGJbMDFdKyg/Ol9bMDFdKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEJJTkFSWV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMik7XG4gIHJldHVybiBpc05hTihudW1iZXIpID8gZmFpbHVyZSgpIDogc3VjY2VzcyhudW1iZXIpO1xufVxuY29uc3QgT0NUQUxfUkVHRVhQID0gLzBvWzAtN10rKD86X1swLTddKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gb2N0YWwoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goT0NUQUxfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDgpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IEhFWF9SRUdFWFAgPSAvMHhbMC05YS1mXSsoPzpfWzAtOWEtZl0rKSpcXGIveWk7XG5leHBvcnQgZnVuY3Rpb24gaGV4KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEhFWF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IElOVEVHRVJfUkVHRVhQID0gL1srLV0/KD86MHxbMS05XVswLTldKig/Ol9bMC05XSspKilcXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKElOVEVHRVJfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgaW50ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoaW50KTtcbn1cbmNvbnN0IEZMT0FUX1JFR0VYUCA9IC9bKy1dPyg/OjB8WzEtOV1bMC05XSooPzpfWzAtOV0rKSopKD86XFwuWzAtOV0rKD86X1swLTldKykqKT8oPzplWystXT9bMC05XSsoPzpfWzAtOV0rKSopP1xcYi95aTtcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdChzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChGTE9BVF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBmbG9hdCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICBpZiAoaXNOYU4oZmxvYXQpKSByZXR1cm4gZmFpbHVyZSgpO1xuICByZXR1cm4gc3VjY2VzcyhmbG9hdCk7XG59XG5jb25zdCBEQVRFX1RJTUVfUkVHRVhQID0gLyg/PHllYXI+XFxkezR9KS0oPzxtb250aD5cXGR7Mn0pLSg/PGRheT5cXGR7Mn0pKD86WyAwLTlUWi46Ky1dKyk/XFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gZGF0ZVRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goREFURV9USU1FX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgLy8gc3BlY2lhbCBjYXNlIGlmIG1vbnRoIGlzIEZlYnJ1YXJ5XG4gIGlmIChncm91cHMubW9udGggPT0gXCIwMlwiKSB7XG4gICAgY29uc3QgZGF5cyA9IHBhcnNlSW50KGdyb3Vwcy5kYXkpO1xuICAgIGlmIChkYXlzID4gMjkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KGdyb3Vwcy55ZWFyKTtcbiAgICBpZiAoZGF5cyA+IDI4ICYmICFpc0xlYXAoeWVhcikpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZy50cmltKCkpO1xuICAvLyBpbnZhbGlkIGRhdGVcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgfVxuICByZXR1cm4gc3VjY2VzcyhkYXRlKTtcbn1cbmNvbnN0IExPQ0FMX1RJTUVfUkVHRVhQID0gLyhcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pKD86XFwuWzAtOV0rKT9cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTE9DQUxfVElNRV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICByZXR1cm4gc3VjY2VzcyhtYXRjaCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlWYWx1ZShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJbXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoc2Nhbm5lcik7XG4gICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgIGFycmF5LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gICAgLy8gbWF5IGhhdmUgYSBuZXh0IGl0ZW0sIGJ1dCB0cmFpbGluZyBjb21tYSBpcyBhbGxvd2VkIGF0IGFycmF5XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSBcIixcIikgYnJlYWs7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJdXCIpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFycmF5IGlzIG5vdCBjbG9zZWRcIik7XG4gIHNjYW5uZXIubmV4dCgpO1xuICByZXR1cm4gc3VjY2VzcyhhcnJheSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5saW5lVGFibGUoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigxKSA9PT0gXCJ9XCIpIHtcbiAgICBzY2FubmVyLm5leHQoMik7XG4gICAgcmV0dXJuIHN1Y2Nlc3Moe30pO1xuICB9XG4gIGNvbnN0IHBhaXJzID0gc3Vycm91bmQoXCJ7XCIsIGpvaW4ocGFpciwgXCIsXCIpLCBcIn1cIikoc2Nhbm5lcik7XG4gIGlmICghcGFpcnMub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIGxldCB0YWJsZSA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMuYm9keSl7XG4gICAgdGFibGUgPSBkZWVwTWVyZ2UodGFibGUsIHBhaXIpO1xuICB9XG4gIHJldHVybiBzdWNjZXNzKHRhYmxlKTtcbn1cbmV4cG9ydCBjb25zdCB2YWx1ZSA9IG9yKFtcbiAgbXVsdGlsaW5lQmFzaWNTdHJpbmcsXG4gIG11bHRpbGluZUxpdGVyYWxTdHJpbmcsXG4gIGJhc2ljU3RyaW5nLFxuICBsaXRlcmFsU3RyaW5nLFxuICBib29sZWFuLFxuICBpbmZpbml0eSxcbiAgbmFuLFxuICBkYXRlVGltZSxcbiAgbG9jYWxUaW1lLFxuICBiaW5hcnksXG4gIG9jdGFsLFxuICBoZXgsXG4gIGZsb2F0LFxuICBpbnRlZ2VyLFxuICBhcnJheVZhbHVlLFxuICBpbmxpbmVUYWJsZVxuXSk7XG5leHBvcnQgY29uc3QgcGFpciA9IGt2KGRvdHRlZEtleSwgXCI9XCIsIHZhbHVlKTtcbmV4cG9ydCBmdW5jdGlvbiBibG9jayhzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCByZXN1bHQgPSBtZXJnZShyZXBlYXQocGFpcikpKHNjYW5uZXIpO1xuICBpZiAocmVzdWx0Lm9rKSByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJCbG9ja1wiLFxuICAgIHZhbHVlOiByZXN1bHQuYm9keVxuICB9KTtcbiAgcmV0dXJuIGZhaWx1cmUoKTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUhlYWRlciA9IHN1cnJvdW5kKFwiW1wiLCBkb3R0ZWRLZXksIFwiXVwiKTtcbmV4cG9ydCBmdW5jdGlvbiB0YWJsZShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUhlYWRlcihzY2FubmVyKTtcbiAgaWYgKCFoZWFkZXIub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBiID0gYmxvY2soc2Nhbm5lcik7XG4gIHJldHVybiBzdWNjZXNzKHtcbiAgICB0eXBlOiBcIlRhYmxlXCIsXG4gICAga2V5czogaGVhZGVyLmJvZHksXG4gICAgdmFsdWU6IGIub2sgPyBiLmJvZHkudmFsdWUgOiB7fVxuICB9KTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUFycmF5SGVhZGVyID0gc3Vycm91bmQoXCJbW1wiLCBkb3R0ZWRLZXksIFwiXV1cIik7XG5leHBvcnQgZnVuY3Rpb24gdGFibGVBcnJheShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUFycmF5SGVhZGVyKHNjYW5uZXIpO1xuICBpZiAoIWhlYWRlci5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGNvbnN0IGIgPSBibG9jayhzY2FubmVyKTtcbiAgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIHR5cGU6IFwiVGFibGVBcnJheVwiLFxuICAgIGtleXM6IGhlYWRlci5ib2R5LFxuICAgIHZhbHVlOiBiLm9rID8gYi5ib2R5LnZhbHVlIDoge31cbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9tbChzY2FubmVyKSB7XG4gIGNvbnN0IGJsb2NrcyA9IHJlcGVhdChvcihbXG4gICAgYmxvY2ssXG4gICAgdGFibGVBcnJheSxcbiAgICB0YWJsZVxuICBdKSkoc2Nhbm5lcik7XG4gIGlmICghYmxvY2tzLm9rKSByZXR1cm4gc3VjY2Vzcyh7fSk7XG4gIGNvbnN0IGJvZHkgPSBibG9ja3MuYm9keS5yZWR1Y2UoZGVlcEFzc2lnbiwge30pO1xuICByZXR1cm4gc3VjY2Vzcyhib2R5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlRXJyb3JNZXNzYWdlKHNjYW5uZXIsIG1lc3NhZ2UpIHtcbiAgY29uc3Qgc3RyaW5nID0gc2Nhbm5lci5zb3VyY2Uuc2xpY2UoMCwgc2Nhbm5lci5wb3NpdGlvbik7XG4gIGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICBjb25zdCByb3cgPSBsaW5lcy5sZW5ndGg7XG4gIGNvbnN0IGNvbHVtbiA9IGxpbmVzLmF0KC0xKT8ubGVuZ3RoID8/IDA7XG4gIHJldHVybiBgUGFyc2UgZXJyb3Igb24gbGluZSAke3Jvd30sIGNvbHVtbiAke2NvbHVtbn06ICR7bWVzc2FnZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZhY3RvcnkocGFyc2VyKSB7XG4gIHJldHVybiAodG9tbFN0cmluZyk9PntcbiAgICBjb25zdCBzY2FubmVyID0gbmV3IFNjYW5uZXIodG9tbFN0cmluZyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmIChyZXN1bHQub2sgJiYgc2Nhbm5lci5lb2YoKSkgcmV0dXJuIHJlc3VsdC5ib2R5O1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIke3NjYW5uZXIuY2hhcigpfVwiYDtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBtZXNzYWdlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIGVycm9yIHR5cGUgY2F1Z2h0XCI7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgbWVzc2FnZSkpO1xuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9wYXJzZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IHBhcnNlckZhY3RvcnksIHRvbWwgfSBmcm9tIFwiLi9fcGFyc2VyLmpzXCI7XG4vKipcbiAqIFBhcnNlcyBhIHtAbGluayBodHRwczovL3RvbWwuaW8gfCBUT01MfSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gKlxuICogQGV4YW1wbGUgVXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJAc3RkL3RvbWwvcGFyc2VcIjtcbiAqIGltcG9ydCB7IGFzc2VydEVxdWFscyB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IHRvbWxTdHJpbmcgPSBgdGl0bGUgPSBcIlRPTUwgRXhhbXBsZVwiXG4gKiBbb3duZXJdXG4gKiBuYW1lID0gXCJBbGljZVwiXG4gKiBiaW8gPSBcIkFsaWNlIGlzIGEgcHJvZ3JhbW1lci5cImA7XG4gKlxuICogY29uc3Qgb2JqID0gcGFyc2UodG9tbFN0cmluZyk7XG4gKiBhc3NlcnRFcXVhbHMob2JqLCB7IHRpdGxlOiBcIlRPTUwgRXhhbXBsZVwiLCBvd25lcjogeyBuYW1lOiBcIkFsaWNlXCIsIGJpbzogXCJBbGljZSBpcyBhIHByb2dyYW1tZXIuXCIgfSB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHRvbWxTdHJpbmcgVE9NTCBzdHJpbmcgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBKUyBvYmplY3QuXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRvbWxTdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlckZhY3RvcnkodG9tbCkodG9tbFN0cmluZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXAiLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVJlbmFtZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sncmVuYW1lJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdSZW5hbWUgdGhlIE5BUEktUlMgcHJvamVjdCcsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgJCRuYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1uYW1lLC1uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBiaW5hcnlOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1iaW5hcnktbmFtZSwtYicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgYmluYXJ5IG5hbWUgKi5ub2RlIGZpbGVzJyxcbiAgfSlcblxuICBwYWNrYWdlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBwYWNrYWdlIG5hbWUgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIG1hbmlmZXN0UGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tbWFuaWZlc3QtcGF0aCcsICdDYXJnby50b21sJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgQ2FyZ28udG9tbGAnLFxuICB9KVxuXG4gIHJlcG9zaXRvcnk/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXJlcG9zaXRvcnknLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IHJlcG9zaXRvcnkgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1kZXNjcmlwdGlvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIG5hbWU6IHRoaXMuJCRuYW1lLFxuICAgICAgYmluYXJ5TmFtZTogdGhpcy5iaW5hcnlOYW1lLFxuICAgICAgcGFja2FnZU5hbWU6IHRoaXMucGFja2FnZU5hbWUsXG4gICAgICBtYW5pZmVzdFBhdGg6IHRoaXMubWFuaWZlc3RQYXRoLFxuICAgICAgcmVwb3NpdG9yeTogdGhpcy5yZXBvc2l0b3J5LFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVuYW1lIHRoZSBOQVBJLVJTIHByb2plY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZW5hbWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBiaW5hcnkgbmFtZSAqLm5vZGUgZmlsZXNcbiAgICovXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcGFja2FnZSBuYW1lIG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICBwYWNrYWdlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgQ2FyZ28udG9tbGBcbiAgICpcbiAgICogQGRlZmF1bHQgJ0NhcmdvLnRvbWwnXG4gICAqL1xuICBtYW5pZmVzdFBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcmVwb3NpdG9yeSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgcmVwb3NpdG9yeT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFJlbmFtZU9wdGlvbnMob3B0aW9uczogUmVuYW1lT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgbWFuaWZlc3RQYXRoOiAnQ2FyZ28udG9tbCcsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyByZW5hbWUgfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJ1xuaW1wb3J0IHsgcmVzb2x2ZSwgam9pbiB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VUb21sLCBzdHJpbmdpZnkgYXMgc3RyaW5naWZ5VG9tbCB9IGZyb20gJ0BzdGQvdG9tbCdcbmltcG9ydCB7IGxvYWQgYXMgeWFtbFBhcnNlLCBkdW1wIGFzIHlhbWxTdHJpbmdpZnkgfSBmcm9tICdqcy15YW1sJ1xuaW1wb3J0IHsgaXNOaWwsIG1lcmdlLCBvbWl0QnksIHBpY2sgfSBmcm9tICdsb2Rhc2gtZXMnXG5pbXBvcnQgeyBmaW5kVXAgfSBmcm9tICdmaW5kLXVwJ1xuXG5pbXBvcnQgeyBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zLCBSZW5hbWVPcHRpb25zIH0gZnJvbSAnLi4vZGVmL3JlbmFtZS5qcydcbmltcG9ydCB7IHJlYWRDb25maWcsIHJlYWRGaWxlQXN5bmMsIHdyaXRlRmlsZUFzeW5jIH0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5hbWVQcm9qZWN0KHVzZXJPcHRpb25zOiBSZW5hbWVPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zKHVzZXJPcHRpb25zKVxuICBjb25zdCBuYXBpQ29uZmlnID0gYXdhaXQgcmVhZENvbmZpZyhvcHRpb25zKVxuICBjb25zdCBvbGROYW1lID0gbmFwaUNvbmZpZy5iaW5hcnlOYW1lXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IGNhcmdvVG9tbFBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm1hbmlmZXN0UGF0aClcblxuICBjb25zdCBwYWNrYWdlSnNvbkNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKHBhY2thZ2VKc29uUGF0aCwgJ3V0ZjgnKVxuICBjb25zdCBwYWNrYWdlSnNvbkRhdGEgPSBKU09OLnBhcnNlKHBhY2thZ2VKc29uQ29udGVudClcblxuICBtZXJnZShcbiAgICBwYWNrYWdlSnNvbkRhdGEsXG4gICAgb21pdEJ5KHBpY2sob3B0aW9ucywgWyduYW1lJywgJ2Rlc2NyaXB0aW9uJywgJ2F1dGhvcicsICdsaWNlbnNlJ10pLCBpc05pbCksXG4gICAge1xuICAgICAgbmFwaTogb21pdEJ5KFxuICAgICAgICB7XG4gICAgICAgICAgYmluYXJ5TmFtZTogb3B0aW9ucy5iaW5hcnlOYW1lLFxuICAgICAgICAgIHBhY2thZ2VOYW1lOiBvcHRpb25zLnBhY2thZ2VOYW1lLFxuICAgICAgICB9LFxuICAgICAgICBpc05pbCxcbiAgICAgICksXG4gICAgfSxcbiAgKVxuXG4gIGlmIChvcHRpb25zLmNvbmZpZ1BhdGgpIHtcbiAgICBjb25zdCBjb25maWdQYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKVxuICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGNvbmZpZ1BhdGgsICd1dGY4JylcbiAgICBjb25zdCBjb25maWdEYXRhID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgIGNvbmZpZ0RhdGEuYmluYXJ5TmFtZSA9IG9wdGlvbnMuYmluYXJ5TmFtZVxuICAgIGNvbmZpZ0RhdGEucGFja2FnZU5hbWUgPSBvcHRpb25zLnBhY2thZ2VOYW1lXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoY29uZmlnUGF0aCwgSlNPTi5zdHJpbmdpZnkoY29uZmlnRGF0YSwgbnVsbCwgMikpXG4gIH1cblxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb25EYXRhLCBudWxsLCAyKSxcbiAgKVxuXG4gIGNvbnN0IHRvbWxDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjYXJnb1RvbWxQYXRoLCAndXRmOCcpXG4gIGNvbnN0IGNhcmdvVG9tbCA9IHBhcnNlVG9tbCh0b21sQ29udGVudCkgYXMgYW55XG5cbiAgLy8gVXBkYXRlIHRoZSBwYWNrYWdlIG5hbWVcbiAgaWYgKGNhcmdvVG9tbC5wYWNrYWdlICYmIG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIC8vIFNhbml0aXplIHRoZSBiaW5hcnkgbmFtZSBmb3IgUnVzdCBwYWNrYWdlIG5hbWluZyBjb252ZW50aW9uc1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBvcHRpb25zLmJpbmFyeU5hbWVcbiAgICAgIC5yZXBsYWNlKCdAJywgJycpXG4gICAgICAucmVwbGFjZSgnLycsICdfJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgY2FyZ29Ub21sLnBhY2thZ2UubmFtZSA9IHNhbml0aXplZE5hbWVcbiAgfVxuXG4gIC8vIFN0cmluZ2lmeSB0aGUgdXBkYXRlZCBUT01MXG4gIGNvbnN0IHVwZGF0ZWRUb21sQ29udGVudCA9IHN0cmluZ2lmeVRvbWwoY2FyZ29Ub21sKVxuXG4gIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGNhcmdvVG9tbFBhdGgsIHVwZGF0ZWRUb21sQ29udGVudClcbiAgaWYgKG9sZE5hbWUgIT09IG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNQYXRoID0gYXdhaXQgZmluZFVwKCcuZ2l0aHViJywge1xuICAgICAgY3dkOiBvcHRpb25zLmN3ZCxcbiAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgIH0pXG4gICAgaWYgKGdpdGh1YkFjdGlvbnNQYXRoKSB7XG4gICAgICBjb25zdCBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoID0gam9pbihcbiAgICAgICAgZ2l0aHViQWN0aW9uc1BhdGgsXG4gICAgICAgICd3b3JrZmxvd3MnLFxuICAgICAgICAnQ0kueW1sJyxcbiAgICAgIClcbiAgICAgIGlmIChleGlzdHNTeW5jKGdpdGh1YkFjdGlvbnNDSVltbFBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICd1dGY4JyxcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBnaXRodWJBY3Rpb25zRGF0YSA9IHlhbWxQYXJzZShnaXRodWJBY3Rpb25zQ29udGVudCkgYXMgYW55XG4gICAgICAgIGlmIChnaXRodWJBY3Rpb25zRGF0YS5lbnY/LkFQUF9OQU1FKSB7XG4gICAgICAgICAgZ2l0aHViQWN0aW9uc0RhdGEuZW52LkFQUF9OQU1FID0gb3B0aW9ucy5iaW5hcnlOYW1lXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICAgeWFtbFN0cmluZ2lmeShnaXRodWJBY3Rpb25zRGF0YSwge1xuICAgICAgICAgICAgICBsaW5lV2lkdGg6IC0xLFxuICAgICAgICAgICAgICBub1JlZnM6IHRydWUsXG4gICAgICAgICAgICAgIHNvcnRLZXlzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvbGRXYXNpQnJvd3NlckJpbmRpbmdQYXRoID0gam9pbihcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgYCR7b2xkTmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICApXG4gICAgaWYgKGV4aXN0c1N5bmMob2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCxcbiAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgKSxcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3Qgb2xkV2FzaUJpbmRpbmdQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgYCR7b2xkTmFtZX0ud2FzaS5janNgKVxuICAgIGlmIChleGlzdHNTeW5jKG9sZFdhc2lCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJpbmRpbmdQYXRoLFxuICAgICAgICBqb2luKG9wdGlvbnMuY3dkLCBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2kuY2pzYCksXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgJy5naXRhdHRyaWJ1dGVzJylcbiAgICBpZiAoZXhpc3RzU3luYyhnaXRBdHRyaWJ1dGVzUGF0aCkpIHtcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgZ2l0QXR0cmlidXRlc1BhdGgsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNEYXRhID0gZ2l0QXR0cmlidXRlc0NvbnRlbnRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVcbiAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICBgJHtvbGROYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgICAgICAgICBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAucmVwbGFjZShgJHtvbGROYW1lfS53YXNpLmNqc2AsIGAke29wdGlvbnMuYmluYXJ5TmFtZX0ud2FzaS5janNgKVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGdpdEF0dHJpYnV0ZXNQYXRoLCBnaXRBdHRyaWJ1dGVzRGF0YSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWMsIGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnbm9kZTpmcydcblxuaW1wb3J0IHsgbG9hZCBhcyB5YW1sTG9hZCwgZHVtcCBhcyB5YW1sRHVtcCB9IGZyb20gJ2pzLXlhbWwnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMsXG4gIE5ld09wdGlvbnMgYXMgUmF3TmV3T3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL25ldy5qcydcbmltcG9ydCB7XG4gIEFWQUlMQUJMRV9UQVJHRVRTLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVEFSR0VUUyxcbiAgbWtkaXJBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICBzdGF0QXN5bmMsXG4gIFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcbmltcG9ydCB7IG5hcGlFbmdpbmVSZXF1aXJlbWVudCB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24uanMnXG5pbXBvcnQgeyByZW5hbWVQcm9qZWN0IH0gZnJvbSAnLi9yZW5hbWUuanMnXG5cbi8vIFRlbXBsYXRlIGltcG9ydHMgcmVtb3ZlZCBhcyB3ZSdyZSBub3cgdXNpbmcgZXh0ZXJuYWwgdGVtcGxhdGVzXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCduZXcnKVxuXG50eXBlIE5ld09wdGlvbnMgPSBSZXF1aXJlZDxSYXdOZXdPcHRpb25zPlxuXG5jb25zdCBURU1QTEFURV9SRVBPUyA9IHtcbiAgeWFybjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL3BhY2thZ2UtdGVtcGxhdGUnLFxuICBwbnBtOiAnaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvcGFja2FnZS10ZW1wbGF0ZS1wbnBtJyxcbn0gYXMgY29uc3RcblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tHaXRDb21tYW5kKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBjcCA9IGV4ZWMoJ2dpdCAtLXZlcnNpb24nKVxuICAgICAgY3Aub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGZhbHNlKVxuICAgICAgfSlcbiAgICAgIGNwLm9uKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUNhY2hlRGlyKFxuICBwYWNrYWdlTWFuYWdlcjogU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBjYWNoZURpciA9IHBhdGguam9pbihob21lZGlyKCksICcubmFwaS1ycycsICd0ZW1wbGF0ZScsIHBhY2thZ2VNYW5hZ2VyKVxuICBhd2FpdCBta2RpckFzeW5jKGNhY2hlRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICByZXR1cm4gY2FjaGVEaXJcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRUZW1wbGF0ZShcbiAgcGFja2FnZU1hbmFnZXI6IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxuICBjYWNoZURpcjogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcG9VcmwgPSBURU1QTEFURV9SRVBPU1twYWNrYWdlTWFuYWdlcl1cbiAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGNhY2hlRGlyLCAncmVwbycpXG5cbiAgaWYgKGV4aXN0c1N5bmModGVtcGxhdGVQYXRoKSkge1xuICAgIGRlYnVnKGBUZW1wbGF0ZSBjYWNoZSBmb3VuZCBhdCAke3RlbXBsYXRlUGF0aH0sIHVwZGF0aW5nLi4uYClcbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggbGF0ZXN0IGNoYW5nZXMgYW5kIHJlc2V0IHRvIHJlbW90ZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjcCA9IGV4ZWMoJ2dpdCBmZXRjaCBvcmlnaW4nLCB7IGN3ZDogdGVtcGxhdGVQYXRoIH0pXG4gICAgICAgIGNwLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgY3Aub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZhaWxlZCB0byBmZXRjaCBsYXRlc3QgY2hhbmdlcywgZ2l0IHByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgZXhlY1N5bmMoJ2dpdCByZXNldCAtLWhhcmQgb3JpZ2luL21haW4nLCB7XG4gICAgICAgIGN3ZDogdGVtcGxhdGVQYXRoLFxuICAgICAgICBzdGRpbzogJ2lnbm9yZScsXG4gICAgICB9KVxuICAgICAgZGVidWcoJ1RlbXBsYXRlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byB1cGRhdGUgdGVtcGxhdGU6ICR7ZXJyb3J9YClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSB0ZW1wbGF0ZSBmcm9tICR7cmVwb1VybH06ICR7ZXJyb3J9YClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoYENsb25pbmcgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9Li4uYClcbiAgICB0cnkge1xuICAgICAgZXhlY1N5bmMoYGdpdCBjbG9uZSAke3JlcG9Vcmx9IHJlcG9gLCB7IGN3ZDogY2FjaGVEaXIsIHN0ZGlvOiAnaW5oZXJpdCcgfSlcbiAgICAgIGRlYnVnKCdUZW1wbGF0ZSBjbG9uZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2xvbmUgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9OiAke2Vycm9yfWApXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlEaXJlY3RvcnkoXG4gIHNyYzogc3RyaW5nLFxuICBkZXN0OiBzdHJpbmcsXG4gIGluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgbWtkaXJBc3luYyhkZXN0LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZnMucmVhZGRpcihzcmMsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGNvbnN0IHNyY1BhdGggPSBwYXRoLmpvaW4oc3JjLCBlbnRyeS5uYW1lKVxuICAgIGNvbnN0IGRlc3RQYXRoID0gcGF0aC5qb2luKGRlc3QsIGVudHJ5Lm5hbWUpXG5cbiAgICAvLyBTa2lwIC5naXQgZGlyZWN0b3J5XG4gICAgaWYgKGVudHJ5Lm5hbWUgPT09ICcuZ2l0Jykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgYXdhaXQgY29weURpcmVjdG9yeShzcmNQYXRoLCBkZXN0UGF0aCwgaW5jbHVkZVdhc2lCaW5kaW5ncylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFxuICAgICAgICAhaW5jbHVkZVdhc2lCaW5kaW5ncyAmJlxuICAgICAgICAoZW50cnkubmFtZS5lbmRzV2l0aCgnLndhc2ktYnJvd3Nlci5qcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnLndhc2kuY2pzJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCd3YXNpLXdvcmtlci5icm93c2VyLm1qcyAnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJ3dhc2ktd29ya2VyLm1qcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnYnJvd3Nlci5qcycpKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBhd2FpdCBmcy5jb3B5RmlsZShzcmNQYXRoLCBkZXN0UGF0aClcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmlsdGVyVGFyZ2V0c0luUGFja2FnZUpzb24oXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIGVuYWJsZWRUYXJnZXRzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShjb250ZW50KVxuXG4gIC8vIEZpbHRlciBuYXBpLnRhcmdldHNcbiAgaWYgKHBhY2thZ2VKc29uLm5hcGk/LnRhcmdldHMpIHtcbiAgICBwYWNrYWdlSnNvbi5uYXBpLnRhcmdldHMgPSBwYWNrYWdlSnNvbi5uYXBpLnRhcmdldHMuZmlsdGVyKFxuICAgICAgKHRhcmdldDogc3RyaW5nKSA9PiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpLFxuICAgIClcbiAgfVxuXG4gIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb24sIG51bGwsIDIpICsgJ1xcbicpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbHRlclRhcmdldHNJbkdpdGh1YkFjdGlvbnMoXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIGVuYWJsZWRUYXJnZXRzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpXG4gIGNvbnN0IHlhbWwgPSB5YW1sTG9hZChjb250ZW50KSBhcyBhbnlcblxuICBjb25zdCBtYWNPU0FuZFdpbmRvd3NUYXJnZXRzID0gbmV3IFNldChbXG4gICAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAgICdhYXJjaDY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICAgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nLFxuICBdKVxuXG4gIGNvbnN0IGxpbnV4VGFyZ2V0cyA9IG5ldyBTZXQoW1xuICAgICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICd4ODZfNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgICAnYWFyY2g2NC11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgICAnYXJtdjctdW5rbm93bi1saW51eC1nbnVlYWJpaGYnLFxuICAgICdhcm12Ny11bmtub3duLWxpbnV4LW11c2xlYWJpaGYnLFxuICAgICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JyxcbiAgICAnYWFyY2g2NC1saW51eC1hbmRyb2lkJyxcbiAgICAnYXJtdjctbGludXgtYW5kcm9pZGVhYmknLFxuICBdKVxuXG4gIC8vIENoZWNrIGlmIGFueSBMaW51eCB0YXJnZXRzIGFyZSBlbmFibGVkXG4gIGNvbnN0IGhhc0xpbnV4VGFyZ2V0cyA9IGVuYWJsZWRUYXJnZXRzLnNvbWUoKHRhcmdldCkgPT5cbiAgICBsaW51eFRhcmdldHMuaGFzKHRhcmdldCksXG4gIClcblxuICAvLyBGaWx0ZXIgdGhlIG1hdHJpeCBjb25maWd1cmF0aW9ucyBpbiB0aGUgYnVpbGQgam9iXG4gIGlmICh5YW1sPy5qb2JzPy5idWlsZD8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3MpIHtcbiAgICB5YW1sLmpvYnMuYnVpbGQuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzID1cbiAgICAgIHlhbWwuam9icy5idWlsZC5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MuZmlsdGVyKChzZXR0aW5nOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHNldHRpbmcudGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICB9XG5cbiAgY29uc3Qgam9ic1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdXG5cbiAgaWYgKGVuYWJsZWRUYXJnZXRzLmV2ZXJ5KCh0YXJnZXQpID0+ICFtYWNPU0FuZFdpbmRvd3NUYXJnZXRzLmhhcyh0YXJnZXQpKSkge1xuICAgIGpvYnNUb1JlbW92ZS5wdXNoKCd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nIGpvYlxuICAgIGlmIChcbiAgICAgIHlhbWw/LmpvYnM/LlsndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXT8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3NcbiAgICApIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXS5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MgPVxuICAgICAgICB5YW1sLmpvYnNbJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzLmZpbHRlcihcbiAgICAgICAgICAoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gTGludXggdGFyZ2V0cyBhcmUgZW5hYmxlZCwgcmVtb3ZlIExpbnV4LXNwZWNpZmljIGpvYnNcbiAgaWYgKCFoYXNMaW51eFRhcmdldHMpIHtcbiAgICAvLyBSZW1vdmUgdGVzdC1saW51eC1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddKSB7XG4gICAgICBqb2JzVG9SZW1vdmUucHVzaCgndGVzdC1saW51eC1iaW5kaW5nJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbGludXgteDY0LWdudS1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddPy5zdHJhdGVneT8ubWF0cml4Py50YXJnZXQpIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1saW51eC1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnRhcmdldCA9IHlhbWwuam9ic1tcbiAgICAgICAgJ3Rlc3QtbGludXgtYmluZGluZydcbiAgICAgIF0uc3RyYXRlZ3kubWF0cml4LnRhcmdldC5maWx0ZXIoKHRhcmdldDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZW5hYmxlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghZW5hYmxlZFRhcmdldHMuaW5jbHVkZXMoJ3dhc20zMi13YXNpcDEtdGhyZWFkcycpKSB7XG4gICAgam9ic1RvUmVtb3ZlLnB1c2goJ3Rlc3Qtd2FzaScpXG4gIH1cblxuICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKCd4ODZfNjQtdW5rbm93bi1mcmVlYnNkJykpIHtcbiAgICBqb2JzVG9SZW1vdmUucHVzaCgnYnVpbGQtZnJlZWJzZCcpXG4gIH1cblxuICAvLyBGaWx0ZXIgb3RoZXIgdGVzdCBqb2JzIGJhc2VkIG9uIHRhcmdldFxuICBmb3IgKGNvbnN0IFtqb2JOYW1lLCBqb2JDb25maWddIG9mIE9iamVjdC5lbnRyaWVzKHlhbWwuam9icyB8fCB7fSkpIHtcbiAgICBpZiAoXG4gICAgICBqb2JOYW1lLnN0YXJ0c1dpdGgoJ3Rlc3QtJykgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LWxpbnV4LXg2NC1nbnUtYmluZGluZydcbiAgICApIHtcbiAgICAgIC8vIEV4dHJhY3QgdGFyZ2V0IGZyb20gam9iIG5hbWUgb3IgY29uZmlnXG4gICAgICBjb25zdCBqb2IgPSBqb2JDb25maWcgYXMgYW55XG4gICAgICBpZiAoam9iLnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzPy5bMF0/LnRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBqb2Iuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzWzBdLnRhcmdldFxuICAgICAgICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgICAgICBqb2JzVG9SZW1vdmUucHVzaChqb2JOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGpvYnMgZm9yIGRpc2FibGVkIHRhcmdldHNcbiAgZm9yIChjb25zdCBqb2JOYW1lIG9mIGpvYnNUb1JlbW92ZSkge1xuICAgIGRlbGV0ZSB5YW1sLmpvYnNbam9iTmFtZV1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHlhbWwuam9icz8ucHVibGlzaD8ubmVlZHMpKSB7XG4gICAgeWFtbC5qb2JzLnB1Ymxpc2gubmVlZHMgPSB5YW1sLmpvYnMucHVibGlzaC5uZWVkcy5maWx0ZXIoXG4gICAgICAobmVlZDogc3RyaW5nKSA9PiAham9ic1RvUmVtb3ZlLmluY2x1ZGVzKG5lZWQpLFxuICAgIClcbiAgfVxuXG4gIC8vIFdyaXRlIGJhY2sgdGhlIGZpbHRlcmVkIFlBTUxcbiAgY29uc3QgdXBkYXRlZFlhbWwgPSB5YW1sRHVtcCh5YW1sLCB7XG4gICAgbGluZVdpZHRoOiAtMSxcbiAgICBub1JlZnM6IHRydWUsXG4gICAgc29ydEtleXM6IGZhbHNlLFxuICB9KVxuICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIHVwZGF0ZWRZYW1sKVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdQcm9jZXNzaW5nIG9wdGlvbnMuLi4nKVxuICBpZiAoIW9wdGlvbnMucGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdGhlIHBhdGggYXMgdGhlIGFyZ3VtZW50JylcbiAgfVxuICBvcHRpb25zLnBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgb3B0aW9ucy5wYXRoKVxuICBkZWJ1ZyhgUmVzb2x2ZWQgdGFyZ2V0IHBhdGggdG86ICR7b3B0aW9ucy5wYXRofWApXG5cbiAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICBvcHRpb25zLm5hbWUgPSBwYXRoLnBhcnNlKG9wdGlvbnMucGF0aCkuYmFzZVxuICAgIGRlYnVnKGBObyBwcm9qZWN0IG5hbWUgcHJvdmlkZWQsIGZpeCBpdCB0byBkaXIgbmFtZTogJHtvcHRpb25zLm5hbWV9YClcbiAgfVxuXG4gIGlmICghb3B0aW9ucy50YXJnZXRzPy5sZW5ndGgpIHtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVBbGxUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBBVkFJTEFCTEVfVEFSR0VUUy5jb25jYXQoKVxuICAgICAgZGVidWcoJ0VuYWJsZSBhbGwgdGFyZ2V0cycpXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVuYWJsZURlZmF1bHRUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBERUZBVUxUX1RBUkdFVFMuY29uY2F0KClcbiAgICAgIGRlYnVnKCdFbmFibGUgZGVmYXVsdCB0YXJnZXRzJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdGFyZ2V0IG11c3QgYmUgZW5hYmxlZCcpXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICBvcHRpb25zLnRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJylcbiAgKSB7XG4gICAgY29uc3Qgb3V0ID0gZXhlY1N5bmMoYHJ1c3R1cCB0YXJnZXQgbGlzdGAsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgfSlcbiAgICBpZiAob3V0LmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSkge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gb3B0aW9ucy50YXJnZXRzLm1hcCgodGFyZ2V0KSA9PlxuICAgICAgICB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJ1xuICAgICAgICAgID8gJ3dhc20zMi13YXNpcDEtdGhyZWFkcydcbiAgICAgICAgICA6IHRhcmdldCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBwbHlEZWZhdWx0TmV3T3B0aW9ucyhvcHRpb25zKSBhcyBOZXdPcHRpb25zXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdQcm9qZWN0KHVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdXaWxsIGNyZWF0ZSBuYXBpLXJzIHByb2plY3Qgd2l0aCBnaXZlbiBvcHRpb25zOicpXG4gIGRlYnVnKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBkZWJ1ZygnVGFyZ2V0cyB0byBiZSBlbmFibGVkOicpXG4gIGRlYnVnKG9wdGlvbnMudGFyZ2V0cylcblxuICAvLyBDaGVjayBpZiBnaXQgaXMgYXZhaWxhYmxlXG4gIGlmICghKGF3YWl0IGNoZWNrR2l0Q29tbWFuZCgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdHaXQgaXMgbm90IGluc3RhbGxlZCBvciBub3QgYXZhaWxhYmxlIGluIFBBVEguIFBsZWFzZSBpbnN0YWxsIEdpdCB0byBjb250aW51ZS4nLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHBhY2thZ2VNYW5hZ2VyID0gb3B0aW9ucy5wYWNrYWdlTWFuYWdlciBhcyBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlclxuXG4gIC8vIEVuc3VyZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cyBhbmQgaXMgZW1wdHlcbiAgYXdhaXQgZW5zdXJlUGF0aChvcHRpb25zLnBhdGgsIG9wdGlvbnMuZHJ5UnVuKVxuXG4gIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICB0cnkge1xuICAgICAgLy8gRG93bmxvYWQgb3IgdXBkYXRlIHRlbXBsYXRlXG4gICAgICBjb25zdCBjYWNoZURpciA9IGF3YWl0IGVuc3VyZUNhY2hlRGlyKHBhY2thZ2VNYW5hZ2VyKVxuICAgICAgYXdhaXQgZG93bmxvYWRUZW1wbGF0ZShwYWNrYWdlTWFuYWdlciwgY2FjaGVEaXIpXG5cbiAgICAgIC8vIENvcHkgdGVtcGxhdGUgZmlsZXMgdG8gdGFyZ2V0IGRpcmVjdG9yeVxuICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGNhY2hlRGlyLCAncmVwbycpXG4gICAgICBhd2FpdCBjb3B5RGlyZWN0b3J5KFxuICAgICAgICB0ZW1wbGF0ZVBhdGgsXG4gICAgICAgIG9wdGlvbnMucGF0aCxcbiAgICAgICAgb3B0aW9ucy50YXJnZXRzLmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSxcbiAgICAgIClcblxuICAgICAgLy8gUmVuYW1lIHByb2plY3QgdXNpbmcgdGhlIHJlbmFtZSBBUElcbiAgICAgIGF3YWl0IHJlbmFtZVByb2plY3Qoe1xuICAgICAgICBjd2Q6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICBiaW5hcnlOYW1lOiBnZXRCaW5hcnlOYW1lKG9wdGlvbnMubmFtZSksXG4gICAgICB9KVxuXG4gICAgICAvLyBGaWx0ZXIgdGFyZ2V0cyBpbiBwYWNrYWdlLmpzb25cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICdwYWNrYWdlLmpzb24nKVxuICAgICAgaWYgKGV4aXN0c1N5bmMocGFja2FnZUpzb25QYXRoKSkge1xuICAgICAgICBhd2FpdCBmaWx0ZXJUYXJnZXRzSW5QYWNrYWdlSnNvbihwYWNrYWdlSnNvblBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIHRhcmdldHMgaW4gR2l0SHViIEFjdGlvbnMgQ0lcbiAgICAgIGNvbnN0IGNpUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICcuZ2l0aHViJywgJ3dvcmtmbG93cycsICdDSS55bWwnKVxuICAgICAgaWYgKGV4aXN0c1N5bmMoY2lQYXRoKSAmJiBvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgZmlsdGVyVGFyZ2V0c0luR2l0aHViQWN0aW9ucyhjaVBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICFvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMgJiZcbiAgICAgICAgZXhpc3RzU3luYyhwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFJlbW92ZSAuZ2l0aHViIGRpcmVjdG9yeSBpZiBHaXRIdWIgQWN0aW9ucyBpcyBub3QgZW5hYmxlZFxuICAgICAgICBhd2FpdCBmcy5ybShwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpLCB7XG4gICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcGFja2FnZS5qc29uIHdpdGggYWRkaXRpb25hbCBjb25maWd1cmF0aW9uc1xuICAgICAgY29uc3QgcGtnSnNvbkNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShwYWNrYWdlSnNvblBhdGgsICd1dGYtOCcpXG4gICAgICBjb25zdCBwa2dKc29uID0gSlNPTi5wYXJzZShwa2dKc29uQ29udGVudClcblxuICAgICAgLy8gVXBkYXRlIGVuZ2luZSByZXF1aXJlbWVudFxuICAgICAgaWYgKCFwa2dKc29uLmVuZ2luZXMpIHtcbiAgICAgICAgcGtnSnNvbi5lbmdpbmVzID0ge31cbiAgICAgIH1cbiAgICAgIHBrZ0pzb24uZW5naW5lcy5ub2RlID0gbmFwaUVuZ2luZVJlcXVpcmVtZW50KG9wdGlvbnMubWluTm9kZUFwaVZlcnNpb24pXG5cbiAgICAgIC8vIFVwZGF0ZSBsaWNlbnNlIGlmIGRpZmZlcmVudCBmcm9tIHRlbXBsYXRlXG4gICAgICBpZiAob3B0aW9ucy5saWNlbnNlICYmIHBrZ0pzb24ubGljZW5zZSAhPT0gb3B0aW9ucy5saWNlbnNlKSB7XG4gICAgICAgIHBrZ0pzb24ubGljZW5zZSA9IG9wdGlvbnMubGljZW5zZVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGVzdCBmcmFtZXdvcmsgaWYgbmVlZGVkXG4gICAgICBpZiAob3B0aW9ucy50ZXN0RnJhbWV3b3JrICE9PSAnYXZhJykge1xuICAgICAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgbW9yZSBjb21wbGV4IGxvZ2ljIHRvIHVwZGF0ZSB0ZXN0IHNjcmlwdHMgYW5kIGRlcGVuZGVuY2llc1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBgVGVzdCBmcmFtZXdvcmsgJHtvcHRpb25zLnRlc3RGcmFtZXdvcmt9IHJlcXVlc3RlZCBidXQgbm90IHlldCBpbXBsZW1lbnRlZGAsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHBrZ0pzb24sIG51bGwsIDIpICsgJ1xcbicsXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBwcm9qZWN0OiAke2Vycm9yfWApXG4gICAgfVxuICB9XG5cbiAgZGVidWcoYFByb2plY3QgY3JlYXRlZCBhdDogJHtvcHRpb25zLnBhdGh9YClcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlUGF0aChwYXRoOiBzdHJpbmcsIGRyeVJ1biA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0QXN5bmMocGF0aCwge30pLmNhdGNoKCgpID0+IHVuZGVmaW5lZClcblxuICAvLyBmaWxlIGRlc2NyaXB0b3IgZXhpc3RzXG4gIGlmIChzdGF0KSB7XG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBhdGggJHtwYXRofSBmb3IgY3JlYXRpbmcgbmV3IG5hcGktcnMgcHJvamVjdCBhbHJlYWR5IGV4aXN0cyBhbmQgaXQncyBub3QgYSBkaXJlY3RvcnkuYCxcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCByZWFkZGlyQXN5bmMocGF0aClcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQYXRoICR7cGF0aH0gZm9yIGNyZWF0aW5nIG5ldyBuYXBpLXJzIHByb2plY3QgYWxyZWFkeSBleGlzdHMgYW5kIGl0J3Mgbm90IGVtcHR5LmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWRyeVJ1bikge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSB0YXJnZXQgZGlyZWN0b3J5OiAke3BhdGh9YClcbiAgICAgIGlmICghZHJ5UnVuKSB7XG4gICAgICAgIGF3YWl0IG1rZGlyQXN5bmMocGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdGFyZ2V0IGRpcmVjdG9yeTogJHtwYXRofWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlOYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBuYW1lLnNwbGl0KCcvJykucG9wKCkhXG59XG5cbmV4cG9ydCB7IE5ld09wdGlvbnMgfVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VQcmVQdWJsaXNoQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydwcmUtcHVibGlzaCddLCBbJ3ByZXB1Ymxpc2gnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdVcGRhdGUgcGFja2FnZS5qc29uIGFuZCBjb3B5IGFkZG9ucyBpbnRvIHBlciBwbGF0Zm9ybSBwYWNrYWdlcycsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyLC1wJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgdGFnU3R5bGUgPSBPcHRpb24uU3RyaW5nKCctLXRhZy1zdHlsZSwtLXRhZ3N0eWxlLC10JywgJ2xlcm5hJywge1xuICAgIGRlc2NyaXB0aW9uOiAnZ2l0IHRhZyBzdHlsZSwgYG5wbWAgb3IgYGxlcm5hYCcsXG4gIH0pXG5cbiAgZ2hSZWxlYXNlID0gT3B0aW9uLkJvb2xlYW4oJy0tZ2gtcmVsZWFzZScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgY3JlYXRlIEdpdEh1YiByZWxlYXNlJyxcbiAgfSlcblxuICBnaFJlbGVhc2VOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1naC1yZWxlYXNlLW5hbWUnLCB7XG4gICAgZGVzY3JpcHRpb246ICdHaXRIdWIgcmVsZWFzZSBuYW1lJyxcbiAgfSlcblxuICBnaFJlbGVhc2VJZD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZ2gtcmVsZWFzZS1pZCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0V4aXN0aW5nIEdpdEh1YiByZWxlYXNlIGlkJyxcbiAgfSlcblxuICBza2lwT3B0aW9uYWxQdWJsaXNoID0gT3B0aW9uLkJvb2xlYW4oJy0tc2tpcC1vcHRpb25hbC1wdWJsaXNoJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgc2tpcCBvcHRpb25hbERlcGVuZGVuY2llcyBwYWNrYWdlcyBwdWJsaXNoJyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgdGFnU3R5bGU6IHRoaXMudGFnU3R5bGUsXG4gICAgICBnaFJlbGVhc2U6IHRoaXMuZ2hSZWxlYXNlLFxuICAgICAgZ2hSZWxlYXNlTmFtZTogdGhpcy5naFJlbGVhc2VOYW1lLFxuICAgICAgZ2hSZWxlYXNlSWQ6IHRoaXMuZ2hSZWxlYXNlSWQsXG4gICAgICBza2lwT3B0aW9uYWxQdWJsaXNoOiB0aGlzLnNraXBPcHRpb25hbFB1Ymxpc2gsXG4gICAgICBkcnlSdW46IHRoaXMuZHJ5UnVuLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBwYWNrYWdlLmpzb24gYW5kIGNvcHkgYWRkb25zIGludG8gcGVyIHBsYXRmb3JtIHBhY2thZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJlUHVibGlzaE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogZ2l0IHRhZyBzdHlsZSwgYG5wbWAgb3IgYGxlcm5hYFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbGVybmEnXG4gICAqL1xuICB0YWdTdHlsZT86ICducG0nIHwgJ2xlcm5hJ1xuICAvKipcbiAgICogV2hldGhlciBjcmVhdGUgR2l0SHViIHJlbGVhc2VcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZ2hSZWxlYXNlPzogYm9vbGVhblxuICAvKipcbiAgICogR2l0SHViIHJlbGVhc2UgbmFtZVxuICAgKi9cbiAgZ2hSZWxlYXNlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogRXhpc3RpbmcgR2l0SHViIHJlbGVhc2UgaWRcbiAgICovXG4gIGdoUmVsZWFzZUlkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHNraXAgb3B0aW9uYWxEZXBlbmRlbmNpZXMgcGFja2FnZXMgcHVibGlzaFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2tpcE9wdGlvbmFsUHVibGlzaD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIERyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0UHJlUHVibGlzaE9wdGlvbnMob3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIHRhZ1N0eWxlOiAnbGVybmEnLFxuICAgIGdoUmVsZWFzZTogdHJ1ZSxcbiAgICBza2lwT3B0aW9uYWxQdWJsaXNoOiBmYWxzZSxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlVmVyc2lvbkNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sndmVyc2lvbiddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnVXBkYXRlIHZlcnNpb24gaW4gY3JlYXRlZCBucG0gcGFja2FnZXMnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpcicsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgdmVyc2lvbiBpbiBjcmVhdGVkIG5wbSBwYWNrYWdlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFZlcnNpb25PcHRpb25zKG9wdGlvbnM6IFZlcnNpb25PcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgeyBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyBhcHBseURlZmF1bHRWZXJzaW9uT3B0aW9ucywgVmVyc2lvbk9wdGlvbnMgfSBmcm9tICcuLi9kZWYvdmVyc2lvbi5qcydcbmltcG9ydCB7XG4gIHJlYWROYXBpQ29uZmlnLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIHVwZGF0ZVBhY2thZ2VKc29uLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3ZlcnNpb24nKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyc2lvbih1c2VyT3B0aW9uczogVmVyc2lvbk9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdFZlcnNpb25PcHRpb25zKHVzZXJPcHRpb25zKVxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIGNvbmZpZy50YXJnZXRzKSB7XG4gICAgY29uc3QgcGtnRGlyID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5ucG1EaXIsIHRhcmdldC5wbGF0Zm9ybUFyY2hBQkkpXG5cbiAgICBkZWJ1ZyhgVXBkYXRlIHZlcnNpb24gdG8gJWkgaW4gWyVpXWAsIGNvbmZpZy5wYWNrYWdlSnNvbi52ZXJzaW9uLCBwa2dEaXIpXG4gICAgYXdhaXQgdXBkYXRlUGFja2FnZUpzb24oam9pbihwa2dEaXIsICdwYWNrYWdlLmpzb24nKSwge1xuICAgICAgdmVyc2lvbjogY29uZmlnLnBhY2thZ2VKc29uLnZlcnNpb24sXG4gICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBleGlzdHNTeW5jLCBzdGF0U3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyBPY3Rva2l0IH0gZnJvbSAnQG9jdG9raXQvcmVzdCdcblxuaW1wb3J0IHtcbiAgYXBwbHlEZWZhdWx0UHJlUHVibGlzaE9wdGlvbnMsXG4gIFByZVB1Ymxpc2hPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvcHJlLXB1Ymxpc2guanMnXG5pbXBvcnQge1xuICByZWFkRmlsZUFzeW5jLFxuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICB1cGRhdGVQYWNrYWdlSnNvbixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdwcmUtcHVibGlzaCcpXG5cbmludGVyZmFjZSBQYWNrYWdlSW5mbyB7XG4gIG5hbWU6IHN0cmluZ1xuICB2ZXJzaW9uOiBzdHJpbmdcbiAgdGFnOiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZVB1Ymxpc2godXNlck9wdGlvbnM6IFByZVB1Ymxpc2hPcHRpb25zKSB7XG4gIGRlYnVnKCdSZWNlaXZlIHByZS1wdWJsaXNoIG9wdGlvbnM6JylcbiAgZGVidWcoJyAgJU8nLCB1c2VyT3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0UHJlUHVibGlzaE9wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgeyBwYWNrYWdlSnNvbiwgdGFyZ2V0cywgcGFja2FnZU5hbWUsIGJpbmFyeU5hbWUsIG5wbUNsaWVudCB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gICAgKVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUdoUmVsZWFzZShwYWNrYWdlTmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcpIHtcbiAgICBpZiAoIW9wdGlvbnMuZ2hSZWxlYXNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgcmVwbzogbnVsbCxcbiAgICAgICAgcGtnSW5mbzogeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsLCB0YWc6IG51bGwgfSxcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyByZXBvLCBvd25lciwgcGtnSW5mbywgb2N0b2tpdCB9ID0gZ2V0UmVwb0luZm8ocGFja2FnZU5hbWUsIHZlcnNpb24pXG5cbiAgICBpZiAoIXJlcG8gfHwgIW93bmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgcmVwbzogbnVsbCxcbiAgICAgICAgcGtnSW5mbzogeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsLCB0YWc6IG51bGwgfSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvY3Rva2l0LnJlcG9zLmNyZWF0ZVJlbGVhc2Uoe1xuICAgICAgICAgIG93bmVyLFxuICAgICAgICAgIHJlcG8sXG4gICAgICAgICAgdGFnX25hbWU6IHBrZ0luZm8udGFnLFxuICAgICAgICAgIG5hbWU6IG9wdGlvbnMuZ2hSZWxlYXNlTmFtZSxcbiAgICAgICAgICBwcmVyZWxlYXNlOlxuICAgICAgICAgICAgdmVyc2lvbi5pbmNsdWRlcygnYWxwaGEnKSB8fFxuICAgICAgICAgICAgdmVyc2lvbi5pbmNsdWRlcygnYmV0YScpIHx8XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdyYycpLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBgUGFyYW1zOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgeyBvd25lciwgcmVwbywgdGFnX25hbWU6IHBrZ0luZm8udGFnIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICApfWAsXG4gICAgICAgIClcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBvd25lciwgcmVwbywgcGtnSW5mbywgb2N0b2tpdCB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXBvSW5mbyhwYWNrYWdlTmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcpIHtcbiAgICBjb25zdCBoZWFkQ29tbWl0ID0gZXhlY1N5bmMoJ2dpdCBsb2cgLTEgLS1wcmV0dHk9JUInLCB7XG4gICAgICBlbmNvZGluZzogJ3V0Zi04JyxcbiAgICB9KS50cmltKClcblxuICAgIGNvbnN0IHsgR0lUSFVCX1JFUE9TSVRPUlkgfSA9IHByb2Nlc3MuZW52XG4gICAgaWYgKCFHSVRIVUJfUkVQT1NJVE9SWSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIHJlcG86IG51bGwsXG4gICAgICAgIHBrZ0luZm86IHsgbmFtZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdGFnOiBudWxsIH0sXG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnKGBHaXRodWIgcmVwb3NpdG9yeTogJHtHSVRIVUJfUkVQT1NJVE9SWX1gKVxuICAgIGNvbnN0IFtvd25lciwgcmVwb10gPSBHSVRIVUJfUkVQT1NJVE9SWS5zcGxpdCgnLycpXG4gICAgY29uc3Qgb2N0b2tpdCA9IG5ldyBPY3Rva2l0KHtcbiAgICAgIGF1dGg6IHByb2Nlc3MuZW52LkdJVEhVQl9UT0tFTixcbiAgICB9KVxuICAgIGxldCBwa2dJbmZvOiBQYWNrYWdlSW5mbyB8IHVuZGVmaW5lZFxuICAgIGlmIChvcHRpb25zLnRhZ1N0eWxlID09PSAnbGVybmEnKSB7XG4gICAgICBjb25zdCBwYWNrYWdlc1RvUHVibGlzaCA9IGhlYWRDb21taXRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnRyaW0oKSlcbiAgICAgICAgLmZpbHRlcigobGluZSwgaW5kZXgpID0+IGxpbmUubGVuZ3RoICYmIGluZGV4KVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnN1YnN0cmluZygyKSlcbiAgICAgICAgLm1hcChwYXJzZVRhZylcblxuICAgICAgcGtnSW5mbyA9IHBhY2thZ2VzVG9QdWJsaXNoLmZpbmQoXG4gICAgICAgIChwa2dJbmZvKSA9PiBwa2dJbmZvLm5hbWUgPT09IHBhY2thZ2VOYW1lLFxuICAgICAgKVxuXG4gICAgICBpZiAoIXBrZ0luZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgTm8gcmVsZWFzZSBjb21taXQgZm91bmQgd2l0aCAke3BhY2thZ2VOYW1lfSwgb3JpZ2luYWwgY29tbWl0IGluZm86ICR7aGVhZENvbW1pdH1gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBrZ0luZm8gPSB7XG4gICAgICAgIHRhZzogYHYke3ZlcnNpb259YCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgbmFtZTogcGFja2FnZU5hbWUsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG93bmVyLCByZXBvLCBwa2dJbmZvLCBvY3Rva2l0IH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICBhd2FpdCB2ZXJzaW9uKHVzZXJPcHRpb25zKVxuICAgIGF3YWl0IHVwZGF0ZVBhY2thZ2VKc29uKHBhY2thZ2VKc29uUGF0aCwge1xuICAgICAgb3B0aW9uYWxEZXBlbmRlbmNpZXM6IHRhcmdldHMucmVkdWNlKFxuICAgICAgICAoZGVwcywgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgZGVwc1tgJHtwYWNrYWdlTmFtZX0tJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfWBdID0gcGFja2FnZUpzb24udmVyc2lvblxuXG4gICAgICAgICAgcmV0dXJuIGRlcHNcbiAgICAgICAgfSxcbiAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICAgICksXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHsgb3duZXIsIHJlcG8sIHBrZ0luZm8sIG9jdG9raXQgfSA9IG9wdGlvbnMuZ2hSZWxlYXNlSWRcbiAgICA/IGdldFJlcG9JbmZvKHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbi52ZXJzaW9uKVxuICAgIDogYXdhaXQgY3JlYXRlR2hSZWxlYXNlKHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbi52ZXJzaW9uKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCBwa2dEaXIgPSByZXNvbHZlKFxuICAgICAgb3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm5wbURpcixcbiAgICAgIGAke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YCxcbiAgICApXG4gICAgY29uc3QgZXh0ID1cbiAgICAgIHRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knIHx8IHRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc20nID8gJ3dhc20nIDogJ25vZGUnXG4gICAgY29uc3QgZmlsZW5hbWUgPSBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9LiR7ZXh0fWBcbiAgICBjb25zdCBkc3RQYXRoID0gam9pbihwa2dEaXIsIGZpbGVuYW1lKVxuXG4gICAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgICAgaWYgKCFleGlzdHNTeW5jKGRzdFBhdGgpKSB7XG4gICAgICAgIGRlYnVnLndhcm4oYCVzIGRvZXNuJ3QgZXhpc3RgLCBkc3RQYXRoKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuc2tpcE9wdGlvbmFsUHVibGlzaCkge1xuICAgICAgICBleGVjU3luYyhgJHtucG1DbGllbnR9IHB1Ymxpc2hgLCB7XG4gICAgICAgICAgY3dkOiBwa2dEaXIsXG4gICAgICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZ2hSZWxlYXNlICYmIHJlcG8gJiYgb3duZXIpIHtcbiAgICAgICAgZGVidWcuaW5mbyhgQ3JlYXRpbmcgR2l0SHViIHJlbGVhc2UgJHtwa2dJbmZvLnRhZ31gKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VJZCA9IG9wdGlvbnMuZ2hSZWxlYXNlSWRcbiAgICAgICAgICAgID8gTnVtYmVyKG9wdGlvbnMuZ2hSZWxlYXNlSWQpXG4gICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICBhd2FpdCBvY3Rva2l0IS5yZXBvcy5nZXRSZWxlYXNlQnlUYWcoe1xuICAgICAgICAgICAgICAgICAgcmVwbzogcmVwbyxcbiAgICAgICAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgICAgICAgIHRhZzogcGtnSW5mby50YWcsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKS5kYXRhLmlkXG4gICAgICAgICAgY29uc3QgZHN0RmlsZVN0YXRzID0gc3RhdFN5bmMoZHN0UGF0aClcbiAgICAgICAgICBjb25zdCBhc3NldEluZm8gPSBhd2FpdCBvY3Rva2l0IS5yZXBvcy51cGxvYWRSZWxlYXNlQXNzZXQoe1xuICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgcmVwbzogcmVwbyxcbiAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgcmVsZWFzZV9pZDogcmVsZWFzZUlkLFxuICAgICAgICAgICAgbWVkaWFUeXBlOiB7IGZvcm1hdDogJ3JhdycgfSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ2NvbnRlbnQtbGVuZ3RoJzogZHN0RmlsZVN0YXRzLnNpemUsXG4gICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG9jdG9raXQgdHlwZXMgYXJlIHdyb25nXG4gICAgICAgICAgICBkYXRhOiBhd2FpdCByZWFkRmlsZUFzeW5jKGRzdFBhdGgpLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgZGVidWcuaW5mbyhgR2l0SHViIHJlbGVhc2UgY3JlYXRlZGApXG4gICAgICAgICAgZGVidWcuaW5mbyhgRG93bmxvYWQgVVJMOiAlc2AsIGFzc2V0SW5mby5kYXRhLmJyb3dzZXJfZG93bmxvYWRfdXJsKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcuZXJyb3IoXG4gICAgICAgICAgICBgUGFyYW06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHsgb3duZXIsIHJlcG8sIHRhZzogcGtnSW5mby50YWcsIGZpbGVuYW1lOiBkc3RQYXRoIH0sXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGRlYnVnLmVycm9yKGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUYWcodGFnOiBzdHJpbmcpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSB0YWcuc3BsaXQoJ0AnKVxuICBjb25zdCB2ZXJzaW9uID0gc2VnbWVudHMucG9wKCkhXG4gIGNvbnN0IG5hbWUgPSBzZWdtZW50cy5qb2luKCdAJylcblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgdmVyc2lvbixcbiAgICB0YWcsXG4gIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlVW5pdmVyc2FsaXplQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWyd1bml2ZXJzYWxpemUnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NvbWJpbGUgYnVpbHQgYmluYXJpZXMgaW50byBvbmUgdW5pdmVyc2FsIGJpbmFyeScsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgb3V0cHV0RGlyID0gT3B0aW9uLlN0cmluZygnLS1vdXRwdXQtZGlyLC1vJywgJy4vJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBvdXRwdXREaXI6IHRoaXMub3V0cHV0RGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbWJpbGUgYnVpbHQgYmluYXJpZXMgaW50byBvbmUgdW5pdmVyc2FsIGJpbmFyeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVuaXZlcnNhbGl6ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmRcbiAgICpcbiAgICogQGRlZmF1bHQgJy4vJ1xuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRVbml2ZXJzYWxpemVPcHRpb25zKG9wdGlvbnM6IFVuaXZlcnNhbGl6ZU9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBvdXRwdXREaXI6ICcuLycsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgc3Bhd25TeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHtcbiAgYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyxcbiAgVW5pdmVyc2FsaXplT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL3VuaXZlcnNhbGl6ZS5qcydcbmltcG9ydCB7IHJlYWROYXBpQ29uZmlnIH0gZnJvbSAnLi4vdXRpbHMvY29uZmlnLmpzJ1xuaW1wb3J0IHsgZGVidWdGYWN0b3J5IH0gZnJvbSAnLi4vdXRpbHMvbG9nLmpzJ1xuaW1wb3J0IHsgZmlsZUV4aXN0cyB9IGZyb20gJy4uL3V0aWxzL21pc2MuanMnXG5pbXBvcnQgeyBVbmlBcmNoc0J5UGxhdGZvcm0gfSBmcm9tICcuLi91dGlscy90YXJnZXQuanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCd1bml2ZXJzYWxpemUnKVxuXG5jb25zdCB1bml2ZXJzYWxpemVyczogUGFydGlhbDxcbiAgUmVjb3JkPE5vZGVKUy5QbGF0Zm9ybSwgKGlucHV0czogc3RyaW5nW10sIG91dHB1dDogc3RyaW5nKSA9PiB2b2lkPlxuPiA9IHtcbiAgZGFyd2luOiAoaW5wdXRzLCBvdXRwdXQpID0+IHtcbiAgICBzcGF3blN5bmMoJ2xpcG8nLCBbJy1jcmVhdGUnLCAnLW91dHB1dCcsIG91dHB1dCwgLi4uaW5wdXRzXSwge1xuICAgICAgc3RkaW86ICdpbmhlcml0JyxcbiAgICB9KVxuICB9LFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdW5pdmVyc2FsaXplQmluYXJpZXModXNlck9wdGlvbnM6IFVuaXZlcnNhbGl6ZU9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdFVuaXZlcnNhbGl6ZU9wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcblxuICBjb25zdCB0YXJnZXQgPSBjb25maWcudGFyZ2V0cy5maW5kKFxuICAgICh0KSA9PiB0LnBsYXRmb3JtID09PSBwcm9jZXNzLnBsYXRmb3JtICYmIHQuYXJjaCA9PT0gJ3VuaXZlcnNhbCcsXG4gIClcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAndW5pdmVyc2FsJyBhcmNoIGZvciBwbGF0Zm9ybSAnJHtwcm9jZXNzLnBsYXRmb3JtfScgbm90IGZvdW5kIGluIGNvbmZpZyFgLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHNyY0ZpbGVzID0gVW5pQXJjaHNCeVBsYXRmb3JtW3Byb2Nlc3MucGxhdGZvcm1dPy5tYXAoKGFyY2gpID0+XG4gICAgcmVzb2x2ZShcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5vdXRwdXREaXIsXG4gICAgICBgJHtjb25maWcuYmluYXJ5TmFtZX0uJHtwcm9jZXNzLnBsYXRmb3JtfS0ke2FyY2h9Lm5vZGVgLFxuICAgICksXG4gIClcblxuICBpZiAoIXNyY0ZpbGVzIHx8ICF1bml2ZXJzYWxpemVyc1twcm9jZXNzLnBsYXRmb3JtXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAndW5pdmVyc2FsJyBhcmNoIGZvciBwbGF0Zm9ybSAnJHtwcm9jZXNzLnBsYXRmb3JtfScgbm90IHN1cHBvcnRlZC5gLFxuICAgIClcbiAgfVxuXG4gIGRlYnVnKGBMb29raW5nIHVwIHNvdXJjZSBiaW5hcmllcyB0byBjb21iaW5lOiBgKVxuICBkZWJ1ZygnICAlTycsIHNyY0ZpbGVzKVxuXG4gIGNvbnN0IHNyY0ZpbGVMb29rdXAgPSBhd2FpdCBQcm9taXNlLmFsbChzcmNGaWxlcy5tYXAoKGYpID0+IGZpbGVFeGlzdHMoZikpKVxuXG4gIGNvbnN0IG5vdEZvdW5kRmlsZXMgPSBzcmNGaWxlcy5maWx0ZXIoKF8sIGkpID0+ICFzcmNGaWxlTG9va3VwW2ldKVxuXG4gIGlmIChub3RGb3VuZEZpbGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTb21lIGJpbmFyeSBmaWxlcyB3ZXJlIG5vdCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeShub3RGb3VuZEZpbGVzKX1gLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IHJlc29sdmUoXG4gICAgb3B0aW9ucy5jd2QsXG4gICAgb3B0aW9ucy5vdXRwdXREaXIsXG4gICAgYCR7Y29uZmlnLmJpbmFyeU5hbWV9LiR7cHJvY2Vzcy5wbGF0Zm9ybX0tdW5pdmVyc2FsLm5vZGVgLFxuICApXG5cbiAgdW5pdmVyc2FsaXplcnNbcHJvY2Vzcy5wbGF0Zm9ybV0/LihzcmNGaWxlcywgb3V0cHV0KVxuXG4gIGRlYnVnKGBQcm9kdWNlZCB1bml2ZXJzYWwgYmluYXJ5OiAke291dHB1dH1gKVxufVxuIiwiaW1wb3J0IHsgY29sbGVjdEFydGlmYWN0cyB9IGZyb20gJy4vYXBpL2FydGlmYWN0cy5qcydcbmltcG9ydCB7IGJ1aWxkUHJvamVjdCB9IGZyb20gJy4vYXBpL2J1aWxkLmpzJ1xuaW1wb3J0IHsgY3JlYXRlTnBtRGlycyB9IGZyb20gJy4vYXBpL2NyZWF0ZS1ucG0tZGlycy5qcydcbmltcG9ydCB7IG5ld1Byb2plY3QgfSBmcm9tICcuL2FwaS9uZXcuanMnXG5pbXBvcnQgeyBwcmVQdWJsaXNoIH0gZnJvbSAnLi9hcGkvcHJlLXB1Ymxpc2guanMnXG5pbXBvcnQgeyByZW5hbWVQcm9qZWN0IH0gZnJvbSAnLi9hcGkvcmVuYW1lLmpzJ1xuaW1wb3J0IHsgdW5pdmVyc2FsaXplQmluYXJpZXMgfSBmcm9tICcuL2FwaS91bml2ZXJzYWxpemUuanMnXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi9hcGkvdmVyc2lvbi5qcydcblxuLyoqXG4gKlxuICogQHVzYWdlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGNsaSA9IG5ldyBOYXBpQ2xpKClcbiAqXG4gKiBjbGkuYnVpbGQoe1xuICogICBjd2Q6ICcvcGF0aC90by95b3VyL3Byb2plY3QnLFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTmFwaUNsaSB7XG4gIGFydGlmYWN0cyA9IGNvbGxlY3RBcnRpZmFjdHNcbiAgbmV3ID0gbmV3UHJvamVjdFxuICBidWlsZCA9IGJ1aWxkUHJvamVjdFxuICBjcmVhdGVOcG1EaXJzID0gY3JlYXRlTnBtRGlyc1xuICBwcmVQdWJsaXNoID0gcHJlUHVibGlzaFxuICByZW5hbWUgPSByZW5hbWVQcm9qZWN0XG4gIHVuaXZlcnNhbGl6ZSA9IHVuaXZlcnNhbGl6ZUJpbmFyaWVzXG4gIHZlcnNpb24gPSB2ZXJzaW9uXG59XG5cbmV4cG9ydCB7IHBhcnNlVHJpcGxlIH0gZnJvbSAnLi91dGlscy90YXJnZXQuanMnXG4iXSwieF9nb29nbGVfaWdub3JlTGlzdCI6WzE5LDIwLDIxLDIyLDIzXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsSUFBc0IsdUJBQXRCLGNBQW1ELFFBQVE7Q0FDekQsT0FBTyxRQUFRLENBQUMsQ0FBQyxXQUFZLENBQUM7Q0FFOUIsT0FBTyxRQUFRLFFBQVEsTUFBTSxFQUMzQixhQUNFLDRFQUNILEVBQUM7Q0FFRixNQUFNLE9BQU8sT0FBTyxTQUFTLFFBQVEsS0FBSyxFQUFFLEVBQzFDLGFBQ0UscUhBQ0gsRUFBQztDQUVGLGFBQXNCLE9BQU8sT0FBTyxvQkFBb0IsRUFDdEQsYUFBYSxrQ0FDZCxFQUFDO0NBRUYsa0JBQWtCLE9BQU8sT0FBTyx1QkFBdUIsZ0JBQWdCLEVBQ3JFLGFBQWEseUJBQ2QsRUFBQztDQUVGLFlBQVksT0FBTyxPQUFPLHNCQUFzQixlQUFlLEVBQzdELGFBQ0Us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